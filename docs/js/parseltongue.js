// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
function resolve() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : '/';

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
}
// path.normalize(path)
// posix version
function normalize(path) {
  var isPathAbsolute = isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isPathAbsolute).join('/');

  if (!path && !isPathAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isPathAbsolute ? '/' : '') + path;
}
// posix version
function isAbsolute(path) {
  return path.charAt(0) === '/';
}

// posix version
function join() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
}


// path.relative(from, to)
// posix version
function relative(from, to) {
  from = resolve(from).substr(1);
  to = resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
}

function dirname(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
}

function basename(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
}
function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b' ?
    function (str, start, len) { return str.substr(start, len) } :
    function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

const { ts } = globalThis;

class KeyValueCache {
    constructor() {
        this.cacheItems = new Map();
    }
    getSize() {
        return this.cacheItems.size;
    }
    getValues() {
        return this.cacheItems.values();
    }
    getValuesAsArray() {
        return Array.from(this.getValues());
    }
    getKeys() {
        return this.cacheItems.keys();
    }
    getEntries() {
        return this.cacheItems.entries();
    }
    getOrCreate(key, createFunc) {
        let item = this.get(key);
        if (item == null) {
            item = createFunc();
            this.set(key, item);
        }
        return item;
    }
    has(key) {
        return this.cacheItems.has(key);
    }
    get(key) {
        return this.cacheItems.get(key);
    }
    set(key, value) {
        this.cacheItems.set(key, value);
    }
    replaceKey(key, newKey) {
        if (!this.cacheItems.has(key))
            throw new Error("Key not found.");
        const value = this.cacheItems.get(key);
        this.cacheItems.delete(key);
        this.cacheItems.set(newKey, value);
    }
    removeByKey(key) {
        this.cacheItems.delete(key);
    }
    clear() {
        this.cacheItems.clear();
    }
}

class ArrayUtils {
    constructor() {
    }
    static isReadonlyArray(a) {
        return a instanceof Array;
    }
    static isNullOrEmpty(a) {
        return !(a instanceof Array) || a.length === 0;
    }
    static getUniqueItems(a) {
        return a.filter((item, index) => a.indexOf(item) === index);
    }
    static removeFirst(a, item) {
        const index = a.indexOf(item);
        if (index === -1)
            return false;
        a.splice(index, 1);
        return true;
    }
    static removeAll(a, isMatch) {
        const removedItems = [];
        for (let i = a.length - 1; i >= 0; i--) {
            if (isMatch(a[i])) {
                removedItems.push(a[i]);
                a.splice(i, 1);
            }
        }
        return removedItems;
    }
    static flatten(items) {
        return items.reduce((a, b) => a.concat(b), []);
    }
    static from(items) {
        const a = [];
        for (const item of items)
            a.push(item);
        return a;
    }
    static *toIterator(items) {
        for (const item of items)
            yield item;
    }
    static sortByProperty(items, getProp) {
        items.sort((a, b) => getProp(a) <= getProp(b) ? -1 : 1);
        return items;
    }
    static groupBy(items, getGroup) {
        const result = [];
        const groups = {};
        for (const item of items) {
            const group = getGroup(item).toString();
            if (groups[group] == null) {
                groups[group] = [];
                result.push(groups[group]);
            }
            groups[group].push(item);
        }
        return result;
    }
    static binaryInsertWithOverwrite(items, newItem, comparer) {
        let top = items.length - 1;
        let bottom = 0;
        while (bottom <= top) {
            const mid = Math.floor((top + bottom) / 2);
            if (comparer.compareTo(newItem, items[mid]) < 0)
                top = mid - 1;
            else
                bottom = mid + 1;
        }
        if (items[top] != null && comparer.compareTo(newItem, items[top]) === 0)
            items[top] = newItem;
        else
            items.splice(top + 1, 0, newItem);
    }
    static binarySearch(items, storedComparer) {
        let top = items.length - 1;
        let bottom = 0;
        while (bottom <= top) {
            const mid = Math.floor((top + bottom) / 2);
            const comparisonResult = storedComparer.compareTo(items[mid]);
            if (comparisonResult === 0)
                return mid;
            else if (comparisonResult < 0)
                top = mid - 1;
            else
                bottom = mid + 1;
        }
        return -1;
    }
    static containsSubArray(items, subArray) {
        let findIndex = 0;
        for (const item of items) {
            if (subArray[findIndex] === item) {
                findIndex++;
                if (findIndex === subArray.length)
                    return true;
            }
            else {
                findIndex = 0;
            }
        }
        return false;
    }
}

class EventContainer {
    constructor() {
        this.subscriptions = [];
    }
    subscribe(subscription) {
        const index = this.getIndex(subscription);
        if (index === -1)
            this.subscriptions.push(subscription);
    }
    unsubscribe(subscription) {
        const index = this.getIndex(subscription);
        if (index >= 0)
            this.subscriptions.splice(index, 1);
    }
    fire(arg) {
        for (const subscription of this.subscriptions)
            subscription(arg);
    }
    getIndex(subscription) {
        return this.subscriptions.indexOf(subscription);
    }
}

class ObjectUtils {
    constructor() {
    }
    static clone(obj) {
        if (obj == null)
            return undefined;
        if (obj instanceof Array)
            return cloneArray(obj);
        return ObjectUtils.assign({}, obj);
        function cloneArray(a) {
            return a.map(item => ObjectUtils.clone(item));
        }
    }
    static assign(a, b, c) {
        if (Object.assign != null) {
            if (c == null)
                return Object.assign(a, b);
            else
                return Object.assign(a, b, c);
        }
        if (c == null)
            return this.es5Assign(a, b);
        else
            return this.es5Assign(a, b, c);
    }
    static es5Assign(a, b, c) {
        const to = Object(a);
        for (let index = 1; index < arguments.length; index++) {
            const nextSource = arguments[index];
            if (nextSource == null)
                continue;
            for (const nextKey in nextSource) {
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey))
                    to[nextKey] = nextSource[nextKey];
            }
        }
        return to;
    }
}

function matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, depth, getEntries, realpath) {
    return ts.matchFiles.apply(this, arguments);
}
function getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory) {
    return ts.getFileMatcherPatterns.apply(this, arguments);
}

function getSyntaxKindName(kind) {
    return getKindCache()[kind];
}
let kindCache = undefined;
function getKindCache() {
    if (kindCache != null)
        return kindCache;
    kindCache = {};
    for (const name of Object.keys(ts.SyntaxKind).filter(k => isNaN(parseInt(k, 10)))) {
        const value = ts.SyntaxKind[name];
        if (kindCache[value] == null)
            kindCache[value] = name;
    }
    return kindCache;
}

const errors = {};

class BaseError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.message = message;
    }
}
errors.BaseError = BaseError;
class ArgumentError extends BaseError {
    constructor(argName, message) {
        super(`Argument Error (${argName}): ${message}`);
    }
}
errors.ArgumentError = ArgumentError;
class ArgumentNullOrWhitespaceError extends ArgumentError {
    constructor(argName) {
        super(argName, "Cannot be null or whitespace.");
    }
}
errors.ArgumentNullOrWhitespaceError = ArgumentNullOrWhitespaceError;
class ArgumentOutOfRangeError extends ArgumentError {
    constructor(argName, value, range) {
        super(argName, `Range is ${range[0]} to ${range[1]}, but ${value} was provided.`);
    }
}
errors.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
class ArgumentTypeError extends ArgumentError {
    constructor(argName, expectedType, actualType) {
        super(argName, `Expected type '${expectedType}', but was '${actualType}'.`);
    }
}
errors.ArgumentTypeError = ArgumentTypeError;
class PathNotFoundError extends BaseError {
    constructor(path, prefix = "Path") {
        super(`${prefix} not found: ${path}`);
        this.path = path;
        this.code = "ENOENT";
    }
}
errors.PathNotFoundError = PathNotFoundError;
class DirectoryNotFoundError extends PathNotFoundError {
    constructor(dirPath) {
        super(dirPath, "Directory");
    }
}
errors.DirectoryNotFoundError = DirectoryNotFoundError;
class FileNotFoundError extends PathNotFoundError {
    constructor(filePath) {
        super(filePath, "File");
    }
}
errors.FileNotFoundError = FileNotFoundError;
class InvalidOperationError extends BaseError {
    constructor(message) {
        super(message);
    }
}
errors.InvalidOperationError = InvalidOperationError;
class NotImplementedError extends BaseError {
    constructor(message = "Not implemented.") {
        super(message);
    }
}
errors.NotImplementedError = NotImplementedError;
class NotSupportedError extends BaseError {
    constructor(message) {
        super(message);
    }
}
errors.NotSupportedError = NotSupportedError;
function throwIfNotType(value, expectedType, argName) {
    if (typeof value !== expectedType)
        throw new ArgumentTypeError(argName, expectedType, typeof value);
}
errors.throwIfNotType = throwIfNotType;
function throwIfNotString(value, argName) {
    if (typeof value !== "string")
        throw new ArgumentTypeError(argName, "string", typeof value);
}
errors.throwIfNotString = throwIfNotString;
function throwIfWhitespaceOrNotString(value, argName) {
    throwIfNotString(value, argName);
    if (value.trim().length === 0)
        throw new ArgumentNullOrWhitespaceError(argName);
}
errors.throwIfWhitespaceOrNotString = throwIfWhitespaceOrNotString;
function throwIfOutOfRange(value, range, argName) {
    if (value < range[0] || value > range[1])
        throw new ArgumentOutOfRangeError(argName, value, range);
}
errors.throwIfOutOfRange = throwIfOutOfRange;
function throwIfRangeOutOfRange(actualRange, range, argName) {
    if (actualRange[0] > actualRange[1])
        throw new ArgumentError(argName, `The start of a range must not be greater than the end: [${actualRange[0]}, ${actualRange[1]}]`);
    throwIfOutOfRange(actualRange[0], range, argName);
    throwIfOutOfRange(actualRange[1], range, argName);
}
errors.throwIfRangeOutOfRange = throwIfRangeOutOfRange;
function throwNotImplementedForSyntaxKindError(kind) {
    throw new NotImplementedError(`Not implemented feature for syntax kind '${getSyntaxKindName(kind)}'.`);
}
errors.throwNotImplementedForSyntaxKindError = throwNotImplementedForSyntaxKindError;
function throwIfNegative(value, argName) {
    if (value < 0)
        throw new ArgumentError(argName, "Expected a non-negative value.");
}
errors.throwIfNegative = throwIfNegative;
function throwIfNullOrUndefined(value, errorMessage) {
    if (value == null)
        throw new InvalidOperationError(typeof errorMessage === "string" ? errorMessage : errorMessage());
    return value;
}
errors.throwIfNullOrUndefined = throwIfNullOrUndefined;
function throwNotImplementedForNeverValueError(value) {
    const node = value;
    if (node != null && typeof node.kind === "string")
        return throwNotImplementedForSyntaxKindError(node.kind);
    throw new NotImplementedError(`Not implemented value: ${JSON.stringify(value)}`);
}
errors.throwNotImplementedForNeverValueError = throwNotImplementedForNeverValueError;
function throwIfNotEqual(actual, expected, description) {
    if (actual !== expected)
        throw new InvalidOperationError(`Expected ${actual} to equal ${expected}. ${description}`);
}
errors.throwIfNotEqual = throwIfNotEqual;
function throwIfTrue(value, errorMessage) {
    if (value === true)
        throw new InvalidOperationError(errorMessage);
}
errors.throwIfTrue = throwIfTrue;

const CharCodes = {
    ASTERISK: "*".charCodeAt(0),
    NEWLINE: "\n".charCodeAt(0),
    CARRIAGE_RETURN: "\r".charCodeAt(0),
    SPACE: " ".charCodeAt(0),
    TAB: "\t".charCodeAt(0),
    CLOSE_BRACE: "}".charCodeAt(0),
};

const regExWhitespaceSet = new Set([" ", "\f", "\n", "\r", "\t", "\v", "\u00A0", "\u2028", "\u2029"].map(c => c.charCodeAt(0)));
class StringUtils {
    constructor() {
    }
    static isWhitespaceCharCode(charCode) {
        return regExWhitespaceSet.has(charCode);
    }
    static isSpaces(text) {
        if (text == null || text.length === 0)
            return false;
        for (let i = 0; i < text.length; i++) {
            if (text.charCodeAt(i) !== CharCodes.SPACE)
                return false;
        }
        return true;
    }
    static hasBom(text) {
        return text.charCodeAt(0) === 0xFEFF;
    }
    static stripBom(text) {
        if (StringUtils.hasBom(text))
            return text.slice(1);
        return text;
    }
    static isNullOrWhitespace(str) {
        return typeof str !== "string" || StringUtils.isWhitespace(str);
    }
    static isNullOrEmpty(str) {
        return typeof str !== "string" || str.length === 0;
    }
    static isWhitespace(text) {
        if (text == null)
            return true;
        for (let i = 0; i < text.length; i++) {
            if (!StringUtils.isWhitespaceCharCode(text.charCodeAt(i)))
                return false;
        }
        return true;
    }
    static startsWithNewLine(str) {
        if (str == null)
            return false;
        return str.charCodeAt(0) === CharCodes.NEWLINE || str.charCodeAt(0) === CharCodes.CARRIAGE_RETURN && str.charCodeAt(1) === CharCodes.NEWLINE;
    }
    static endsWithNewLine(str) {
        if (str == null)
            return false;
        return str.charCodeAt(str.length - 1) === CharCodes.NEWLINE;
    }
    static insertAtLastNonWhitespace(str, insertText) {
        let i = str.length;
        while (i > 0 && StringUtils.isWhitespaceCharCode(str.charCodeAt(i - 1)))
            i--;
        return str.substring(0, i) + insertText + str.substring(i);
    }
    static getLineNumberAtPos(str, pos) {
        errors.throwIfOutOfRange(pos, [0, str.length], "pos");
        let count = 0;
        for (let i = 0; i < pos; i++) {
            if (str.charCodeAt(i) === CharCodes.NEWLINE)
                count++;
        }
        return count + 1;
    }
    static getLengthFromLineStartAtPos(str, pos) {
        errors.throwIfOutOfRange(pos, [0, str.length], "pos");
        return pos - StringUtils.getLineStartFromPos(str, pos);
    }
    static getLineStartFromPos(str, pos) {
        errors.throwIfOutOfRange(pos, [0, str.length], "pos");
        while (pos > 0) {
            const previousCharCode = str.charCodeAt(pos - 1);
            if (previousCharCode === CharCodes.NEWLINE || previousCharCode === CharCodes.CARRIAGE_RETURN)
                break;
            pos--;
        }
        return pos;
    }
    static getLineEndFromPos(str, pos) {
        errors.throwIfOutOfRange(pos, [0, str.length], "pos");
        while (pos < str.length) {
            const currentChar = str.charCodeAt(pos);
            if (currentChar === CharCodes.NEWLINE || currentChar === CharCodes.CARRIAGE_RETURN)
                break;
            pos++;
        }
        return pos;
    }
    static escapeForWithinString(str, quoteKind) {
        return StringUtils.escapeChar(str, quoteKind).replace(/(\r?\n)/g, "\\$1");
    }
    static escapeChar(str, char) {
        if (char.length !== 1)
            throw new errors.InvalidOperationError(`Specified char must be one character long.`);
        let result = "";
        for (const currentChar of str) {
            if (currentChar === char)
                result += "\\";
            result += currentChar;
        }
        return result;
    }
    static removeIndentation(str, opts) {
        const { isInStringAtPos, indentSizeInSpaces } = opts;
        const startPositions = [];
        const endPositions = [];
        let minIndentWidth;
        analyze();
        return buildString();
        function analyze() {
            let isAtStartOfLine = str.charCodeAt(0) === CharCodes.SPACE || str.charCodeAt(0) === CharCodes.TAB;
            for (let i = 0; i < str.length; i++) {
                if (!isAtStartOfLine) {
                    if (str.charCodeAt(i) === CharCodes.NEWLINE && !isInStringAtPos(i + 1))
                        isAtStartOfLine = true;
                    continue;
                }
                startPositions.push(i);
                let spacesCount = 0;
                let tabsCount = 0;
                while (true) {
                    if (str.charCodeAt(i) === CharCodes.SPACE)
                        spacesCount++;
                    else if (str.charCodeAt(i) === CharCodes.TAB)
                        tabsCount++;
                    else
                        break;
                    i++;
                }
                const indentWidth = Math.ceil(spacesCount / indentSizeInSpaces) * indentSizeInSpaces + tabsCount * indentSizeInSpaces;
                if (minIndentWidth == null || indentWidth < minIndentWidth)
                    minIndentWidth = indentWidth;
                endPositions.push(i);
                isAtStartOfLine = false;
            }
        }
        function buildString() {
            if (startPositions.length === 0)
                return str;
            if (minIndentWidth == null || minIndentWidth === 0)
                return str;
            const deindentWidth = minIndentWidth;
            let result = "";
            result += str.substring(0, startPositions[0]);
            let lastEndPos = startPositions[0];
            for (let i = 0; i < startPositions.length; i++) {
                const startPosition = startPositions[i];
                const endPosition = endPositions[i];
                let indentCount = 0;
                let pos;
                for (pos = startPosition; pos < endPosition; pos++) {
                    if (indentCount >= deindentWidth)
                        break;
                    if (str.charCodeAt(pos) === CharCodes.SPACE)
                        indentCount++;
                    else if (str.charCodeAt(pos) === CharCodes.TAB)
                        indentCount += indentSizeInSpaces;
                }
                lastEndPos = startPositions[i + 1] == null ? str.length : startPositions[i + 1];
                result += str.substring(pos, lastEndPos);
            }
            result += str.substring(lastEndPos);
            return result;
        }
    }
    static indent(str, times, options) {
        if (times === 0)
            return str;
        const { indentText, indentSizeInSpaces, isInStringAtPos } = options;
        const fullIndentationText = times > 0 ? indentText.repeat(times) : undefined;
        const totalIndentSpaces = Math.abs(times * indentSizeInSpaces);
        let result = "";
        let lineStart = 0;
        let lineEnd = 0;
        for (let i = 0; i < str.length; i++) {
            lineStart = i;
            while (i < str.length && str.charCodeAt(i) !== CharCodes.NEWLINE)
                i++;
            lineEnd = i === str.length ? i : i + 1;
            appendLine();
        }
        return result;
        function appendLine() {
            if (isInStringAtPos(lineStart))
                result += str.substring(lineStart, lineEnd);
            else if (times > 0)
                result += fullIndentationText + str.substring(lineStart, lineEnd);
            else {
                let start = lineStart;
                let indentSpaces = 0;
                for (start = lineStart; start < str.length; start++) {
                    if (indentSpaces >= totalIndentSpaces)
                        break;
                    if (str.charCodeAt(start) === CharCodes.SPACE)
                        indentSpaces++;
                    else if (str.charCodeAt(start) === CharCodes.TAB)
                        indentSpaces += indentSizeInSpaces;
                    else
                        break;
                }
                result += str.substring(start, lineEnd);
            }
        }
    }
}

class ComparerToStoredComparer {
    constructor(comparer, storedValue) {
        this.comparer = comparer;
        this.storedValue = storedValue;
    }
    compareTo(value) {
        return this.comparer.compareTo(this.storedValue, value);
    }
}

class LocaleStringComparer {
    compareTo(a, b) {
        const comparisonResult = a.localeCompare(b, "en-us-u-kf-upper");
        if (comparisonResult < 0)
            return -1;
        else if (comparisonResult === 0)
            return 0;
        return 1;
    }
}
LocaleStringComparer.instance = new LocaleStringComparer();

class PropertyComparer {
    constructor(getProperty, comparer) {
        this.getProperty = getProperty;
        this.comparer = comparer;
    }
    compareTo(a, b) {
        return this.comparer.compareTo(this.getProperty(a), this.getProperty(b));
    }
}

class PropertyStoredComparer {
    constructor(getProperty, comparer) {
        this.getProperty = getProperty;
        this.comparer = comparer;
    }
    compareTo(value) {
        return this.comparer.compareTo(this.getProperty(value));
    }
}

class SortedKeyValueArray {
    constructor(getKey, comparer) {
        this.getKey = getKey;
        this.comparer = comparer;
        this.array = [];
    }
    set(value) {
        ArrayUtils.binaryInsertWithOverwrite(this.array, value, new PropertyComparer(this.getKey, this.comparer));
    }
    removeByValue(value) {
        this.removeByKey(this.getKey(value));
    }
    removeByKey(key) {
        const storedComparer = new ComparerToStoredComparer(this.comparer, key);
        const index = ArrayUtils.binarySearch(this.array, new PropertyStoredComparer(this.getKey, storedComparer));
        if (index >= 0)
            this.array.splice(index, 1);
    }
    getArrayCopy() {
        return [...this.array];
    }
    hasItems() {
        return this.array.length > 0;
    }
    *entries() {
        yield* this.array;
    }
}

class WeakCache {
    constructor() {
        this.cacheItems = new WeakMap();
    }
    getOrCreate(key, createFunc) {
        let item = this.get(key);
        if (item == null) {
            item = createFunc();
            this.set(key, item);
        }
        return item;
    }
    has(key) {
        return this.cacheItems.has(key);
    }
    get(key) {
        return this.cacheItems.get(key);
    }
    set(key, value) {
        this.cacheItems.set(key, value);
    }
    removeByKey(key) {
        this.cacheItems.delete(key);
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function(resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function(v) { return new Promise(function(a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

class FileUtils {
    constructor() {
    }
    static isNotExistsError(err) {
        return err != null && err.code === FileUtils.ENOENT;
    }
    static pathJoin(basePath, ...paths) {
        if (FileUtils.pathIsAbsolute(basePath)) {
            return FileUtils.standardizeSlashes(normalize(join(basePath, ...paths)));
        }
        return FileUtils.standardizeSlashes(join(basePath, ...paths));
    }
    static pathIsAbsolute(fileOrDirPath) {
        return isAbsolute(fileOrDirPath);
    }
    static getStandardizedAbsolutePath(fileSystem, fileOrDirPath, relativeBase) {
        return FileUtils.standardizeSlashes(normalize(getAbsolutePath()));
        function getAbsolutePath() {
            const isAbsolutePath = isAbsolute(fileOrDirPath);
            if (isAbsolutePath)
                return fileOrDirPath;
            if (!fileOrDirPath.startsWith("./") && relativeBase != null)
                return join(relativeBase, fileOrDirPath);
            return join(fileSystem.getCurrentDirectory(), fileOrDirPath);
        }
    }
    static getDirPath(fileOrDirPath) {
        return FileUtils.standardizeSlashes(dirname(fileOrDirPath));
    }
    static getBaseName(fileOrDirPath) {
        return basename(fileOrDirPath);
    }
    static getExtension(fileOrDirPath) {
        const baseName = FileUtils.getBaseName(fileOrDirPath);
        const lastDotIndex = baseName.lastIndexOf(".");
        if (lastDotIndex <= 0)
            return "";
        const lastExt = baseName.substring(lastDotIndex);
        const lastExtLowerCase = lastExt.toLowerCase();
        if (lastExtLowerCase === ".ts" && baseName.substring(lastDotIndex - 2, lastDotIndex).toLowerCase() === ".d")
            return baseName.substring(lastDotIndex - 2);
        if (lastExtLowerCase === ".map" && baseName.substring(lastDotIndex - 3, lastDotIndex).toLowerCase() === ".js")
            return baseName.substring(lastDotIndex - 3);
        return lastExt;
    }
    static standardizeSlashes(fileOrDirPath) {
        return fileOrDirPath.replace(this.standardizeSlashesRegex, "/");
    }
    static pathEndsWith(fileOrDirPath, endsWithPath) {
        const pathItems = FileUtils.splitPathBySlashes(fileOrDirPath);
        const endsWithItems = FileUtils.splitPathBySlashes(endsWithPath);
        if (endsWithItems.length > pathItems.length)
            return false;
        for (let i = 0; i < endsWithItems.length; i++) {
            if (endsWithItems[endsWithItems.length - i - 1] !== pathItems[pathItems.length - i - 1])
                return false;
        }
        return endsWithItems.length > 0;
    }
    static pathStartsWith(fileOrDirPath, startsWithPath) {
        const isfileOrDirPathEmpty = StringUtils.isNullOrWhitespace(fileOrDirPath);
        const isStartsWithPathEmpty = StringUtils.isNullOrWhitespace(startsWithPath);
        const pathItems = FileUtils.splitPathBySlashes(fileOrDirPath);
        const startsWithItems = FileUtils.splitPathBySlashes(startsWithPath);
        if (isfileOrDirPathEmpty && isStartsWithPathEmpty)
            return true;
        if (isStartsWithPathEmpty || startsWithItems.length > pathItems.length)
            return false;
        if (startsWithItems.length === 1 && startsWithItems[0].length === 0)
            return true;
        for (let i = 0; i < startsWithItems.length; i++) {
            if (startsWithItems[i] !== pathItems[i])
                return false;
        }
        return startsWithItems.length > 0;
    }
    static splitPathBySlashes(fileOrDirPath) {
        fileOrDirPath = (fileOrDirPath || "").replace(FileUtils.trimSlashStartRegex, "").replace(FileUtils.trimSlashEndRegex, "");
        return FileUtils.standardizeSlashes(fileOrDirPath).replace(/^\//, "").split("/");
    }
    static getParentMostPaths(paths) {
        const finalPaths = [];
        for (const fileOrDirPath of ArrayUtils.sortByProperty(paths, p => p.length)) {
            if (finalPaths.every(p => !FileUtils.pathStartsWith(fileOrDirPath, p)))
                finalPaths.push(fileOrDirPath);
        }
        return finalPaths;
    }
    static readFileOrNotExists(fileSystem, filePath, encoding) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                return yield fileSystem.readFile(filePath, encoding);
            }
            catch (err) {
                if (!FileUtils.isNotExistsError(err))
                    throw err;
                return false;
            }
        });
    }
    static readFileOrNotExistsSync(fileSystem, filePath, encoding) {
        try {
            return fileSystem.readFileSync(filePath, encoding);
        }
        catch (err) {
            if (!FileUtils.isNotExistsError(err))
                throw err;
            return false;
        }
    }
    static getTextWithByteOrderMark(text) {
        if (StringUtils.hasBom(text))
            return text;
        return "\uFEFF" + text;
    }
    static getRelativePathTo(absoluteDirPathFrom, absolutePathTo) {
        const relativePath = relative(absoluteDirPathFrom, dirname(absolutePathTo));
        return FileUtils.standardizeSlashes(join(relativePath, basename(absolutePathTo)));
    }
    static isRootDirPath(dirOrFilePath) {
        return dirOrFilePath === FileUtils.getDirPath(dirOrFilePath);
    }
    static *getDescendantDirectories(fileSystemWrapper, dirPath) {
        for (const subDirPath of fileSystemWrapper.readDirSync(dirPath)) {
            if (!fileSystemWrapper.directoryExistsSync(subDirPath))
                continue;
            yield subDirPath;
            yield* FileUtils.getDescendantDirectories(fileSystemWrapper, subDirPath);
        }
    }
    static toAbsoluteGlob(glob, cwd) {
        return toAbsoluteGlob(glob, { cwd });
    }
    static isNegatedGlob(glob) {
        return isNegatedGlob(glob).negated;
    }
}
FileUtils.standardizeSlashesRegex = /\\/g;
FileUtils.trimSlashStartRegex = /^\//;
FileUtils.trimSlashEndRegex = /\/$/;
FileUtils.ENOENT = "ENOENT";

class RealFileSystemHost {
    constructor() {
        this.fs = require("fs-extra");
        this.fastGlob = require("fast-glob");
    }
    delete(path) {
        return new Promise((resolve, reject) => {
            this.fs.unlink(path, err => {
                if (err)
                    reject(this.getFileNotFoundErrorIfNecessary(err, path));
                else
                    resolve();
            });
        });
    }
    deleteSync(path) {
        try {
            this.fs.unlinkSync(path);
        }
        catch (err) {
            throw this.getFileNotFoundErrorIfNecessary(err, path);
        }
    }
    readDirSync(dirPath) {
        try {
            return this.fs.readdirSync(dirPath).map(name => FileUtils.pathJoin(dirPath, name));
        }
        catch (err) {
            throw this.getDirectoryNotFoundErrorIfNecessary(err, dirPath);
        }
    }
    readFile(filePath, encoding = "utf-8") {
        return new Promise((resolve, reject) => {
            this.fs.readFile(filePath, encoding, (err, data) => {
                if (err)
                    reject(this.getFileNotFoundErrorIfNecessary(err, filePath));
                else
                    resolve(data);
            });
        });
    }
    readFileSync(filePath, encoding = "utf-8") {
        try {
            return this.fs.readFileSync(filePath, encoding);
        }
        catch (err) {
            throw this.getFileNotFoundErrorIfNecessary(err, filePath);
        }
    }
    writeFile(filePath, fileText) {
        return __awaiter(this, void 0, void 0, function*() {
            yield new Promise((resolve, reject) => {
                this.fs.writeFile(filePath, fileText, err => {
                    if (err)
                        reject(err);
                    else
                        resolve();
                });
            });
        });
    }
    writeFileSync(filePath, fileText) {
        this.fs.writeFileSync(filePath, fileText);
    }
    mkdir(dirPath) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                yield this.fs.mkdirp(dirPath);
            }
            catch (err) {
                if (err.code !== "EEXIST")
                    throw err;
            }
        });
    }
    mkdirSync(dirPath) {
        try {
            this.fs.mkdirpSync(dirPath);
        }
        catch (err) {
            if (err.code !== "EEXIST")
                throw err;
        }
    }
    move(srcPath, destPath) {
        return this.fs.move(srcPath, destPath, { overwrite: true });
    }
    moveSync(srcPath, destPath) {
        this.fs.moveSync(srcPath, destPath, { overwrite: true });
    }
    copy(srcPath, destPath) {
        return this.fs.copy(srcPath, destPath, { overwrite: true });
    }
    copySync(srcPath, destPath) {
        this.fs.copySync(srcPath, destPath, { overwrite: true });
    }
    fileExists(filePath) {
        return new Promise(resolve => {
            this.fs.stat(filePath, (err, stat) => {
                if (err)
                    resolve(false);
                else
                    resolve(stat.isFile());
            });
        });
    }
    fileExistsSync(filePath) {
        try {
            return this.fs.statSync(filePath).isFile();
        }
        catch (err) {
            return false;
        }
    }
    directoryExists(dirPath) {
        return new Promise(resolve => {
            this.fs.stat(dirPath, (err, stat) => {
                if (err)
                    resolve(false);
                else
                    resolve(stat.isDirectory());
            });
        });
    }
    directoryExistsSync(dirPath) {
        try {
            return this.fs.statSync(dirPath).isDirectory();
        }
        catch (err) {
            return false;
        }
    }
    realpathSync(path) {
        return this.fs.realpathSync(path);
    }
    getCurrentDirectory() {
        return FileUtils.standardizeSlashes(resolve());
    }
    glob(patterns) {
        return this.fastGlob(backSlashesToForward(patterns), {
            cwd: this.getCurrentDirectory(),
            absolute: true,
        });
    }
    globSync(patterns) {
        return this.fastGlob.sync(backSlashesToForward(patterns), {
            cwd: this.getCurrentDirectory(),
            absolute: true,
        });
    }
    isCaseSensitive() {
        const platform = process.platform;
        return platform !== "win32" && platform !== "darwin";
    }
    getDirectoryNotFoundErrorIfNecessary(err, path) {
        return FileUtils.isNotExistsError(err) ? new errors.DirectoryNotFoundError(FileUtils.getStandardizedAbsolutePath(this, path)) : err;
    }
    getFileNotFoundErrorIfNecessary(err, path) {
        return FileUtils.isNotExistsError(err) ? new errors.FileNotFoundError(FileUtils.getStandardizedAbsolutePath(this, path)) : err;
    }
}
function backSlashesToForward(patterns) {
    return patterns.map(p => p.replace(/\\/g, "/"));
}

class Directory {
    constructor(path) {
        this.path = path;
        this.operations = [];
        this.inboundOperations = [];
        this.isDeleted = false;
        this.wasEverDeleted = false;
        this.childDirs = new SortedKeyValueArray(item => item.path, LocaleStringComparer.instance);
    }
    getExternalOperations() {
        return [
            ...ArrayUtils.flatten(this.getAncestors().map(a => getMoveCopyOrDeleteOperations(a))).filter(o => isAncestorAffectedOperation(this, o)),
            ...ArrayUtils.flatten([this, ...this.getDescendants()].map(d => getMoveOrCopyOperations(d))).filter(o => !isInternalOperation(this, o)),
        ];
        function isInternalOperation(thisDir, operation) {
            return operation.oldDir.isDescendantOrEqual(thisDir) && operation.newDir.isDescendantOrEqual(thisDir);
        }
        function isAncestorAffectedOperation(thisDir, operation) {
            switch (operation.kind) {
                case "move":
                case "copy":
                    return thisDir.isDescendantOrEqual(operation.oldDir) || thisDir.isDescendantOrEqual(operation.newDir);
                case "deleteDir":
                    return thisDir.isDescendantOrEqual(operation.dir);
                default:
                    return errors.throwNotImplementedForNeverValueError(operation);
            }
        }
        function getMoveOrCopyOperations(dir) {
            return dir.operations.filter(o => o.kind === "move" || o.kind === "copy");
        }
        function getMoveCopyOrDeleteOperations(dir) {
            return dir.operations.filter(o => o.kind === "move" || o.kind === "deleteDir" || o.kind === "copy");
        }
    }
    isDescendantOrEqual(directory) {
        return this.isDescendant(directory) || this === directory;
    }
    isDescendant(directory) {
        return FileUtils.pathStartsWith(this.path, directory.path);
    }
    getIsDeleted() {
        return this.isDeleted;
    }
    getWasEverDeleted() {
        if (this.wasEverDeleted)
            return true;
        for (const ancestor of this.getAncestorsIterator()) {
            if (ancestor.wasEverDeleted)
                return true;
        }
        return false;
    }
    setIsDeleted(isDeleted) {
        if (this.isDeleted === isDeleted)
            return;
        if (isDeleted) {
            this.wasEverDeleted = true;
            for (const child of this.childDirs.entries())
                child.setIsDeleted(true);
        }
        else {
            if (this.parent != null)
                this.parent.setIsDeleted(false);
        }
        this.isDeleted = isDeleted;
    }
    getParent() {
        return this.parent;
    }
    setParent(parent) {
        if (this.parent != null)
            throw new errors.InvalidOperationError("For some reason, a parent was being set when the directory already had a parent. Please open an issue.");
        this.parent = parent;
        parent.childDirs.set(this);
        if (parent.isDeleted && !this.isDeleted)
            parent.setIsDeleted(false);
    }
    removeParent() {
        const parent = this.parent;
        if (parent == null)
            return;
        parent.childDirs.removeByValue(this);
        this.parent = undefined;
    }
    getAncestors() {
        return Array.from(this.getAncestorsIterator());
    }
    *getAncestorsIterator() {
        let parent = this.parent;
        while (parent != null) {
            yield parent;
            parent = parent.parent;
        }
    }
    *getChildrenPathsIterator() {
        for (const childDir of this.childDirs.entries())
            yield childDir.path;
    }
    getDescendants() {
        const descendants = [];
        for (const child of this.childDirs.entries()) {
            descendants.push(child);
            descendants.push(...child.getDescendants());
        }
        return descendants;
    }
    isFileQueuedForDelete(filePath) {
        return this.hasOperation(operation => operation.kind === "deleteFile" && operation.filePath === filePath);
    }
    hasOperation(operationMatches) {
        for (const operation of this.operations) {
            if (operationMatches(operation))
                return true;
        }
        return false;
    }
    dequeueFileDelete(filePath) {
        this.removeMatchingOperations(operation => operation.kind === "deleteFile" && operation.filePath === filePath);
    }
    dequeueDirDelete(dirPath) {
        this.removeMatchingOperations(operation => operation.kind === "deleteDir" && operation.dir.path === dirPath);
    }
    isRootDir() {
        return FileUtils.isRootDirPath(this.path);
    }
    removeMatchingOperations(operationMatches) {
        ArrayUtils.removeAll(this.operations, operationMatches);
    }
}
class TransactionalFileSystem {
    constructor(fileSystem) {
        this.fileSystem = fileSystem;
        this.directories = new KeyValueCache();
        this.operationIndex = 0;
        this.pathCasingMaintainer = new PathCasingMaintainer(fileSystem);
    }
    queueFileDelete(filePath) {
        const parentDir = this.getOrCreateParentDirectory(filePath);
        parentDir.operations.push({
            kind: "deleteFile",
            index: this.getNextOperationIndex(),
            filePath,
        });
        this.pathCasingMaintainer.removePath(filePath);
    }
    removeFileDelete(filePath) {
        this.getOrCreateParentDirectory(filePath).dequeueFileDelete(filePath);
    }
    queueMkdir(dirPath) {
        const dir = this.getOrCreateDirectory(dirPath);
        dir.setIsDeleted(false);
        const parentDir = this.getOrCreateParentDirectory(dirPath);
        parentDir.operations.push({
            kind: "mkdir",
            index: this.getNextOperationIndex(),
            dir,
        });
    }
    queueDirectoryDelete(dirPath) {
        const dir = this.getOrCreateDirectory(dirPath);
        dir.setIsDeleted(true);
        const parentDir = this.getOrCreateParentDirectory(dirPath);
        parentDir.operations.push({
            kind: "deleteDir",
            index: this.getNextOperationIndex(),
            dir,
        });
        this.pathCasingMaintainer.removePath(dirPath);
    }
    queueMoveDirectory(srcPath, destPath) {
        const parentDir = this.getOrCreateParentDirectory(srcPath);
        const moveDir = this.getOrCreateDirectory(srcPath);
        const destinationDir = this.getOrCreateDirectory(destPath);
        const moveOperation = {
            kind: "move",
            index: this.getNextOperationIndex(),
            oldDir: moveDir,
            newDir: destinationDir,
        };
        parentDir.operations.push(moveOperation);
        (destinationDir.getParent() || destinationDir).inboundOperations.push(moveOperation);
        moveDir.setIsDeleted(true);
        this.pathCasingMaintainer.removePath(srcPath);
    }
    queueCopyDirectory(srcPath, destPath) {
        const parentDir = this.getOrCreateParentDirectory(srcPath);
        const copyDir = this.getOrCreateDirectory(srcPath);
        const destinationDir = this.getOrCreateDirectory(destPath);
        const copyOperation = {
            kind: "copy",
            index: this.getNextOperationIndex(),
            oldDir: copyDir,
            newDir: destinationDir,
        };
        parentDir.operations.push(copyOperation);
        (destinationDir.getParent() || destinationDir).inboundOperations.push(copyOperation);
    }
    flush() {
        return __awaiter(this, void 0, void 0, function*() {
            const operations = this.getAndClearOperations();
            for (const operation of operations)
                yield this.executeOperation(operation);
        });
    }
    flushSync() {
        for (const operation of this.getAndClearOperations())
            this.executeOperationSync(operation);
    }
    saveForDirectory(dirPath) {
        return __awaiter(this, void 0, void 0, function*() {
            const dir = this.getOrCreateDirectory(dirPath);
            this.throwIfHasExternalOperations(dir, "save directory");
            const operations = this.getAndClearOperationsForDir(dir);
            yield this.ensureDirectoryExists(dir);
            for (const operation of operations)
                yield this.executeOperation(operation);
        });
    }
    saveForDirectorySync(dirPath) {
        const dir = this.getOrCreateDirectory(dirPath);
        this.throwIfHasExternalOperations(dir, "save directory");
        this.ensureDirectoryExistsSync(dir);
        for (const operation of this.getAndClearOperationsForDir(dir))
            this.executeOperationSync(operation);
    }
    getAndClearOperationsForDir(dir) {
        const operations = getAndClearParentMkDirOperations(dir.getParent(), dir);
        for (const currentDir of [dir, ...dir.getDescendants()])
            operations.push(...currentDir.operations);
        ArrayUtils.sortByProperty(operations, item => item.index);
        this.removeDirAndSubDirs(dir);
        return operations;
        function getAndClearParentMkDirOperations(parentDir, childDir) {
            if (parentDir == null)
                return [];
            const parentOperations = ArrayUtils.removeAll(parentDir.operations, operation => operation.kind === "mkdir" && operation.dir === childDir);
            return [...parentOperations, ...getAndClearParentMkDirOperations(parentDir.getParent(), parentDir)];
        }
    }
    executeOperation(operation) {
        return __awaiter(this, void 0, void 0, function*() {
            switch (operation.kind) {
                case "deleteDir":
                    yield this.deleteSuppressNotFound(operation.dir.path);
                    break;
                case "deleteFile":
                    yield this.deleteSuppressNotFound(operation.filePath);
                    break;
                case "move":
                    yield this.fileSystem.move(operation.oldDir.path, operation.newDir.path);
                    break;
                case "copy":
                    yield this.fileSystem.copy(operation.oldDir.path, operation.newDir.path);
                    break;
                case "mkdir":
                    yield this.fileSystem.mkdir(operation.dir.path);
                    break;
                default:
                    errors.throwNotImplementedForNeverValueError(operation);
            }
        });
    }
    executeOperationSync(operation) {
        switch (operation.kind) {
            case "deleteDir":
                this.deleteSuppressNotFoundSync(operation.dir.path);
                break;
            case "deleteFile":
                this.deleteSuppressNotFoundSync(operation.filePath);
                break;
            case "move":
                this.fileSystem.moveSync(operation.oldDir.path, operation.newDir.path);
                break;
            case "copy":
                this.fileSystem.copySync(operation.oldDir.path, operation.newDir.path);
                break;
            case "mkdir":
                this.fileSystem.mkdirSync(operation.dir.path);
                break;
            default:
                errors.throwNotImplementedForNeverValueError(operation);
        }
    }
    getAndClearOperations() {
        const operations = [];
        for (const dir of this.directories.getValues())
            operations.push(...dir.operations);
        ArrayUtils.sortByProperty(operations, item => item.index);
        this.directories.clear();
        return operations;
    }
    moveFileImmediately(oldFilePath, newFilePath, fileText) {
        return __awaiter(this, void 0, void 0, function*() {
            this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(oldFilePath), "move file");
            this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(newFilePath), "move file");
            yield this.writeFile(newFilePath, fileText);
            yield this.deleteFileImmediately(oldFilePath);
        });
    }
    moveFileImmediatelySync(oldFilePath, newFilePath, fileText) {
        this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(oldFilePath), "move file");
        this.throwIfHasExternalOperations(this.getOrCreateParentDirectory(newFilePath), "move file");
        this.writeFileSync(newFilePath, fileText);
        this.deleteFileImmediatelySync(oldFilePath);
    }
    deleteFileImmediately(filePath) {
        return __awaiter(this, void 0, void 0, function*() {
            const dir = this.getOrCreateParentDirectory(filePath);
            this.throwIfHasExternalOperations(dir, "delete file");
            dir.dequeueFileDelete(filePath);
            this.pathCasingMaintainer.removePath(filePath);
            try {
                yield this.deleteSuppressNotFound(filePath);
            }
            catch (err) {
                this.queueFileDelete(filePath);
                throw err;
            }
        });
    }
    deleteFileImmediatelySync(filePath) {
        const dir = this.getOrCreateParentDirectory(filePath);
        this.throwIfHasExternalOperations(dir, "delete file");
        dir.dequeueFileDelete(filePath);
        this.pathCasingMaintainer.removePath(filePath);
        try {
            this.deleteSuppressNotFoundSync(filePath);
        }
        catch (err) {
            this.queueFileDelete(filePath);
            throw err;
        }
    }
    copyDirectoryImmediately(srcDirPath, destDirPath) {
        return __awaiter(this, void 0, void 0, function*() {
            const srcDir = this.getOrCreateDirectory(srcDirPath);
            const destDir = this.getOrCreateDirectory(destDirPath);
            this.throwIfHasExternalOperations(srcDir, "copy directory");
            this.throwIfHasExternalOperations(destDir, "copy directory");
            const saveTask = Promise.all([this.saveForDirectory(srcDirPath), this.saveForDirectory(destDirPath)]);
            this.removeDirAndSubDirs(srcDir);
            yield saveTask;
            yield this.fileSystem.copy(srcDirPath, destDirPath);
        });
    }
    copyDirectoryImmediatelySync(srcDirPath, destDirPath) {
        const srcDir = this.getOrCreateDirectory(srcDirPath);
        const destDir = this.getOrCreateDirectory(destDirPath);
        this.throwIfHasExternalOperations(srcDir, "copy directory");
        this.throwIfHasExternalOperations(destDir, "copy directory");
        this.saveForDirectorySync(srcDirPath);
        this.saveForDirectorySync(destDirPath);
        this.removeDirAndSubDirs(srcDir);
        this.fileSystem.copySync(srcDirPath, destDirPath);
    }
    moveDirectoryImmediately(srcDirPath, destDirPath) {
        return __awaiter(this, void 0, void 0, function*() {
            const srcDir = this.getOrCreateDirectory(srcDirPath);
            const destDir = this.getOrCreateDirectory(destDirPath);
            this.throwIfHasExternalOperations(srcDir, "move directory");
            this.throwIfHasExternalOperations(destDir, "move directory");
            const saveTask = Promise.all([this.saveForDirectory(srcDirPath), this.saveForDirectory(destDirPath)]);
            this.removeDirAndSubDirs(srcDir);
            this.pathCasingMaintainer.removePath(srcDirPath);
            yield saveTask;
            yield this.fileSystem.move(srcDirPath, destDirPath);
        });
    }
    moveDirectoryImmediatelySync(srcDirPath, destDirPath) {
        const srcDir = this.getOrCreateDirectory(srcDirPath);
        const destDir = this.getOrCreateDirectory(destDirPath);
        this.throwIfHasExternalOperations(srcDir, "move directory");
        this.throwIfHasExternalOperations(destDir, "move directory");
        this.saveForDirectorySync(srcDirPath);
        this.saveForDirectorySync(destDirPath);
        this.removeDirAndSubDirs(srcDir);
        this.pathCasingMaintainer.removePath(srcDirPath);
        this.fileSystem.moveSync(srcDirPath, destDirPath);
    }
    deleteDirectoryImmediately(dirPath) {
        return __awaiter(this, void 0, void 0, function*() {
            const dir = this.getOrCreateDirectory(dirPath);
            this.throwIfHasExternalOperations(dir, "delete");
            this.removeDirAndSubDirs(dir);
            this.pathCasingMaintainer.removePath(dirPath);
            try {
                yield this.deleteSuppressNotFound(dirPath);
            }
            catch (err) {
                this.addBackDirAndSubDirs(dir);
                this.queueDirectoryDelete(dirPath);
            }
        });
    }
    clearDirectoryImmediately(dirPath) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.deleteDirectoryImmediately(dirPath);
            this.getOrCreateDirectory(dirPath).setIsDeleted(false);
            yield this.fileSystem.mkdir(dirPath);
        });
    }
    clearDirectoryImmediatelySync(dirPath) {
        this.deleteDirectoryImmediatelySync(dirPath);
        this.getOrCreateDirectory(dirPath).setIsDeleted(false);
        this.fileSystem.mkdirSync(dirPath);
    }
    deleteDirectoryImmediatelySync(dirPath) {
        const dir = this.getOrCreateDirectory(dirPath);
        this.throwIfHasExternalOperations(dir, "delete");
        this.removeDirAndSubDirs(dir);
        this.pathCasingMaintainer.removePath(dirPath);
        try {
            this.deleteSuppressNotFoundSync(dirPath);
        }
        catch (err) {
            this.addBackDirAndSubDirs(dir);
            this.queueDirectoryDelete(dirPath);
        }
    }
    deleteSuppressNotFound(path) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                yield this.fileSystem.delete(path);
            }
            catch (err) {
                if (!FileUtils.isNotExistsError(err))
                    throw err;
            }
        });
    }
    deleteSuppressNotFoundSync(path) {
        try {
            this.fileSystem.deleteSync(path);
        }
        catch (err) {
            if (!FileUtils.isNotExistsError(err))
                throw err;
        }
    }
    fileExists(filePath) {
        if (this._fileDeletedInMemory(filePath))
            return false;
        return this.fileSystem.fileExists(filePath);
    }
    fileExistsSync(filePath) {
        if (this._fileDeletedInMemory(filePath))
            return false;
        return this.fileSystem.fileExistsSync(filePath);
    }
    _fileDeletedInMemory(filePath) {
        if (this.isPathQueuedForDeletion(filePath))
            return true;
        const parentDir = this.getParentDirectoryIfExists(filePath);
        if (parentDir != null && parentDir.getWasEverDeleted())
            return true;
        return false;
    }
    directoryExistsSync(dirPath) {
        if (this.isPathQueuedForDeletion(dirPath))
            return false;
        if (this.isPathDirectoryInQueueThatExists(dirPath))
            return true;
        const dir = this.getDirectoryIfExists(dirPath);
        if (dir != null && dir.getWasEverDeleted())
            return false;
        return this.fileSystem.directoryExistsSync(dirPath);
    }
    readFileSync(filePath, encoding) {
        this._verifyCanReadFile(filePath);
        return this.fileSystem.readFileSync(filePath, encoding);
    }
    readFile(filePath, encoding) {
        this._verifyCanReadFile(filePath);
        return this.fileSystem.readFile(filePath, encoding);
    }
    _verifyCanReadFile(filePath) {
        if (this.isPathQueuedForDeletion(filePath))
            throw new errors.InvalidOperationError(`Cannot read file at ${filePath} when it is queued for deletion.`);
        if (this.getOrCreateParentDirectory(filePath).getWasEverDeleted())
            throw new errors.InvalidOperationError(`Cannot read file at ${filePath} because one of its ancestor directories was once deleted or moved.`);
    }
    readDirSync(dirPath) {
        const dir = this.getOrCreateDirectory(dirPath);
        if (dir.getIsDeleted())
            throw new errors.InvalidOperationError(`Cannot read directory at ${dirPath} when it is queued for deletion.`);
        if (dir.getWasEverDeleted())
            throw new errors.InvalidOperationError(`Cannot read directory at ${dirPath} because one of its ancestor directories was once deleted or moved.`);
        const uniqueDirPaths = new Set(dir.getChildrenPathsIterator());
        for (const childDirOrFilePath of this.fileSystem.readDirSync(dirPath)) {
            const standardizedChildDirOrFilePath = this.getStandardizedAbsolutePath(childDirOrFilePath);
            if (!this.isPathQueuedForDeletion(standardizedChildDirOrFilePath))
                uniqueDirPaths.add(standardizedChildDirOrFilePath);
        }
        return Array.from(uniqueDirPaths).sort();
    }
    glob(patterns) {
        return __asyncGenerator(this, arguments, function* glob_1() {
            const filePaths = yield __await(this.fileSystem.glob(patterns));
            for (const filePath of filePaths) {
                const standardizedFilePath = this.getStandardizedAbsolutePath(filePath);
                if (!this.isPathQueuedForDeletion(standardizedFilePath))
                    yield yield __await(standardizedFilePath);
            }
        });
    }
    *globSync(patterns) {
        const filePaths = this.fileSystem.globSync(patterns);
        for (const filePath of filePaths) {
            const standardizedFilePath = this.getStandardizedAbsolutePath(filePath);
            if (!this.isPathQueuedForDeletion(standardizedFilePath))
                yield standardizedFilePath;
        }
    }
    getFileSystem() {
        return this.fileSystem;
    }
    getCurrentDirectory() {
        return this.getStandardizedAbsolutePath(this.fileSystem.getCurrentDirectory());
    }
    getDirectories(dirPath) {
        return this.readDirSync(dirPath).filter(path => this.directoryExistsSync(path));
    }
    realpathSync(path) {
        try {
            return this.getStandardizedAbsolutePath(this.fileSystem.realpathSync(path));
        }
        catch (_a) {
            return path;
        }
    }
    getStandardizedAbsolutePath(fileOrDirPath, relativeBase) {
        const standardizedFileOrDirPath = FileUtils.getStandardizedAbsolutePath(this.fileSystem, fileOrDirPath, relativeBase);
        return this.pathCasingMaintainer.getPath(standardizedFileOrDirPath);
    }
    readFileOrNotExists(filePath, encoding) {
        if (this.isPathQueuedForDeletion(filePath))
            return false;
        return FileUtils.readFileOrNotExists(this.fileSystem, filePath, encoding);
    }
    readFileOrNotExistsSync(filePath, encoding) {
        if (this.isPathQueuedForDeletion(filePath))
            return false;
        return FileUtils.readFileOrNotExistsSync(this.fileSystem, filePath, encoding);
    }
    writeFile(filePath, fileText) {
        return __awaiter(this, void 0, void 0, function*() {
            const parentDir = this.getOrCreateParentDirectory(filePath);
            this.throwIfHasExternalOperations(parentDir, "write file");
            parentDir.dequeueFileDelete(filePath);
            yield this.ensureDirectoryExists(parentDir);
            yield this.fileSystem.writeFile(filePath, fileText);
        });
    }
    writeFileSync(filePath, fileText) {
        const parentDir = this.getOrCreateParentDirectory(filePath);
        this.throwIfHasExternalOperations(parentDir, "write file");
        parentDir.dequeueFileDelete(filePath);
        this.ensureDirectoryExistsSync(parentDir);
        this.fileSystem.writeFileSync(filePath, fileText);
    }
    isPathDirectoryInQueueThatExists(path) {
        const pathDir = this.getDirectoryIfExists(path);
        return pathDir == null ? false : !pathDir.getIsDeleted();
    }
    isPathQueuedForDeletion(path) {
        const pathDir = this.getDirectoryIfExists(path);
        if (pathDir != null)
            return pathDir.getIsDeleted();
        const parentDir = this.getParentDirectoryIfExists(path);
        if (parentDir == null)
            return false;
        return parentDir.isFileQueuedForDelete(path) || parentDir.getIsDeleted();
    }
    removeDirAndSubDirs(dir) {
        const originalParent = dir.getParent();
        dir.removeParent();
        for (const dirToRemove of [dir, ...dir.getDescendants()])
            this.directories.removeByKey(dirToRemove.path);
        if (originalParent != null)
            originalParent.dequeueDirDelete(dir.path);
    }
    addBackDirAndSubDirs(dir) {
        for (const dirToAdd of [dir, ...dir.getDescendants()])
            this.directories.set(dirToAdd.path, dirToAdd);
        if (!dir.isRootDir())
            dir.setParent(this.getOrCreateParentDirectory(dir.path));
    }
    getNextOperationIndex() {
        return this.operationIndex++;
    }
    getParentDirectoryIfExists(filePath) {
        return this.getDirectoryIfExists(FileUtils.getDirPath(filePath));
    }
    getOrCreateParentDirectory(filePath) {
        return this.getOrCreateDirectory(FileUtils.getDirPath(filePath));
    }
    getDirectoryIfExists(dirPath) {
        return this.directories.get(dirPath);
    }
    getOrCreateDirectory(dirPath) {
        let dir = this.directories.get(dirPath);
        if (dir != null)
            return dir;
        const getOrCreateDir = (creatingDirPath) => this.directories.getOrCreate(creatingDirPath, () => new Directory(creatingDirPath));
        dir = getOrCreateDir(dirPath);
        let currentDirPath = dirPath;
        let currentDir = dir;
        while (!FileUtils.isRootDirPath(currentDirPath)) {
            const nextDirPath = FileUtils.getDirPath(currentDirPath);
            const hadNextDir = this.directories.has(nextDirPath);
            const nextDir = getOrCreateDir(nextDirPath);
            currentDir.setParent(nextDir);
            if (hadNextDir)
                return dir;
            currentDir = nextDir;
            currentDirPath = nextDirPath;
        }
        return dir;
    }
    throwIfHasExternalOperations(dir, commandName) {
        const operations = dir.getExternalOperations();
        if (operations.length === 0)
            return;
        throw new errors.InvalidOperationError(getErrorText());
        function getErrorText() {
            let hasCopy = false;
            let errorText = `Cannot execute immediate operation '${commandName}' because of the following external operations:\n`;
            for (const operation of operations) {
                if (operation.kind === "move")
                    errorText += `\n* Move: ${operation.oldDir.path} --> ${operation.newDir.path}`;
                else if (operation.kind === "copy") {
                    errorText += `\n* Copy: ${operation.oldDir.path} --> ${operation.newDir.path}`;
                    hasCopy = true;
                }
                else if (operation.kind === "deleteDir")
                    errorText += `\n* Delete: ${operation.dir.path}`;
                else {
                    errorText += `\n* Unknown operation: Please report this as a bug.`;
                }
            }
            if (hasCopy)
                errorText += "\n\nNote: Copy operations can be removed from external operations by setting `includeUntrackedFiles` to `false` when copying.";
            return errorText;
        }
    }
    ensureDirectoryExists(dir) {
        return __awaiter(this, void 0, void 0, function*() {
            if (dir.isRootDir())
                return;
            this.removeMkDirOperationsForDir(dir);
            yield this.fileSystem.mkdir(dir.path);
        });
    }
    ensureDirectoryExistsSync(dir) {
        if (dir.isRootDir())
            return;
        this.removeMkDirOperationsForDir(dir);
        this.fileSystem.mkdirSync(dir.path);
    }
    removeMkDirOperationsForDir(dir) {
        const parentDir = dir.getParent();
        if (parentDir != null) {
            ArrayUtils.removeAll(parentDir.operations, operation => operation.kind === "mkdir" && operation.dir === dir);
            this.removeMkDirOperationsForDir(parentDir);
        }
    }
}
class PathCasingMaintainer {
    constructor(fileSystem) {
        if (fileSystem.isCaseSensitive != null && !fileSystem.isCaseSensitive())
            this.caseInsensitiveMappings = new Map();
    }
    getPath(fileOrDirPath) {
        if (this.caseInsensitiveMappings == null)
            return fileOrDirPath;
        const key = fileOrDirPath.toLowerCase();
        let path = this.caseInsensitiveMappings.get(key);
        if (path == null) {
            path = fileOrDirPath;
            this.caseInsensitiveMappings.set(key, path);
        }
        return path;
    }
    removePath(dirPath) {
        if (this.caseInsensitiveMappings == null)
            return;
        this.caseInsensitiveMappings.delete(dirPath.toLowerCase());
    }
}

function matchGlobs(paths, patterns, cwd) {
    if (typeof patterns === "string")
        patterns = FileUtils.toAbsoluteGlob(patterns, cwd);
    else
        patterns = patterns.map(p => FileUtils.toAbsoluteGlob(p, cwd));
    return multimatch(paths, patterns);
}

function getLibFiles() {
    const libFiles = [{
        fileName: "lib.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es5" />\n/// <reference lib="dom" />\n/// <reference lib="webworker.importscripts" />\n/// <reference lib="scripthost" />\n`
    }, {
        fileName: "lib.dom.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface Account{displayName:string;id:string;imageURL?:string;name?:string;rpDisplayName:string;}interface AddEventListenerOptions extends EventListenerOptions{once?:boolean;passive?:boolean;}interface AesCbcParams extends Algorithm{iv:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface AesCtrParams extends Algorithm{counter:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;length:number;}interface AesDerivedKeyParams extends Algorithm{length:number;}interface AesGcmParams extends Algorithm{additionalData?:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;iv:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;tagLength?:number;}interface AesKeyAlgorithm extends KeyAlgorithm{length:number;}interface AesKeyGenParams extends Algorithm{length:number;}interface Algorithm{name:string;}interface AnalyserOptions extends AudioNodeOptions{fftSize?:number;maxDecibels?:number;minDecibels?:number;smoothingTimeConstant?:number;}interface AnimationEventInit extends EventInit{animationName?:string;elapsedTime?:number;pseudoElement?:string;}interface AnimationPlaybackEventInit extends EventInit{currentTime?:number|null;timelineTime?:number|null;}interface AssertionOptions{allowList?:ScopedCredentialDescriptor[];extensions?:WebAuthnExtensions;rpId?:string;timeoutSeconds?:number;}interface AssignedNodesOptions{flatten?:boolean;}interface AudioBufferOptions{length:number;numberOfChannels?:number;sampleRate:number;}interface AudioBufferSourceOptions{buffer?:AudioBuffer|null;detune?:number;loop?:boolean;loopEnd?:number;loopStart?:number;playbackRate?:number;}interface AudioContextInfo{currentTime?:number;sampleRate?:number;}interface AudioContextOptions{latencyHint?:AudioContextLatencyCategory|number;sampleRate?:number;}interface AudioNodeOptions{channelCount?:number;channelCountMode?:ChannelCountMode;channelInterpretation?:ChannelInterpretation;}interface AudioParamDescriptor{automationRate?:AutomationRate;defaultValue?:number;maxValue?:number;minValue?:number;name:string;}interface AudioProcessingEventInit extends EventInit{inputBuffer:AudioBuffer;outputBuffer:AudioBuffer;playbackTime:number;}interface AudioTimestamp{contextTime?:number;performanceTime?:number;}interface AudioWorkletNodeOptions extends AudioNodeOptions{numberOfInputs?:number;numberOfOutputs?:number;outputChannelCount?:number[];parameterData?:Record<string,number>;processorOptions?:any;}interface AuthenticationExtensionsClientInputs{appid?:string;authnSel?:AuthenticatorSelectionList;exts?:boolean;loc?:boolean;txAuthGeneric?:txAuthGenericArg;txAuthSimple?:string;uvi?:boolean;uvm?:boolean;}interface AuthenticationExtensionsClientOutputs{appid?:boolean;authnSel?:boolean;exts?:AuthenticationExtensionsSupported;loc?:Coordinates;txAuthGeneric?:ArrayBuffer;txAuthSimple?:string;uvi?:ArrayBuffer;uvm?:UvmEntries;}interface AuthenticatorSelectionCriteria{authenticatorAttachment?:AuthenticatorAttachment;requireResidentKey?:boolean;userVerification?:UserVerificationRequirement;}interface BiquadFilterOptions extends AudioNodeOptions{Q?:number;detune?:number;frequency?:number;gain?:number;type?:BiquadFilterType;}interface BlobPropertyBag{endings?:EndingType;type?:string;}interface ByteLengthChunk{byteLength?:number;}interface CacheQueryOptions{ignoreMethod?:boolean;ignoreSearch?:boolean;ignoreVary?:boolean;}interface CanvasRenderingContext2DSettings{alpha?:boolean;desynchronized?:boolean;}interface ChannelMergerOptions extends AudioNodeOptions{numberOfInputs?:number;}interface ChannelSplitterOptions extends AudioNodeOptions{numberOfOutputs?:number;}interface ClientData{challenge:string;extensions?:WebAuthnExtensions;hashAlg:string|Algorithm;origin:string;rpId:string;tokenBinding?:string;}interface ClientQueryOptions{includeUncontrolled?:boolean;type?:ClientTypes;}interface ClipboardEventInit extends EventInit{clipboardData?:DataTransfer|null;}interface CloseEventInit extends EventInit{code?:number;reason?:string;wasClean?:boolean;}interface CompositionEventInit extends UIEventInit{data?:string;}interface ComputedEffectTiming extends EffectTiming{activeDuration?:number;currentIteration?:number|null;endTime?:number;localTime?:number|null;progress?:number|null;}interface ComputedKeyframe{composite:CompositeOperationOrAuto;computedOffset:number;easing:string;offset:number|null;[property:string]:string|number|null|undefined;}interface ConfirmSiteSpecificExceptionsInformation extends ExceptionInformation{arrayOfDomainStrings?:string[];}interface ConstantSourceOptions{offset?:number;}interface ConstrainBooleanParameters{exact?:boolean;ideal?:boolean;}interface ConstrainDOMStringParameters{exact?:string|string[];ideal?:string|string[];}interface ConstrainDoubleRange extends DoubleRange{exact?:number;ideal?:number;}interface ConstrainULongRange extends ULongRange{exact?:number;ideal?:number;}interface ConstrainVideoFacingModeParameters{exact?:VideoFacingModeEnum|VideoFacingModeEnum[];ideal?:VideoFacingModeEnum|VideoFacingModeEnum[];}interface ConvolverOptions extends AudioNodeOptions{buffer?:AudioBuffer|null;disableNormalization?:boolean;}interface CredentialCreationOptions{publicKey?:PublicKeyCredentialCreationOptions;signal?:AbortSignal;}interface CredentialRequestOptions{mediation?:CredentialMediationRequirement;publicKey?:PublicKeyCredentialRequestOptions;signal?:AbortSignal;}interface CustomEventInit<T=any>extends EventInit{detail?:T;}interface DOMMatrix2DInit{a?:number;b?:number;c?:number;d?:number;e?:number;f?:number;m11?:number;m12?:number;m21?:number;m22?:number;m41?:number;m42?:number;}interface DOMMatrixInit extends DOMMatrix2DInit{is2D?:boolean;m13?:number;m14?:number;m23?:number;m24?:number;m31?:number;m32?:number;m33?:number;m34?:number;m43?:number;m44?:number;}interface DOMPointInit{w?:number;x?:number;y?:number;z?:number;}interface DOMQuadInit{p1?:DOMPointInit;p2?:DOMPointInit;p3?:DOMPointInit;p4?:DOMPointInit;}interface DOMRectInit{height?:number;width?:number;x?:number;y?:number;}interface DelayOptions extends AudioNodeOptions{delayTime?:number;maxDelayTime?:number;}interface DeviceLightEventInit extends EventInit{value?:number;}interface DeviceMotionEventAccelerationInit{x?:number|null;y?:number|null;z?:number|null;}interface DeviceMotionEventInit extends EventInit{acceleration?:DeviceMotionEventAccelerationInit;accelerationIncludingGravity?:DeviceMotionEventAccelerationInit;interval?:number;rotationRate?:DeviceMotionEventRotationRateInit;}interface DeviceMotionEventRotationRateInit{alpha?:number|null;beta?:number|null;gamma?:number|null;}interface DeviceOrientationEventInit extends EventInit{absolute?:boolean;alpha?:number|null;beta?:number|null;gamma?:number|null;}interface DevicePermissionDescriptor extends PermissionDescriptor{deviceId?:string;name:"camera"|"microphone"|"speaker";}interface DocumentTimelineOptions{originTime?:number;}interface DoubleRange{max?:number;min?:number;}interface DragEventInit extends MouseEventInit{dataTransfer?:DataTransfer|null;}interface DynamicsCompressorOptions extends AudioNodeOptions{attack?:number;knee?:number;ratio?:number;release?:number;threshold?:number;}interface EcKeyAlgorithm extends KeyAlgorithm{namedCurve:NamedCurve;}interface EcKeyGenParams extends Algorithm{namedCurve:NamedCurve;}interface EcKeyImportParams extends Algorithm{namedCurve:NamedCurve;}interface EcdhKeyDeriveParams extends Algorithm{public:CryptoKey;}interface EcdsaParams extends Algorithm{hash:HashAlgorithmIdentifier;}interface EffectTiming{delay?:number;direction?:PlaybackDirection;duration?:number|string;easing?:string;endDelay?:number;fill?:FillMode;iterationStart?:number;iterations?:number;}interface ElementCreationOptions{is?:string;}interface ElementDefinitionOptions{extends?:string;}interface ErrorEventInit extends EventInit{colno?:number;error?:any;filename?:string;lineno?:number;message?:string;}interface EventInit{bubbles?:boolean;cancelable?:boolean;composed?:boolean;}interface EventListenerOptions{capture?:boolean;}interface EventModifierInit extends UIEventInit{altKey?:boolean;ctrlKey?:boolean;metaKey?:boolean;modifierAltGraph?:boolean;modifierCapsLock?:boolean;modifierFn?:boolean;modifierFnLock?:boolean;modifierHyper?:boolean;modifierNumLock?:boolean;modifierScrollLock?:boolean;modifierSuper?:boolean;modifierSymbol?:boolean;modifierSymbolLock?:boolean;shiftKey?:boolean;}interface EventSourceInit{withCredentials?:boolean;}interface ExceptionInformation{domain?:string|null;}interface FilePropertyBag extends BlobPropertyBag{lastModified?:number;}interface FocusEventInit extends UIEventInit{relatedTarget?:EventTarget|null;}interface FocusNavigationEventInit extends EventInit{navigationReason?:string|null;originHeight?:number;originLeft?:number;originTop?:number;originWidth?:number;}interface FocusNavigationOrigin{originHeight?:number;originLeft?:number;originTop?:number;originWidth?:number;}interface FocusOptions{preventScroll?:boolean;}interface FullscreenOptions{navigationUI?:FullscreenNavigationUI;}interface GainOptions extends AudioNodeOptions{gain?:number;}interface GamepadEventInit extends EventInit{gamepad:Gamepad;}interface GetNotificationOptions{tag?:string;}interface GetRootNodeOptions{composed?:boolean;}interface HashChangeEventInit extends EventInit{newURL?:string;oldURL?:string;}interface HkdfParams extends Algorithm{hash:HashAlgorithmIdentifier;info:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;salt:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface HmacImportParams extends Algorithm{hash:HashAlgorithmIdentifier;length?:number;}interface HmacKeyAlgorithm extends KeyAlgorithm{hash:KeyAlgorithm;length:number;}interface HmacKeyGenParams extends Algorithm{hash:HashAlgorithmIdentifier;length?:number;}interface IDBIndexParameters{multiEntry?:boolean;unique?:boolean;}interface IDBObjectStoreParameters{autoIncrement?:boolean;keyPath?:string|string[]|null;}interface IDBVersionChangeEventInit extends EventInit{newVersion?:number|null;oldVersion?:number;}interface IIRFilterOptions extends AudioNodeOptions{feedback:number[];feedforward:number[];}interface ImageBitmapOptions{colorSpaceConversion?:ColorSpaceConversion;imageOrientation?:ImageOrientation;premultiplyAlpha?:PremultiplyAlpha;resizeHeight?:number;resizeQuality?:ResizeQuality;resizeWidth?:number;}interface ImageBitmapRenderingContextSettings{alpha?:boolean;}interface ImageEncodeOptions{quality?:number;type?:string;}interface InputEventInit extends UIEventInit{data?:string|null;inputType?:string;isComposing?:boolean;}interface IntersectionObserverEntryInit{boundingClientRect:DOMRectInit;intersectionRatio:number;intersectionRect:DOMRectInit;isIntersecting:boolean;rootBounds:DOMRectInit|null;target:Element;time:number;}interface IntersectionObserverInit{root?:Element|null;rootMargin?:string;threshold?:number|number[];}interface JsonWebKey{alg?:string;crv?:string;d?:string;dp?:string;dq?:string;e?:string;ext?:boolean;k?:string;key_ops?:string[];kty?:string;n?:string;oth?:RsaOtherPrimesInfo[];p?:string;q?:string;qi?:string;use?:string;x?:string;y?:string;}interface KeyAlgorithm{name:string;}interface KeyboardEventInit extends EventModifierInit{code?:string;isComposing?:boolean;key?:string;location?:number;repeat?:boolean;}interface Keyframe{composite?:CompositeOperationOrAuto;easing?:string;offset?:number|null;[property:string]:string|number|null|undefined;}interface KeyframeAnimationOptions extends KeyframeEffectOptions{id?:string;}interface KeyframeEffectOptions extends EffectTiming{composite?:CompositeOperation;iterationComposite?:IterationCompositeOperation;}interface MediaElementAudioSourceOptions{mediaElement:HTMLMediaElement;}interface MediaEncryptedEventInit extends EventInit{initData?:ArrayBuffer|null;initDataType?:string;}interface MediaKeyMessageEventInit extends EventInit{message:ArrayBuffer;messageType:MediaKeyMessageType;}interface MediaKeySystemConfiguration{audioCapabilities?:MediaKeySystemMediaCapability[];distinctiveIdentifier?:MediaKeysRequirement;initDataTypes?:string[];label?:string;persistentState?:MediaKeysRequirement;sessionTypes?:string[];videoCapabilities?:MediaKeySystemMediaCapability[];}interface MediaKeySystemMediaCapability{contentType?:string;robustness?:string;}interface MediaQueryListEventInit extends EventInit{matches?:boolean;media?:string;}interface MediaStreamAudioSourceOptions{mediaStream:MediaStream;}interface MediaStreamConstraints{audio?:boolean|MediaTrackConstraints;peerIdentity?:string;video?:boolean|MediaTrackConstraints;}interface MediaStreamErrorEventInit extends EventInit{error?:MediaStreamError|null;}interface MediaStreamEventInit extends EventInit{stream?:MediaStream;}interface MediaStreamTrackAudioSourceOptions{mediaStreamTrack:MediaStreamTrack;}interface MediaStreamTrackEventInit extends EventInit{track:MediaStreamTrack;}interface MediaTrackCapabilities{aspectRatio?:DoubleRange;autoGainControl?:boolean[];channelCount?:ULongRange;deviceId?:string;echoCancellation?:boolean[];facingMode?:string[];frameRate?:DoubleRange;groupId?:string;height?:ULongRange;latency?:DoubleRange;noiseSuppression?:boolean[];resizeMode?:string[];sampleRate?:ULongRange;sampleSize?:ULongRange;width?:ULongRange;}interface MediaTrackConstraintSet{aspectRatio?:ConstrainDouble;autoGainControl?:ConstrainBoolean;channelCount?:ConstrainULong;deviceId?:ConstrainDOMString;echoCancellation?:ConstrainBoolean;facingMode?:ConstrainDOMString;frameRate?:ConstrainDouble;groupId?:ConstrainDOMString;height?:ConstrainULong;latency?:ConstrainDouble;noiseSuppression?:ConstrainBoolean;resizeMode?:ConstrainDOMString;sampleRate?:ConstrainULong;sampleSize?:ConstrainULong;width?:ConstrainULong;}interface MediaTrackConstraints extends MediaTrackConstraintSet{advanced?:MediaTrackConstraintSet[];}interface MediaTrackSettings{aspectRatio?:number;autoGainControl?:boolean;channelCount?:number;deviceId?:string;echoCancellation?:boolean;facingMode?:string;frameRate?:number;groupId?:string;height?:number;latency?:number;noiseSuppression?:boolean;resizeMode?:string;sampleRate?:number;sampleSize?:number;width?:number;}interface MediaTrackSupportedConstraints{aspectRatio?:boolean;autoGainControl?:boolean;channelCount?:boolean;deviceId?:boolean;echoCancellation?:boolean;facingMode?:boolean;frameRate?:boolean;groupId?:boolean;height?:boolean;latency?:boolean;noiseSuppression?:boolean;resizeMode?:boolean;sampleRate?:boolean;sampleSize?:boolean;width?:boolean;}interface MessageEventInit extends EventInit{data?:any;lastEventId?:string;origin?:string;ports?:MessagePort[];source?:MessageEventSource|null;}interface MidiPermissionDescriptor extends PermissionDescriptor{name:"midi";sysex?:boolean;}interface MouseEventInit extends EventModifierInit{button?:number;buttons?:number;clientX?:number;clientY?:number;movementX?:number;movementY?:number;relatedTarget?:EventTarget|null;screenX?:number;screenY?:number;}interface MultiCacheQueryOptions extends CacheQueryOptions{cacheName?:string;}interface MutationObserverInit{attributeFilter?:string[];attributeOldValue?:boolean;attributes?:boolean;characterData?:boolean;characterDataOldValue?:boolean;childList?:boolean;subtree?:boolean;}interface NavigationPreloadState{enabled?:boolean;headerValue?:string;}interface NotificationAction{action:string;icon?:string;title:string;}interface NotificationOptions{actions?:NotificationAction[];badge?:string;body?:string;data?:any;dir?:NotificationDirection;icon?:string;image?:string;lang?:string;renotify?:boolean;requireInteraction?:boolean;silent?:boolean;tag?:string;timestamp?:number;vibrate?:VibratePattern;}interface OfflineAudioCompletionEventInit extends EventInit{renderedBuffer:AudioBuffer;}interface OfflineAudioContextOptions{length:number;numberOfChannels?:number;sampleRate:number;}interface OptionalEffectTiming{delay?:number;direction?:PlaybackDirection;duration?:number|string;easing?:string;endDelay?:number;fill?:FillMode;iterationStart?:number;iterations?:number;}interface OscillatorOptions extends AudioNodeOptions{detune?:number;frequency?:number;periodicWave?:PeriodicWave;type?:OscillatorType;}interface PageTransitionEventInit extends EventInit{persisted?:boolean;}interface PannerOptions extends AudioNodeOptions{coneInnerAngle?:number;coneOuterAngle?:number;coneOuterGain?:number;distanceModel?:DistanceModelType;maxDistance?:number;orientationX?:number;orientationY?:number;orientationZ?:number;panningModel?:PanningModelType;positionX?:number;positionY?:number;positionZ?:number;refDistance?:number;rolloffFactor?:number;}interface PaymentCurrencyAmount{currency:string;currencySystem?:string;value:string;}interface PaymentDetailsBase{displayItems?:PaymentItem[];modifiers?:PaymentDetailsModifier[];shippingOptions?:PaymentShippingOption[];}interface PaymentDetailsInit extends PaymentDetailsBase{id?:string;total:PaymentItem;}interface PaymentDetailsModifier{additionalDisplayItems?:PaymentItem[];data?:any;supportedMethods:string|string[];total?:PaymentItem;}interface PaymentDetailsUpdate extends PaymentDetailsBase{error?:string;total?:PaymentItem;}interface PaymentItem{amount:PaymentCurrencyAmount;label:string;pending?:boolean;}interface PaymentMethodData{data?:any;supportedMethods:string|string[];}interface PaymentOptions{requestPayerEmail?:boolean;requestPayerName?:boolean;requestPayerPhone?:boolean;requestShipping?:boolean;shippingType?:string;}interface PaymentRequestUpdateEventInit extends EventInit{}interface PaymentShippingOption{amount:PaymentCurrencyAmount;id:string;label:string;selected?:boolean;}interface Pbkdf2Params extends Algorithm{hash:HashAlgorithmIdentifier;iterations:number;salt:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface PerformanceObserverInit{buffered?:boolean;entryTypes?:string[];type?:string;}interface PeriodicWaveConstraints{disableNormalization?:boolean;}interface PeriodicWaveOptions extends PeriodicWaveConstraints{imag?:number[]|Float32Array;real?:number[]|Float32Array;}interface PermissionDescriptor{name:PermissionName;}interface PipeOptions{preventAbort?:boolean;preventCancel?:boolean;preventClose?:boolean;signal?:AbortSignal;}interface PointerEventInit extends MouseEventInit{height?:number;isPrimary?:boolean;pointerId?:number;pointerType?:string;pressure?:number;tangentialPressure?:number;tiltX?:number;tiltY?:number;twist?:number;width?:number;}interface PopStateEventInit extends EventInit{state?:any;}interface PositionOptions{enableHighAccuracy?:boolean;maximumAge?:number;timeout?:number;}interface PostMessageOptions{transfer?:any[];}interface ProgressEventInit extends EventInit{lengthComputable?:boolean;loaded?:number;total?:number;}interface PromiseRejectionEventInit extends EventInit{promise:Promise<any>;reason?:any;}interface PropertyIndexedKeyframes{composite?:CompositeOperationOrAuto|CompositeOperationOrAuto[];easing?:string|string[];offset?:number|(number|null)[];[property:string]:string|string[]|number|null|(number|null)[]|undefined;}interface PublicKeyCredentialCreationOptions{attestation?:AttestationConveyancePreference;authenticatorSelection?:AuthenticatorSelectionCriteria;challenge:BufferSource;excludeCredentials?:PublicKeyCredentialDescriptor[];extensions?:AuthenticationExtensionsClientInputs;pubKeyCredParams:PublicKeyCredentialParameters[];rp:PublicKeyCredentialRpEntity;timeout?:number;user:PublicKeyCredentialUserEntity;}interface PublicKeyCredentialDescriptor{id:BufferSource;transports?:AuthenticatorTransport[];type:PublicKeyCredentialType;}interface PublicKeyCredentialEntity{icon?:string;name:string;}interface PublicKeyCredentialParameters{alg:COSEAlgorithmIdentifier;type:PublicKeyCredentialType;}interface PublicKeyCredentialRequestOptions{allowCredentials?:PublicKeyCredentialDescriptor[];challenge:BufferSource;extensions?:AuthenticationExtensionsClientInputs;rpId?:string;timeout?:number;userVerification?:UserVerificationRequirement;}interface PublicKeyCredentialRpEntity extends PublicKeyCredentialEntity{id?:string;}interface PublicKeyCredentialUserEntity extends PublicKeyCredentialEntity{displayName:string;id:BufferSource;}interface PushPermissionDescriptor extends PermissionDescriptor{name:"push";userVisibleOnly?:boolean;}interface PushSubscriptionJSON{endpoint?:string;expirationTime?:number|null;keys?:Record<string,string>;}interface PushSubscriptionOptionsInit{applicationServerKey?:BufferSource|string|null;userVisibleOnly?:boolean;}interface QueuingStrategy<T=any>{highWaterMark?:number;size?:QueuingStrategySizeCallback<T>;}interface RTCAnswerOptions extends RTCOfferAnswerOptions{}interface RTCCertificateExpiration{expires?:number;}interface RTCConfiguration{bundlePolicy?:RTCBundlePolicy;certificates?:RTCCertificate[];iceCandidatePoolSize?:number;iceServers?:RTCIceServer[];iceTransportPolicy?:RTCIceTransportPolicy;peerIdentity?:string;rtcpMuxPolicy?:RTCRtcpMuxPolicy;}interface RTCDTMFToneChangeEventInit extends EventInit{tone:string;}interface RTCDataChannelEventInit extends EventInit{channel:RTCDataChannel;}interface RTCDataChannelInit{id?:number;maxPacketLifeTime?:number;maxRetransmits?:number;negotiated?:boolean;ordered?:boolean;priority?:RTCPriorityType;protocol?:string;}interface RTCDtlsFingerprint{algorithm?:string;value?:string;}interface RTCDtlsParameters{fingerprints?:RTCDtlsFingerprint[];role?:RTCDtlsRole;}interface RTCErrorEventInit extends EventInit{error:RTCError;}interface RTCErrorInit{errorDetail:RTCErrorDetailType;httpRequestStatusCode?:number;receivedAlert?:number;sctpCauseCode?:number;sdpLineNumber?:number;sentAlert?:number;}interface RTCIceCandidateAttributes extends RTCStats{addressSourceUrl?:string;candidateType?:RTCStatsIceCandidateType;ipAddress?:string;portNumber?:number;priority?:number;transport?:string;}interface RTCIceCandidateComplete{}interface RTCIceCandidateDictionary{foundation?:string;ip?:string;msMTurnSessionId?:string;port?:number;priority?:number;protocol?:RTCIceProtocol;relatedAddress?:string;relatedPort?:number;tcpType?:RTCIceTcpCandidateType;type?:RTCIceCandidateType;}interface RTCIceCandidateInit{candidate?:string;sdpMLineIndex?:number|null;sdpMid?:string|null;usernameFragment?:string|null;}interface RTCIceCandidatePair{local?:RTCIceCandidate;remote?:RTCIceCandidate;}interface RTCIceCandidatePairStats extends RTCStats{availableIncomingBitrate?:number;availableOutgoingBitrate?:number;bytesReceived?:number;bytesSent?:number;localCandidateId?:string;nominated?:boolean;priority?:number;readable?:boolean;remoteCandidateId?:string;roundTripTime?:number;state?:RTCStatsIceCandidatePairState;transportId?:string;writable?:boolean;}interface RTCIceGatherOptions{gatherPolicy?:RTCIceGatherPolicy;iceservers?:RTCIceServer[];}interface RTCIceParameters{password?:string;usernameFragment?:string;}interface RTCIceServer{credential?:string|RTCOAuthCredential;credentialType?:RTCIceCredentialType;urls:string|string[];username?:string;}interface RTCIdentityProviderOptions{peerIdentity?:string;protocol?:string;usernameHint?:string;}interface RTCInboundRTPStreamStats extends RTCRTPStreamStats{bytesReceived?:number;fractionLost?:number;jitter?:number;packetsLost?:number;packetsReceived?:number;}interface RTCMediaStreamTrackStats extends RTCStats{audioLevel?:number;echoReturnLoss?:number;echoReturnLossEnhancement?:number;frameHeight?:number;frameWidth?:number;framesCorrupted?:number;framesDecoded?:number;framesDropped?:number;framesPerSecond?:number;framesReceived?:number;framesSent?:number;remoteSource?:boolean;ssrcIds?:string[];trackIdentifier?:string;}interface RTCOAuthCredential{accessToken:string;macKey:string;}interface RTCOfferAnswerOptions{voiceActivityDetection?:boolean;}interface RTCOfferOptions extends RTCOfferAnswerOptions{iceRestart?:boolean;offerToReceiveAudio?:boolean;offerToReceiveVideo?:boolean;}interface RTCOutboundRTPStreamStats extends RTCRTPStreamStats{bytesSent?:number;packetsSent?:number;roundTripTime?:number;targetBitrate?:number;}interface RTCPeerConnectionIceErrorEventInit extends EventInit{errorCode:number;hostCandidate?:string;statusText?:string;url?:string;}interface RTCPeerConnectionIceEventInit extends EventInit{candidate?:RTCIceCandidate|null;url?:string|null;}interface RTCRTPStreamStats extends RTCStats{associateStatsId?:string;codecId?:string;firCount?:number;isRemote?:boolean;mediaTrackId?:string;mediaType?:string;nackCount?:number;pliCount?:number;sliCount?:number;ssrc?:string;transportId?:string;}interface RTCRtcpFeedback{parameter?:string;type?:string;}interface RTCRtcpParameters{cname?:string;reducedSize?:boolean;}interface RTCRtpCapabilities{codecs:RTCRtpCodecCapability[];headerExtensions:RTCRtpHeaderExtensionCapability[];}interface RTCRtpCodecCapability{channels?:number;clockRate:number;mimeType:string;sdpFmtpLine?:string;}interface RTCRtpCodecParameters{channels?:number;clockRate:number;mimeType:string;payloadType:number;sdpFmtpLine?:string;}interface RTCRtpCodingParameters{rid?:string;}interface RTCRtpContributingSource{audioLevel?:number;rtpTimestamp:number;source:number;timestamp:number;}interface RTCRtpDecodingParameters extends RTCRtpCodingParameters{}interface RTCRtpEncodingParameters extends RTCRtpCodingParameters{active?:boolean;codecPayloadType?:number;dtx?:RTCDtxStatus;maxBitrate?:number;maxFramerate?:number;ptime?:number;scaleResolutionDownBy?:number;}interface RTCRtpFecParameters{mechanism?:string;ssrc?:number;}interface RTCRtpHeaderExtension{kind?:string;preferredEncrypt?:boolean;preferredId?:number;uri?:string;}interface RTCRtpHeaderExtensionCapability{uri?:string;}interface RTCRtpHeaderExtensionParameters{encrypted?:boolean;id:number;uri:string;}interface RTCRtpParameters{codecs:RTCRtpCodecParameters[];headerExtensions:RTCRtpHeaderExtensionParameters[];rtcp:RTCRtcpParameters;}interface RTCRtpReceiveParameters extends RTCRtpParameters{encodings:RTCRtpDecodingParameters[];}interface RTCRtpRtxParameters{ssrc?:number;}interface RTCRtpSendParameters extends RTCRtpParameters{degradationPreference?:RTCDegradationPreference;encodings:RTCRtpEncodingParameters[];priority?:RTCPriorityType;transactionId:string;}interface RTCRtpSynchronizationSource extends RTCRtpContributingSource{voiceActivityFlag?:boolean;}interface RTCRtpTransceiverInit{direction?:RTCRtpTransceiverDirection;sendEncodings?:RTCRtpEncodingParameters[];streams?:MediaStream[];}interface RTCRtpUnhandled{muxId?:string;payloadType?:number;ssrc?:number;}interface RTCSessionDescriptionInit{sdp?:string;type?:RTCSdpType;}interface RTCSrtpKeyParam{keyMethod?:string;keySalt?:string;lifetime?:string;mkiLength?:number;mkiValue?:number;}interface RTCSrtpSdesParameters{cryptoSuite?:string;keyParams?:RTCSrtpKeyParam[];sessionParams?:string[];tag?:number;}interface RTCSsrcRange{max?:number;min?:number;}interface RTCStats{id:string;timestamp:number;type:RTCStatsType;}interface RTCStatsEventInit extends EventInit{report:RTCStatsReport;}interface RTCStatsReport{}interface RTCTrackEventInit extends EventInit{receiver:RTCRtpReceiver;streams?:MediaStream[];track:MediaStreamTrack;transceiver:RTCRtpTransceiver;}interface RTCTransportStats extends RTCStats{activeConnection?:boolean;bytesReceived?:number;bytesSent?:number;localCertificateId?:string;remoteCertificateId?:string;rtcpTransportStatsId?:string;selectedCandidatePairId?:string;}interface ReadableStreamReadDoneResult<T>{done:true;value?:T;}interface ReadableStreamReadValueResult<T>{done:false;value:T;}interface RegistrationOptions{scope?:string;type?:WorkerType;updateViaCache?:ServiceWorkerUpdateViaCache;}interface RequestInit{body?:BodyInit|null;cache?:RequestCache;credentials?:RequestCredentials;headers?:HeadersInit;integrity?:string;keepalive?:boolean;method?:string;mode?:RequestMode;redirect?:RequestRedirect;referrer?:string;referrerPolicy?:ReferrerPolicy;signal?:AbortSignal|null;window?:any;}interface ResponseInit{headers?:HeadersInit;status?:number;statusText?:string;}interface RsaHashedImportParams extends Algorithm{hash:HashAlgorithmIdentifier;}interface RsaHashedKeyAlgorithm extends RsaKeyAlgorithm{hash:KeyAlgorithm;}interface RsaHashedKeyGenParams extends RsaKeyGenParams{hash:HashAlgorithmIdentifier;}interface RsaKeyAlgorithm extends KeyAlgorithm{modulusLength:number;publicExponent:BigInteger;}interface RsaKeyGenParams extends Algorithm{modulusLength:number;publicExponent:BigInteger;}interface RsaOaepParams extends Algorithm{label?:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface RsaOtherPrimesInfo{d?:string;r?:string;t?:string;}interface RsaPssParams extends Algorithm{saltLength:number;}interface SVGBoundingBoxOptions{clipped?:boolean;fill?:boolean;markers?:boolean;stroke?:boolean;}interface ScopedCredentialDescriptor{id:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer|null;transports?:Transport[];type:ScopedCredentialType;}interface ScopedCredentialOptions{excludeList?:ScopedCredentialDescriptor[];extensions?:WebAuthnExtensions;rpId?:string;timeoutSeconds?:number;}interface ScopedCredentialParameters{algorithm:string|Algorithm;type:ScopedCredentialType;}interface ScrollIntoViewOptions extends ScrollOptions{block?:ScrollLogicalPosition;inline?:ScrollLogicalPosition;}interface ScrollOptions{behavior?:ScrollBehavior;}interface ScrollToOptions extends ScrollOptions{left?:number;top?:number;}interface SecurityPolicyViolationEventInit extends EventInit{blockedURI?:string;columnNumber?:number;documentURI?:string;effectiveDirective?:string;lineNumber?:number;originalPolicy?:string;referrer?:string;sourceFile?:string;statusCode?:number;violatedDirective?:string;}interface ServiceWorkerMessageEventInit extends EventInit{data?:any;lastEventId?:string;origin?:string;ports?:MessagePort[]|null;source?:ServiceWorker|MessagePort|null;}interface ShadowRootInit{delegatesFocus?:boolean;mode:ShadowRootMode;}interface ShareData{text?:string;title?:string;url?:string;}interface SpeechSynthesisErrorEventInit extends SpeechSynthesisEventInit{error:SpeechSynthesisErrorCode;}interface SpeechSynthesisEventInit extends EventInit{charIndex?:number;charLength?:number;elapsedTime?:number;name?:string;utterance:SpeechSynthesisUtterance;}interface StaticRangeInit{endContainer:Node;endOffset:number;startContainer:Node;startOffset:number;}interface StereoPannerOptions extends AudioNodeOptions{pan?:number;}interface StorageEstimate{quota?:number;usage?:number;}interface StorageEventInit extends EventInit{key?:string|null;newValue?:string|null;oldValue?:string|null;storageArea?:Storage|null;url?:string;}interface StoreExceptionsInformation extends ExceptionInformation{detailURI?:string|null;explanationString?:string|null;siteName?:string|null;}interface StoreSiteSpecificExceptionsInformation extends StoreExceptionsInformation{arrayOfDomainStrings?:string[];}interface TextDecodeOptions{stream?:boolean;}interface TextDecoderOptions{fatal?:boolean;ignoreBOM?:boolean;}interface TextEncoderEncodeIntoResult{read?:number;written?:number;}interface TouchEventInit extends EventModifierInit{changedTouches?:Touch[];targetTouches?:Touch[];touches?:Touch[];}interface TouchInit{altitudeAngle?:number;azimuthAngle?:number;clientX?:number;clientY?:number;force?:number;identifier:number;pageX?:number;pageY?:number;radiusX?:number;radiusY?:number;rotationAngle?:number;screenX?:number;screenY?:number;target:EventTarget;touchType?:TouchType;}interface TrackEventInit extends EventInit{track?:TextTrack|null;}interface Transformer<I=any,O=any>{flush?:TransformStreamDefaultControllerCallback<O>;readableType?:undefined;start?:TransformStreamDefaultControllerCallback<O>;transform?:TransformStreamDefaultControllerTransformCallback<I,O>;writableType?:undefined;}interface TransitionEventInit extends EventInit{elapsedTime?:number;propertyName?:string;pseudoElement?:string;}interface UIEventInit extends EventInit{detail?:number;view?:Window|null;}interface ULongRange{max?:number;min?:number;}interface UnderlyingByteSource{autoAllocateChunkSize?:number;cancel?:ReadableStreamErrorCallback;pull?:ReadableByteStreamControllerCallback;start?:ReadableByteStreamControllerCallback;type:"bytes";}interface UnderlyingSink<W=any>{abort?:WritableStreamErrorCallback;close?:WritableStreamDefaultControllerCloseCallback;start?:WritableStreamDefaultControllerStartCallback;type?:undefined;write?:WritableStreamDefaultControllerWriteCallback<W>;}interface UnderlyingSource<R=any>{cancel?:ReadableStreamErrorCallback;pull?:ReadableStreamDefaultControllerCallback<R>;start?:ReadableStreamDefaultControllerCallback<R>;type?:undefined;}interface VRDisplayEventInit extends EventInit{display:VRDisplay;reason?:VRDisplayEventReason;}interface VRLayer{leftBounds?:number[]|Float32Array|null;rightBounds?:number[]|Float32Array|null;source?:HTMLCanvasElement|null;}interface VRStageParameters{sittingToStandingTransform?:Float32Array;sizeX?:number;sizeY?:number;}interface WaveShaperOptions extends AudioNodeOptions{curve?:number[]|Float32Array;oversample?:OverSampleType;}interface WebAuthnExtensions{}interface WebGLContextAttributes{alpha?:boolean;antialias?:boolean;depth?:boolean;desynchronized?:boolean;failIfMajorPerformanceCaveat?:boolean;powerPreference?:WebGLPowerPreference;premultipliedAlpha?:boolean;preserveDrawingBuffer?:boolean;stencil?:boolean;}interface WebGLContextEventInit extends EventInit{statusMessage?:string;}interface WheelEventInit extends MouseEventInit{deltaMode?:number;deltaX?:number;deltaY?:number;deltaZ?:number;}interface WorkerOptions{credentials?:RequestCredentials;name?:string;type?:WorkerType;}interface WorkletOptions{credentials?:RequestCredentials;}interface txAuthGenericArg{content:ArrayBuffer;contentType:string;}interface EventListener{(evt:Event):void;}type XPathNSResolver=((prefix:string|null)=>string|null)|{lookupNamespaceURI(prefix:string|null):string|null;};interface ANGLE_instanced_arrays{drawArraysInstancedANGLE(mode:GLenum,first:GLint,count:GLsizei,primcount:GLsizei):void;drawElementsInstancedANGLE(mode:GLenum,count:GLsizei,type:GLenum,offset:GLintptr,primcount:GLsizei):void;vertexAttribDivisorANGLE(index:GLuint,divisor:GLuint):void;readonly VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE:GLenum;}interface AbortController{readonly signal:AbortSignal;abort():void;}declare var AbortController:{prototype:AbortController;new():AbortController;};interface AbortSignalEventMap{"abort":Event;}interface AbortSignal extends EventTarget{readonly aborted:boolean;onabort:((this:AbortSignal,ev:Event)=>any)|null;addEventListener<K extends keyof AbortSignalEventMap>(type:K,listener:(this:AbortSignal,ev:AbortSignalEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AbortSignalEventMap>(type:K,listener:(this:AbortSignal,ev:AbortSignalEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var AbortSignal:{prototype:AbortSignal;new():AbortSignal;};interface AbstractRange{readonly collapsed:boolean;readonly endContainer:Node;readonly endOffset:number;readonly startContainer:Node;readonly startOffset:number;}declare var AbstractRange:{prototype:AbstractRange;new():AbstractRange;};interface AbstractWorkerEventMap{"error":ErrorEvent;}interface AbstractWorker{onerror:((this:AbstractWorker,ev:ErrorEvent)=>any)|null;addEventListener<K extends keyof AbstractWorkerEventMap>(type:K,listener:(this:AbstractWorker,ev:AbstractWorkerEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AbstractWorkerEventMap>(type:K,listener:(this:AbstractWorker,ev:AbstractWorkerEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}interface AesCfbParams extends Algorithm{iv:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface AesCmacParams extends Algorithm{length:number;}interface AnalyserNode extends AudioNode{fftSize:number;readonly frequencyBinCount:number;maxDecibels:number;minDecibels:number;smoothingTimeConstant:number;getByteFrequencyData(array:Uint8Array):void;getByteTimeDomainData(array:Uint8Array):void;getFloatFrequencyData(array:Float32Array):void;getFloatTimeDomainData(array:Float32Array):void;}declare var AnalyserNode:{prototype:AnalyserNode;new(context:BaseAudioContext,options?:AnalyserOptions):AnalyserNode;};interface Animatable{animate(keyframes:Keyframe[]|PropertyIndexedKeyframes|null,options?:number|KeyframeAnimationOptions):Animation;getAnimations():Animation[];}interface AnimationEventMap{"cancel":AnimationPlaybackEvent;"finish":AnimationPlaybackEvent;}interface Animation extends EventTarget{currentTime:number|null;effect:AnimationEffect|null;readonly finished:Promise<Animation>;id:string;oncancel:((this:Animation,ev:AnimationPlaybackEvent)=>any)|null;onfinish:((this:Animation,ev:AnimationPlaybackEvent)=>any)|null;readonly pending:boolean;readonly playState:AnimationPlayState;playbackRate:number;readonly ready:Promise<Animation>;startTime:number|null;timeline:AnimationTimeline|null;cancel():void;finish():void;pause():void;play():void;reverse():void;updatePlaybackRate(playbackRate:number):void;addEventListener<K extends keyof AnimationEventMap>(type:K,listener:(this:Animation,ev:AnimationEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AnimationEventMap>(type:K,listener:(this:Animation,ev:AnimationEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var Animation:{prototype:Animation;new(effect?:AnimationEffect|null,timeline?:AnimationTimeline|null):Animation;};interface AnimationEffect{getComputedTiming():ComputedEffectTiming;getTiming():EffectTiming;updateTiming(timing?:OptionalEffectTiming):void;}declare var AnimationEffect:{prototype:AnimationEffect;new():AnimationEffect;};interface AnimationEvent extends Event{readonly animationName:string;readonly elapsedTime:number;readonly pseudoElement:string;}declare var AnimationEvent:{prototype:AnimationEvent;new(type:string,animationEventInitDict?:AnimationEventInit):AnimationEvent;};interface AnimationFrameProvider{cancelAnimationFrame(handle:number):void;requestAnimationFrame(callback:FrameRequestCallback):number;}interface AnimationPlaybackEvent extends Event{readonly currentTime:number|null;readonly timelineTime:number|null;}declare var AnimationPlaybackEvent:{prototype:AnimationPlaybackEvent;new(type:string,eventInitDict?:AnimationPlaybackEventInit):AnimationPlaybackEvent;};interface AnimationTimeline{readonly currentTime:number|null;}declare var AnimationTimeline:{prototype:AnimationTimeline;new():AnimationTimeline;};interface ApplicationCacheEventMap{"cached":Event;"checking":Event;"downloading":Event;"error":Event;"noupdate":Event;"obsolete":Event;"progress":ProgressEvent<ApplicationCache>;"updateready":Event;}interface ApplicationCache extends EventTarget{oncached:((this:ApplicationCache,ev:Event)=>any)|null;onchecking:((this:ApplicationCache,ev:Event)=>any)|null;ondownloading:((this:ApplicationCache,ev:Event)=>any)|null;onerror:((this:ApplicationCache,ev:Event)=>any)|null;onnoupdate:((this:ApplicationCache,ev:Event)=>any)|null;onobsolete:((this:ApplicationCache,ev:Event)=>any)|null;onprogress:((this:ApplicationCache,ev:ProgressEvent<ApplicationCache>)=>any)|null;onupdateready:((this:ApplicationCache,ev:Event)=>any)|null;readonly status:number;abort():void;swapCache():void;update():void;readonly CHECKING:number;readonly DOWNLOADING:number;readonly IDLE:number;readonly OBSOLETE:number;readonly UNCACHED:number;readonly UPDATEREADY:number;addEventListener<K extends keyof ApplicationCacheEventMap>(type:K,listener:(this:ApplicationCache,ev:ApplicationCacheEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ApplicationCacheEventMap>(type:K,listener:(this:ApplicationCache,ev:ApplicationCacheEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ApplicationCache:{prototype:ApplicationCache;new():ApplicationCache;readonly CHECKING:number;readonly DOWNLOADING:number;readonly IDLE:number;readonly OBSOLETE:number;readonly UNCACHED:number;readonly UPDATEREADY:number;};interface Attr extends Node{readonly localName:string;readonly name:string;readonly namespaceURI:string|null;readonly ownerDocument:Document;readonly ownerElement:Element|null;readonly prefix:string|null;readonly specified:boolean;value:string;}declare var Attr:{prototype:Attr;new():Attr;};interface AudioBuffer{readonly duration:number;readonly length:number;readonly numberOfChannels:number;readonly sampleRate:number;copyFromChannel(destination:Float32Array,channelNumber:number,bufferOffset?:number):void;copyToChannel(source:Float32Array,channelNumber:number,bufferOffset?:number):void;getChannelData(channel:number):Float32Array;}declare var AudioBuffer:{prototype:AudioBuffer;new(options:AudioBufferOptions):AudioBuffer;};interface AudioBufferSourceNode extends AudioScheduledSourceNode{buffer:AudioBuffer|null;readonly detune:AudioParam;loop:boolean;loopEnd:number;loopStart:number;readonly playbackRate:AudioParam;start(when?:number,offset?:number,duration?:number):void;addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type:K,listener:(this:AudioBufferSourceNode,ev:AudioScheduledSourceNodeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type:K,listener:(this:AudioBufferSourceNode,ev:AudioScheduledSourceNodeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var AudioBufferSourceNode:{prototype:AudioBufferSourceNode;new(context:BaseAudioContext,options?:AudioBufferSourceOptions):AudioBufferSourceNode;};interface AudioContext extends BaseAudioContext{readonly baseLatency:number;readonly outputLatency:number;close():Promise<void>;createMediaElementSource(mediaElement:HTMLMediaElement):MediaElementAudioSourceNode;createMediaStreamDestination():MediaStreamAudioDestinationNode;createMediaStreamSource(mediaStream:MediaStream):MediaStreamAudioSourceNode;createMediaStreamTrackSource(mediaStreamTrack:MediaStreamTrack):MediaStreamTrackAudioSourceNode;getOutputTimestamp():AudioTimestamp;resume():Promise<void>;suspend():Promise<void>;addEventListener<K extends keyof BaseAudioContextEventMap>(type:K,listener:(this:AudioContext,ev:BaseAudioContextEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof BaseAudioContextEventMap>(type:K,listener:(this:AudioContext,ev:BaseAudioContextEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var AudioContext:{prototype:AudioContext;new(contextOptions?:AudioContextOptions):AudioContext;};interface AudioDestinationNode extends AudioNode{readonly maxChannelCount:number;}declare var AudioDestinationNode:{prototype:AudioDestinationNode;new():AudioDestinationNode;};interface AudioListener{readonly forwardX:AudioParam;readonly forwardY:AudioParam;readonly forwardZ:AudioParam;readonly positionX:AudioParam;readonly positionY:AudioParam;readonly positionZ:AudioParam;readonly upX:AudioParam;readonly upY:AudioParam;readonly upZ:AudioParam;setOrientation(x:number,y:number,z:number,xUp:number,yUp:number,zUp:number):void;setPosition(x:number,y:number,z:number):void;}declare var AudioListener:{prototype:AudioListener;new():AudioListener;};interface AudioNode extends EventTarget{channelCount:number;channelCountMode:ChannelCountMode;channelInterpretation:ChannelInterpretation;readonly context:BaseAudioContext;readonly numberOfInputs:number;readonly numberOfOutputs:number;connect(destinationNode:AudioNode,output?:number,input?:number):AudioNode;connect(destinationParam:AudioParam,output?:number):void;disconnect():void;disconnect(output:number):void;disconnect(destinationNode:AudioNode):void;disconnect(destinationNode:AudioNode,output:number):void;disconnect(destinationNode:AudioNode,output:number,input:number):void;disconnect(destinationParam:AudioParam):void;disconnect(destinationParam:AudioParam,output:number):void;}declare var AudioNode:{prototype:AudioNode;new():AudioNode;};interface AudioParam{automationRate:AutomationRate;readonly defaultValue:number;readonly maxValue:number;readonly minValue:number;value:number;cancelAndHoldAtTime(cancelTime:number):AudioParam;cancelScheduledValues(cancelTime:number):AudioParam;exponentialRampToValueAtTime(value:number,endTime:number):AudioParam;linearRampToValueAtTime(value:number,endTime:number):AudioParam;setTargetAtTime(target:number,startTime:number,timeConstant:number):AudioParam;setValueAtTime(value:number,startTime:number):AudioParam;setValueCurveAtTime(values:number[]|Float32Array,startTime:number,duration:number):AudioParam;}declare var AudioParam:{prototype:AudioParam;new():AudioParam;};interface AudioParamMap{forEach(callbackfn:(value:AudioParam,key:string,parent:AudioParamMap)=>void,thisArg?:any):void;}declare var AudioParamMap:{prototype:AudioParamMap;new():AudioParamMap;};interface AudioProcessingEvent extends Event{readonly inputBuffer:AudioBuffer;readonly outputBuffer:AudioBuffer;readonly playbackTime:number;}declare var AudioProcessingEvent:{prototype:AudioProcessingEvent;new(type:string,eventInitDict:AudioProcessingEventInit):AudioProcessingEvent;};interface AudioScheduledSourceNodeEventMap{"ended":Event;}interface AudioScheduledSourceNode extends AudioNode{onended:((this:AudioScheduledSourceNode,ev:Event)=>any)|null;start(when?:number):void;stop(when?:number):void;addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type:K,listener:(this:AudioScheduledSourceNode,ev:AudioScheduledSourceNodeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type:K,listener:(this:AudioScheduledSourceNode,ev:AudioScheduledSourceNodeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var AudioScheduledSourceNode:{prototype:AudioScheduledSourceNode;new():AudioScheduledSourceNode;};interface AudioWorklet extends Worklet{}declare var AudioWorklet:{prototype:AudioWorklet;new():AudioWorklet;};interface AudioWorkletNodeEventMap{"processorerror":Event;}interface AudioWorkletNode extends AudioNode{onprocessorerror:((this:AudioWorkletNode,ev:Event)=>any)|null;readonly parameters:AudioParamMap;readonly port:MessagePort;addEventListener<K extends keyof AudioWorkletNodeEventMap>(type:K,listener:(this:AudioWorkletNode,ev:AudioWorkletNodeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AudioWorkletNodeEventMap>(type:K,listener:(this:AudioWorkletNode,ev:AudioWorkletNodeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var AudioWorkletNode:{prototype:AudioWorkletNode;new(context:BaseAudioContext,name:string,options?:AudioWorkletNodeOptions):AudioWorkletNode;};interface AuthenticatorAssertionResponse extends AuthenticatorResponse{readonly authenticatorData:ArrayBuffer;readonly signature:ArrayBuffer;readonly userHandle:ArrayBuffer|null;}declare var AuthenticatorAssertionResponse:{prototype:AuthenticatorAssertionResponse;new():AuthenticatorAssertionResponse;};interface AuthenticatorAttestationResponse extends AuthenticatorResponse{readonly attestationObject:ArrayBuffer;}declare var AuthenticatorAttestationResponse:{prototype:AuthenticatorAttestationResponse;new():AuthenticatorAttestationResponse;};interface AuthenticatorResponse{readonly clientDataJSON:ArrayBuffer;}declare var AuthenticatorResponse:{prototype:AuthenticatorResponse;new():AuthenticatorResponse;};interface BarProp{readonly visible:boolean;}declare var BarProp:{prototype:BarProp;new():BarProp;};interface BaseAudioContextEventMap{"statechange":Event;}interface BaseAudioContext extends EventTarget{readonly audioWorklet:AudioWorklet;readonly currentTime:number;readonly destination:AudioDestinationNode;readonly listener:AudioListener;onstatechange:((this:BaseAudioContext,ev:Event)=>any)|null;readonly sampleRate:number;readonly state:AudioContextState;createAnalyser():AnalyserNode;createBiquadFilter():BiquadFilterNode;createBuffer(numberOfChannels:number,length:number,sampleRate:number):AudioBuffer;createBufferSource():AudioBufferSourceNode;createChannelMerger(numberOfInputs?:number):ChannelMergerNode;createChannelSplitter(numberOfOutputs?:number):ChannelSplitterNode;createConstantSource():ConstantSourceNode;createConvolver():ConvolverNode;createDelay(maxDelayTime?:number):DelayNode;createDynamicsCompressor():DynamicsCompressorNode;createGain():GainNode;createIIRFilter(feedforward:number[],feedback:number[]):IIRFilterNode;createOscillator():OscillatorNode;createPanner():PannerNode;createPeriodicWave(real:number[]|Float32Array,imag:number[]|Float32Array,constraints?:PeriodicWaveConstraints):PeriodicWave;createScriptProcessor(bufferSize?:number,numberOfInputChannels?:number,numberOfOutputChannels?:number):ScriptProcessorNode;createStereoPanner():StereoPannerNode;createWaveShaper():WaveShaperNode;decodeAudioData(audioData:ArrayBuffer,successCallback?:DecodeSuccessCallback|null,errorCallback?:DecodeErrorCallback|null):Promise<AudioBuffer>;addEventListener<K extends keyof BaseAudioContextEventMap>(type:K,listener:(this:BaseAudioContext,ev:BaseAudioContextEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof BaseAudioContextEventMap>(type:K,listener:(this:BaseAudioContext,ev:BaseAudioContextEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var BaseAudioContext:{prototype:BaseAudioContext;new():BaseAudioContext;};interface BeforeUnloadEvent extends Event{returnValue:any;}declare var BeforeUnloadEvent:{prototype:BeforeUnloadEvent;new():BeforeUnloadEvent;};interface BhxBrowser{readonly lastError:DOMException;checkMatchesGlobExpression(pattern:string,value:string):boolean;checkMatchesUriExpression(pattern:string,value:string):boolean;clearLastError():void;currentWindowId():number;fireExtensionApiTelemetry(functionName:string,isSucceeded:boolean,isSupported:boolean,errorString:string):void;genericFunction(functionId:number,destination:any,parameters?:string,callbackId?:number):void;genericSynchronousFunction(functionId:number,parameters?:string):string;getExtensionId():string;getThisAddress():any;registerGenericFunctionCallbackHandler(callbackHandler:Function):void;registerGenericListenerHandler(eventHandler:Function):void;setLastError(parameters:string):void;webPlatformGenericFunction(destination:any,parameters?:string,callbackId?:number):void;}declare var BhxBrowser:{prototype:BhxBrowser;new():BhxBrowser;};interface BiquadFilterNode extends AudioNode{readonly Q:AudioParam;readonly detune:AudioParam;readonly frequency:AudioParam;readonly gain:AudioParam;type:BiquadFilterType;getFrequencyResponse(frequencyHz:Float32Array,magResponse:Float32Array,phaseResponse:Float32Array):void;}declare var BiquadFilterNode:{prototype:BiquadFilterNode;new(context:BaseAudioContext,options?:BiquadFilterOptions):BiquadFilterNode;};interface Blob{readonly size:number;readonly type:string;arrayBuffer():Promise<ArrayBuffer>;slice(start?:number,end?:number,contentType?:string):Blob;stream():ReadableStream;text():Promise<string>;}declare var Blob:{prototype:Blob;new(blobParts?:BlobPart[],options?:BlobPropertyBag):Blob;};interface Body{readonly body:ReadableStream<Uint8Array>|null;readonly bodyUsed:boolean;arrayBuffer():Promise<ArrayBuffer>;blob():Promise<Blob>;formData():Promise<FormData>;json():Promise<any>;text():Promise<string>;}interface BroadcastChannelEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface BroadcastChannel extends EventTarget{readonly name:string;onmessage:((this:BroadcastChannel,ev:MessageEvent)=>any)|null;onmessageerror:((this:BroadcastChannel,ev:MessageEvent)=>any)|null;close():void;postMessage(message:any):void;addEventListener<K extends keyof BroadcastChannelEventMap>(type:K,listener:(this:BroadcastChannel,ev:BroadcastChannelEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof BroadcastChannelEventMap>(type:K,listener:(this:BroadcastChannel,ev:BroadcastChannelEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var BroadcastChannel:{prototype:BroadcastChannel;new(name:string):BroadcastChannel;};interface ByteLengthQueuingStrategy extends QueuingStrategy<ArrayBufferView>{highWaterMark:number;size(chunk:ArrayBufferView):number;}declare var ByteLengthQueuingStrategy:{prototype:ByteLengthQueuingStrategy;new(options:{highWaterMark:number}):ByteLengthQueuingStrategy;};interface CDATASection extends Text{}declare var CDATASection:{prototype:CDATASection;new():CDATASection;};interface CSSConditionRule extends CSSGroupingRule{conditionText:string;}declare var CSSConditionRule:{prototype:CSSConditionRule;new():CSSConditionRule;};interface CSSFontFaceRule extends CSSRule{readonly style:CSSStyleDeclaration;}declare var CSSFontFaceRule:{prototype:CSSFontFaceRule;new():CSSFontFaceRule;};interface CSSGroupingRule extends CSSRule{readonly cssRules:CSSRuleList;deleteRule(index:number):void;insertRule(rule:string,index?:number):number;}declare var CSSGroupingRule:{prototype:CSSGroupingRule;new():CSSGroupingRule;};interface CSSImportRule extends CSSRule{readonly href:string;readonly media:MediaList;readonly styleSheet:CSSStyleSheet;}declare var CSSImportRule:{prototype:CSSImportRule;new():CSSImportRule;};interface CSSKeyframeRule extends CSSRule{keyText:string;readonly style:CSSStyleDeclaration;}declare var CSSKeyframeRule:{prototype:CSSKeyframeRule;new():CSSKeyframeRule;};interface CSSKeyframesRule extends CSSRule{readonly cssRules:CSSRuleList;name:string;appendRule(rule:string):void;deleteRule(select:string):void;findRule(select:string):CSSKeyframeRule|null;}declare var CSSKeyframesRule:{prototype:CSSKeyframesRule;new():CSSKeyframesRule;};interface CSSMediaRule extends CSSConditionRule{readonly media:MediaList;}declare var CSSMediaRule:{prototype:CSSMediaRule;new():CSSMediaRule;};interface CSSNamespaceRule extends CSSRule{readonly namespaceURI:string;readonly prefix:string;}declare var CSSNamespaceRule:{prototype:CSSNamespaceRule;new():CSSNamespaceRule;};interface CSSPageRule extends CSSGroupingRule{selectorText:string;readonly style:CSSStyleDeclaration;}declare var CSSPageRule:{prototype:CSSPageRule;new():CSSPageRule;};interface CSSRule{cssText:string;readonly parentRule:CSSRule|null;readonly parentStyleSheet:CSSStyleSheet|null;readonly type:number;readonly CHARSET_RULE:number;readonly FONT_FACE_RULE:number;readonly IMPORT_RULE:number;readonly KEYFRAMES_RULE:number;readonly KEYFRAME_RULE:number;readonly MEDIA_RULE:number;readonly NAMESPACE_RULE:number;readonly PAGE_RULE:number;readonly STYLE_RULE:number;readonly SUPPORTS_RULE:number;}declare var CSSRule:{prototype:CSSRule;new():CSSRule;readonly CHARSET_RULE:number;readonly FONT_FACE_RULE:number;readonly IMPORT_RULE:number;readonly KEYFRAMES_RULE:number;readonly KEYFRAME_RULE:number;readonly MEDIA_RULE:number;readonly NAMESPACE_RULE:number;readonly PAGE_RULE:number;readonly STYLE_RULE:number;readonly SUPPORTS_RULE:number;};interface CSSRuleList{readonly length:number;item(index:number):CSSRule|null;[index:number]:CSSRule;}declare var CSSRuleList:{prototype:CSSRuleList;new():CSSRuleList;};interface CSSStyleDeclaration{alignContent:string;alignItems:string;alignSelf:string;alignmentBaseline:string;all:string;animation:string;animationDelay:string;animationDirection:string;animationDuration:string;animationFillMode:string;animationIterationCount:string;animationName:string;animationPlayState:string;animationTimingFunction:string;backfaceVisibility:string;background:string;backgroundAttachment:string;backgroundClip:string;backgroundColor:string;backgroundImage:string;backgroundOrigin:string;backgroundPosition:string;backgroundPositionX:string;backgroundPositionY:string;backgroundRepeat:string;backgroundSize:string;baselineShift:string;blockSize:string;border:string;borderBlockEnd:string;borderBlockEndColor:string;borderBlockEndStyle:string;borderBlockEndWidth:string;borderBlockStart:string;borderBlockStartColor:string;borderBlockStartStyle:string;borderBlockStartWidth:string;borderBottom:string;borderBottomColor:string;borderBottomLeftRadius:string;borderBottomRightRadius:string;borderBottomStyle:string;borderBottomWidth:string;borderCollapse:string;borderColor:string;borderImage:string;borderImageOutset:string;borderImageRepeat:string;borderImageSlice:string;borderImageSource:string;borderImageWidth:string;borderInlineEnd:string;borderInlineEndColor:string;borderInlineEndStyle:string;borderInlineEndWidth:string;borderInlineStart:string;borderInlineStartColor:string;borderInlineStartStyle:string;borderInlineStartWidth:string;borderLeft:string;borderLeftColor:string;borderLeftStyle:string;borderLeftWidth:string;borderRadius:string;borderRight:string;borderRightColor:string;borderRightStyle:string;borderRightWidth:string;borderSpacing:string;borderStyle:string;borderTop:string;borderTopColor:string;borderTopLeftRadius:string;borderTopRightRadius:string;borderTopStyle:string;borderTopWidth:string;borderWidth:string;bottom:string;boxShadow:string;boxSizing:string;breakAfter:string;breakBefore:string;breakInside:string;captionSide:string;caretColor:string;clear:string;clip:string;clipPath:string;clipRule:string;color:string;colorInterpolation:string;colorInterpolationFilters:string;columnCount:string;columnFill:string;columnGap:string;columnRule:string;columnRuleColor:string;columnRuleStyle:string;columnRuleWidth:string;columnSpan:string;columnWidth:string;columns:string;content:string;counterIncrement:string;counterReset:string;cssFloat:string;cssText:string;cursor:string;direction:string;display:string;dominantBaseline:string;emptyCells:string;fill:string;fillOpacity:string;fillRule:string;filter:string;flex:string;flexBasis:string;flexDirection:string;flexFlow:string;flexGrow:string;flexShrink:string;flexWrap:string;float:string;floodColor:string;floodOpacity:string;font:string;fontFamily:string;fontFeatureSettings:string;fontKerning:string;fontSize:string;fontSizeAdjust:string;fontStretch:string;fontStyle:string;fontSynthesis:string;fontVariant:string;fontVariantCaps:string;fontVariantEastAsian:string;fontVariantLigatures:string;fontVariantNumeric:string;fontVariantPosition:string;fontWeight:string;gap:string;glyphOrientationVertical:string;grid:string;gridArea:string;gridAutoColumns:string;gridAutoFlow:string;gridAutoRows:string;gridColumn:string;gridColumnEnd:string;gridColumnGap:string;gridColumnStart:string;gridGap:string;gridRow:string;gridRowEnd:string;gridRowGap:string;gridRowStart:string;gridTemplate:string;gridTemplateAreas:string;gridTemplateColumns:string;gridTemplateRows:string;height:string;hyphens:string;imageOrientation:string;imageRendering:string;inlineSize:string;justifyContent:string;justifyItems:string;justifySelf:string;left:string;readonly length:number;letterSpacing:string;lightingColor:string;lineBreak:string;lineHeight:string;listStyle:string;listStyleImage:string;listStylePosition:string;listStyleType:string;margin:string;marginBlockEnd:string;marginBlockStart:string;marginBottom:string;marginInlineEnd:string;marginInlineStart:string;marginLeft:string;marginRight:string;marginTop:string;marker:string;markerEnd:string;markerMid:string;markerStart:string;mask:string;maskComposite:string;maskImage:string;maskPosition:string;maskRepeat:string;maskSize:string;maskType:string;maxBlockSize:string;maxHeight:string;maxInlineSize:string;maxWidth:string;minBlockSize:string;minHeight:string;minInlineSize:string;minWidth:string;objectFit:string;objectPosition:string;opacity:string;order:string;orphans:string;outline:string;outlineColor:string;outlineOffset:string;outlineStyle:string;outlineWidth:string;overflow:string;overflowAnchor:string;overflowWrap:string;overflowX:string;overflowY:string;padding:string;paddingBlockEnd:string;paddingBlockStart:string;paddingBottom:string;paddingInlineEnd:string;paddingInlineStart:string;paddingLeft:string;paddingRight:string;paddingTop:string;pageBreakAfter:string;pageBreakBefore:string;pageBreakInside:string;paintOrder:string;readonly parentRule:CSSRule|null;perspective:string;perspectiveOrigin:string;placeContent:string;placeItems:string;placeSelf:string;pointerEvents:string;position:string;quotes:string;resize:string;right:string;rotate:string;rowGap:string;rubyAlign:string;rubyPosition:string;scale:string;scrollBehavior:string;shapeRendering:string;stopColor:string;stopOpacity:string;stroke:string;strokeDasharray:string;strokeDashoffset:string;strokeLinecap:string;strokeLinejoin:string;strokeMiterlimit:string;strokeOpacity:string;strokeWidth:string;tabSize:string;tableLayout:string;textAlign:string;textAlignLast:string;textAnchor:string;textCombineUpright:string;textDecoration:string;textDecorationColor:string;textDecorationLine:string;textDecorationStyle:string;textEmphasis:string;textEmphasisColor:string;textEmphasisPosition:string;textEmphasisStyle:string;textIndent:string;textJustify:string;textOrientation:string;textOverflow:string;textRendering:string;textShadow:string;textTransform:string;textUnderlinePosition:string;top:string;touchAction:string;transform:string;transformBox:string;transformOrigin:string;transformStyle:string;transition:string;transitionDelay:string;transitionDuration:string;transitionProperty:string;transitionTimingFunction:string;translate:string;unicodeBidi:string;userSelect:string;verticalAlign:string;visibility:string;webkitAlignContent:string;webkitAlignItems:string;webkitAlignSelf:string;webkitAnimation:string;webkitAnimationDelay:string;webkitAnimationDirection:string;webkitAnimationDuration:string;webkitAnimationFillMode:string;webkitAnimationIterationCount:string;webkitAnimationName:string;webkitAnimationPlayState:string;webkitAnimationTimingFunction:string;webkitAppearance:string;webkitBackfaceVisibility:string;webkitBackgroundClip:string;webkitBackgroundOrigin:string;webkitBackgroundSize:string;webkitBorderBottomLeftRadius:string;webkitBorderBottomRightRadius:string;webkitBorderRadius:string;webkitBorderTopLeftRadius:string;webkitBorderTopRightRadius:string;webkitBoxAlign:string;webkitBoxFlex:string;webkitBoxOrdinalGroup:string;webkitBoxOrient:string;webkitBoxPack:string;webkitBoxShadow:string;webkitBoxSizing:string;webkitFilter:string;webkitFlex:string;webkitFlexBasis:string;webkitFlexDirection:string;webkitFlexFlow:string;webkitFlexGrow:string;webkitFlexShrink:string;webkitFlexWrap:string;webkitJustifyContent:string;webkitLineClamp:string;webkitMask:string;webkitMaskBoxImage:string;webkitMaskBoxImageOutset:string;webkitMaskBoxImageRepeat:string;webkitMaskBoxImageSlice:string;webkitMaskBoxImageSource:string;webkitMaskBoxImageWidth:string;webkitMaskClip:string;webkitMaskComposite:string;webkitMaskImage:string;webkitMaskOrigin:string;webkitMaskPosition:string;webkitMaskRepeat:string;webkitMaskSize:string;webkitOrder:string;webkitPerspective:string;webkitPerspectiveOrigin:string;webkitTapHighlightColor:string;webkitTextFillColor:string;webkitTextSizeAdjust:string;webkitTextStroke:string;webkitTextStrokeColor:string;webkitTextStrokeWidth:string;webkitTransform:string;webkitTransformOrigin:string;webkitTransformStyle:string;webkitTransition:string;webkitTransitionDelay:string;webkitTransitionDuration:string;webkitTransitionProperty:string;webkitTransitionTimingFunction:string;webkitUserSelect:string;whiteSpace:string;widows:string;width:string;willChange:string;wordBreak:string;wordSpacing:string;wordWrap:string;writingMode:string;zIndex:string;zoom:string;getPropertyPriority(property:string):string;getPropertyValue(property:string):string;item(index:number):string;removeProperty(property:string):string;setProperty(property:string,value:string|null,priority?:string):void;[index:number]:string;}declare var CSSStyleDeclaration:{prototype:CSSStyleDeclaration;new():CSSStyleDeclaration;};interface CSSStyleRule extends CSSRule{selectorText:string;readonly style:CSSStyleDeclaration;}declare var CSSStyleRule:{prototype:CSSStyleRule;new():CSSStyleRule;};interface CSSStyleSheet extends StyleSheet{readonly cssRules:CSSRuleList;readonly ownerRule:CSSRule|null;readonly rules:CSSRuleList;addRule(selector?:string,style?:string,index?:number):number;deleteRule(index:number):void;insertRule(rule:string,index?:number):number;removeRule(index?:number):void;}declare var CSSStyleSheet:{prototype:CSSStyleSheet;new():CSSStyleSheet;};interface CSSSupportsRule extends CSSConditionRule{}declare var CSSSupportsRule:{prototype:CSSSupportsRule;new():CSSSupportsRule;};interface Cache{add(request:RequestInfo):Promise<void>;addAll(requests:RequestInfo[]):Promise<void>;delete(request:RequestInfo,options?:CacheQueryOptions):Promise<boolean>;keys(request?:RequestInfo,options?:CacheQueryOptions):Promise<ReadonlyArray<Request>>;match(request:RequestInfo,options?:CacheQueryOptions):Promise<Response|undefined>;matchAll(request?:RequestInfo,options?:CacheQueryOptions):Promise<ReadonlyArray<Response>>;put(request:RequestInfo,response:Response):Promise<void>;}declare var Cache:{prototype:Cache;new():Cache;};interface CacheStorage{delete(cacheName:string):Promise<boolean>;has(cacheName:string):Promise<boolean>;keys():Promise<string[]>;match(request:RequestInfo,options?:MultiCacheQueryOptions):Promise<Response|undefined>;open(cacheName:string):Promise<Cache>;}declare var CacheStorage:{prototype:CacheStorage;new():CacheStorage;};interface CanvasCompositing{globalAlpha:number;globalCompositeOperation:string;}interface CanvasDrawImage{drawImage(image:CanvasImageSource,dx:number,dy:number):void;drawImage(image:CanvasImageSource,dx:number,dy:number,dw:number,dh:number):void;drawImage(image:CanvasImageSource,sx:number,sy:number,sw:number,sh:number,dx:number,dy:number,dw:number,dh:number):void;}interface CanvasDrawPath{beginPath():void;clip(fillRule?:CanvasFillRule):void;clip(path:Path2D,fillRule?:CanvasFillRule):void;fill(fillRule?:CanvasFillRule):void;fill(path:Path2D,fillRule?:CanvasFillRule):void;isPointInPath(x:number,y:number,fillRule?:CanvasFillRule):boolean;isPointInPath(path:Path2D,x:number,y:number,fillRule?:CanvasFillRule):boolean;isPointInStroke(x:number,y:number):boolean;isPointInStroke(path:Path2D,x:number,y:number):boolean;stroke():void;stroke(path:Path2D):void;}interface CanvasFillStrokeStyles{fillStyle:string|CanvasGradient|CanvasPattern;strokeStyle:string|CanvasGradient|CanvasPattern;createLinearGradient(x0:number,y0:number,x1:number,y1:number):CanvasGradient;createPattern(image:CanvasImageSource,repetition:string|null):CanvasPattern|null;createRadialGradient(x0:number,y0:number,r0:number,x1:number,y1:number,r1:number):CanvasGradient;}interface CanvasFilters{filter:string;}interface CanvasGradient{addColorStop(offset:number,color:string):void;}declare var CanvasGradient:{prototype:CanvasGradient;new():CanvasGradient;};interface CanvasImageData{createImageData(sw:number,sh:number):ImageData;createImageData(imagedata:ImageData):ImageData;getImageData(sx:number,sy:number,sw:number,sh:number):ImageData;putImageData(imagedata:ImageData,dx:number,dy:number):void;putImageData(imagedata:ImageData,dx:number,dy:number,dirtyX:number,dirtyY:number,dirtyWidth:number,dirtyHeight:number):void;}interface CanvasImageSmoothing{imageSmoothingEnabled:boolean;imageSmoothingQuality:ImageSmoothingQuality;}interface CanvasPath{arc(x:number,y:number,radius:number,startAngle:number,endAngle:number,anticlockwise?:boolean):void;arcTo(x1:number,y1:number,x2:number,y2:number,radius:number):void;bezierCurveTo(cp1x:number,cp1y:number,cp2x:number,cp2y:number,x:number,y:number):void;closePath():void;ellipse(x:number,y:number,radiusX:number,radiusY:number,rotation:number,startAngle:number,endAngle:number,anticlockwise?:boolean):void;lineTo(x:number,y:number):void;moveTo(x:number,y:number):void;quadraticCurveTo(cpx:number,cpy:number,x:number,y:number):void;rect(x:number,y:number,w:number,h:number):void;}interface CanvasPathDrawingStyles{lineCap:CanvasLineCap;lineDashOffset:number;lineJoin:CanvasLineJoin;lineWidth:number;miterLimit:number;getLineDash():number[];setLineDash(segments:number[]):void;}interface CanvasPattern{setTransform(transform?:DOMMatrix2DInit):void;}declare var CanvasPattern:{prototype:CanvasPattern;new():CanvasPattern;};interface CanvasRect{clearRect(x:number,y:number,w:number,h:number):void;fillRect(x:number,y:number,w:number,h:number):void;strokeRect(x:number,y:number,w:number,h:number):void;}interface CanvasRenderingContext2D extends CanvasCompositing,CanvasDrawImage,CanvasDrawPath,CanvasFillStrokeStyles,CanvasFilters,CanvasImageData,CanvasImageSmoothing,CanvasPath,CanvasPathDrawingStyles,CanvasRect,CanvasShadowStyles,CanvasState,CanvasText,CanvasTextDrawingStyles,CanvasTransform,CanvasUserInterface{readonly canvas:HTMLCanvasElement;}declare var CanvasRenderingContext2D:{prototype:CanvasRenderingContext2D;new():CanvasRenderingContext2D;};interface CanvasShadowStyles{shadowBlur:number;shadowColor:string;shadowOffsetX:number;shadowOffsetY:number;}interface CanvasState{restore():void;save():void;}interface CanvasText{fillText(text:string,x:number,y:number,maxWidth?:number):void;measureText(text:string):TextMetrics;strokeText(text:string,x:number,y:number,maxWidth?:number):void;}interface CanvasTextDrawingStyles{direction:CanvasDirection;font:string;textAlign:CanvasTextAlign;textBaseline:CanvasTextBaseline;}interface CanvasTransform{getTransform():DOMMatrix;resetTransform():void;rotate(angle:number):void;scale(x:number,y:number):void;setTransform(a:number,b:number,c:number,d:number,e:number,f:number):void;setTransform(transform?:DOMMatrix2DInit):void;transform(a:number,b:number,c:number,d:number,e:number,f:number):void;translate(x:number,y:number):void;}interface CanvasUserInterface{drawFocusIfNeeded(element:Element):void;drawFocusIfNeeded(path:Path2D,element:Element):void;scrollPathIntoView():void;scrollPathIntoView(path:Path2D):void;}interface CaretPosition{readonly offset:number;readonly offsetNode:Node;getClientRect():DOMRect|null;}declare var CaretPosition:{prototype:CaretPosition;new():CaretPosition;};interface ChannelMergerNode extends AudioNode{}declare var ChannelMergerNode:{prototype:ChannelMergerNode;new(context:BaseAudioContext,options?:ChannelMergerOptions):ChannelMergerNode;};interface ChannelSplitterNode extends AudioNode{}declare var ChannelSplitterNode:{prototype:ChannelSplitterNode;new(context:BaseAudioContext,options?:ChannelSplitterOptions):ChannelSplitterNode;};interface CharacterData extends Node,ChildNode,NonDocumentTypeChildNode{data:string;readonly length:number;readonly ownerDocument:Document;appendData(data:string):void;deleteData(offset:number,count:number):void;insertData(offset:number,data:string):void;replaceData(offset:number,count:number,data:string):void;substringData(offset:number,count:number):string;}declare var CharacterData:{prototype:CharacterData;new():CharacterData;};interface ChildNode extends Node{after(...nodes:(Node|string)[]):void;before(...nodes:(Node|string)[]):void;remove():void;replaceWith(...nodes:(Node|string)[]):void;}interface ClientRect{bottom:number;readonly height:number;left:number;right:number;top:number;readonly width:number;}declare var ClientRect:{prototype:ClientRect;new():ClientRect;};interface ClientRectList{readonly length:number;item(index:number):ClientRect;[index:number]:ClientRect;}declare var ClientRectList:{prototype:ClientRectList;new():ClientRectList;};interface Clipboard extends EventTarget{readText():Promise<string>;writeText(data:string):Promise<void>;}declare var Clipboard:{prototype:Clipboard;new():Clipboard;};interface ClipboardEvent extends Event{readonly clipboardData:DataTransfer|null;}declare var ClipboardEvent:{prototype:ClipboardEvent;new(type:string,eventInitDict?:ClipboardEventInit):ClipboardEvent;};interface CloseEvent extends Event{readonly code:number;readonly reason:string;readonly wasClean:boolean;}declare var CloseEvent:{prototype:CloseEvent;new(type:string,eventInitDict?:CloseEventInit):CloseEvent;};interface Comment extends CharacterData{}declare var Comment:{prototype:Comment;new(data?:string):Comment;};interface CompositionEvent extends UIEvent{readonly data:string;}declare var CompositionEvent:{prototype:CompositionEvent;new(type:string,eventInitDict?:CompositionEventInit):CompositionEvent;};interface ConcatParams extends Algorithm{algorithmId:Uint8Array;hash?:string|Algorithm;partyUInfo:Uint8Array;partyVInfo:Uint8Array;privateInfo?:Uint8Array;publicInfo?:Uint8Array;}interface ConstantSourceNode extends AudioScheduledSourceNode{readonly offset:AudioParam;addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type:K,listener:(this:ConstantSourceNode,ev:AudioScheduledSourceNodeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type:K,listener:(this:ConstantSourceNode,ev:AudioScheduledSourceNodeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ConstantSourceNode:{prototype:ConstantSourceNode;new(context:BaseAudioContext,options?:ConstantSourceOptions):ConstantSourceNode;};interface ConvolverNode extends AudioNode{buffer:AudioBuffer|null;normalize:boolean;}declare var ConvolverNode:{prototype:ConvolverNode;new(context:BaseAudioContext,options?:ConvolverOptions):ConvolverNode;};interface Coordinates{readonly accuracy:number;readonly altitude:number|null;readonly altitudeAccuracy:number|null;readonly heading:number|null;readonly latitude:number;readonly longitude:number;readonly speed:number|null;}interface CountQueuingStrategy extends QueuingStrategy{highWaterMark:number;size(chunk:any):1;}declare var CountQueuingStrategy:{prototype:CountQueuingStrategy;new(options:{highWaterMark:number}):CountQueuingStrategy;};interface Credential{readonly id:string;readonly type:string;}declare var Credential:{prototype:Credential;new():Credential;};interface CredentialsContainer{create(options?:CredentialCreationOptions):Promise<Credential|null>;get(options?:CredentialRequestOptions):Promise<Credential|null>;preventSilentAccess():Promise<void>;store(credential:Credential):Promise<Credential>;}declare var CredentialsContainer:{prototype:CredentialsContainer;new():CredentialsContainer;};interface Crypto{readonly subtle:SubtleCrypto;getRandomValues<T extends Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|null>(array:T):T;}declare var Crypto:{prototype:Crypto;new():Crypto;};interface CryptoKey{readonly algorithm:KeyAlgorithm;readonly extractable:boolean;readonly type:KeyType;readonly usages:KeyUsage[];}declare var CryptoKey:{prototype:CryptoKey;new():CryptoKey;};interface CryptoKeyPair{privateKey:CryptoKey;publicKey:CryptoKey;}declare var CryptoKeyPair:{prototype:CryptoKeyPair;new():CryptoKeyPair;};interface CustomElementRegistry{define(name:string,constructor:CustomElementConstructor,options?:ElementDefinitionOptions):void;get(name:string):any;upgrade(root:Node):void;whenDefined(name:string):Promise<void>;}declare var CustomElementRegistry:{prototype:CustomElementRegistry;new():CustomElementRegistry;};interface CustomEvent<T=any>extends Event{readonly detail:T;initCustomEvent(typeArg:string,canBubbleArg:boolean,cancelableArg:boolean,detailArg:T):void;}declare var CustomEvent:{prototype:CustomEvent;new<T>(typeArg:string,eventInitDict?:CustomEventInit<T>):CustomEvent<T>;};interface DOMError{readonly name:string;toString():string;}declare var DOMError:{prototype:DOMError;new():DOMError;};interface DOMException{readonly code:number;readonly message:string;readonly name:string;readonly ABORT_ERR:number;readonly DATA_CLONE_ERR:number;readonly DOMSTRING_SIZE_ERR:number;readonly HIERARCHY_REQUEST_ERR:number;readonly INDEX_SIZE_ERR:number;readonly INUSE_ATTRIBUTE_ERR:number;readonly INVALID_ACCESS_ERR:number;readonly INVALID_CHARACTER_ERR:number;readonly INVALID_MODIFICATION_ERR:number;readonly INVALID_NODE_TYPE_ERR:number;readonly INVALID_STATE_ERR:number;readonly NAMESPACE_ERR:number;readonly NETWORK_ERR:number;readonly NOT_FOUND_ERR:number;readonly NOT_SUPPORTED_ERR:number;readonly NO_DATA_ALLOWED_ERR:number;readonly NO_MODIFICATION_ALLOWED_ERR:number;readonly QUOTA_EXCEEDED_ERR:number;readonly SECURITY_ERR:number;readonly SYNTAX_ERR:number;readonly TIMEOUT_ERR:number;readonly TYPE_MISMATCH_ERR:number;readonly URL_MISMATCH_ERR:number;readonly VALIDATION_ERR:number;readonly WRONG_DOCUMENT_ERR:number;}declare var DOMException:{prototype:DOMException;new(message?:string,name?:string):DOMException;readonly ABORT_ERR:number;readonly DATA_CLONE_ERR:number;readonly DOMSTRING_SIZE_ERR:number;readonly HIERARCHY_REQUEST_ERR:number;readonly INDEX_SIZE_ERR:number;readonly INUSE_ATTRIBUTE_ERR:number;readonly INVALID_ACCESS_ERR:number;readonly INVALID_CHARACTER_ERR:number;readonly INVALID_MODIFICATION_ERR:number;readonly INVALID_NODE_TYPE_ERR:number;readonly INVALID_STATE_ERR:number;readonly NAMESPACE_ERR:number;readonly NETWORK_ERR:number;readonly NOT_FOUND_ERR:number;readonly NOT_SUPPORTED_ERR:number;readonly NO_DATA_ALLOWED_ERR:number;readonly NO_MODIFICATION_ALLOWED_ERR:number;readonly QUOTA_EXCEEDED_ERR:number;readonly SECURITY_ERR:number;readonly SYNTAX_ERR:number;readonly TIMEOUT_ERR:number;readonly TYPE_MISMATCH_ERR:number;readonly URL_MISMATCH_ERR:number;readonly VALIDATION_ERR:number;readonly WRONG_DOCUMENT_ERR:number;};interface DOMImplementation{createDocument(namespaceURI:string|null,qualifiedName:string|null,doctype:DocumentType|null):Document;createDocumentType(qualifiedName:string,publicId:string,systemId:string):DocumentType;createHTMLDocument(title?:string):Document;hasFeature(...args:any[]):true;}declare var DOMImplementation:{prototype:DOMImplementation;new():DOMImplementation;};interface DOML2DeprecatedColorProperty{color:string;}interface DOMMatrix extends DOMMatrixReadOnly{a:number;b:number;c:number;d:number;e:number;f:number;m11:number;m12:number;m13:number;m14:number;m21:number;m22:number;m23:number;m24:number;m31:number;m32:number;m33:number;m34:number;m41:number;m42:number;m43:number;m44:number;invertSelf():DOMMatrix;multiplySelf(other?:DOMMatrixInit):DOMMatrix;preMultiplySelf(other?:DOMMatrixInit):DOMMatrix;rotateAxisAngleSelf(x?:number,y?:number,z?:number,angle?:number):DOMMatrix;rotateFromVectorSelf(x?:number,y?:number):DOMMatrix;rotateSelf(rotX?:number,rotY?:number,rotZ?:number):DOMMatrix;scale3dSelf(scale?:number,originX?:number,originY?:number,originZ?:number):DOMMatrix;scaleSelf(scaleX?:number,scaleY?:number,scaleZ?:number,originX?:number,originY?:number,originZ?:number):DOMMatrix;setMatrixValue(transformList:string):DOMMatrix;skewXSelf(sx?:number):DOMMatrix;skewYSelf(sy?:number):DOMMatrix;translateSelf(tx?:number,ty?:number,tz?:number):DOMMatrix;}declare var DOMMatrix:{prototype:DOMMatrix;new(init?:string|number[]):DOMMatrix;fromFloat32Array(array32:Float32Array):DOMMatrix;fromFloat64Array(array64:Float64Array):DOMMatrix;fromMatrix(other?:DOMMatrixInit):DOMMatrix;};type SVGMatrix=DOMMatrix;declare var SVGMatrix:typeof DOMMatrix;type WebKitCSSMatrix=DOMMatrix;declare var WebKitCSSMatrix:typeof DOMMatrix;interface DOMMatrixReadOnly{readonly a:number;readonly b:number;readonly c:number;readonly d:number;readonly e:number;readonly f:number;readonly is2D:boolean;readonly isIdentity:boolean;readonly m11:number;readonly m12:number;readonly m13:number;readonly m14:number;readonly m21:number;readonly m22:number;readonly m23:number;readonly m24:number;readonly m31:number;readonly m32:number;readonly m33:number;readonly m34:number;readonly m41:number;readonly m42:number;readonly m43:number;readonly m44:number;flipX():DOMMatrix;flipY():DOMMatrix;inverse():DOMMatrix;multiply(other?:DOMMatrixInit):DOMMatrix;rotate(rotX?:number,rotY?:number,rotZ?:number):DOMMatrix;rotateAxisAngle(x?:number,y?:number,z?:number,angle?:number):DOMMatrix;rotateFromVector(x?:number,y?:number):DOMMatrix;scale(scaleX?:number,scaleY?:number,scaleZ?:number,originX?:number,originY?:number,originZ?:number):DOMMatrix;scale3d(scale?:number,originX?:number,originY?:number,originZ?:number):DOMMatrix;scaleNonUniform(scaleX?:number,scaleY?:number):DOMMatrix;skewX(sx?:number):DOMMatrix;skewY(sy?:number):DOMMatrix;toFloat32Array():Float32Array;toFloat64Array():Float64Array;toJSON():any;transformPoint(point?:DOMPointInit):DOMPoint;translate(tx?:number,ty?:number,tz?:number):DOMMatrix;toString():string;}declare var DOMMatrixReadOnly:{prototype:DOMMatrixReadOnly;new(init?:string|number[]):DOMMatrixReadOnly;fromFloat32Array(array32:Float32Array):DOMMatrixReadOnly;fromFloat64Array(array64:Float64Array):DOMMatrixReadOnly;fromMatrix(other?:DOMMatrixInit):DOMMatrixReadOnly;toString():string;};interface DOMParser{parseFromString(str:string,type:SupportedType):Document;}declare var DOMParser:{prototype:DOMParser;new():DOMParser;};interface DOMPoint extends DOMPointReadOnly{w:number;x:number;y:number;z:number;}declare var DOMPoint:{prototype:DOMPoint;new(x?:number,y?:number,z?:number,w?:number):DOMPoint;fromPoint(other?:DOMPointInit):DOMPoint;};type SVGPoint=DOMPoint;declare var SVGPoint:typeof DOMPoint;interface DOMPointReadOnly{readonly w:number;readonly x:number;readonly y:number;readonly z:number;matrixTransform(matrix?:DOMMatrixInit):DOMPoint;toJSON():any;}declare var DOMPointReadOnly:{prototype:DOMPointReadOnly;new(x?:number,y?:number,z?:number,w?:number):DOMPointReadOnly;fromPoint(other?:DOMPointInit):DOMPointReadOnly;};interface DOMQuad{readonly p1:DOMPoint;readonly p2:DOMPoint;readonly p3:DOMPoint;readonly p4:DOMPoint;getBounds():DOMRect;toJSON():any;}declare var DOMQuad:{prototype:DOMQuad;new(p1?:DOMPointInit,p2?:DOMPointInit,p3?:DOMPointInit,p4?:DOMPointInit):DOMQuad;fromQuad(other?:DOMQuadInit):DOMQuad;fromRect(other?:DOMRectInit):DOMQuad;};interface DOMRect extends DOMRectReadOnly{height:number;width:number;x:number;y:number;}declare var DOMRect:{prototype:DOMRect;new(x?:number,y?:number,width?:number,height?:number):DOMRect;fromRect(other?:DOMRectInit):DOMRect;};type SVGRect=DOMRect;declare var SVGRect:typeof DOMRect;interface DOMRectList{readonly length:number;item(index:number):DOMRect|null;[index:number]:DOMRect;}declare var DOMRectList:{prototype:DOMRectList;new():DOMRectList;};interface DOMRectReadOnly{readonly bottom:number;readonly height:number;readonly left:number;readonly right:number;readonly top:number;readonly width:number;readonly x:number;readonly y:number;toJSON():any;}declare var DOMRectReadOnly:{prototype:DOMRectReadOnly;new(x?:number,y?:number,width?:number,height?:number):DOMRectReadOnly;fromRect(other?:DOMRectInit):DOMRectReadOnly;};interface DOMSettableTokenList extends DOMTokenList{value:string;}declare var DOMSettableTokenList:{prototype:DOMSettableTokenList;new():DOMSettableTokenList;};interface DOMStringList{readonly length:number;contains(string:string):boolean;item(index:number):string|null;[index:number]:string;}declare var DOMStringList:{prototype:DOMStringList;new():DOMStringList;};interface DOMStringMap{[name:string]:string|undefined;}declare var DOMStringMap:{prototype:DOMStringMap;new():DOMStringMap;};interface DOMTokenList{readonly length:number;value:string;toString():string;add(...tokens:string[]):void;contains(token:string):boolean;item(index:number):string|null;remove(...tokens:string[]):void;replace(oldToken:string,newToken:string):void;supports(token:string):boolean;toggle(token:string,force?:boolean):boolean;forEach(callbackfn:(value:string,key:number,parent:DOMTokenList)=>void,thisArg?:any):void;[index:number]:string;}declare var DOMTokenList:{prototype:DOMTokenList;new():DOMTokenList;};interface DataCue extends TextTrackCue{data:ArrayBuffer;addEventListener<K extends keyof TextTrackCueEventMap>(type:K,listener:(this:DataCue,ev:TextTrackCueEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof TextTrackCueEventMap>(type:K,listener:(this:DataCue,ev:TextTrackCueEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var DataCue:{prototype:DataCue;new():DataCue;};interface DataTransfer{dropEffect:string;effectAllowed:string;readonly files:FileList;readonly items:DataTransferItemList;readonly types:ReadonlyArray<string>;clearData(format?:string):void;getData(format:string):string;setData(format:string,data:string):void;setDragImage(image:Element,x:number,y:number):void;}declare var DataTransfer:{prototype:DataTransfer;new():DataTransfer;};interface DataTransferItem{readonly kind:string;readonly type:string;getAsFile():File|null;getAsString(callback:FunctionStringCallback|null):void;webkitGetAsEntry():any;}declare var DataTransferItem:{prototype:DataTransferItem;new():DataTransferItem;};interface DataTransferItemList{readonly length:number;add(data:string,type:string):DataTransferItem|null;add(data:File):DataTransferItem|null;clear():void;item(index:number):DataTransferItem;remove(index:number):void;[name:number]:DataTransferItem;}declare var DataTransferItemList:{prototype:DataTransferItemList;new():DataTransferItemList;};interface DeferredPermissionRequest{readonly id:number;readonly type:MSWebViewPermissionType;readonly uri:string;allow():void;deny():void;}declare var DeferredPermissionRequest:{prototype:DeferredPermissionRequest;new():DeferredPermissionRequest;};interface DelayNode extends AudioNode{readonly delayTime:AudioParam;}declare var DelayNode:{prototype:DelayNode;new(context:BaseAudioContext,options?:DelayOptions):DelayNode;};interface DeviceAcceleration{readonly x:number|null;readonly y:number|null;readonly z:number|null;}declare var DeviceAcceleration:{prototype:DeviceAcceleration;new():DeviceAcceleration;};interface DeviceLightEvent extends Event{readonly value:number;}declare var DeviceLightEvent:{prototype:DeviceLightEvent;new(typeArg:string,eventInitDict?:DeviceLightEventInit):DeviceLightEvent;};interface DeviceMotionEvent extends Event{readonly acceleration:DeviceMotionEventAcceleration|null;readonly accelerationIncludingGravity:DeviceMotionEventAcceleration|null;readonly interval:number;readonly rotationRate:DeviceMotionEventRotationRate|null;}declare var DeviceMotionEvent:{prototype:DeviceMotionEvent;new(type:string,eventInitDict?:DeviceMotionEventInit):DeviceMotionEvent;requestPermission():Promise<PermissionState>;};interface DeviceMotionEventAcceleration{readonly x:number|null;readonly y:number|null;readonly z:number|null;}interface DeviceMotionEventRotationRate{readonly alpha:number|null;readonly beta:number|null;readonly gamma:number|null;}interface DeviceOrientationEvent extends Event{readonly absolute:boolean;readonly alpha:number|null;readonly beta:number|null;readonly gamma:number|null;}declare var DeviceOrientationEvent:{prototype:DeviceOrientationEvent;new(type:string,eventInitDict?:DeviceOrientationEventInit):DeviceOrientationEvent;requestPermission():Promise<PermissionState>;};interface DeviceRotationRate{readonly alpha:number|null;readonly beta:number|null;readonly gamma:number|null;}declare var DeviceRotationRate:{prototype:DeviceRotationRate;new():DeviceRotationRate;};interface DhImportKeyParams extends Algorithm{generator:Uint8Array;prime:Uint8Array;}interface DhKeyAlgorithm extends KeyAlgorithm{generator:Uint8Array;prime:Uint8Array;}interface DhKeyDeriveParams extends Algorithm{public:CryptoKey;}interface DhKeyGenParams extends Algorithm{generator:Uint8Array;prime:Uint8Array;}interface DocumentEventMap extends GlobalEventHandlersEventMap,DocumentAndElementEventHandlersEventMap{"fullscreenchange":Event;"fullscreenerror":Event;"pointerlockchange":Event;"pointerlockerror":Event;"readystatechange":Event;"visibilitychange":Event;}interface Document extends Node,DocumentAndElementEventHandlers,DocumentOrShadowRoot,GlobalEventHandlers,NonElementParentNode,ParentNode,XPathEvaluatorBase{readonly URL:string;alinkColor:string;readonly all:HTMLAllCollection;readonly anchors:HTMLCollectionOf<HTMLAnchorElement>;readonly applets:HTMLCollectionOf<HTMLAppletElement>;bgColor:string;body:HTMLElement;readonly characterSet:string;readonly charset:string;readonly compatMode:string;readonly contentType:string;cookie:string;readonly currentScript:HTMLOrSVGScriptElement|null;readonly defaultView:(WindowProxy&typeof globalThis)|null;designMode:string;dir:string;readonly doctype:DocumentType|null;readonly documentElement:HTMLElement;readonly documentURI:string;domain:string;readonly embeds:HTMLCollectionOf<HTMLEmbedElement>;fgColor:string;readonly forms:HTMLCollectionOf<HTMLFormElement>;readonly fullscreen:boolean;readonly fullscreenEnabled:boolean;readonly head:HTMLHeadElement;readonly hidden:boolean;readonly images:HTMLCollectionOf<HTMLImageElement>;readonly implementation:DOMImplementation;readonly inputEncoding:string;readonly lastModified:string;linkColor:string;readonly links:HTMLCollectionOf<HTMLAnchorElement|HTMLAreaElement>;location:Location;onfullscreenchange:((this:Document,ev:Event)=>any)|null;onfullscreenerror:((this:Document,ev:Event)=>any)|null;onpointerlockchange:((this:Document,ev:Event)=>any)|null;onpointerlockerror:((this:Document,ev:Event)=>any)|null;onreadystatechange:((this:Document,ev:Event)=>any)|null;onvisibilitychange:((this:Document,ev:Event)=>any)|null;readonly origin:string;readonly ownerDocument:null;readonly plugins:HTMLCollectionOf<HTMLEmbedElement>;readonly readyState:DocumentReadyState;readonly referrer:string;readonly scripts:HTMLCollectionOf<HTMLScriptElement>;readonly scrollingElement:Element|null;readonly timeline:DocumentTimeline;title:string;readonly visibilityState:VisibilityState;vlinkColor:string;adoptNode<T extends Node>(source:T):T;captureEvents():void;caretPositionFromPoint(x:number,y:number):CaretPosition|null;caretRangeFromPoint(x:number,y:number):Range;clear():void;close():void;createAttribute(localName:string):Attr;createAttributeNS(namespace:string|null,qualifiedName:string):Attr;createCDATASection(data:string):CDATASection;createComment(data:string):Comment;createDocumentFragment():DocumentFragment;createElement<K extends keyof HTMLElementTagNameMap>(tagName:K,options?:ElementCreationOptions):HTMLElementTagNameMap[K];createElement<K extends keyof HTMLElementDeprecatedTagNameMap>(tagName:K,options?:ElementCreationOptions):HTMLElementDeprecatedTagNameMap[K];createElement(tagName:string,options?:ElementCreationOptions):HTMLElement;createElementNS(namespaceURI:"http://www.w3.org/1999/xhtml",qualifiedName:string):HTMLElement;createElementNS<K extends keyof SVGElementTagNameMap>(namespaceURI:"http://www.w3.org/2000/svg",qualifiedName:K):SVGElementTagNameMap[K];createElementNS(namespaceURI:"http://www.w3.org/2000/svg",qualifiedName:string):SVGElement;createElementNS(namespaceURI:string|null,qualifiedName:string,options?:ElementCreationOptions):Element;createElementNS(namespace:string|null,qualifiedName:string,options?:string|ElementCreationOptions):Element;createEvent(eventInterface:"AnimationEvent"):AnimationEvent;createEvent(eventInterface:"AnimationPlaybackEvent"):AnimationPlaybackEvent;createEvent(eventInterface:"AudioProcessingEvent"):AudioProcessingEvent;createEvent(eventInterface:"BeforeUnloadEvent"):BeforeUnloadEvent;createEvent(eventInterface:"ClipboardEvent"):ClipboardEvent;createEvent(eventInterface:"CloseEvent"):CloseEvent;createEvent(eventInterface:"CompositionEvent"):CompositionEvent;createEvent(eventInterface:"CustomEvent"):CustomEvent;createEvent(eventInterface:"DeviceLightEvent"):DeviceLightEvent;createEvent(eventInterface:"DeviceMotionEvent"):DeviceMotionEvent;createEvent(eventInterface:"DeviceOrientationEvent"):DeviceOrientationEvent;createEvent(eventInterface:"DragEvent"):DragEvent;createEvent(eventInterface:"ErrorEvent"):ErrorEvent;createEvent(eventInterface:"Event"):Event;createEvent(eventInterface:"Events"):Event;createEvent(eventInterface:"FocusEvent"):FocusEvent;createEvent(eventInterface:"FocusNavigationEvent"):FocusNavigationEvent;createEvent(eventInterface:"GamepadEvent"):GamepadEvent;createEvent(eventInterface:"HashChangeEvent"):HashChangeEvent;createEvent(eventInterface:"IDBVersionChangeEvent"):IDBVersionChangeEvent;createEvent(eventInterface:"InputEvent"):InputEvent;createEvent(eventInterface:"KeyboardEvent"):KeyboardEvent;createEvent(eventInterface:"ListeningStateChangedEvent"):ListeningStateChangedEvent;createEvent(eventInterface:"MSGestureEvent"):MSGestureEvent;createEvent(eventInterface:"MSMediaKeyMessageEvent"):MSMediaKeyMessageEvent;createEvent(eventInterface:"MSMediaKeyNeededEvent"):MSMediaKeyNeededEvent;createEvent(eventInterface:"MSPointerEvent"):MSPointerEvent;createEvent(eventInterface:"MediaEncryptedEvent"):MediaEncryptedEvent;createEvent(eventInterface:"MediaKeyMessageEvent"):MediaKeyMessageEvent;createEvent(eventInterface:"MediaQueryListEvent"):MediaQueryListEvent;createEvent(eventInterface:"MediaStreamErrorEvent"):MediaStreamErrorEvent;createEvent(eventInterface:"MediaStreamEvent"):MediaStreamEvent;createEvent(eventInterface:"MediaStreamTrackEvent"):MediaStreamTrackEvent;createEvent(eventInterface:"MessageEvent"):MessageEvent;createEvent(eventInterface:"MouseEvent"):MouseEvent;createEvent(eventInterface:"MouseEvents"):MouseEvent;createEvent(eventInterface:"MutationEvent"):MutationEvent;createEvent(eventInterface:"MutationEvents"):MutationEvent;createEvent(eventInterface:"OfflineAudioCompletionEvent"):OfflineAudioCompletionEvent;createEvent(eventInterface:"OverflowEvent"):OverflowEvent;createEvent(eventInterface:"PageTransitionEvent"):PageTransitionEvent;createEvent(eventInterface:"PaymentRequestUpdateEvent"):PaymentRequestUpdateEvent;createEvent(eventInterface:"PermissionRequestedEvent"):PermissionRequestedEvent;createEvent(eventInterface:"PointerEvent"):PointerEvent;createEvent(eventInterface:"PopStateEvent"):PopStateEvent;createEvent(eventInterface:"ProgressEvent"):ProgressEvent;createEvent(eventInterface:"PromiseRejectionEvent"):PromiseRejectionEvent;createEvent(eventInterface:"RTCDTMFToneChangeEvent"):RTCDTMFToneChangeEvent;createEvent(eventInterface:"RTCDataChannelEvent"):RTCDataChannelEvent;createEvent(eventInterface:"RTCDtlsTransportStateChangedEvent"):RTCDtlsTransportStateChangedEvent;createEvent(eventInterface:"RTCErrorEvent"):RTCErrorEvent;createEvent(eventInterface:"RTCIceCandidatePairChangedEvent"):RTCIceCandidatePairChangedEvent;createEvent(eventInterface:"RTCIceGathererEvent"):RTCIceGathererEvent;createEvent(eventInterface:"RTCIceTransportStateChangedEvent"):RTCIceTransportStateChangedEvent;createEvent(eventInterface:"RTCPeerConnectionIceErrorEvent"):RTCPeerConnectionIceErrorEvent;createEvent(eventInterface:"RTCPeerConnectionIceEvent"):RTCPeerConnectionIceEvent;createEvent(eventInterface:"RTCSsrcConflictEvent"):RTCSsrcConflictEvent;createEvent(eventInterface:"RTCStatsEvent"):RTCStatsEvent;createEvent(eventInterface:"RTCTrackEvent"):RTCTrackEvent;createEvent(eventInterface:"SVGZoomEvent"):SVGZoomEvent;createEvent(eventInterface:"SVGZoomEvents"):SVGZoomEvent;createEvent(eventInterface:"SecurityPolicyViolationEvent"):SecurityPolicyViolationEvent;createEvent(eventInterface:"ServiceWorkerMessageEvent"):ServiceWorkerMessageEvent;createEvent(eventInterface:"SpeechRecognitionEvent"):SpeechRecognitionEvent;createEvent(eventInterface:"SpeechSynthesisErrorEvent"):SpeechSynthesisErrorEvent;createEvent(eventInterface:"SpeechSynthesisEvent"):SpeechSynthesisEvent;createEvent(eventInterface:"StorageEvent"):StorageEvent;createEvent(eventInterface:"TextEvent"):TextEvent;createEvent(eventInterface:"TouchEvent"):TouchEvent;createEvent(eventInterface:"TrackEvent"):TrackEvent;createEvent(eventInterface:"TransitionEvent"):TransitionEvent;createEvent(eventInterface:"UIEvent"):UIEvent;createEvent(eventInterface:"UIEvents"):UIEvent;createEvent(eventInterface:"VRDisplayEvent"):VRDisplayEvent;createEvent(eventInterface:"VRDisplayEvent "):VRDisplayEvent;createEvent(eventInterface:"WebGLContextEvent"):WebGLContextEvent;createEvent(eventInterface:"WheelEvent"):WheelEvent;createEvent(eventInterface:string):Event;createNodeIterator(root:Node,whatToShow?:number,filter?:NodeFilter|null):NodeIterator;createProcessingInstruction(target:string,data:string):ProcessingInstruction;createRange():Range;createTextNode(data:string):Text;createTreeWalker(root:Node,whatToShow?:number,filter?:NodeFilter|null):TreeWalker;createTreeWalker(root:Node,whatToShow:number,filter:NodeFilter|null,entityReferenceExpansion?:boolean):TreeWalker;elementFromPoint(x:number,y:number):Element|null;elementsFromPoint(x:number,y:number):Element[];execCommand(commandId:string,showUI?:boolean,value?:string):boolean;exitFullscreen():Promise<void>;exitPointerLock():void;getAnimations():Animation[];getElementById(elementId:string):HTMLElement|null;getElementsByClassName(classNames:string):HTMLCollectionOf<Element>;getElementsByName(elementName:string):NodeListOf<HTMLElement>;getElementsByTagName<K extends keyof HTMLElementTagNameMap>(qualifiedName:K):HTMLCollectionOf<HTMLElementTagNameMap[K]>;getElementsByTagName<K extends keyof SVGElementTagNameMap>(qualifiedName:K):HTMLCollectionOf<SVGElementTagNameMap[K]>;getElementsByTagName(qualifiedName:string):HTMLCollectionOf<Element>;getElementsByTagNameNS(namespaceURI:"http://www.w3.org/1999/xhtml",localName:string):HTMLCollectionOf<HTMLElement>;getElementsByTagNameNS(namespaceURI:"http://www.w3.org/2000/svg",localName:string):HTMLCollectionOf<SVGElement>;getElementsByTagNameNS(namespaceURI:string,localName:string):HTMLCollectionOf<Element>;getSelection():Selection|null;hasFocus():boolean;importNode<T extends Node>(importedNode:T,deep:boolean):T;open(url?:string,name?:string,features?:string,replace?:boolean):Document;queryCommandEnabled(commandId:string):boolean;queryCommandIndeterm(commandId:string):boolean;queryCommandState(commandId:string):boolean;queryCommandSupported(commandId:string):boolean;queryCommandValue(commandId:string):string;releaseEvents():void;write(...text:string[]):void;writeln(...text:string[]):void;addEventListener<K extends keyof DocumentEventMap>(type:K,listener:(this:Document,ev:DocumentEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof DocumentEventMap>(type:K,listener:(this:Document,ev:DocumentEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var Document:{prototype:Document;new():Document;};interface DocumentAndElementEventHandlersEventMap{"copy":ClipboardEvent;"cut":ClipboardEvent;"paste":ClipboardEvent;}interface DocumentAndElementEventHandlers{oncopy:((this:DocumentAndElementEventHandlers,ev:ClipboardEvent)=>any)|null;oncut:((this:DocumentAndElementEventHandlers,ev:ClipboardEvent)=>any)|null;onpaste:((this:DocumentAndElementEventHandlers,ev:ClipboardEvent)=>any)|null;addEventListener<K extends keyof DocumentAndElementEventHandlersEventMap>(type:K,listener:(this:DocumentAndElementEventHandlers,ev:DocumentAndElementEventHandlersEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof DocumentAndElementEventHandlersEventMap>(type:K,listener:(this:DocumentAndElementEventHandlers,ev:DocumentAndElementEventHandlersEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}interface DocumentEvent{createEvent(eventInterface:"AnimationEvent"):AnimationEvent;createEvent(eventInterface:"AnimationPlaybackEvent"):AnimationPlaybackEvent;createEvent(eventInterface:"AudioProcessingEvent"):AudioProcessingEvent;createEvent(eventInterface:"BeforeUnloadEvent"):BeforeUnloadEvent;createEvent(eventInterface:"ClipboardEvent"):ClipboardEvent;createEvent(eventInterface:"CloseEvent"):CloseEvent;createEvent(eventInterface:"CompositionEvent"):CompositionEvent;createEvent(eventInterface:"CustomEvent"):CustomEvent;createEvent(eventInterface:"DeviceLightEvent"):DeviceLightEvent;createEvent(eventInterface:"DeviceMotionEvent"):DeviceMotionEvent;createEvent(eventInterface:"DeviceOrientationEvent"):DeviceOrientationEvent;createEvent(eventInterface:"DragEvent"):DragEvent;createEvent(eventInterface:"ErrorEvent"):ErrorEvent;createEvent(eventInterface:"Event"):Event;createEvent(eventInterface:"Events"):Event;createEvent(eventInterface:"FocusEvent"):FocusEvent;createEvent(eventInterface:"FocusNavigationEvent"):FocusNavigationEvent;createEvent(eventInterface:"GamepadEvent"):GamepadEvent;createEvent(eventInterface:"HashChangeEvent"):HashChangeEvent;createEvent(eventInterface:"IDBVersionChangeEvent"):IDBVersionChangeEvent;createEvent(eventInterface:"InputEvent"):InputEvent;createEvent(eventInterface:"KeyboardEvent"):KeyboardEvent;createEvent(eventInterface:"ListeningStateChangedEvent"):ListeningStateChangedEvent;createEvent(eventInterface:"MSGestureEvent"):MSGestureEvent;createEvent(eventInterface:"MSMediaKeyMessageEvent"):MSMediaKeyMessageEvent;createEvent(eventInterface:"MSMediaKeyNeededEvent"):MSMediaKeyNeededEvent;createEvent(eventInterface:"MSPointerEvent"):MSPointerEvent;createEvent(eventInterface:"MediaEncryptedEvent"):MediaEncryptedEvent;createEvent(eventInterface:"MediaKeyMessageEvent"):MediaKeyMessageEvent;createEvent(eventInterface:"MediaQueryListEvent"):MediaQueryListEvent;createEvent(eventInterface:"MediaStreamErrorEvent"):MediaStreamErrorEvent;createEvent(eventInterface:"MediaStreamEvent"):MediaStreamEvent;createEvent(eventInterface:"MediaStreamTrackEvent"):MediaStreamTrackEvent;createEvent(eventInterface:"MessageEvent"):MessageEvent;createEvent(eventInterface:"MouseEvent"):MouseEvent;createEvent(eventInterface:"MouseEvents"):MouseEvent;createEvent(eventInterface:"MutationEvent"):MutationEvent;createEvent(eventInterface:"MutationEvents"):MutationEvent;createEvent(eventInterface:"OfflineAudioCompletionEvent"):OfflineAudioCompletionEvent;createEvent(eventInterface:"OverflowEvent"):OverflowEvent;createEvent(eventInterface:"PageTransitionEvent"):PageTransitionEvent;createEvent(eventInterface:"PaymentRequestUpdateEvent"):PaymentRequestUpdateEvent;createEvent(eventInterface:"PermissionRequestedEvent"):PermissionRequestedEvent;createEvent(eventInterface:"PointerEvent"):PointerEvent;createEvent(eventInterface:"PopStateEvent"):PopStateEvent;createEvent(eventInterface:"ProgressEvent"):ProgressEvent;createEvent(eventInterface:"PromiseRejectionEvent"):PromiseRejectionEvent;createEvent(eventInterface:"RTCDTMFToneChangeEvent"):RTCDTMFToneChangeEvent;createEvent(eventInterface:"RTCDataChannelEvent"):RTCDataChannelEvent;createEvent(eventInterface:"RTCDtlsTransportStateChangedEvent"):RTCDtlsTransportStateChangedEvent;createEvent(eventInterface:"RTCErrorEvent"):RTCErrorEvent;createEvent(eventInterface:"RTCIceCandidatePairChangedEvent"):RTCIceCandidatePairChangedEvent;createEvent(eventInterface:"RTCIceGathererEvent"):RTCIceGathererEvent;createEvent(eventInterface:"RTCIceTransportStateChangedEvent"):RTCIceTransportStateChangedEvent;createEvent(eventInterface:"RTCPeerConnectionIceErrorEvent"):RTCPeerConnectionIceErrorEvent;createEvent(eventInterface:"RTCPeerConnectionIceEvent"):RTCPeerConnectionIceEvent;createEvent(eventInterface:"RTCSsrcConflictEvent"):RTCSsrcConflictEvent;createEvent(eventInterface:"RTCStatsEvent"):RTCStatsEvent;createEvent(eventInterface:"RTCTrackEvent"):RTCTrackEvent;createEvent(eventInterface:"SVGZoomEvent"):SVGZoomEvent;createEvent(eventInterface:"SVGZoomEvents"):SVGZoomEvent;createEvent(eventInterface:"SecurityPolicyViolationEvent"):SecurityPolicyViolationEvent;createEvent(eventInterface:"ServiceWorkerMessageEvent"):ServiceWorkerMessageEvent;createEvent(eventInterface:"SpeechRecognitionEvent"):SpeechRecognitionEvent;createEvent(eventInterface:"SpeechSynthesisErrorEvent"):SpeechSynthesisErrorEvent;createEvent(eventInterface:"SpeechSynthesisEvent"):SpeechSynthesisEvent;createEvent(eventInterface:"StorageEvent"):StorageEvent;createEvent(eventInterface:"TextEvent"):TextEvent;createEvent(eventInterface:"TouchEvent"):TouchEvent;createEvent(eventInterface:"TrackEvent"):TrackEvent;createEvent(eventInterface:"TransitionEvent"):TransitionEvent;createEvent(eventInterface:"UIEvent"):UIEvent;createEvent(eventInterface:"UIEvents"):UIEvent;createEvent(eventInterface:"VRDisplayEvent"):VRDisplayEvent;createEvent(eventInterface:"VRDisplayEvent "):VRDisplayEvent;createEvent(eventInterface:"WebGLContextEvent"):WebGLContextEvent;createEvent(eventInterface:"WheelEvent"):WheelEvent;createEvent(eventInterface:string):Event;}interface DocumentFragment extends Node,NonElementParentNode,ParentNode{readonly ownerDocument:Document;getElementById(elementId:string):HTMLElement|null;}declare var DocumentFragment:{prototype:DocumentFragment;new():DocumentFragment;};interface DocumentOrShadowRoot{readonly activeElement:Element|null;readonly fullscreenElement:Element|null;readonly pointerLockElement:Element|null;readonly styleSheets:StyleSheetList;caretPositionFromPoint(x:number,y:number):CaretPosition|null;caretRangeFromPoint(x:number,y:number):Range;elementFromPoint(x:number,y:number):Element|null;elementsFromPoint(x:number,y:number):Element[];getSelection():Selection|null;}interface DocumentTimeline extends AnimationTimeline{}declare var DocumentTimeline:{prototype:DocumentTimeline;new(options?:DocumentTimelineOptions):DocumentTimeline;};interface DocumentType extends Node,ChildNode{readonly name:string;readonly ownerDocument:Document;readonly publicId:string;readonly systemId:string;}declare var DocumentType:{prototype:DocumentType;new():DocumentType;};interface DragEvent extends MouseEvent{readonly dataTransfer:DataTransfer|null;}declare var DragEvent:{prototype:DragEvent;new(type:string,eventInitDict?:DragEventInit):DragEvent;};interface DynamicsCompressorNode extends AudioNode{readonly attack:AudioParam;readonly knee:AudioParam;readonly ratio:AudioParam;readonly reduction:number;readonly release:AudioParam;readonly threshold:AudioParam;}declare var DynamicsCompressorNode:{prototype:DynamicsCompressorNode;new(context:BaseAudioContext,options?:DynamicsCompressorOptions):DynamicsCompressorNode;};interface EXT_blend_minmax{readonly MAX_EXT:GLenum;readonly MIN_EXT:GLenum;}interface EXT_frag_depth{}interface EXT_sRGB{readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT:GLenum;readonly SRGB8_ALPHA8_EXT:GLenum;readonly SRGB_ALPHA_EXT:GLenum;readonly SRGB_EXT:GLenum;}interface EXT_shader_texture_lod{}interface EXT_texture_filter_anisotropic{readonly MAX_TEXTURE_MAX_ANISOTROPY_EXT:GLenum;readonly TEXTURE_MAX_ANISOTROPY_EXT:GLenum;}interface ElementEventMap{"fullscreenchange":Event;"fullscreenerror":Event;}interface Element extends Node,Animatable,ChildNode,InnerHTML,NonDocumentTypeChildNode,ParentNode,Slotable{readonly assignedSlot:HTMLSlotElement|null;readonly attributes:NamedNodeMap;readonly classList:DOMTokenList;className:string;readonly clientHeight:number;readonly clientLeft:number;readonly clientTop:number;readonly clientWidth:number;id:string;readonly localName:string;readonly namespaceURI:string|null;onfullscreenchange:((this:Element,ev:Event)=>any)|null;onfullscreenerror:((this:Element,ev:Event)=>any)|null;outerHTML:string;readonly ownerDocument:Document;readonly prefix:string|null;readonly scrollHeight:number;scrollLeft:number;scrollTop:number;readonly scrollWidth:number;readonly shadowRoot:ShadowRoot|null;slot:string;readonly tagName:string;attachShadow(init:ShadowRootInit):ShadowRoot;closest<K extends keyof HTMLElementTagNameMap>(selector:K):HTMLElementTagNameMap[K]|null;closest<K extends keyof SVGElementTagNameMap>(selector:K):SVGElementTagNameMap[K]|null;closest<E extends Element=Element>(selector:string):E|null;getAttribute(qualifiedName:string):string|null;getAttributeNS(namespace:string|null,localName:string):string|null;getAttributeNames():string[];getAttributeNode(name:string):Attr|null;getAttributeNodeNS(namespaceURI:string,localName:string):Attr|null;getBoundingClientRect():DOMRect;getClientRects():DOMRectList;getElementsByClassName(classNames:string):HTMLCollectionOf<Element>;getElementsByTagName<K extends keyof HTMLElementTagNameMap>(qualifiedName:K):HTMLCollectionOf<HTMLElementTagNameMap[K]>;getElementsByTagName<K extends keyof SVGElementTagNameMap>(qualifiedName:K):HTMLCollectionOf<SVGElementTagNameMap[K]>;getElementsByTagName(qualifiedName:string):HTMLCollectionOf<Element>;getElementsByTagNameNS(namespaceURI:"http://www.w3.org/1999/xhtml",localName:string):HTMLCollectionOf<HTMLElement>;getElementsByTagNameNS(namespaceURI:"http://www.w3.org/2000/svg",localName:string):HTMLCollectionOf<SVGElement>;getElementsByTagNameNS(namespaceURI:string,localName:string):HTMLCollectionOf<Element>;hasAttribute(qualifiedName:string):boolean;hasAttributeNS(namespace:string|null,localName:string):boolean;hasAttributes():boolean;hasPointerCapture(pointerId:number):boolean;insertAdjacentElement(position:InsertPosition,insertedElement:Element):Element|null;insertAdjacentHTML(where:InsertPosition,html:string):void;insertAdjacentText(where:InsertPosition,text:string):void;matches(selectors:string):boolean;msGetRegionContent():any;releasePointerCapture(pointerId:number):void;removeAttribute(qualifiedName:string):void;removeAttributeNS(namespace:string|null,localName:string):void;removeAttributeNode(attr:Attr):Attr;requestFullscreen(options?:FullscreenOptions):Promise<void>;requestPointerLock():void;scroll(options?:ScrollToOptions):void;scroll(x:number,y:number):void;scrollBy(options?:ScrollToOptions):void;scrollBy(x:number,y:number):void;scrollIntoView(arg?:boolean|ScrollIntoViewOptions):void;scrollTo(options?:ScrollToOptions):void;scrollTo(x:number,y:number):void;setAttribute(qualifiedName:string,value:string):void;setAttributeNS(namespace:string|null,qualifiedName:string,value:string):void;setAttributeNode(attr:Attr):Attr|null;setAttributeNodeNS(attr:Attr):Attr|null;setPointerCapture(pointerId:number):void;toggleAttribute(qualifiedName:string,force?:boolean):boolean;webkitMatchesSelector(selectors:string):boolean;addEventListener<K extends keyof ElementEventMap>(type:K,listener:(this:Element,ev:ElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ElementEventMap>(type:K,listener:(this:Element,ev:ElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var Element:{prototype:Element;new():Element;};interface ElementCSSInlineStyle{readonly style:CSSStyleDeclaration;}interface ElementContentEditable{contentEditable:string;inputMode:string;readonly isContentEditable:boolean;}interface ErrorEvent extends Event{readonly colno:number;readonly error:any;readonly filename:string;readonly lineno:number;readonly message:string;}declare var ErrorEvent:{prototype:ErrorEvent;new(type:string,eventInitDict?:ErrorEventInit):ErrorEvent;};interface Event{readonly bubbles:boolean;cancelBubble:boolean;readonly cancelable:boolean;readonly composed:boolean;readonly currentTarget:EventTarget|null;readonly defaultPrevented:boolean;readonly eventPhase:number;readonly isTrusted:boolean;returnValue:boolean;readonly srcElement:EventTarget|null;readonly target:EventTarget|null;readonly timeStamp:number;readonly type:string;composedPath():EventTarget[];initEvent(type:string,bubbles?:boolean,cancelable?:boolean):void;preventDefault():void;stopImmediatePropagation():void;stopPropagation():void;readonly AT_TARGET:number;readonly BUBBLING_PHASE:number;readonly CAPTURING_PHASE:number;readonly NONE:number;}declare var Event:{prototype:Event;new(type:string,eventInitDict?:EventInit):Event;readonly AT_TARGET:number;readonly BUBBLING_PHASE:number;readonly CAPTURING_PHASE:number;readonly NONE:number;};interface EventListenerObject{handleEvent(evt:Event):void;}interface EventSourceEventMap{"error":Event;"message":MessageEvent;"open":Event;}interface EventSource extends EventTarget{onerror:((this:EventSource,ev:Event)=>any)|null;onmessage:((this:EventSource,ev:MessageEvent)=>any)|null;onopen:((this:EventSource,ev:Event)=>any)|null;readonly readyState:number;readonly url:string;readonly withCredentials:boolean;close():void;readonly CLOSED:number;readonly CONNECTING:number;readonly OPEN:number;addEventListener<K extends keyof EventSourceEventMap>(type:K,listener:(this:EventSource,ev:EventSourceEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof EventSourceEventMap>(type:K,listener:(this:EventSource,ev:EventSourceEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var EventSource:{prototype:EventSource;new(url:string,eventSourceInitDict?:EventSourceInit):EventSource;readonly CLOSED:number;readonly CONNECTING:number;readonly OPEN:number;};interface EventTarget{addEventListener(type:string,listener:EventListenerOrEventListenerObject|null,options?:boolean|AddEventListenerOptions):void;dispatchEvent(event:Event):boolean;removeEventListener(type:string,callback:EventListenerOrEventListenerObject|null,options?:EventListenerOptions|boolean):void;}declare var EventTarget:{prototype:EventTarget;new():EventTarget;};interface ExtensionScriptApis{extensionIdToShortId(extensionId:string):number;fireExtensionApiTelemetry(functionName:string,isSucceeded:boolean,isSupported:boolean,errorString:string):void;genericFunction(routerAddress:any,parameters?:string,callbackId?:number):void;genericSynchronousFunction(functionId:number,parameters?:string):string;genericWebRuntimeCallout(to:any,from:any,payload:string):void;getExtensionId():string;registerGenericFunctionCallbackHandler(callbackHandler:Function):void;registerGenericPersistentCallbackHandler(callbackHandler:Function):void;registerWebRuntimeCallbackHandler(handler:Function):any;}declare var ExtensionScriptApis:{prototype:ExtensionScriptApis;new():ExtensionScriptApis;};interface External{AddSearchProvider():void;IsSearchProviderInstalled():void;}declare var External:{prototype:External;new():External;};interface File extends Blob{readonly lastModified:number;readonly name:string;}declare var File:{prototype:File;new(fileBits:BlobPart[],fileName:string,options?:FilePropertyBag):File;};interface FileList{readonly length:number;item(index:number):File|null;[index:number]:File;}declare var FileList:{prototype:FileList;new():FileList;};interface FileReaderEventMap{"abort":ProgressEvent<FileReader>;"error":ProgressEvent<FileReader>;"load":ProgressEvent<FileReader>;"loadend":ProgressEvent<FileReader>;"loadstart":ProgressEvent<FileReader>;"progress":ProgressEvent<FileReader>;}interface FileReader extends EventTarget{readonly error:DOMException|null;onabort:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onerror:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onload:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onloadend:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onloadstart:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onprogress:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;readonly readyState:number;readonly result:string|ArrayBuffer|null;abort():void;readAsArrayBuffer(blob:Blob):void;readAsBinaryString(blob:Blob):void;readAsDataURL(blob:Blob):void;readAsText(blob:Blob,encoding?:string):void;readonly DONE:number;readonly EMPTY:number;readonly LOADING:number;addEventListener<K extends keyof FileReaderEventMap>(type:K,listener:(this:FileReader,ev:FileReaderEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof FileReaderEventMap>(type:K,listener:(this:FileReader,ev:FileReaderEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var FileReader:{prototype:FileReader;new():FileReader;readonly DONE:number;readonly EMPTY:number;readonly LOADING:number;};interface FocusEvent extends UIEvent{readonly relatedTarget:EventTarget|null;}declare var FocusEvent:{prototype:FocusEvent;new(type:string,eventInitDict?:FocusEventInit):FocusEvent;};interface FocusNavigationEvent extends Event{readonly navigationReason:NavigationReason;readonly originHeight:number;readonly originLeft:number;readonly originTop:number;readonly originWidth:number;requestFocus():void;}declare var FocusNavigationEvent:{prototype:FocusNavigationEvent;new(type:string,eventInitDict?:FocusNavigationEventInit):FocusNavigationEvent;};interface FormData{append(name:string,value:string|Blob,fileName?:string):void;delete(name:string):void;get(name:string):FormDataEntryValue|null;getAll(name:string):FormDataEntryValue[];has(name:string):boolean;set(name:string,value:string|Blob,fileName?:string):void;forEach(callbackfn:(value:FormDataEntryValue,key:string,parent:FormData)=>void,thisArg?:any):void;}declare var FormData:{prototype:FormData;new(form?:HTMLFormElement):FormData;};interface GainNode extends AudioNode{readonly gain:AudioParam;}declare var GainNode:{prototype:GainNode;new(context:BaseAudioContext,options?:GainOptions):GainNode;};interface Gamepad{readonly axes:ReadonlyArray<number>;readonly buttons:ReadonlyArray<GamepadButton>;readonly connected:boolean;readonly hand:GamepadHand;readonly hapticActuators:ReadonlyArray<GamepadHapticActuator>;readonly id:string;readonly index:number;readonly mapping:GamepadMappingType;readonly pose:GamepadPose|null;readonly timestamp:number;}declare var Gamepad:{prototype:Gamepad;new():Gamepad;};interface GamepadButton{readonly pressed:boolean;readonly touched:boolean;readonly value:number;}declare var GamepadButton:{prototype:GamepadButton;new():GamepadButton;};interface GamepadEvent extends Event{readonly gamepad:Gamepad;}declare var GamepadEvent:{prototype:GamepadEvent;new(type:string,eventInitDict:GamepadEventInit):GamepadEvent;};interface GamepadHapticActuator{readonly type:GamepadHapticActuatorType;pulse(value:number,duration:number):Promise<boolean>;}declare var GamepadHapticActuator:{prototype:GamepadHapticActuator;new():GamepadHapticActuator;};interface GamepadPose{readonly angularAcceleration:Float32Array|null;readonly angularVelocity:Float32Array|null;readonly hasOrientation:boolean;readonly hasPosition:boolean;readonly linearAcceleration:Float32Array|null;readonly linearVelocity:Float32Array|null;readonly orientation:Float32Array|null;readonly position:Float32Array|null;}declare var GamepadPose:{prototype:GamepadPose;new():GamepadPose;};interface GenericTransformStream{readonly readable:ReadableStream;readonly writable:WritableStream;}interface Geolocation{clearWatch(watchId:number):void;getCurrentPosition(successCallback:PositionCallback,errorCallback?:PositionErrorCallback,options?:PositionOptions):void;watchPosition(successCallback:PositionCallback,errorCallback?:PositionErrorCallback,options?:PositionOptions):number;}interface GlobalEventHandlersEventMap{"abort":UIEvent;"animationcancel":AnimationEvent;"animationend":AnimationEvent;"animationiteration":AnimationEvent;"animationstart":AnimationEvent;"auxclick":MouseEvent;"blur":FocusEvent;"cancel":Event;"canplay":Event;"canplaythrough":Event;"change":Event;"click":MouseEvent;"close":Event;"contextmenu":MouseEvent;"cuechange":Event;"dblclick":MouseEvent;"drag":DragEvent;"dragend":DragEvent;"dragenter":DragEvent;"dragexit":Event;"dragleave":DragEvent;"dragover":DragEvent;"dragstart":DragEvent;"drop":DragEvent;"durationchange":Event;"emptied":Event;"ended":Event;"error":ErrorEvent;"focus":FocusEvent;"focusin":FocusEvent;"focusout":FocusEvent;"gotpointercapture":PointerEvent;"input":Event;"invalid":Event;"keydown":KeyboardEvent;"keypress":KeyboardEvent;"keyup":KeyboardEvent;"load":Event;"loadeddata":Event;"loadedmetadata":Event;"loadstart":Event;"lostpointercapture":PointerEvent;"mousedown":MouseEvent;"mouseenter":MouseEvent;"mouseleave":MouseEvent;"mousemove":MouseEvent;"mouseout":MouseEvent;"mouseover":MouseEvent;"mouseup":MouseEvent;"pause":Event;"play":Event;"playing":Event;"pointercancel":PointerEvent;"pointerdown":PointerEvent;"pointerenter":PointerEvent;"pointerleave":PointerEvent;"pointermove":PointerEvent;"pointerout":PointerEvent;"pointerover":PointerEvent;"pointerup":PointerEvent;"progress":ProgressEvent;"ratechange":Event;"reset":Event;"resize":UIEvent;"scroll":Event;"securitypolicyviolation":SecurityPolicyViolationEvent;"seeked":Event;"seeking":Event;"select":Event;"selectionchange":Event;"selectstart":Event;"stalled":Event;"submit":Event;"suspend":Event;"timeupdate":Event;"toggle":Event;"touchcancel":TouchEvent;"touchend":TouchEvent;"touchmove":TouchEvent;"touchstart":TouchEvent;"transitioncancel":TransitionEvent;"transitionend":TransitionEvent;"transitionrun":TransitionEvent;"transitionstart":TransitionEvent;"volumechange":Event;"waiting":Event;"wheel":WheelEvent;}interface GlobalEventHandlers{onabort:((this:GlobalEventHandlers,ev:UIEvent)=>any)|null;onanimationcancel:((this:GlobalEventHandlers,ev:AnimationEvent)=>any)|null;onanimationend:((this:GlobalEventHandlers,ev:AnimationEvent)=>any)|null;onanimationiteration:((this:GlobalEventHandlers,ev:AnimationEvent)=>any)|null;onanimationstart:((this:GlobalEventHandlers,ev:AnimationEvent)=>any)|null;onauxclick:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;onblur:((this:GlobalEventHandlers,ev:FocusEvent)=>any)|null;oncancel:((this:GlobalEventHandlers,ev:Event)=>any)|null;oncanplay:((this:GlobalEventHandlers,ev:Event)=>any)|null;oncanplaythrough:((this:GlobalEventHandlers,ev:Event)=>any)|null;onchange:((this:GlobalEventHandlers,ev:Event)=>any)|null;onclick:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;onclose:((this:GlobalEventHandlers,ev:Event)=>any)|null;oncontextmenu:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;oncuechange:((this:GlobalEventHandlers,ev:Event)=>any)|null;ondblclick:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;ondrag:((this:GlobalEventHandlers,ev:DragEvent)=>any)|null;ondragend:((this:GlobalEventHandlers,ev:DragEvent)=>any)|null;ondragenter:((this:GlobalEventHandlers,ev:DragEvent)=>any)|null;ondragexit:((this:GlobalEventHandlers,ev:Event)=>any)|null;ondragleave:((this:GlobalEventHandlers,ev:DragEvent)=>any)|null;ondragover:((this:GlobalEventHandlers,ev:DragEvent)=>any)|null;ondragstart:((this:GlobalEventHandlers,ev:DragEvent)=>any)|null;ondrop:((this:GlobalEventHandlers,ev:DragEvent)=>any)|null;ondurationchange:((this:GlobalEventHandlers,ev:Event)=>any)|null;onemptied:((this:GlobalEventHandlers,ev:Event)=>any)|null;onended:((this:GlobalEventHandlers,ev:Event)=>any)|null;onerror:OnErrorEventHandler;onfocus:((this:GlobalEventHandlers,ev:FocusEvent)=>any)|null;ongotpointercapture:((this:GlobalEventHandlers,ev:PointerEvent)=>any)|null;oninput:((this:GlobalEventHandlers,ev:Event)=>any)|null;oninvalid:((this:GlobalEventHandlers,ev:Event)=>any)|null;onkeydown:((this:GlobalEventHandlers,ev:KeyboardEvent)=>any)|null;onkeypress:((this:GlobalEventHandlers,ev:KeyboardEvent)=>any)|null;onkeyup:((this:GlobalEventHandlers,ev:KeyboardEvent)=>any)|null;onload:((this:GlobalEventHandlers,ev:Event)=>any)|null;onloadeddata:((this:GlobalEventHandlers,ev:Event)=>any)|null;onloadedmetadata:((this:GlobalEventHandlers,ev:Event)=>any)|null;onloadstart:((this:GlobalEventHandlers,ev:Event)=>any)|null;onlostpointercapture:((this:GlobalEventHandlers,ev:PointerEvent)=>any)|null;onmousedown:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;onmouseenter:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;onmouseleave:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;onmousemove:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;onmouseout:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;onmouseover:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;onmouseup:((this:GlobalEventHandlers,ev:MouseEvent)=>any)|null;onpause:((this:GlobalEventHandlers,ev:Event)=>any)|null;onplay:((this:GlobalEventHandlers,ev:Event)=>any)|null;onplaying:((this:GlobalEventHandlers,ev:Event)=>any)|null;onpointercancel:((this:GlobalEventHandlers,ev:PointerEvent)=>any)|null;onpointerdown:((this:GlobalEventHandlers,ev:PointerEvent)=>any)|null;onpointerenter:((this:GlobalEventHandlers,ev:PointerEvent)=>any)|null;onpointerleave:((this:GlobalEventHandlers,ev:PointerEvent)=>any)|null;onpointermove:((this:GlobalEventHandlers,ev:PointerEvent)=>any)|null;onpointerout:((this:GlobalEventHandlers,ev:PointerEvent)=>any)|null;onpointerover:((this:GlobalEventHandlers,ev:PointerEvent)=>any)|null;onpointerup:((this:GlobalEventHandlers,ev:PointerEvent)=>any)|null;onprogress:((this:GlobalEventHandlers,ev:ProgressEvent)=>any)|null;onratechange:((this:GlobalEventHandlers,ev:Event)=>any)|null;onreset:((this:GlobalEventHandlers,ev:Event)=>any)|null;onresize:((this:GlobalEventHandlers,ev:UIEvent)=>any)|null;onscroll:((this:GlobalEventHandlers,ev:Event)=>any)|null;onsecuritypolicyviolation:((this:GlobalEventHandlers,ev:SecurityPolicyViolationEvent)=>any)|null;onseeked:((this:GlobalEventHandlers,ev:Event)=>any)|null;onseeking:((this:GlobalEventHandlers,ev:Event)=>any)|null;onselect:((this:GlobalEventHandlers,ev:Event)=>any)|null;onselectionchange:((this:GlobalEventHandlers,ev:Event)=>any)|null;onselectstart:((this:GlobalEventHandlers,ev:Event)=>any)|null;onstalled:((this:GlobalEventHandlers,ev:Event)=>any)|null;onsubmit:((this:GlobalEventHandlers,ev:Event)=>any)|null;onsuspend:((this:GlobalEventHandlers,ev:Event)=>any)|null;ontimeupdate:((this:GlobalEventHandlers,ev:Event)=>any)|null;ontoggle:((this:GlobalEventHandlers,ev:Event)=>any)|null;ontouchcancel?:((this:GlobalEventHandlers,ev:TouchEvent)=>any)|null;ontouchend?:((this:GlobalEventHandlers,ev:TouchEvent)=>any)|null;ontouchmove?:((this:GlobalEventHandlers,ev:TouchEvent)=>any)|null;ontouchstart?:((this:GlobalEventHandlers,ev:TouchEvent)=>any)|null;ontransitioncancel:((this:GlobalEventHandlers,ev:TransitionEvent)=>any)|null;ontransitionend:((this:GlobalEventHandlers,ev:TransitionEvent)=>any)|null;ontransitionrun:((this:GlobalEventHandlers,ev:TransitionEvent)=>any)|null;ontransitionstart:((this:GlobalEventHandlers,ev:TransitionEvent)=>any)|null;onvolumechange:((this:GlobalEventHandlers,ev:Event)=>any)|null;onwaiting:((this:GlobalEventHandlers,ev:Event)=>any)|null;onwheel:((this:GlobalEventHandlers,ev:WheelEvent)=>any)|null;addEventListener<K extends keyof GlobalEventHandlersEventMap>(type:K,listener:(this:GlobalEventHandlers,ev:GlobalEventHandlersEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof GlobalEventHandlersEventMap>(type:K,listener:(this:GlobalEventHandlers,ev:GlobalEventHandlersEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}interface HTMLAllCollection{readonly length:number;item(nameOrIndex?:string):HTMLCollection|Element|null;namedItem(name:string):HTMLCollection|Element|null;[index:number]:Element;}declare var HTMLAllCollection:{prototype:HTMLAllCollection;new():HTMLAllCollection;};interface HTMLAnchorElement extends HTMLElement,HTMLHyperlinkElementUtils{charset:string;coords:string;download:string;hreflang:string;name:string;ping:string;referrerPolicy:string;rel:string;readonly relList:DOMTokenList;rev:string;shape:string;target:string;text:string;type:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLAnchorElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLAnchorElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLAnchorElement:{prototype:HTMLAnchorElement;new():HTMLAnchorElement;};interface HTMLAppletElement extends HTMLElement{align:string;alt:string;archive:string;code:string;codeBase:string;readonly form:HTMLFormElement|null;height:string;hspace:number;name:string;object:string;vspace:number;width:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLAppletElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLAppletElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLAppletElement:{prototype:HTMLAppletElement;new():HTMLAppletElement;};interface HTMLAreaElement extends HTMLElement,HTMLHyperlinkElementUtils{alt:string;coords:string;download:string;noHref:boolean;ping:string;referrerPolicy:string;rel:string;readonly relList:DOMTokenList;shape:string;target:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLAreaElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLAreaElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLAreaElement:{prototype:HTMLAreaElement;new():HTMLAreaElement;};interface HTMLAudioElement extends HTMLMediaElement{addEventListener<K extends keyof HTMLMediaElementEventMap>(type:K,listener:(this:HTMLAudioElement,ev:HTMLMediaElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLMediaElementEventMap>(type:K,listener:(this:HTMLAudioElement,ev:HTMLMediaElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLAudioElement:{prototype:HTMLAudioElement;new():HTMLAudioElement;};interface HTMLBRElement extends HTMLElement{clear:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLBRElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLBRElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLBRElement:{prototype:HTMLBRElement;new():HTMLBRElement;};interface HTMLBaseElement extends HTMLElement{href:string;target:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLBaseElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLBaseElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLBaseElement:{prototype:HTMLBaseElement;new():HTMLBaseElement;};interface HTMLBaseFontElement extends HTMLElement,DOML2DeprecatedColorProperty{face:string;size:number;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLBaseFontElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLBaseFontElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLBaseFontElement:{prototype:HTMLBaseFontElement;new():HTMLBaseFontElement;};interface HTMLBodyElementEventMap extends HTMLElementEventMap,WindowEventHandlersEventMap{"orientationchange":Event;}interface HTMLBodyElement extends HTMLElement,WindowEventHandlers{aLink:string;background:string;bgColor:string;link:string;onorientationchange:((this:HTMLBodyElement,ev:Event)=>any)|null;text:string;vLink:string;addEventListener<K extends keyof HTMLBodyElementEventMap>(type:K,listener:(this:HTMLBodyElement,ev:HTMLBodyElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLBodyElementEventMap>(type:K,listener:(this:HTMLBodyElement,ev:HTMLBodyElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLBodyElement:{prototype:HTMLBodyElement;new():HTMLBodyElement;};interface HTMLButtonElement extends HTMLElement{disabled:boolean;readonly form:HTMLFormElement|null;formAction:string;formEnctype:string;formMethod:string;formNoValidate:boolean;formTarget:string;readonly labels:NodeListOf<HTMLLabelElement>;name:string;type:string;readonly validationMessage:string;readonly validity:ValidityState;value:string;readonly willValidate:boolean;checkValidity():boolean;reportValidity():boolean;setCustomValidity(error:string):void;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLButtonElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLButtonElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLButtonElement:{prototype:HTMLButtonElement;new():HTMLButtonElement;};interface HTMLCanvasElement extends HTMLElement{height:number;width:number;getContext(contextId:"2d",options?:CanvasRenderingContext2DSettings):CanvasRenderingContext2D|null;getContext(contextId:"bitmaprenderer",options?:ImageBitmapRenderingContextSettings):ImageBitmapRenderingContext|null;getContext(contextId:"webgl",options?:WebGLContextAttributes):WebGLRenderingContext|null;getContext(contextId:"webgl2",options?:WebGLContextAttributes):WebGL2RenderingContext|null;getContext(contextId:string,options?:any):RenderingContext|null;toBlob(callback:BlobCallback,type?:string,quality?:any):void;toDataURL(type?:string,quality?:any):string;transferControlToOffscreen():OffscreenCanvas;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLCanvasElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLCanvasElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLCanvasElement:{prototype:HTMLCanvasElement;new():HTMLCanvasElement;};interface HTMLCollectionBase{readonly length:number;item(index:number):Element|null;[index:number]:Element;}interface HTMLCollection extends HTMLCollectionBase{namedItem(name:string):Element|null;}declare var HTMLCollection:{prototype:HTMLCollection;new():HTMLCollection;};interface HTMLCollectionOf<T extends Element>extends HTMLCollectionBase{item(index:number):T|null;namedItem(name:string):T|null;[index:number]:T;}interface HTMLDListElement extends HTMLElement{compact:boolean;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDListElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDListElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLDListElement:{prototype:HTMLDListElement;new():HTMLDListElement;};interface HTMLDataElement extends HTMLElement{value:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDataElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDataElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLDataElement:{prototype:HTMLDataElement;new():HTMLDataElement;};interface HTMLDataListElement extends HTMLElement{readonly options:HTMLCollectionOf<HTMLOptionElement>;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDataListElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDataListElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLDataListElement:{prototype:HTMLDataListElement;new():HTMLDataListElement;};interface HTMLDetailsElement extends HTMLElement{open:boolean;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDetailsElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDetailsElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLDetailsElement:{prototype:HTMLDetailsElement;new():HTMLDetailsElement;};interface HTMLDialogElement extends HTMLElement{open:boolean;returnValue:string;close(returnValue?:string):void;show():void;showModal():void;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDialogElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDialogElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLDialogElement:{prototype:HTMLDialogElement;new():HTMLDialogElement;};interface HTMLDirectoryElement extends HTMLElement{compact:boolean;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDirectoryElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDirectoryElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLDirectoryElement:{prototype:HTMLDirectoryElement;new():HTMLDirectoryElement;};interface HTMLDivElement extends HTMLElement{align:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDivElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLDivElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLDivElement:{prototype:HTMLDivElement;new():HTMLDivElement;};interface HTMLDocument extends Document{addEventListener<K extends keyof DocumentEventMap>(type:K,listener:(this:HTMLDocument,ev:DocumentEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof DocumentEventMap>(type:K,listener:(this:HTMLDocument,ev:DocumentEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLDocument:{prototype:HTMLDocument;new():HTMLDocument;};interface HTMLElementEventMap extends ElementEventMap,GlobalEventHandlersEventMap,DocumentAndElementEventHandlersEventMap{}interface HTMLElement extends Element,DocumentAndElementEventHandlers,ElementCSSInlineStyle,ElementCSSInlineStyle,ElementContentEditable,GlobalEventHandlers,HTMLOrSVGElement{accessKey:string;readonly accessKeyLabel:string;autocapitalize:string;dir:string;draggable:boolean;hidden:boolean;innerText:string;lang:string;readonly offsetHeight:number;readonly offsetLeft:number;readonly offsetParent:Element|null;readonly offsetTop:number;readonly offsetWidth:number;spellcheck:boolean;title:string;translate:boolean;click():void;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLElement:{prototype:HTMLElement;new():HTMLElement;};interface HTMLEmbedElement extends HTMLElement{align:string;height:string;name:string;src:string;type:string;width:string;getSVGDocument():Document|null;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLEmbedElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLEmbedElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLEmbedElement:{prototype:HTMLEmbedElement;new():HTMLEmbedElement;};interface HTMLFieldSetElement extends HTMLElement{disabled:boolean;readonly elements:HTMLCollection;readonly form:HTMLFormElement|null;name:string;readonly type:string;readonly validationMessage:string;readonly validity:ValidityState;readonly willValidate:boolean;checkValidity():boolean;reportValidity():boolean;setCustomValidity(error:string):void;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLFieldSetElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLFieldSetElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLFieldSetElement:{prototype:HTMLFieldSetElement;new():HTMLFieldSetElement;};interface HTMLFontElement extends HTMLElement{color:string;face:string;size:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLFontElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLFontElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLFontElement:{prototype:HTMLFontElement;new():HTMLFontElement;};interface HTMLFormControlsCollection extends HTMLCollectionBase{namedItem(name:string):RadioNodeList|Element|null;}declare var HTMLFormControlsCollection:{prototype:HTMLFormControlsCollection;new():HTMLFormControlsCollection;};interface HTMLFormElement extends HTMLElement{acceptCharset:string;action:string;autocomplete:string;readonly elements:HTMLFormControlsCollection;encoding:string;enctype:string;readonly length:number;method:string;name:string;noValidate:boolean;target:string;checkValidity():boolean;reportValidity():boolean;reset():void;submit():void;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLFormElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLFormElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;[index:number]:Element;[name:string]:any;}declare var HTMLFormElement:{prototype:HTMLFormElement;new():HTMLFormElement;};interface HTMLFrameElement extends HTMLElement{readonly contentDocument:Document|null;readonly contentWindow:WindowProxy|null;frameBorder:string;longDesc:string;marginHeight:string;marginWidth:string;name:string;noResize:boolean;scrolling:string;src:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLFrameElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLFrameElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLFrameElement:{prototype:HTMLFrameElement;new():HTMLFrameElement;};interface HTMLFrameSetElementEventMap extends HTMLElementEventMap,WindowEventHandlersEventMap{}interface HTMLFrameSetElement extends HTMLElement,WindowEventHandlers{cols:string;rows:string;addEventListener<K extends keyof HTMLFrameSetElementEventMap>(type:K,listener:(this:HTMLFrameSetElement,ev:HTMLFrameSetElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLFrameSetElementEventMap>(type:K,listener:(this:HTMLFrameSetElement,ev:HTMLFrameSetElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLFrameSetElement:{prototype:HTMLFrameSetElement;new():HTMLFrameSetElement;};interface HTMLHRElement extends HTMLElement{align:string;color:string;noShade:boolean;size:string;width:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLHRElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLHRElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLHRElement:{prototype:HTMLHRElement;new():HTMLHRElement;};interface HTMLHeadElement extends HTMLElement{addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLHeadElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLHeadElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLHeadElement:{prototype:HTMLHeadElement;new():HTMLHeadElement;};interface HTMLHeadingElement extends HTMLElement{align:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLHeadingElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLHeadingElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLHeadingElement:{prototype:HTMLHeadingElement;new():HTMLHeadingElement;};interface HTMLHtmlElement extends HTMLElement{version:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLHtmlElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLHtmlElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLHtmlElement:{prototype:HTMLHtmlElement;new():HTMLHtmlElement;};interface HTMLHyperlinkElementUtils{hash:string;host:string;hostname:string;href:string;toString():string;readonly origin:string;password:string;pathname:string;port:string;protocol:string;search:string;username:string;}interface HTMLIFrameElement extends HTMLElement{align:string;allow:string;allowFullscreen:boolean;allowPaymentRequest:boolean;readonly contentDocument:Document|null;readonly contentWindow:WindowProxy|null;frameBorder:string;height:string;longDesc:string;marginHeight:string;marginWidth:string;name:string;referrerPolicy:ReferrerPolicy;readonly sandbox:DOMTokenList;scrolling:string;src:string;srcdoc:string;width:string;getSVGDocument():Document|null;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLIFrameElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLIFrameElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLIFrameElement:{prototype:HTMLIFrameElement;new():HTMLIFrameElement;};interface HTMLImageElement extends HTMLElement{align:string;alt:string;border:string;readonly complete:boolean;crossOrigin:string|null;readonly currentSrc:string;decoding:"async"|"sync"|"auto";height:number;hspace:number;isMap:boolean;longDesc:string;lowsrc:string;name:string;readonly naturalHeight:number;readonly naturalWidth:number;referrerPolicy:string;sizes:string;src:string;srcset:string;useMap:string;vspace:number;width:number;readonly x:number;readonly y:number;decode():Promise<void>;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLImageElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLImageElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLImageElement:{prototype:HTMLImageElement;new():HTMLImageElement;};interface HTMLInputElement extends HTMLElement{accept:string;align:string;alt:string;autocomplete:string;checked:boolean;defaultChecked:boolean;defaultValue:string;dirName:string;disabled:boolean;files:FileList|null;readonly form:HTMLFormElement|null;formAction:string;formEnctype:string;formMethod:string;formNoValidate:boolean;formTarget:string;height:number;indeterminate:boolean;readonly labels:NodeListOf<HTMLLabelElement>|null;readonly list:HTMLElement|null;max:string;maxLength:number;min:string;minLength:number;multiple:boolean;name:string;pattern:string;placeholder:string;readOnly:boolean;required:boolean;selectionDirection:"forward"|"backward"|"none"|null;selectionEnd:number|null;selectionStart:number|null;size:number;src:string;step:string;type:string;useMap:string;readonly validationMessage:string;readonly validity:ValidityState;value:string;valueAsDate:Date|null;valueAsNumber:number;width:number;readonly willValidate:boolean;checkValidity():boolean;reportValidity():boolean;select():void;setCustomValidity(error:string):void;setRangeText(replacement:string):void;setRangeText(replacement:string,start:number,end:number,selectionMode?:SelectionMode):void;setSelectionRange(start:number,end:number,direction?:"forward"|"backward"|"none"):void;stepDown(n?:number):void;stepUp(n?:number):void;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLInputElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLInputElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLInputElement:{prototype:HTMLInputElement;new():HTMLInputElement;};interface HTMLLIElement extends HTMLElement{type:string;value:number;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLLIElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLLIElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLLIElement:{prototype:HTMLLIElement;new():HTMLLIElement;};interface HTMLLabelElement extends HTMLElement{readonly control:HTMLElement|null;readonly form:HTMLFormElement|null;htmlFor:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLLabelElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLLabelElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLLabelElement:{prototype:HTMLLabelElement;new():HTMLLabelElement;};interface HTMLLegendElement extends HTMLElement{align:string;readonly form:HTMLFormElement|null;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLLegendElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLLegendElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLLegendElement:{prototype:HTMLLegendElement;new():HTMLLegendElement;};interface HTMLLinkElement extends HTMLElement,LinkStyle{as:string;charset:string;crossOrigin:string|null;disabled:boolean;href:string;hreflang:string;imageSizes:string;imageSrcset:string;integrity:string;media:string;referrerPolicy:string;rel:string;readonly relList:DOMTokenList;rev:string;readonly sizes:DOMTokenList;target:string;type:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLLinkElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLLinkElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLLinkElement:{prototype:HTMLLinkElement;new():HTMLLinkElement;};interface HTMLMapElement extends HTMLElement{readonly areas:HTMLCollection;name:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLMapElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLMapElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLMapElement:{prototype:HTMLMapElement;new():HTMLMapElement;};interface HTMLMarqueeElementEventMap extends HTMLElementEventMap{"bounce":Event;"finish":Event;"start":Event;}interface HTMLMarqueeElement extends HTMLElement{behavior:string;bgColor:string;direction:string;height:string;hspace:number;loop:number;onbounce:((this:HTMLMarqueeElement,ev:Event)=>any)|null;onfinish:((this:HTMLMarqueeElement,ev:Event)=>any)|null;onstart:((this:HTMLMarqueeElement,ev:Event)=>any)|null;scrollAmount:number;scrollDelay:number;trueSpeed:boolean;vspace:number;width:string;start():void;stop():void;addEventListener<K extends keyof HTMLMarqueeElementEventMap>(type:K,listener:(this:HTMLMarqueeElement,ev:HTMLMarqueeElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLMarqueeElementEventMap>(type:K,listener:(this:HTMLMarqueeElement,ev:HTMLMarqueeElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLMarqueeElement:{prototype:HTMLMarqueeElement;new():HTMLMarqueeElement;};interface HTMLMediaElementEventMap extends HTMLElementEventMap{"encrypted":MediaEncryptedEvent;"waitingforkey":Event;}interface HTMLMediaElement extends HTMLElement{autoplay:boolean;readonly buffered:TimeRanges;controls:boolean;crossOrigin:string|null;readonly currentSrc:string;currentTime:number;defaultMuted:boolean;defaultPlaybackRate:number;readonly duration:number;readonly ended:boolean;readonly error:MediaError|null;loop:boolean;readonly mediaKeys:MediaKeys|null;muted:boolean;readonly networkState:number;onencrypted:((this:HTMLMediaElement,ev:MediaEncryptedEvent)=>any)|null;onwaitingforkey:((this:HTMLMediaElement,ev:Event)=>any)|null;readonly paused:boolean;playbackRate:number;readonly played:TimeRanges;preload:string;readonly readyState:number;readonly seekable:TimeRanges;readonly seeking:boolean;src:string;srcObject:MediaProvider|null;readonly textTracks:TextTrackList;volume:number;addTextTrack(kind:TextTrackKind,label?:string,language?:string):TextTrack;canPlayType(type:string):CanPlayTypeResult;fastSeek(time:number):void;load():void;pause():void;play():Promise<void>;setMediaKeys(mediaKeys:MediaKeys|null):Promise<void>;readonly HAVE_CURRENT_DATA:number;readonly HAVE_ENOUGH_DATA:number;readonly HAVE_FUTURE_DATA:number;readonly HAVE_METADATA:number;readonly HAVE_NOTHING:number;readonly NETWORK_EMPTY:number;readonly NETWORK_IDLE:number;readonly NETWORK_LOADING:number;readonly NETWORK_NO_SOURCE:number;addEventListener<K extends keyof HTMLMediaElementEventMap>(type:K,listener:(this:HTMLMediaElement,ev:HTMLMediaElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLMediaElementEventMap>(type:K,listener:(this:HTMLMediaElement,ev:HTMLMediaElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLMediaElement:{prototype:HTMLMediaElement;new():HTMLMediaElement;readonly HAVE_CURRENT_DATA:number;readonly HAVE_ENOUGH_DATA:number;readonly HAVE_FUTURE_DATA:number;readonly HAVE_METADATA:number;readonly HAVE_NOTHING:number;readonly NETWORK_EMPTY:number;readonly NETWORK_IDLE:number;readonly NETWORK_LOADING:number;readonly NETWORK_NO_SOURCE:number;};interface HTMLMenuElement extends HTMLElement{compact:boolean;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLMenuElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLMenuElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLMenuElement:{prototype:HTMLMenuElement;new():HTMLMenuElement;};interface HTMLMetaElement extends HTMLElement{content:string;httpEquiv:string;name:string;scheme:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLMetaElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLMetaElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLMetaElement:{prototype:HTMLMetaElement;new():HTMLMetaElement;};interface HTMLMeterElement extends HTMLElement{high:number;readonly labels:NodeListOf<HTMLLabelElement>;low:number;max:number;min:number;optimum:number;value:number;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLMeterElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLMeterElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLMeterElement:{prototype:HTMLMeterElement;new():HTMLMeterElement;};interface HTMLModElement extends HTMLElement{cite:string;dateTime:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLModElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLModElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLModElement:{prototype:HTMLModElement;new():HTMLModElement;};interface HTMLOListElement extends HTMLElement{compact:boolean;reversed:boolean;start:number;type:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLOListElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLOListElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLOListElement:{prototype:HTMLOListElement;new():HTMLOListElement;};interface HTMLObjectElement extends HTMLElement{align:string;archive:string;border:string;code:string;codeBase:string;codeType:string;readonly contentDocument:Document|null;readonly contentWindow:WindowProxy|null;data:string;declare:boolean;readonly form:HTMLFormElement|null;height:string;hspace:number;name:string;standby:string;type:string;useMap:string;readonly validationMessage:string;readonly validity:ValidityState;vspace:number;width:string;readonly willValidate:boolean;checkValidity():boolean;getSVGDocument():Document|null;reportValidity():boolean;setCustomValidity(error:string):void;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLObjectElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLObjectElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLObjectElement:{prototype:HTMLObjectElement;new():HTMLObjectElement;};interface HTMLOptGroupElement extends HTMLElement{disabled:boolean;readonly form:HTMLFormElement|null;label:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLOptGroupElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLOptGroupElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLOptGroupElement:{prototype:HTMLOptGroupElement;new():HTMLOptGroupElement;};interface HTMLOptionElement extends HTMLElement{defaultSelected:boolean;disabled:boolean;readonly form:HTMLFormElement|null;readonly index:number;label:string;selected:boolean;text:string;value:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLOptionElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLOptionElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLOptionElement:{prototype:HTMLOptionElement;new():HTMLOptionElement;};interface HTMLOptionsCollection extends HTMLCollectionOf<HTMLOptionElement>{length:number;selectedIndex:number;add(element:HTMLOptionElement|HTMLOptGroupElement,before?:HTMLElement|number|null):void;remove(index:number):void;}declare var HTMLOptionsCollection:{prototype:HTMLOptionsCollection;new():HTMLOptionsCollection;};interface HTMLOrSVGElement{autofocus:boolean;readonly dataset:DOMStringMap;nonce?:string;tabIndex:number;blur():void;focus(options?:FocusOptions):void;}interface HTMLOutputElement extends HTMLElement{defaultValue:string;readonly form:HTMLFormElement|null;readonly htmlFor:DOMTokenList;readonly labels:NodeListOf<HTMLLabelElement>;name:string;readonly type:string;readonly validationMessage:string;readonly validity:ValidityState;value:string;readonly willValidate:boolean;checkValidity():boolean;reportValidity():boolean;setCustomValidity(error:string):void;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLOutputElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLOutputElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLOutputElement:{prototype:HTMLOutputElement;new():HTMLOutputElement;};interface HTMLParagraphElement extends HTMLElement{align:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLParagraphElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLParagraphElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLParagraphElement:{prototype:HTMLParagraphElement;new():HTMLParagraphElement;};interface HTMLParamElement extends HTMLElement{name:string;type:string;value:string;valueType:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLParamElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLParamElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLParamElement:{prototype:HTMLParamElement;new():HTMLParamElement;};interface HTMLPictureElement extends HTMLElement{addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLPictureElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLPictureElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLPictureElement:{prototype:HTMLPictureElement;new():HTMLPictureElement;};interface HTMLPreElement extends HTMLElement{width:number;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLPreElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLPreElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLPreElement:{prototype:HTMLPreElement;new():HTMLPreElement;};interface HTMLProgressElement extends HTMLElement{readonly labels:NodeListOf<HTMLLabelElement>;max:number;readonly position:number;value:number;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLProgressElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLProgressElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLProgressElement:{prototype:HTMLProgressElement;new():HTMLProgressElement;};interface HTMLQuoteElement extends HTMLElement{cite:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLQuoteElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLQuoteElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLQuoteElement:{prototype:HTMLQuoteElement;new():HTMLQuoteElement;};interface HTMLScriptElement extends HTMLElement{async:boolean;charset:string;crossOrigin:string|null;defer:boolean;event:string;htmlFor:string;integrity:string;noModule:boolean;referrerPolicy:string;src:string;text:string;type:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLScriptElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLScriptElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLScriptElement:{prototype:HTMLScriptElement;new():HTMLScriptElement;};interface HTMLSelectElement extends HTMLElement{autocomplete:string;disabled:boolean;readonly form:HTMLFormElement|null;readonly labels:NodeListOf<HTMLLabelElement>;length:number;multiple:boolean;name:string;readonly options:HTMLOptionsCollection;required:boolean;selectedIndex:number;readonly selectedOptions:HTMLCollectionOf<HTMLOptionElement>;size:number;readonly type:string;readonly validationMessage:string;readonly validity:ValidityState;value:string;readonly willValidate:boolean;add(element:HTMLOptionElement|HTMLOptGroupElement,before?:HTMLElement|number|null):void;checkValidity():boolean;item(index:number):Element|null;namedItem(name:string):HTMLOptionElement|null;remove():void;remove(index:number):void;reportValidity():boolean;setCustomValidity(error:string):void;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLSelectElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLSelectElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;[name:number]:HTMLOptionElement|HTMLOptGroupElement;}declare var HTMLSelectElement:{prototype:HTMLSelectElement;new():HTMLSelectElement;};interface HTMLSlotElement extends HTMLElement{name:string;assignedElements(options?:AssignedNodesOptions):Element[];assignedNodes(options?:AssignedNodesOptions):Node[];addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLSlotElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLSlotElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLSlotElement:{prototype:HTMLSlotElement;new():HTMLSlotElement;};interface HTMLSourceElement extends HTMLElement{media:string;sizes:string;src:string;srcset:string;type:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLSourceElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLSourceElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLSourceElement:{prototype:HTMLSourceElement;new():HTMLSourceElement;};interface HTMLSpanElement extends HTMLElement{addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLSpanElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLSpanElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLSpanElement:{prototype:HTMLSpanElement;new():HTMLSpanElement;};interface HTMLStyleElement extends HTMLElement,LinkStyle{media:string;type:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLStyleElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLStyleElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLStyleElement:{prototype:HTMLStyleElement;new():HTMLStyleElement;};interface HTMLTableCaptionElement extends HTMLElement{align:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableCaptionElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableCaptionElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTableCaptionElement:{prototype:HTMLTableCaptionElement;new():HTMLTableCaptionElement;};interface HTMLTableCellElement extends HTMLElement{abbr:string;align:string;axis:string;bgColor:string;readonly cellIndex:number;ch:string;chOff:string;colSpan:number;headers:string;height:string;noWrap:boolean;rowSpan:number;scope:string;vAlign:string;width:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableCellElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableCellElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTableCellElement:{prototype:HTMLTableCellElement;new():HTMLTableCellElement;};interface HTMLTableColElement extends HTMLElement{align:string;ch:string;chOff:string;span:number;vAlign:string;width:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableColElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableColElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTableColElement:{prototype:HTMLTableColElement;new():HTMLTableColElement;};interface HTMLTableDataCellElement extends HTMLTableCellElement{addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableDataCellElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableDataCellElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTableDataCellElement:{prototype:HTMLTableDataCellElement;new():HTMLTableDataCellElement;};interface HTMLTableElement extends HTMLElement{align:string;bgColor:string;border:string;caption:HTMLTableCaptionElement|null;cellPadding:string;cellSpacing:string;frame:string;readonly rows:HTMLCollectionOf<HTMLTableRowElement>;rules:string;summary:string;readonly tBodies:HTMLCollectionOf<HTMLTableSectionElement>;tFoot:HTMLTableSectionElement|null;tHead:HTMLTableSectionElement|null;width:string;createCaption():HTMLTableCaptionElement;createTBody():HTMLTableSectionElement;createTFoot():HTMLTableSectionElement;createTHead():HTMLTableSectionElement;deleteCaption():void;deleteRow(index:number):void;deleteTFoot():void;deleteTHead():void;insertRow(index?:number):HTMLTableRowElement;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTableElement:{prototype:HTMLTableElement;new():HTMLTableElement;};interface HTMLTableHeaderCellElement extends HTMLTableCellElement{scope:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableHeaderCellElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableHeaderCellElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTableHeaderCellElement:{prototype:HTMLTableHeaderCellElement;new():HTMLTableHeaderCellElement;};interface HTMLTableRowElement extends HTMLElement{align:string;bgColor:string;readonly cells:HTMLCollectionOf<HTMLTableDataCellElement|HTMLTableHeaderCellElement>;ch:string;chOff:string;readonly rowIndex:number;readonly sectionRowIndex:number;vAlign:string;deleteCell(index:number):void;insertCell(index?:number):HTMLTableDataCellElement;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableRowElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableRowElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTableRowElement:{prototype:HTMLTableRowElement;new():HTMLTableRowElement;};interface HTMLTableSectionElement extends HTMLElement{align:string;ch:string;chOff:string;readonly rows:HTMLCollectionOf<HTMLTableRowElement>;vAlign:string;deleteRow(index:number):void;insertRow(index?:number):HTMLTableRowElement;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableSectionElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTableSectionElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTableSectionElement:{prototype:HTMLTableSectionElement;new():HTMLTableSectionElement;};interface HTMLTemplateElement extends HTMLElement{readonly content:DocumentFragment;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTemplateElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTemplateElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTemplateElement:{prototype:HTMLTemplateElement;new():HTMLTemplateElement;};interface HTMLTextAreaElement extends HTMLElement{autocomplete:string;cols:number;defaultValue:string;dirName:string;disabled:boolean;readonly form:HTMLFormElement|null;readonly labels:NodeListOf<HTMLLabelElement>;maxLength:number;minLength:number;name:string;placeholder:string;readOnly:boolean;required:boolean;rows:number;selectionDirection:"forward"|"backward"|"none";selectionEnd:number;selectionStart:number;readonly textLength:number;readonly type:string;readonly validationMessage:string;readonly validity:ValidityState;value:string;readonly willValidate:boolean;wrap:string;checkValidity():boolean;reportValidity():boolean;select():void;setCustomValidity(error:string):void;setRangeText(replacement:string):void;setRangeText(replacement:string,start:number,end:number,selectionMode?:SelectionMode):void;setSelectionRange(start:number,end:number,direction?:"forward"|"backward"|"none"):void;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTextAreaElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTextAreaElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTextAreaElement:{prototype:HTMLTextAreaElement;new():HTMLTextAreaElement;};interface HTMLTimeElement extends HTMLElement{dateTime:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTimeElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTimeElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTimeElement:{prototype:HTMLTimeElement;new():HTMLTimeElement;};interface HTMLTitleElement extends HTMLElement{text:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTitleElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTitleElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTitleElement:{prototype:HTMLTitleElement;new():HTMLTitleElement;};interface HTMLTrackElement extends HTMLElement{default:boolean;kind:string;label:string;readonly readyState:number;src:string;srclang:string;readonly track:TextTrack;readonly ERROR:number;readonly LOADED:number;readonly LOADING:number;readonly NONE:number;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTrackElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLTrackElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLTrackElement:{prototype:HTMLTrackElement;new():HTMLTrackElement;readonly ERROR:number;readonly LOADED:number;readonly LOADING:number;readonly NONE:number;};interface HTMLUListElement extends HTMLElement{compact:boolean;type:string;addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLUListElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLUListElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLUListElement:{prototype:HTMLUListElement;new():HTMLUListElement;};interface HTMLUnknownElement extends HTMLElement{addEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLUnknownElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLElementEventMap>(type:K,listener:(this:HTMLUnknownElement,ev:HTMLElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLUnknownElement:{prototype:HTMLUnknownElement;new():HTMLUnknownElement;};interface HTMLVideoElement extends HTMLMediaElement{height:number;poster:string;readonly videoHeight:number;readonly videoWidth:number;width:number;getVideoPlaybackQuality():VideoPlaybackQuality;addEventListener<K extends keyof HTMLMediaElementEventMap>(type:K,listener:(this:HTMLVideoElement,ev:HTMLMediaElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof HTMLMediaElementEventMap>(type:K,listener:(this:HTMLVideoElement,ev:HTMLMediaElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var HTMLVideoElement:{prototype:HTMLVideoElement;new():HTMLVideoElement;};interface HashChangeEvent extends Event{readonly newURL:string;readonly oldURL:string;}declare var HashChangeEvent:{prototype:HashChangeEvent;new(type:string,eventInitDict?:HashChangeEventInit):HashChangeEvent;};interface Headers{append(name:string,value:string):void;delete(name:string):void;get(name:string):string|null;has(name:string):boolean;set(name:string,value:string):void;forEach(callbackfn:(value:string,key:string,parent:Headers)=>void,thisArg?:any):void;}declare var Headers:{prototype:Headers;new(init?:HeadersInit):Headers;};interface History{readonly length:number;scrollRestoration:ScrollRestoration;readonly state:any;back():void;forward():void;go(delta?:number):void;pushState(data:any,title:string,url?:string|null):void;replaceState(data:any,title:string,url?:string|null):void;}declare var History:{prototype:History;new():History;};interface HkdfCtrParams extends Algorithm{context:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;hash:string|Algorithm;label:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface IDBArrayKey extends Array<IDBValidKey>{}interface IDBCursor{readonly direction:IDBCursorDirection;readonly key:IDBValidKey;readonly primaryKey:IDBValidKey;readonly source:IDBObjectStore|IDBIndex;advance(count:number):void;continue(key?:IDBValidKey):void;continuePrimaryKey(key:IDBValidKey,primaryKey:IDBValidKey):void;delete():IDBRequest<undefined>;update(value:any):IDBRequest<IDBValidKey>;}declare var IDBCursor:{prototype:IDBCursor;new():IDBCursor;};interface IDBCursorWithValue extends IDBCursor{readonly value:any;}declare var IDBCursorWithValue:{prototype:IDBCursorWithValue;new():IDBCursorWithValue;};interface IDBDatabaseEventMap{"abort":Event;"close":Event;"error":Event;"versionchange":IDBVersionChangeEvent;}interface IDBDatabase extends EventTarget{readonly name:string;readonly objectStoreNames:DOMStringList;onabort:((this:IDBDatabase,ev:Event)=>any)|null;onclose:((this:IDBDatabase,ev:Event)=>any)|null;onerror:((this:IDBDatabase,ev:Event)=>any)|null;onversionchange:((this:IDBDatabase,ev:IDBVersionChangeEvent)=>any)|null;readonly version:number;close():void;createObjectStore(name:string,optionalParameters?:IDBObjectStoreParameters):IDBObjectStore;deleteObjectStore(name:string):void;transaction(storeNames:string|string[],mode?:IDBTransactionMode):IDBTransaction;addEventListener<K extends keyof IDBDatabaseEventMap>(type:K,listener:(this:IDBDatabase,ev:IDBDatabaseEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof IDBDatabaseEventMap>(type:K,listener:(this:IDBDatabase,ev:IDBDatabaseEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var IDBDatabase:{prototype:IDBDatabase;new():IDBDatabase;};interface IDBFactory{cmp(first:any,second:any):number;deleteDatabase(name:string):IDBOpenDBRequest;open(name:string,version?:number):IDBOpenDBRequest;}declare var IDBFactory:{prototype:IDBFactory;new():IDBFactory;};interface IDBIndex{readonly keyPath:string|string[];readonly multiEntry:boolean;name:string;readonly objectStore:IDBObjectStore;readonly unique:boolean;count(key?:IDBValidKey|IDBKeyRange):IDBRequest<number>;get(key:IDBValidKey|IDBKeyRange):IDBRequest<any|undefined>;getAll(query?:IDBValidKey|IDBKeyRange|null,count?:number):IDBRequest<any[]>;getAllKeys(query?:IDBValidKey|IDBKeyRange|null,count?:number):IDBRequest<IDBValidKey[]>;getKey(key:IDBValidKey|IDBKeyRange):IDBRequest<IDBValidKey|undefined>;openCursor(query?:IDBValidKey|IDBKeyRange|null,direction?:IDBCursorDirection):IDBRequest<IDBCursorWithValue|null>;openKeyCursor(query?:IDBValidKey|IDBKeyRange|null,direction?:IDBCursorDirection):IDBRequest<IDBCursor|null>;}declare var IDBIndex:{prototype:IDBIndex;new():IDBIndex;};interface IDBKeyRange{readonly lower:any;readonly lowerOpen:boolean;readonly upper:any;readonly upperOpen:boolean;includes(key:any):boolean;}declare var IDBKeyRange:{prototype:IDBKeyRange;new():IDBKeyRange;bound(lower:any,upper:any,lowerOpen?:boolean,upperOpen?:boolean):IDBKeyRange;lowerBound(lower:any,open?:boolean):IDBKeyRange;only(value:any):IDBKeyRange;upperBound(upper:any,open?:boolean):IDBKeyRange;};interface IDBObjectStore{readonly autoIncrement:boolean;readonly indexNames:DOMStringList;readonly keyPath:string|string[];name:string;readonly transaction:IDBTransaction;add(value:any,key?:IDBValidKey):IDBRequest<IDBValidKey>;clear():IDBRequest<undefined>;count(key?:IDBValidKey|IDBKeyRange):IDBRequest<number>;createIndex(name:string,keyPath:string|string[],options?:IDBIndexParameters):IDBIndex;delete(key:IDBValidKey|IDBKeyRange):IDBRequest<undefined>;deleteIndex(name:string):void;get(query:IDBValidKey|IDBKeyRange):IDBRequest<any|undefined>;getAll(query?:IDBValidKey|IDBKeyRange|null,count?:number):IDBRequest<any[]>;getAllKeys(query?:IDBValidKey|IDBKeyRange|null,count?:number):IDBRequest<IDBValidKey[]>;getKey(query:IDBValidKey|IDBKeyRange):IDBRequest<IDBValidKey|undefined>;index(name:string):IDBIndex;openCursor(query?:IDBValidKey|IDBKeyRange|null,direction?:IDBCursorDirection):IDBRequest<IDBCursorWithValue|null>;openKeyCursor(query?:IDBValidKey|IDBKeyRange|null,direction?:IDBCursorDirection):IDBRequest<IDBCursor|null>;put(value:any,key?:IDBValidKey):IDBRequest<IDBValidKey>;}declare var IDBObjectStore:{prototype:IDBObjectStore;new():IDBObjectStore;};interface IDBOpenDBRequestEventMap extends IDBRequestEventMap{"blocked":Event;"upgradeneeded":IDBVersionChangeEvent;}interface IDBOpenDBRequest extends IDBRequest<IDBDatabase>{onblocked:((this:IDBOpenDBRequest,ev:Event)=>any)|null;onupgradeneeded:((this:IDBOpenDBRequest,ev:IDBVersionChangeEvent)=>any)|null;addEventListener<K extends keyof IDBOpenDBRequestEventMap>(type:K,listener:(this:IDBOpenDBRequest,ev:IDBOpenDBRequestEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof IDBOpenDBRequestEventMap>(type:K,listener:(this:IDBOpenDBRequest,ev:IDBOpenDBRequestEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var IDBOpenDBRequest:{prototype:IDBOpenDBRequest;new():IDBOpenDBRequest;};interface IDBRequestEventMap{"error":Event;"success":Event;}interface IDBRequest<T=any>extends EventTarget{readonly error:DOMException|null;onerror:((this:IDBRequest<T>,ev:Event)=>any)|null;onsuccess:((this:IDBRequest<T>,ev:Event)=>any)|null;readonly readyState:IDBRequestReadyState;readonly result:T;readonly source:IDBObjectStore|IDBIndex|IDBCursor;readonly transaction:IDBTransaction|null;addEventListener<K extends keyof IDBRequestEventMap>(type:K,listener:(this:IDBRequest<T>,ev:IDBRequestEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof IDBRequestEventMap>(type:K,listener:(this:IDBRequest<T>,ev:IDBRequestEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var IDBRequest:{prototype:IDBRequest;new():IDBRequest;};interface IDBTransactionEventMap{"abort":Event;"complete":Event;"error":Event;}interface IDBTransaction extends EventTarget{readonly db:IDBDatabase;readonly error:DOMException;readonly mode:IDBTransactionMode;readonly objectStoreNames:DOMStringList;onabort:((this:IDBTransaction,ev:Event)=>any)|null;oncomplete:((this:IDBTransaction,ev:Event)=>any)|null;onerror:((this:IDBTransaction,ev:Event)=>any)|null;abort():void;objectStore(name:string):IDBObjectStore;addEventListener<K extends keyof IDBTransactionEventMap>(type:K,listener:(this:IDBTransaction,ev:IDBTransactionEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof IDBTransactionEventMap>(type:K,listener:(this:IDBTransaction,ev:IDBTransactionEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var IDBTransaction:{prototype:IDBTransaction;new():IDBTransaction;};interface IDBVersionChangeEvent extends Event{readonly newVersion:number|null;readonly oldVersion:number;}declare var IDBVersionChangeEvent:{prototype:IDBVersionChangeEvent;new(type:string,eventInitDict?:IDBVersionChangeEventInit):IDBVersionChangeEvent;};interface IIRFilterNode extends AudioNode{getFrequencyResponse(frequencyHz:Float32Array,magResponse:Float32Array,phaseResponse:Float32Array):void;}declare var IIRFilterNode:{prototype:IIRFilterNode;new(context:BaseAudioContext,options:IIRFilterOptions):IIRFilterNode;};interface ImageBitmap{readonly height:number;readonly width:number;close():void;}declare var ImageBitmap:{prototype:ImageBitmap;new():ImageBitmap;};interface ImageBitmapRenderingContext{readonly canvas:HTMLCanvasElement|OffscreenCanvas;transferFromImageBitmap(bitmap:ImageBitmap|null):void;}declare var ImageBitmapRenderingContext:{prototype:ImageBitmapRenderingContext;new():ImageBitmapRenderingContext;};interface ImageData{readonly data:Uint8ClampedArray;readonly height:number;readonly width:number;}declare var ImageData:{prototype:ImageData;new(width:number,height:number):ImageData;new(array:Uint8ClampedArray,width:number,height?:number):ImageData;};interface InnerHTML{innerHTML:string;}interface InputDeviceInfo extends MediaDeviceInfo{getCapabilities():MediaTrackCapabilities;}declare var InputDeviceInfo:{prototype:InputDeviceInfo;new():InputDeviceInfo;};interface InputEvent extends UIEvent{readonly data:string|null;readonly inputType:string;readonly isComposing:boolean;}declare var InputEvent:{prototype:InputEvent;new(type:string,eventInitDict?:InputEventInit):InputEvent;};interface IntersectionObserver{readonly root:Element|null;readonly rootMargin:string;readonly thresholds:ReadonlyArray<number>;disconnect():void;observe(target:Element):void;takeRecords():IntersectionObserverEntry[];unobserve(target:Element):void;}declare var IntersectionObserver:{prototype:IntersectionObserver;new(callback:IntersectionObserverCallback,options?:IntersectionObserverInit):IntersectionObserver;};interface IntersectionObserverEntry{readonly boundingClientRect:DOMRectReadOnly;readonly intersectionRatio:number;readonly intersectionRect:DOMRectReadOnly;readonly isIntersecting:boolean;readonly rootBounds:DOMRectReadOnly|null;readonly target:Element;readonly time:number;}declare var IntersectionObserverEntry:{prototype:IntersectionObserverEntry;new(intersectionObserverEntryInit:IntersectionObserverEntryInit):IntersectionObserverEntry;};interface KeyboardEvent extends UIEvent{readonly altKey:boolean;char:string;readonly charCode:number;readonly code:string;readonly ctrlKey:boolean;readonly isComposing:boolean;readonly key:string;readonly keyCode:number;readonly location:number;readonly metaKey:boolean;readonly repeat:boolean;readonly shiftKey:boolean;getModifierState(keyArg:string):boolean;readonly DOM_KEY_LOCATION_LEFT:number;readonly DOM_KEY_LOCATION_NUMPAD:number;readonly DOM_KEY_LOCATION_RIGHT:number;readonly DOM_KEY_LOCATION_STANDARD:number;}declare var KeyboardEvent:{prototype:KeyboardEvent;new(type:string,eventInitDict?:KeyboardEventInit):KeyboardEvent;readonly DOM_KEY_LOCATION_LEFT:number;readonly DOM_KEY_LOCATION_NUMPAD:number;readonly DOM_KEY_LOCATION_RIGHT:number;readonly DOM_KEY_LOCATION_STANDARD:number;};interface KeyframeEffect extends AnimationEffect{composite:CompositeOperation;iterationComposite:IterationCompositeOperation;target:Element|null;getKeyframes():ComputedKeyframe[];setKeyframes(keyframes:Keyframe[]|PropertyIndexedKeyframes|null):void;}declare var KeyframeEffect:{prototype:KeyframeEffect;new(target:Element|null,keyframes:Keyframe[]|PropertyIndexedKeyframes|null,options?:number|KeyframeEffectOptions):KeyframeEffect;new(source:KeyframeEffect):KeyframeEffect;};interface LinkStyle{readonly sheet:CSSStyleSheet|null;}interface ListeningStateChangedEvent extends Event{readonly label:string;readonly state:ListeningState;}declare var ListeningStateChangedEvent:{prototype:ListeningStateChangedEvent;new():ListeningStateChangedEvent;};interface Location{readonly ancestorOrigins:DOMStringList;hash:string;host:string;hostname:string;href:string;toString():string;readonly origin:string;pathname:string;port:string;protocol:string;search:string;assign(url:string):void;reload():void;reload(forcedReload:boolean):void;replace(url:string):void;}declare var Location:{prototype:Location;new():Location;};interface MSAssertion{readonly id:string;readonly type:MSCredentialType;}declare var MSAssertion:{prototype:MSAssertion;new():MSAssertion;};interface MSBlobBuilder{append(data:any,endings?:string):void;getBlob(contentType?:string):Blob;}declare var MSBlobBuilder:{prototype:MSBlobBuilder;new():MSBlobBuilder;};interface MSFIDOCredentialAssertion extends MSAssertion{readonly algorithm:string|Algorithm;readonly attestation:any;readonly publicKey:string;readonly transportHints:MSTransportType[];}declare var MSFIDOCredentialAssertion:{prototype:MSFIDOCredentialAssertion;new():MSFIDOCredentialAssertion;};interface MSFIDOSignature{readonly authnrData:string;readonly clientData:string;readonly signature:string;}declare var MSFIDOSignature:{prototype:MSFIDOSignature;new():MSFIDOSignature;};interface MSFIDOSignatureAssertion extends MSAssertion{readonly signature:MSFIDOSignature;}declare var MSFIDOSignatureAssertion:{prototype:MSFIDOSignatureAssertion;new():MSFIDOSignatureAssertion;};interface MSFileSaver{msSaveBlob(blob:any,defaultName?:string):boolean;msSaveOrOpenBlob(blob:any,defaultName?:string):boolean;}interface MSGesture{target:Element;addPointer(pointerId:number):void;stop():void;}declare var MSGesture:{prototype:MSGesture;new():MSGesture;};interface MSGestureEvent extends UIEvent{readonly clientX:number;readonly clientY:number;readonly expansion:number;readonly gestureObject:any;readonly hwTimestamp:number;readonly offsetX:number;readonly offsetY:number;readonly rotation:number;readonly scale:number;readonly screenX:number;readonly screenY:number;readonly translationX:number;readonly translationY:number;readonly velocityAngular:number;readonly velocityExpansion:number;readonly velocityX:number;readonly velocityY:number;initGestureEvent(typeArg:string,canBubbleArg:boolean,cancelableArg:boolean,viewArg:Window,detailArg:number,screenXArg:number,screenYArg:number,clientXArg:number,clientYArg:number,offsetXArg:number,offsetYArg:number,translationXArg:number,translationYArg:number,scaleArg:number,expansionArg:number,rotationArg:number,velocityXArg:number,velocityYArg:number,velocityExpansionArg:number,velocityAngularArg:number,hwTimestampArg:number):void;readonly MSGESTURE_FLAG_BEGIN:number;readonly MSGESTURE_FLAG_CANCEL:number;readonly MSGESTURE_FLAG_END:number;readonly MSGESTURE_FLAG_INERTIA:number;readonly MSGESTURE_FLAG_NONE:number;}declare var MSGestureEvent:{prototype:MSGestureEvent;new():MSGestureEvent;readonly MSGESTURE_FLAG_BEGIN:number;readonly MSGESTURE_FLAG_CANCEL:number;readonly MSGESTURE_FLAG_END:number;readonly MSGESTURE_FLAG_INERTIA:number;readonly MSGESTURE_FLAG_NONE:number;};interface MSGraphicsTrust{readonly constrictionActive:boolean;readonly status:string;}declare var MSGraphicsTrust:{prototype:MSGraphicsTrust;new():MSGraphicsTrust;};interface MSInputMethodContextEventMap{"MSCandidateWindowHide":Event;"MSCandidateWindowShow":Event;"MSCandidateWindowUpdate":Event;}interface MSInputMethodContext extends EventTarget{readonly compositionEndOffset:number;readonly compositionStartOffset:number;oncandidatewindowhide:((this:MSInputMethodContext,ev:Event)=>any)|null;oncandidatewindowshow:((this:MSInputMethodContext,ev:Event)=>any)|null;oncandidatewindowupdate:((this:MSInputMethodContext,ev:Event)=>any)|null;readonly target:HTMLElement;getCandidateWindowClientRect():ClientRect;getCompositionAlternatives():string[];hasComposition():boolean;isCandidateWindowVisible():boolean;addEventListener<K extends keyof MSInputMethodContextEventMap>(type:K,listener:(this:MSInputMethodContext,ev:MSInputMethodContextEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof MSInputMethodContextEventMap>(type:K,listener:(this:MSInputMethodContext,ev:MSInputMethodContextEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var MSInputMethodContext:{prototype:MSInputMethodContext;new():MSInputMethodContext;};interface MSMediaKeyError{readonly code:number;readonly systemCode:number;readonly MS_MEDIA_KEYERR_CLIENT:number;readonly MS_MEDIA_KEYERR_DOMAIN:number;readonly MS_MEDIA_KEYERR_HARDWARECHANGE:number;readonly MS_MEDIA_KEYERR_OUTPUT:number;readonly MS_MEDIA_KEYERR_SERVICE:number;readonly MS_MEDIA_KEYERR_UNKNOWN:number;}declare var MSMediaKeyError:{prototype:MSMediaKeyError;new():MSMediaKeyError;readonly MS_MEDIA_KEYERR_CLIENT:number;readonly MS_MEDIA_KEYERR_DOMAIN:number;readonly MS_MEDIA_KEYERR_HARDWARECHANGE:number;readonly MS_MEDIA_KEYERR_OUTPUT:number;readonly MS_MEDIA_KEYERR_SERVICE:number;readonly MS_MEDIA_KEYERR_UNKNOWN:number;};interface MSMediaKeyMessageEvent extends Event{readonly destinationURL:string|null;readonly message:Uint8Array;}declare var MSMediaKeyMessageEvent:{prototype:MSMediaKeyMessageEvent;new():MSMediaKeyMessageEvent;};interface MSMediaKeyNeededEvent extends Event{readonly initData:Uint8Array|null;}declare var MSMediaKeyNeededEvent:{prototype:MSMediaKeyNeededEvent;new():MSMediaKeyNeededEvent;};interface MSMediaKeySession extends EventTarget{readonly error:MSMediaKeyError|null;readonly keySystem:string;readonly sessionId:string;close():void;update(key:Uint8Array):void;}declare var MSMediaKeySession:{prototype:MSMediaKeySession;new():MSMediaKeySession;};interface MSMediaKeys{readonly keySystem:string;createSession(type:string,initData:Uint8Array,cdmData?:Uint8Array|null):MSMediaKeySession;}declare var MSMediaKeys:{prototype:MSMediaKeys;new(keySystem:string):MSMediaKeys;isTypeSupported(keySystem:string,type?:string|null):boolean;isTypeSupportedWithFeatures(keySystem:string,type?:string|null):string;};interface MSNavigatorDoNotTrack{confirmSiteSpecificTrackingException(args:ConfirmSiteSpecificExceptionsInformation):boolean;confirmWebWideTrackingException(args:ExceptionInformation):boolean;removeSiteSpecificTrackingException(args:ExceptionInformation):void;removeWebWideTrackingException(args:ExceptionInformation):void;storeSiteSpecificTrackingException(args:StoreSiteSpecificExceptionsInformation):void;storeWebWideTrackingException(args:StoreExceptionsInformation):void;}interface MSPointerEvent extends MouseEvent{readonly currentPoint:any;readonly height:number;readonly hwTimestamp:number;readonly intermediatePoints:any;readonly isPrimary:boolean;readonly pointerId:number;readonly pointerType:any;readonly pressure:number;readonly rotation:number;readonly tiltX:number;readonly tiltY:number;readonly width:number;getCurrentPoint(element:Element):void;getIntermediatePoints(element:Element):void;initPointerEvent(typeArg:string,canBubbleArg:boolean,cancelableArg:boolean,viewArg:Window,detailArg:number,screenXArg:number,screenYArg:number,clientXArg:number,clientYArg:number,ctrlKeyArg:boolean,altKeyArg:boolean,shiftKeyArg:boolean,metaKeyArg:boolean,buttonArg:number,relatedTargetArg:EventTarget,offsetXArg:number,offsetYArg:number,widthArg:number,heightArg:number,pressure:number,rotation:number,tiltX:number,tiltY:number,pointerIdArg:number,pointerType:any,hwTimestampArg:number,isPrimary:boolean):void;}declare var MSPointerEvent:{prototype:MSPointerEvent;new(typeArg:string,eventInitDict?:PointerEventInit):MSPointerEvent;};interface MSStream{readonly type:string;msClose():void;msDetachStream():any;}declare var MSStream:{prototype:MSStream;new():MSStream;};interface MediaDeviceInfo{readonly deviceId:string;readonly groupId:string;readonly kind:MediaDeviceKind;readonly label:string;toJSON():any;}declare var MediaDeviceInfo:{prototype:MediaDeviceInfo;new():MediaDeviceInfo;};interface MediaDevicesEventMap{"devicechange":Event;}interface MediaDevices extends EventTarget{ondevicechange:((this:MediaDevices,ev:Event)=>any)|null;enumerateDevices():Promise<MediaDeviceInfo[]>;getSupportedConstraints():MediaTrackSupportedConstraints;getUserMedia(constraints?:MediaStreamConstraints):Promise<MediaStream>;addEventListener<K extends keyof MediaDevicesEventMap>(type:K,listener:(this:MediaDevices,ev:MediaDevicesEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof MediaDevicesEventMap>(type:K,listener:(this:MediaDevices,ev:MediaDevicesEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var MediaDevices:{prototype:MediaDevices;new():MediaDevices;};interface MediaElementAudioSourceNode extends AudioNode{readonly mediaElement:HTMLMediaElement;}declare var MediaElementAudioSourceNode:{prototype:MediaElementAudioSourceNode;new(context:AudioContext,options:MediaElementAudioSourceOptions):MediaElementAudioSourceNode;};interface MediaEncryptedEvent extends Event{readonly initData:ArrayBuffer|null;readonly initDataType:string;}declare var MediaEncryptedEvent:{prototype:MediaEncryptedEvent;new(type:string,eventInitDict?:MediaEncryptedEventInit):MediaEncryptedEvent;};interface MediaError{readonly code:number;readonly message:string;readonly MEDIA_ERR_ABORTED:number;readonly MEDIA_ERR_DECODE:number;readonly MEDIA_ERR_NETWORK:number;readonly MEDIA_ERR_SRC_NOT_SUPPORTED:number;}declare var MediaError:{prototype:MediaError;new():MediaError;readonly MEDIA_ERR_ABORTED:number;readonly MEDIA_ERR_DECODE:number;readonly MEDIA_ERR_NETWORK:number;readonly MEDIA_ERR_SRC_NOT_SUPPORTED:number;};interface MediaKeyMessageEvent extends Event{readonly message:ArrayBuffer;readonly messageType:MediaKeyMessageType;}declare var MediaKeyMessageEvent:{prototype:MediaKeyMessageEvent;new(type:string,eventInitDict:MediaKeyMessageEventInit):MediaKeyMessageEvent;};interface MediaKeySessionEventMap{"keystatuseschange":Event;"message":MediaKeyMessageEvent;}interface MediaKeySession extends EventTarget{readonly closed:Promise<void>;readonly expiration:number;readonly keyStatuses:MediaKeyStatusMap;onkeystatuseschange:((this:MediaKeySession,ev:Event)=>any)|null;onmessage:((this:MediaKeySession,ev:MediaKeyMessageEvent)=>any)|null;readonly sessionId:string;close():Promise<void>;generateRequest(initDataType:string,initData:BufferSource):Promise<void>;load(sessionId:string):Promise<boolean>;remove():Promise<void>;update(response:BufferSource):Promise<void>;addEventListener<K extends keyof MediaKeySessionEventMap>(type:K,listener:(this:MediaKeySession,ev:MediaKeySessionEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof MediaKeySessionEventMap>(type:K,listener:(this:MediaKeySession,ev:MediaKeySessionEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var MediaKeySession:{prototype:MediaKeySession;new():MediaKeySession;};interface MediaKeyStatusMap{readonly size:number;get(keyId:BufferSource):MediaKeyStatus|undefined;has(keyId:BufferSource):boolean;forEach(callbackfn:(value:MediaKeyStatus,key:BufferSource,parent:MediaKeyStatusMap)=>void,thisArg?:any):void;}declare var MediaKeyStatusMap:{prototype:MediaKeyStatusMap;new():MediaKeyStatusMap;};interface MediaKeySystemAccess{readonly keySystem:string;createMediaKeys():Promise<MediaKeys>;getConfiguration():MediaKeySystemConfiguration;}declare var MediaKeySystemAccess:{prototype:MediaKeySystemAccess;new():MediaKeySystemAccess;};interface MediaKeys{createSession(sessionType?:MediaKeySessionType):MediaKeySession;setServerCertificate(serverCertificate:BufferSource):Promise<boolean>;}declare var MediaKeys:{prototype:MediaKeys;new():MediaKeys;};interface MediaList{readonly length:number;mediaText:string;toString():string;appendMedium(medium:string):void;deleteMedium(medium:string):void;item(index:number):string|null;[index:number]:string;}declare var MediaList:{prototype:MediaList;new():MediaList;};interface MediaQueryListEventMap{"change":MediaQueryListEvent;}interface MediaQueryList extends EventTarget{readonly matches:boolean;readonly media:string;onchange:((this:MediaQueryList,ev:MediaQueryListEvent)=>any)|null;addListener(listener:((this:MediaQueryList,ev:MediaQueryListEvent)=>any)|null):void;removeListener(listener:((this:MediaQueryList,ev:MediaQueryListEvent)=>any)|null):void;addEventListener<K extends keyof MediaQueryListEventMap>(type:K,listener:(this:MediaQueryList,ev:MediaQueryListEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof MediaQueryListEventMap>(type:K,listener:(this:MediaQueryList,ev:MediaQueryListEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var MediaQueryList:{prototype:MediaQueryList;new():MediaQueryList;};interface MediaQueryListEvent extends Event{readonly matches:boolean;readonly media:string;}declare var MediaQueryListEvent:{prototype:MediaQueryListEvent;new(type:string,eventInitDict?:MediaQueryListEventInit):MediaQueryListEvent;};interface MediaSourceEventMap{"sourceclose":Event;"sourceended":Event;"sourceopen":Event;}interface MediaSource extends EventTarget{readonly activeSourceBuffers:SourceBufferList;duration:number;onsourceclose:((this:MediaSource,ev:Event)=>any)|null;onsourceended:((this:MediaSource,ev:Event)=>any)|null;onsourceopen:((this:MediaSource,ev:Event)=>any)|null;readonly readyState:ReadyState;readonly sourceBuffers:SourceBufferList;addSourceBuffer(type:string):SourceBuffer;clearLiveSeekableRange():void;endOfStream(error?:EndOfStreamError):void;removeSourceBuffer(sourceBuffer:SourceBuffer):void;setLiveSeekableRange(start:number,end:number):void;addEventListener<K extends keyof MediaSourceEventMap>(type:K,listener:(this:MediaSource,ev:MediaSourceEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof MediaSourceEventMap>(type:K,listener:(this:MediaSource,ev:MediaSourceEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var MediaSource:{prototype:MediaSource;new():MediaSource;isTypeSupported(type:string):boolean;};interface MediaStreamEventMap{"addtrack":MediaStreamTrackEvent;"removetrack":MediaStreamTrackEvent;}interface MediaStream extends EventTarget{readonly active:boolean;readonly id:string;onaddtrack:((this:MediaStream,ev:MediaStreamTrackEvent)=>any)|null;onremovetrack:((this:MediaStream,ev:MediaStreamTrackEvent)=>any)|null;addTrack(track:MediaStreamTrack):void;clone():MediaStream;getAudioTracks():MediaStreamTrack[];getTrackById(trackId:string):MediaStreamTrack|null;getTracks():MediaStreamTrack[];getVideoTracks():MediaStreamTrack[];removeTrack(track:MediaStreamTrack):void;addEventListener<K extends keyof MediaStreamEventMap>(type:K,listener:(this:MediaStream,ev:MediaStreamEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof MediaStreamEventMap>(type:K,listener:(this:MediaStream,ev:MediaStreamEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var MediaStream:{prototype:MediaStream;new():MediaStream;new(stream:MediaStream):MediaStream;new(tracks:MediaStreamTrack[]):MediaStream;};interface MediaStreamAudioDestinationNode extends AudioNode{readonly stream:MediaStream;}declare var MediaStreamAudioDestinationNode:{prototype:MediaStreamAudioDestinationNode;new(context:AudioContext,options?:AudioNodeOptions):MediaStreamAudioDestinationNode;};interface MediaStreamAudioSourceNode extends AudioNode{readonly mediaStream:MediaStream;}declare var MediaStreamAudioSourceNode:{prototype:MediaStreamAudioSourceNode;new(context:AudioContext,options:MediaStreamAudioSourceOptions):MediaStreamAudioSourceNode;};interface MediaStreamError{readonly constraintName:string|null;readonly message:string|null;readonly name:string;}declare var MediaStreamError:{prototype:MediaStreamError;new():MediaStreamError;};interface MediaStreamErrorEvent extends Event{readonly error:MediaStreamError|null;}declare var MediaStreamErrorEvent:{prototype:MediaStreamErrorEvent;new(typeArg:string,eventInitDict?:MediaStreamErrorEventInit):MediaStreamErrorEvent;};interface MediaStreamEvent extends Event{readonly stream:MediaStream|null;}declare var MediaStreamEvent:{prototype:MediaStreamEvent;new(type:string,eventInitDict:MediaStreamEventInit):MediaStreamEvent;};interface MediaStreamTrackEventMap{"ended":Event;"isolationchange":Event;"mute":Event;"unmute":Event;}interface MediaStreamTrack extends EventTarget{enabled:boolean;readonly id:string;readonly isolated:boolean;readonly kind:string;readonly label:string;readonly muted:boolean;onended:((this:MediaStreamTrack,ev:Event)=>any)|null;onisolationchange:((this:MediaStreamTrack,ev:Event)=>any)|null;onmute:((this:MediaStreamTrack,ev:Event)=>any)|null;onunmute:((this:MediaStreamTrack,ev:Event)=>any)|null;readonly readyState:MediaStreamTrackState;applyConstraints(constraints?:MediaTrackConstraints):Promise<void>;clone():MediaStreamTrack;getCapabilities():MediaTrackCapabilities;getConstraints():MediaTrackConstraints;getSettings():MediaTrackSettings;stop():void;addEventListener<K extends keyof MediaStreamTrackEventMap>(type:K,listener:(this:MediaStreamTrack,ev:MediaStreamTrackEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof MediaStreamTrackEventMap>(type:K,listener:(this:MediaStreamTrack,ev:MediaStreamTrackEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var MediaStreamTrack:{prototype:MediaStreamTrack;new():MediaStreamTrack;};interface MediaStreamTrackAudioSourceNode extends AudioNode{}declare var MediaStreamTrackAudioSourceNode:{prototype:MediaStreamTrackAudioSourceNode;new(context:AudioContext,options:MediaStreamTrackAudioSourceOptions):MediaStreamTrackAudioSourceNode;};interface MediaStreamTrackEvent extends Event{readonly track:MediaStreamTrack;}declare var MediaStreamTrackEvent:{prototype:MediaStreamTrackEvent;new(type:string,eventInitDict:MediaStreamTrackEventInit):MediaStreamTrackEvent;};interface MessageChannel{readonly port1:MessagePort;readonly port2:MessagePort;}declare var MessageChannel:{prototype:MessageChannel;new():MessageChannel;};interface MessageEvent extends Event{readonly data:any;readonly lastEventId:string;readonly origin:string;readonly ports:ReadonlyArray<MessagePort>;readonly source:MessageEventSource|null;}declare var MessageEvent:{prototype:MessageEvent;new(type:string,eventInitDict?:MessageEventInit):MessageEvent;};interface MessagePortEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface MessagePort extends EventTarget{onmessage:((this:MessagePort,ev:MessageEvent)=>any)|null;onmessageerror:((this:MessagePort,ev:MessageEvent)=>any)|null;close():void;postMessage(message:any,transfer:Transferable[]):void;postMessage(message:any,options?:PostMessageOptions):void;start():void;addEventListener<K extends keyof MessagePortEventMap>(type:K,listener:(this:MessagePort,ev:MessagePortEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof MessagePortEventMap>(type:K,listener:(this:MessagePort,ev:MessagePortEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var MessagePort:{prototype:MessagePort;new():MessagePort;};interface MimeType{readonly description:string;readonly enabledPlugin:Plugin;readonly suffixes:string;readonly type:string;}declare var MimeType:{prototype:MimeType;new():MimeType;};interface MimeTypeArray{readonly length:number;item(index:number):MimeType|null;namedItem(name:string):MimeType|null;[index:number]:MimeType;}declare var MimeTypeArray:{prototype:MimeTypeArray;new():MimeTypeArray;};interface MouseEvent extends UIEvent{readonly altKey:boolean;readonly button:number;readonly buttons:number;readonly clientX:number;readonly clientY:number;readonly ctrlKey:boolean;readonly metaKey:boolean;readonly movementX:number;readonly movementY:number;readonly offsetX:number;readonly offsetY:number;readonly pageX:number;readonly pageY:number;readonly relatedTarget:EventTarget|null;readonly screenX:number;readonly screenY:number;readonly shiftKey:boolean;readonly x:number;readonly y:number;getModifierState(keyArg:string):boolean;initMouseEvent(typeArg:string,canBubbleArg:boolean,cancelableArg:boolean,viewArg:Window,detailArg:number,screenXArg:number,screenYArg:number,clientXArg:number,clientYArg:number,ctrlKeyArg:boolean,altKeyArg:boolean,shiftKeyArg:boolean,metaKeyArg:boolean,buttonArg:number,relatedTargetArg:EventTarget|null):void;}declare var MouseEvent:{prototype:MouseEvent;new(type:string,eventInitDict?:MouseEventInit):MouseEvent;};interface MutationEvent extends Event{readonly attrChange:number;readonly attrName:string;readonly newValue:string;readonly prevValue:string;readonly relatedNode:Node;initMutationEvent(typeArg:string,canBubbleArg:boolean,cancelableArg:boolean,relatedNodeArg:Node,prevValueArg:string,newValueArg:string,attrNameArg:string,attrChangeArg:number):void;readonly ADDITION:number;readonly MODIFICATION:number;readonly REMOVAL:number;}declare var MutationEvent:{prototype:MutationEvent;new():MutationEvent;readonly ADDITION:number;readonly MODIFICATION:number;readonly REMOVAL:number;};interface MutationObserver{disconnect():void;observe(target:Node,options?:MutationObserverInit):void;takeRecords():MutationRecord[];}declare var MutationObserver:{prototype:MutationObserver;new(callback:MutationCallback):MutationObserver;};interface MutationRecord{readonly addedNodes:NodeList;readonly attributeName:string|null;readonly attributeNamespace:string|null;readonly nextSibling:Node|null;readonly oldValue:string|null;readonly previousSibling:Node|null;readonly removedNodes:NodeList;readonly target:Node;readonly type:MutationRecordType;}declare var MutationRecord:{prototype:MutationRecord;new():MutationRecord;};interface NamedNodeMap{readonly length:number;getNamedItem(qualifiedName:string):Attr|null;getNamedItemNS(namespace:string|null,localName:string):Attr|null;item(index:number):Attr|null;removeNamedItem(qualifiedName:string):Attr;removeNamedItemNS(namespace:string|null,localName:string):Attr;setNamedItem(attr:Attr):Attr|null;setNamedItemNS(attr:Attr):Attr|null;[index:number]:Attr;}declare var NamedNodeMap:{prototype:NamedNodeMap;new():NamedNodeMap;};interface NavigationPreloadManager{disable():Promise<void>;enable():Promise<void>;getState():Promise<NavigationPreloadState>;setHeaderValue(value:string):Promise<void>;}declare var NavigationPreloadManager:{prototype:NavigationPreloadManager;new():NavigationPreloadManager;};interface Navigator extends MSFileSaver,MSNavigatorDoNotTrack,NavigatorAutomationInformation,NavigatorBeacon,NavigatorConcurrentHardware,NavigatorContentUtils,NavigatorCookies,NavigatorID,NavigatorLanguage,NavigatorOnLine,NavigatorPlugins,NavigatorStorage{readonly activeVRDisplays:ReadonlyArray<VRDisplay>;readonly clipboard:Clipboard;readonly credentials:CredentialsContainer;readonly doNotTrack:string|null;readonly geolocation:Geolocation;readonly maxTouchPoints:number;readonly mediaDevices:MediaDevices;readonly msManipulationViewsEnabled:boolean;readonly msMaxTouchPoints:number;readonly msPointerEnabled:boolean;readonly permissions:Permissions;readonly pointerEnabled:boolean;readonly serviceWorker:ServiceWorkerContainer;getGamepads():(Gamepad|null)[];getUserMedia(constraints:MediaStreamConstraints,successCallback:NavigatorUserMediaSuccessCallback,errorCallback:NavigatorUserMediaErrorCallback):void;getVRDisplays():Promise<VRDisplay[]>;msLaunchUri(uri:string,successCallback?:MSLaunchUriCallback,noHandlerCallback?:MSLaunchUriCallback):void;requestMediaKeySystemAccess(keySystem:string,supportedConfigurations:MediaKeySystemConfiguration[]):Promise<MediaKeySystemAccess>;sendBeacon(url:string,data?:BodyInit|null):boolean;share(data?:ShareData):Promise<void>;vibrate(pattern:number|number[]):boolean;}declare var Navigator:{prototype:Navigator;new():Navigator;};interface NavigatorAutomationInformation{readonly webdriver:boolean;}interface NavigatorBeacon{sendBeacon(url:string,data?:Blob|Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer|FormData|string|null):boolean;}interface NavigatorConcurrentHardware{readonly hardwareConcurrency:number;}interface NavigatorContentUtils{registerProtocolHandler(scheme:string,url:string,title:string):void;unregisterProtocolHandler(scheme:string,url:string):void;}interface NavigatorCookies{readonly cookieEnabled:boolean;}interface NavigatorID{readonly appCodeName:string;readonly appName:string;readonly appVersion:string;readonly platform:string;readonly product:string;readonly productSub:string;readonly userAgent:string;readonly vendor:string;readonly vendorSub:string;}interface NavigatorLanguage{readonly language:string;readonly languages:ReadonlyArray<string>;}interface NavigatorOnLine{readonly onLine:boolean;}interface NavigatorPlugins{readonly mimeTypes:MimeTypeArray;readonly plugins:PluginArray;javaEnabled():boolean;}interface NavigatorStorage{readonly storage:StorageManager;}interface Node extends EventTarget{readonly baseURI:string;readonly childNodes:NodeListOf<ChildNode>;readonly firstChild:ChildNode|null;readonly isConnected:boolean;readonly lastChild:ChildNode|null;readonly namespaceURI:string|null;readonly nextSibling:ChildNode|null;readonly nodeName:string;readonly nodeType:number;nodeValue:string|null;readonly ownerDocument:Document|null;readonly parentElement:HTMLElement|null;readonly parentNode:Node&ParentNode|null;readonly previousSibling:ChildNode|null;textContent:string|null;appendChild<T extends Node>(newChild:T):T;cloneNode(deep?:boolean):Node;compareDocumentPosition(other:Node):number;contains(other:Node|null):boolean;getRootNode(options?:GetRootNodeOptions):Node;hasChildNodes():boolean;insertBefore<T extends Node>(newChild:T,refChild:Node|null):T;isDefaultNamespace(namespace:string|null):boolean;isEqualNode(otherNode:Node|null):boolean;isSameNode(otherNode:Node|null):boolean;lookupNamespaceURI(prefix:string|null):string|null;lookupPrefix(namespace:string|null):string|null;normalize():void;removeChild<T extends Node>(oldChild:T):T;replaceChild<T extends Node>(newChild:Node,oldChild:T):T;readonly ATTRIBUTE_NODE:number;readonly CDATA_SECTION_NODE:number;readonly COMMENT_NODE:number;readonly DOCUMENT_FRAGMENT_NODE:number;readonly DOCUMENT_NODE:number;readonly DOCUMENT_POSITION_CONTAINED_BY:number;readonly DOCUMENT_POSITION_CONTAINS:number;readonly DOCUMENT_POSITION_DISCONNECTED:number;readonly DOCUMENT_POSITION_FOLLOWING:number;readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC:number;readonly DOCUMENT_POSITION_PRECEDING:number;readonly DOCUMENT_TYPE_NODE:number;readonly ELEMENT_NODE:number;readonly ENTITY_NODE:number;readonly ENTITY_REFERENCE_NODE:number;readonly NOTATION_NODE:number;readonly PROCESSING_INSTRUCTION_NODE:number;readonly TEXT_NODE:number;}declare var Node:{prototype:Node;new():Node;readonly ATTRIBUTE_NODE:number;readonly CDATA_SECTION_NODE:number;readonly COMMENT_NODE:number;readonly DOCUMENT_FRAGMENT_NODE:number;readonly DOCUMENT_NODE:number;readonly DOCUMENT_POSITION_CONTAINED_BY:number;readonly DOCUMENT_POSITION_CONTAINS:number;readonly DOCUMENT_POSITION_DISCONNECTED:number;readonly DOCUMENT_POSITION_FOLLOWING:number;readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC:number;readonly DOCUMENT_POSITION_PRECEDING:number;readonly DOCUMENT_TYPE_NODE:number;readonly ELEMENT_NODE:number;readonly ENTITY_NODE:number;readonly ENTITY_REFERENCE_NODE:number;readonly NOTATION_NODE:number;readonly PROCESSING_INSTRUCTION_NODE:number;readonly TEXT_NODE:number;};interface NodeFilter{acceptNode(node:Node):number;}declare var NodeFilter:{readonly FILTER_ACCEPT:number;readonly FILTER_REJECT:number;readonly FILTER_SKIP:number;readonly SHOW_ALL:number;readonly SHOW_ATTRIBUTE:number;readonly SHOW_CDATA_SECTION:number;readonly SHOW_COMMENT:number;readonly SHOW_DOCUMENT:number;readonly SHOW_DOCUMENT_FRAGMENT:number;readonly SHOW_DOCUMENT_TYPE:number;readonly SHOW_ELEMENT:number;readonly SHOW_ENTITY:number;readonly SHOW_ENTITY_REFERENCE:number;readonly SHOW_NOTATION:number;readonly SHOW_PROCESSING_INSTRUCTION:number;readonly SHOW_TEXT:number;};interface NodeIterator{readonly filter:NodeFilter|null;readonly pointerBeforeReferenceNode:boolean;readonly referenceNode:Node;readonly root:Node;readonly whatToShow:number;detach():void;nextNode():Node|null;previousNode():Node|null;}declare var NodeIterator:{prototype:NodeIterator;new():NodeIterator;};interface NodeList{readonly length:number;item(index:number):Node|null;forEach(callbackfn:(value:Node,key:number,parent:NodeList)=>void,thisArg?:any):void;[index:number]:Node;}declare var NodeList:{prototype:NodeList;new():NodeList;};interface NodeListOf<TNode extends Node>extends NodeList{length:number;item(index:number):TNode;forEach(callbackfn:(value:TNode,key:number,parent:NodeListOf<TNode>)=>void,thisArg?:any):void;[index:number]:TNode;}interface NonDocumentTypeChildNode{readonly nextElementSibling:Element|null;readonly previousElementSibling:Element|null;}interface NonElementParentNode{getElementById(elementId:string):Element|null;}interface NotificationEventMap{"click":Event;"close":Event;"error":Event;"show":Event;}interface Notification extends EventTarget{readonly actions:ReadonlyArray<NotificationAction>;readonly badge:string;readonly body:string;readonly data:any;readonly dir:NotificationDirection;readonly icon:string;readonly image:string;readonly lang:string;onclick:((this:Notification,ev:Event)=>any)|null;onclose:((this:Notification,ev:Event)=>any)|null;onerror:((this:Notification,ev:Event)=>any)|null;onshow:((this:Notification,ev:Event)=>any)|null;readonly renotify:boolean;readonly requireInteraction:boolean;readonly silent:boolean;readonly tag:string;readonly timestamp:number;readonly title:string;readonly vibrate:ReadonlyArray<number>;close():void;addEventListener<K extends keyof NotificationEventMap>(type:K,listener:(this:Notification,ev:NotificationEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof NotificationEventMap>(type:K,listener:(this:Notification,ev:NotificationEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var Notification:{prototype:Notification;new(title:string,options?:NotificationOptions):Notification;readonly maxActions:number;readonly permission:NotificationPermission;requestPermission(deprecatedCallback?:NotificationPermissionCallback):Promise<NotificationPermission>;};interface OES_element_index_uint{}interface OES_standard_derivatives{readonly FRAGMENT_SHADER_DERIVATIVE_HINT_OES:GLenum;}interface OES_texture_float{}interface OES_texture_float_linear{}interface OES_texture_half_float{readonly HALF_FLOAT_OES:GLenum;}interface OES_texture_half_float_linear{}interface OES_vertex_array_object{bindVertexArrayOES(arrayObject:WebGLVertexArrayObjectOES|null):void;createVertexArrayOES():WebGLVertexArrayObjectOES|null;deleteVertexArrayOES(arrayObject:WebGLVertexArrayObjectOES|null):void;isVertexArrayOES(arrayObject:WebGLVertexArrayObjectOES|null):GLboolean;readonly VERTEX_ARRAY_BINDING_OES:GLenum;}interface OfflineAudioCompletionEvent extends Event{readonly renderedBuffer:AudioBuffer;}declare var OfflineAudioCompletionEvent:{prototype:OfflineAudioCompletionEvent;new(type:string,eventInitDict:OfflineAudioCompletionEventInit):OfflineAudioCompletionEvent;};interface OfflineAudioContextEventMap extends BaseAudioContextEventMap{"complete":OfflineAudioCompletionEvent;}interface OfflineAudioContext extends BaseAudioContext{readonly length:number;oncomplete:((this:OfflineAudioContext,ev:OfflineAudioCompletionEvent)=>any)|null;resume():Promise<void>;startRendering():Promise<AudioBuffer>;suspend(suspendTime:number):Promise<void>;addEventListener<K extends keyof OfflineAudioContextEventMap>(type:K,listener:(this:OfflineAudioContext,ev:OfflineAudioContextEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof OfflineAudioContextEventMap>(type:K,listener:(this:OfflineAudioContext,ev:OfflineAudioContextEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var OfflineAudioContext:{prototype:OfflineAudioContext;new(contextOptions:OfflineAudioContextOptions):OfflineAudioContext;new(numberOfChannels:number,length:number,sampleRate:number):OfflineAudioContext;};interface OffscreenCanvas extends EventTarget{height:number;width:number;convertToBlob(options?:ImageEncodeOptions):Promise<Blob>;getContext(contextId:"2d",options?:CanvasRenderingContext2DSettings):OffscreenCanvasRenderingContext2D|null;getContext(contextId:"bitmaprenderer",options?:ImageBitmapRenderingContextSettings):ImageBitmapRenderingContext|null;getContext(contextId:"webgl",options?:WebGLContextAttributes):WebGLRenderingContext|null;getContext(contextId:"webgl2",options?:WebGLContextAttributes):WebGL2RenderingContext|null;getContext(contextId:OffscreenRenderingContextId,options?:any):OffscreenRenderingContext|null;transferToImageBitmap():ImageBitmap;}declare var OffscreenCanvas:{prototype:OffscreenCanvas;new(width:number,height:number):OffscreenCanvas;};interface OffscreenCanvasRenderingContext2D extends CanvasCompositing,CanvasDrawImage,CanvasDrawPath,CanvasFillStrokeStyles,CanvasFilters,CanvasImageData,CanvasImageSmoothing,CanvasPath,CanvasPathDrawingStyles,CanvasRect,CanvasShadowStyles,CanvasState,CanvasText,CanvasTextDrawingStyles,CanvasTransform{readonly canvas:OffscreenCanvas;commit():void;}declare var OffscreenCanvasRenderingContext2D:{prototype:OffscreenCanvasRenderingContext2D;new():OffscreenCanvasRenderingContext2D;};interface OscillatorNode extends AudioScheduledSourceNode{readonly detune:AudioParam;readonly frequency:AudioParam;type:OscillatorType;setPeriodicWave(periodicWave:PeriodicWave):void;addEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type:K,listener:(this:OscillatorNode,ev:AudioScheduledSourceNodeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AudioScheduledSourceNodeEventMap>(type:K,listener:(this:OscillatorNode,ev:AudioScheduledSourceNodeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var OscillatorNode:{prototype:OscillatorNode;new(context:BaseAudioContext,options?:OscillatorOptions):OscillatorNode;};interface OverconstrainedError extends Error{constraint:string;}declare var OverconstrainedError:{prototype:OverconstrainedError;new():OverconstrainedError;};interface OverflowEvent extends UIEvent{readonly horizontalOverflow:boolean;readonly orient:number;readonly verticalOverflow:boolean;readonly BOTH:number;readonly HORIZONTAL:number;readonly VERTICAL:number;}declare var OverflowEvent:{prototype:OverflowEvent;new():OverflowEvent;readonly BOTH:number;readonly HORIZONTAL:number;readonly VERTICAL:number;};interface PageTransitionEvent extends Event{readonly persisted:boolean;}declare var PageTransitionEvent:{prototype:PageTransitionEvent;new(type:string,eventInitDict?:PageTransitionEventInit):PageTransitionEvent;};interface PannerNode extends AudioNode{coneInnerAngle:number;coneOuterAngle:number;coneOuterGain:number;distanceModel:DistanceModelType;maxDistance:number;readonly orientationX:AudioParam;readonly orientationY:AudioParam;readonly orientationZ:AudioParam;panningModel:PanningModelType;readonly positionX:AudioParam;readonly positionY:AudioParam;readonly positionZ:AudioParam;refDistance:number;rolloffFactor:number;setOrientation(x:number,y:number,z:number):void;setPosition(x:number,y:number,z:number):void;}declare var PannerNode:{prototype:PannerNode;new(context:BaseAudioContext,options?:PannerOptions):PannerNode;};interface ParentNode{readonly childElementCount:number;readonly children:HTMLCollection;readonly firstElementChild:Element|null;readonly lastElementChild:Element|null;append(...nodes:(Node|string)[]):void;prepend(...nodes:(Node|string)[]):void;querySelector<K extends keyof HTMLElementTagNameMap>(selectors:K):HTMLElementTagNameMap[K]|null;querySelector<K extends keyof SVGElementTagNameMap>(selectors:K):SVGElementTagNameMap[K]|null;querySelector<E extends Element=Element>(selectors:string):E|null;querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors:K):NodeListOf<HTMLElementTagNameMap[K]>;querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors:K):NodeListOf<SVGElementTagNameMap[K]>;querySelectorAll<E extends Element=Element>(selectors:string):NodeListOf<E>;}interface Path2D extends CanvasPath{addPath(path:Path2D,transform?:DOMMatrix2DInit):void;}declare var Path2D:{prototype:Path2D;new(path?:Path2D|string):Path2D;};interface PaymentAddress{readonly addressLine:string[];readonly city:string;readonly country:string;readonly dependentLocality:string;readonly languageCode:string;readonly organization:string;readonly phone:string;readonly postalCode:string;readonly recipient:string;readonly region:string;readonly sortingCode:string;toJSON():any;}declare var PaymentAddress:{prototype:PaymentAddress;new():PaymentAddress;};interface PaymentRequestEventMap{"shippingaddresschange":Event;"shippingoptionchange":Event;}interface PaymentRequest extends EventTarget{readonly id:string;onshippingaddresschange:((this:PaymentRequest,ev:Event)=>any)|null;onshippingoptionchange:((this:PaymentRequest,ev:Event)=>any)|null;readonly shippingAddress:PaymentAddress|null;readonly shippingOption:string|null;readonly shippingType:PaymentShippingType|null;abort():Promise<void>;canMakePayment():Promise<boolean>;show():Promise<PaymentResponse>;addEventListener<K extends keyof PaymentRequestEventMap>(type:K,listener:(this:PaymentRequest,ev:PaymentRequestEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof PaymentRequestEventMap>(type:K,listener:(this:PaymentRequest,ev:PaymentRequestEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var PaymentRequest:{prototype:PaymentRequest;new(methodData:PaymentMethodData[],details:PaymentDetailsInit,options?:PaymentOptions):PaymentRequest;};interface PaymentRequestUpdateEvent extends Event{updateWith(detailsPromise:PaymentDetailsUpdate|Promise<PaymentDetailsUpdate>):void;}declare var PaymentRequestUpdateEvent:{prototype:PaymentRequestUpdateEvent;new(type:string,eventInitDict?:PaymentRequestUpdateEventInit):PaymentRequestUpdateEvent;};interface PaymentResponse{readonly details:any;readonly methodName:string;readonly payerEmail:string|null;readonly payerName:string|null;readonly payerPhone:string|null;readonly requestId:string;readonly shippingAddress:PaymentAddress|null;readonly shippingOption:string|null;complete(result?:PaymentComplete):Promise<void>;toJSON():any;}declare var PaymentResponse:{prototype:PaymentResponse;new():PaymentResponse;};interface PerfWidgetExternal{readonly activeNetworkRequestCount:number;readonly averageFrameTime:number;readonly averagePaintTime:number;readonly extraInformationEnabled:boolean;readonly independentRenderingEnabled:boolean;readonly irDisablingContentString:string;readonly irStatusAvailable:boolean;readonly maxCpuSpeed:number;readonly paintRequestsPerSecond:number;readonly performanceCounter:number;readonly performanceCounterFrequency:number;addEventListener(eventType:string,callback:Function):void;getMemoryUsage():number;getProcessCpuUsage():number;getRecentCpuUsage(last:number|null):any;getRecentFrames(last:number|null):any;getRecentMemoryUsage(last:number|null):any;getRecentPaintRequests(last:number|null):any;removeEventListener(eventType:string,callback:Function):void;repositionWindow(x:number,y:number):void;resizeWindow(width:number,height:number):void;}declare var PerfWidgetExternal:{prototype:PerfWidgetExternal;new():PerfWidgetExternal;};interface PerformanceEventMap{"resourcetimingbufferfull":Event;}interface Performance extends EventTarget{readonly navigation:PerformanceNavigation;onresourcetimingbufferfull:((this:Performance,ev:Event)=>any)|null;readonly timeOrigin:number;readonly timing:PerformanceTiming;clearMarks(markName?:string):void;clearMeasures(measureName?:string):void;clearResourceTimings():void;getEntries():PerformanceEntryList;getEntriesByName(name:string,type?:string):PerformanceEntryList;getEntriesByType(type:string):PerformanceEntryList;mark(markName:string):void;measure(measureName:string,startMark?:string,endMark?:string):void;now():number;setResourceTimingBufferSize(maxSize:number):void;toJSON():any;addEventListener<K extends keyof PerformanceEventMap>(type:K,listener:(this:Performance,ev:PerformanceEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof PerformanceEventMap>(type:K,listener:(this:Performance,ev:PerformanceEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var Performance:{prototype:Performance;new():Performance;};interface PerformanceEntry{readonly duration:number;readonly entryType:string;readonly name:string;readonly startTime:number;toJSON():any;}declare var PerformanceEntry:{prototype:PerformanceEntry;new():PerformanceEntry;};interface PerformanceMark extends PerformanceEntry{}declare var PerformanceMark:{prototype:PerformanceMark;new():PerformanceMark;};interface PerformanceMeasure extends PerformanceEntry{}declare var PerformanceMeasure:{prototype:PerformanceMeasure;new():PerformanceMeasure;};interface PerformanceNavigation{readonly redirectCount:number;readonly type:number;toJSON():any;readonly TYPE_BACK_FORWARD:number;readonly TYPE_NAVIGATE:number;readonly TYPE_RELOAD:number;readonly TYPE_RESERVED:number;}declare var PerformanceNavigation:{prototype:PerformanceNavigation;new():PerformanceNavigation;readonly TYPE_BACK_FORWARD:number;readonly TYPE_NAVIGATE:number;readonly TYPE_RELOAD:number;readonly TYPE_RESERVED:number;};interface PerformanceNavigationTiming extends PerformanceResourceTiming{readonly domComplete:number;readonly domContentLoadedEventEnd:number;readonly domContentLoadedEventStart:number;readonly domInteractive:number;readonly loadEventEnd:number;readonly loadEventStart:number;readonly redirectCount:number;readonly type:NavigationType;readonly unloadEventEnd:number;readonly unloadEventStart:number;toJSON():any;}declare var PerformanceNavigationTiming:{prototype:PerformanceNavigationTiming;new():PerformanceNavigationTiming;};interface PerformanceObserver{disconnect():void;observe(options?:PerformanceObserverInit):void;takeRecords():PerformanceEntryList;}declare var PerformanceObserver:{prototype:PerformanceObserver;new(callback:PerformanceObserverCallback):PerformanceObserver;readonly supportedEntryTypes:ReadonlyArray<string>;};interface PerformanceObserverEntryList{getEntries():PerformanceEntryList;getEntriesByName(name:string,type?:string):PerformanceEntryList;getEntriesByType(type:string):PerformanceEntryList;}declare var PerformanceObserverEntryList:{prototype:PerformanceObserverEntryList;new():PerformanceObserverEntryList;};interface PerformanceResourceTiming extends PerformanceEntry{readonly connectEnd:number;readonly connectStart:number;readonly decodedBodySize:number;readonly domainLookupEnd:number;readonly domainLookupStart:number;readonly encodedBodySize:number;readonly fetchStart:number;readonly initiatorType:string;readonly nextHopProtocol:string;readonly redirectEnd:number;readonly redirectStart:number;readonly requestStart:number;readonly responseEnd:number;readonly responseStart:number;readonly secureConnectionStart:number;readonly transferSize:number;readonly workerStart:number;toJSON():any;}declare var PerformanceResourceTiming:{prototype:PerformanceResourceTiming;new():PerformanceResourceTiming;};interface PerformanceTiming{readonly connectEnd:number;readonly connectStart:number;readonly domComplete:number;readonly domContentLoadedEventEnd:number;readonly domContentLoadedEventStart:number;readonly domInteractive:number;readonly domLoading:number;readonly domainLookupEnd:number;readonly domainLookupStart:number;readonly fetchStart:number;readonly loadEventEnd:number;readonly loadEventStart:number;readonly navigationStart:number;readonly redirectEnd:number;readonly redirectStart:number;readonly requestStart:number;readonly responseEnd:number;readonly responseStart:number;readonly secureConnectionStart:number;readonly unloadEventEnd:number;readonly unloadEventStart:number;toJSON():any;}declare var PerformanceTiming:{prototype:PerformanceTiming;new():PerformanceTiming;};interface PeriodicWave{}declare var PeriodicWave:{prototype:PeriodicWave;new(context:BaseAudioContext,options?:PeriodicWaveOptions):PeriodicWave;};interface PermissionRequest extends DeferredPermissionRequest{readonly state:MSWebViewPermissionState;defer():void;}declare var PermissionRequest:{prototype:PermissionRequest;new():PermissionRequest;};interface PermissionRequestedEvent extends Event{readonly permissionRequest:PermissionRequest;}declare var PermissionRequestedEvent:{prototype:PermissionRequestedEvent;new():PermissionRequestedEvent;};interface PermissionStatusEventMap{"change":Event;}interface PermissionStatus extends EventTarget{onchange:((this:PermissionStatus,ev:Event)=>any)|null;readonly state:PermissionState;addEventListener<K extends keyof PermissionStatusEventMap>(type:K,listener:(this:PermissionStatus,ev:PermissionStatusEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof PermissionStatusEventMap>(type:K,listener:(this:PermissionStatus,ev:PermissionStatusEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var PermissionStatus:{prototype:PermissionStatus;new():PermissionStatus;};interface Permissions{query(permissionDesc:PermissionDescriptor|DevicePermissionDescriptor|MidiPermissionDescriptor|PushPermissionDescriptor):Promise<PermissionStatus>;}declare var Permissions:{prototype:Permissions;new():Permissions;};interface Plugin{readonly description:string;readonly filename:string;readonly length:number;readonly name:string;item(index:number):MimeType|null;namedItem(name:string):MimeType|null;[index:number]:MimeType;}declare var Plugin:{prototype:Plugin;new():Plugin;};interface PluginArray{readonly length:number;item(index:number):Plugin|null;namedItem(name:string):Plugin|null;refresh(reload?:boolean):void;[index:number]:Plugin;}declare var PluginArray:{prototype:PluginArray;new():PluginArray;};interface PointerEvent extends MouseEvent{readonly height:number;readonly isPrimary:boolean;readonly pointerId:number;readonly pointerType:string;readonly pressure:number;readonly tangentialPressure:number;readonly tiltX:number;readonly tiltY:number;readonly twist:number;readonly width:number;}declare var PointerEvent:{prototype:PointerEvent;new(type:string,eventInitDict?:PointerEventInit):PointerEvent;};interface PopStateEvent extends Event{readonly state:any;}declare var PopStateEvent:{prototype:PopStateEvent;new(type:string,eventInitDict?:PopStateEventInit):PopStateEvent;};interface Position{readonly coords:Coordinates;readonly timestamp:number;}interface PositionError{readonly code:number;readonly message:string;readonly PERMISSION_DENIED:number;readonly POSITION_UNAVAILABLE:number;readonly TIMEOUT:number;}interface ProcessingInstruction extends CharacterData,LinkStyle{readonly ownerDocument:Document;readonly target:string;}declare var ProcessingInstruction:{prototype:ProcessingInstruction;new():ProcessingInstruction;};interface ProgressEvent<T extends EventTarget=EventTarget>extends Event{readonly lengthComputable:boolean;readonly loaded:number;readonly target:T|null;readonly total:number;}declare var ProgressEvent:{prototype:ProgressEvent;new(type:string,eventInitDict?:ProgressEventInit):ProgressEvent;};interface PromiseRejectionEvent extends Event{readonly promise:Promise<any>;readonly reason:any;}declare var PromiseRejectionEvent:{prototype:PromiseRejectionEvent;new(type:string,eventInitDict:PromiseRejectionEventInit):PromiseRejectionEvent;};interface PublicKeyCredential extends Credential{readonly rawId:ArrayBuffer;readonly response:AuthenticatorResponse;getClientExtensionResults():AuthenticationExtensionsClientOutputs;}declare var PublicKeyCredential:{prototype:PublicKeyCredential;new():PublicKeyCredential;isUserVerifyingPlatformAuthenticatorAvailable():Promise<boolean>;};interface PushManager{getSubscription():Promise<PushSubscription|null>;permissionState(options?:PushSubscriptionOptionsInit):Promise<PushPermissionState>;subscribe(options?:PushSubscriptionOptionsInit):Promise<PushSubscription>;}declare var PushManager:{prototype:PushManager;new():PushManager;readonly supportedContentEncodings:ReadonlyArray<string>;};interface PushSubscription{readonly endpoint:string;readonly expirationTime:number|null;readonly options:PushSubscriptionOptions;getKey(name:PushEncryptionKeyName):ArrayBuffer|null;toJSON():PushSubscriptionJSON;unsubscribe():Promise<boolean>;}declare var PushSubscription:{prototype:PushSubscription;new():PushSubscription;};interface PushSubscriptionOptions{readonly applicationServerKey:ArrayBuffer|null;readonly userVisibleOnly:boolean;}declare var PushSubscriptionOptions:{prototype:PushSubscriptionOptions;new():PushSubscriptionOptions;};interface RTCCertificate{readonly expires:number;getFingerprints():RTCDtlsFingerprint[];}declare var RTCCertificate:{prototype:RTCCertificate;new():RTCCertificate;getSupportedAlgorithms():AlgorithmIdentifier[];};interface RTCDTMFSenderEventMap{"tonechange":RTCDTMFToneChangeEvent;}interface RTCDTMFSender extends EventTarget{readonly canInsertDTMF:boolean;ontonechange:((this:RTCDTMFSender,ev:RTCDTMFToneChangeEvent)=>any)|null;readonly toneBuffer:string;insertDTMF(tones:string,duration?:number,interToneGap?:number):void;addEventListener<K extends keyof RTCDTMFSenderEventMap>(type:K,listener:(this:RTCDTMFSender,ev:RTCDTMFSenderEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof RTCDTMFSenderEventMap>(type:K,listener:(this:RTCDTMFSender,ev:RTCDTMFSenderEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var RTCDTMFSender:{prototype:RTCDTMFSender;new():RTCDTMFSender;};interface RTCDTMFToneChangeEvent extends Event{readonly tone:string;}declare var RTCDTMFToneChangeEvent:{prototype:RTCDTMFToneChangeEvent;new(type:string,eventInitDict:RTCDTMFToneChangeEventInit):RTCDTMFToneChangeEvent;};interface RTCDataChannelEventMap{"bufferedamountlow":Event;"close":Event;"error":RTCErrorEvent;"message":MessageEvent;"open":Event;}interface RTCDataChannel extends EventTarget{binaryType:string;readonly bufferedAmount:number;bufferedAmountLowThreshold:number;readonly id:number|null;readonly label:string;readonly maxPacketLifeTime:number|null;readonly maxRetransmits:number|null;readonly negotiated:boolean;onbufferedamountlow:((this:RTCDataChannel,ev:Event)=>any)|null;onclose:((this:RTCDataChannel,ev:Event)=>any)|null;onerror:((this:RTCDataChannel,ev:RTCErrorEvent)=>any)|null;onmessage:((this:RTCDataChannel,ev:MessageEvent)=>any)|null;onopen:((this:RTCDataChannel,ev:Event)=>any)|null;readonly ordered:boolean;readonly priority:RTCPriorityType;readonly protocol:string;readonly readyState:RTCDataChannelState;close():void;send(data:string):void;send(data:Blob):void;send(data:ArrayBuffer):void;send(data:ArrayBufferView):void;addEventListener<K extends keyof RTCDataChannelEventMap>(type:K,listener:(this:RTCDataChannel,ev:RTCDataChannelEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof RTCDataChannelEventMap>(type:K,listener:(this:RTCDataChannel,ev:RTCDataChannelEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var RTCDataChannel:{prototype:RTCDataChannel;new():RTCDataChannel;};interface RTCDataChannelEvent extends Event{readonly channel:RTCDataChannel;}declare var RTCDataChannelEvent:{prototype:RTCDataChannelEvent;new(type:string,eventInitDict:RTCDataChannelEventInit):RTCDataChannelEvent;};interface RTCDtlsTransportEventMap{"error":RTCErrorEvent;"statechange":Event;}interface RTCDtlsTransport extends EventTarget{readonly iceTransport:RTCIceTransport;onerror:((this:RTCDtlsTransport,ev:RTCErrorEvent)=>any)|null;onstatechange:((this:RTCDtlsTransport,ev:Event)=>any)|null;readonly state:RTCDtlsTransportState;getRemoteCertificates():ArrayBuffer[];addEventListener<K extends keyof RTCDtlsTransportEventMap>(type:K,listener:(this:RTCDtlsTransport,ev:RTCDtlsTransportEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof RTCDtlsTransportEventMap>(type:K,listener:(this:RTCDtlsTransport,ev:RTCDtlsTransportEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var RTCDtlsTransport:{prototype:RTCDtlsTransport;new():RTCDtlsTransport;};interface RTCDtlsTransportStateChangedEvent extends Event{readonly state:RTCDtlsTransportState;}declare var RTCDtlsTransportStateChangedEvent:{prototype:RTCDtlsTransportStateChangedEvent;new():RTCDtlsTransportStateChangedEvent;};interface RTCDtmfSenderEventMap{"tonechange":RTCDTMFToneChangeEvent;}interface RTCDtmfSender extends EventTarget{readonly canInsertDTMF:boolean;readonly duration:number;readonly interToneGap:number;ontonechange:((this:RTCDtmfSender,ev:RTCDTMFToneChangeEvent)=>any)|null;readonly sender:RTCRtpSender;readonly toneBuffer:string;insertDTMF(tones:string,duration?:number,interToneGap?:number):void;addEventListener<K extends keyof RTCDtmfSenderEventMap>(type:K,listener:(this:RTCDtmfSender,ev:RTCDtmfSenderEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof RTCDtmfSenderEventMap>(type:K,listener:(this:RTCDtmfSender,ev:RTCDtmfSenderEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var RTCDtmfSender:{prototype:RTCDtmfSender;new(sender:RTCRtpSender):RTCDtmfSender;};interface RTCError extends DOMException{readonly errorDetail:RTCErrorDetailType;readonly httpRequestStatusCode:number|null;readonly receivedAlert:number|null;readonly sctpCauseCode:number|null;readonly sdpLineNumber:number|null;readonly sentAlert:number|null;}declare var RTCError:{prototype:RTCError;new(init:RTCErrorInit,message?:string):RTCError;};interface RTCErrorEvent extends Event{readonly error:RTCError;}declare var RTCErrorEvent:{prototype:RTCErrorEvent;new(type:string,eventInitDict:RTCErrorEventInit):RTCErrorEvent;};interface RTCIceCandidate{readonly candidate:string;readonly component:RTCIceComponent|null;readonly foundation:string|null;readonly port:number|null;readonly priority:number|null;readonly protocol:RTCIceProtocol|null;readonly relatedAddress:string|null;readonly relatedPort:number|null;readonly sdpMLineIndex:number|null;readonly sdpMid:string|null;readonly tcpType:RTCIceTcpCandidateType|null;readonly type:RTCIceCandidateType|null;readonly usernameFragment:string|null;toJSON():RTCIceCandidateInit;}declare var RTCIceCandidate:{prototype:RTCIceCandidate;new(candidateInitDict?:RTCIceCandidateInit):RTCIceCandidate;};interface RTCIceCandidatePairChangedEvent extends Event{readonly pair:RTCIceCandidatePair;}declare var RTCIceCandidatePairChangedEvent:{prototype:RTCIceCandidatePairChangedEvent;new():RTCIceCandidatePairChangedEvent;};interface RTCIceGathererEventMap{"error":Event;"localcandidate":RTCIceGathererEvent;}interface RTCIceGatherer extends RTCStatsProvider{readonly component:RTCIceComponent;onerror:((this:RTCIceGatherer,ev:Event)=>any)|null;onlocalcandidate:((this:RTCIceGatherer,ev:RTCIceGathererEvent)=>any)|null;createAssociatedGatherer():RTCIceGatherer;getLocalCandidates():RTCIceCandidateDictionary[];getLocalParameters():RTCIceParameters;addEventListener<K extends keyof RTCIceGathererEventMap>(type:K,listener:(this:RTCIceGatherer,ev:RTCIceGathererEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof RTCIceGathererEventMap>(type:K,listener:(this:RTCIceGatherer,ev:RTCIceGathererEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var RTCIceGatherer:{prototype:RTCIceGatherer;new(options:RTCIceGatherOptions):RTCIceGatherer;};interface RTCIceGathererEvent extends Event{readonly candidate:RTCIceCandidateDictionary|RTCIceCandidateComplete;}declare var RTCIceGathererEvent:{prototype:RTCIceGathererEvent;new():RTCIceGathererEvent;};interface RTCIceTransportEventMap{"gatheringstatechange":Event;"selectedcandidatepairchange":Event;"statechange":Event;}interface RTCIceTransport extends EventTarget{readonly component:RTCIceComponent;readonly gatheringState:RTCIceGathererState;ongatheringstatechange:((this:RTCIceTransport,ev:Event)=>any)|null;onselectedcandidatepairchange:((this:RTCIceTransport,ev:Event)=>any)|null;onstatechange:((this:RTCIceTransport,ev:Event)=>any)|null;readonly role:RTCIceRole;readonly state:RTCIceTransportState;getLocalCandidates():RTCIceCandidate[];getLocalParameters():RTCIceParameters|null;getRemoteCandidates():RTCIceCandidate[];getRemoteParameters():RTCIceParameters|null;getSelectedCandidatePair():RTCIceCandidatePair|null;addEventListener<K extends keyof RTCIceTransportEventMap>(type:K,listener:(this:RTCIceTransport,ev:RTCIceTransportEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof RTCIceTransportEventMap>(type:K,listener:(this:RTCIceTransport,ev:RTCIceTransportEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var RTCIceTransport:{prototype:RTCIceTransport;new():RTCIceTransport;};interface RTCIceTransportStateChangedEvent extends Event{readonly state:RTCIceTransportState;}declare var RTCIceTransportStateChangedEvent:{prototype:RTCIceTransportStateChangedEvent;new():RTCIceTransportStateChangedEvent;};interface RTCIdentityAssertion{idp:string;name:string;}declare var RTCIdentityAssertion:{prototype:RTCIdentityAssertion;new(idp:string,name:string):RTCIdentityAssertion;};interface RTCPeerConnectionEventMap{"connectionstatechange":Event;"datachannel":RTCDataChannelEvent;"icecandidate":RTCPeerConnectionIceEvent;"icecandidateerror":RTCPeerConnectionIceErrorEvent;"iceconnectionstatechange":Event;"icegatheringstatechange":Event;"negotiationneeded":Event;"signalingstatechange":Event;"statsended":RTCStatsEvent;"track":RTCTrackEvent;}interface RTCPeerConnection extends EventTarget{readonly canTrickleIceCandidates:boolean|null;readonly connectionState:RTCPeerConnectionState;readonly currentLocalDescription:RTCSessionDescription|null;readonly currentRemoteDescription:RTCSessionDescription|null;readonly iceConnectionState:RTCIceConnectionState;readonly iceGatheringState:RTCIceGatheringState;readonly idpErrorInfo:string|null;readonly idpLoginUrl:string|null;readonly localDescription:RTCSessionDescription|null;onconnectionstatechange:((this:RTCPeerConnection,ev:Event)=>any)|null;ondatachannel:((this:RTCPeerConnection,ev:RTCDataChannelEvent)=>any)|null;onicecandidate:((this:RTCPeerConnection,ev:RTCPeerConnectionIceEvent)=>any)|null;onicecandidateerror:((this:RTCPeerConnection,ev:RTCPeerConnectionIceErrorEvent)=>any)|null;oniceconnectionstatechange:((this:RTCPeerConnection,ev:Event)=>any)|null;onicegatheringstatechange:((this:RTCPeerConnection,ev:Event)=>any)|null;onnegotiationneeded:((this:RTCPeerConnection,ev:Event)=>any)|null;onsignalingstatechange:((this:RTCPeerConnection,ev:Event)=>any)|null;onstatsended:((this:RTCPeerConnection,ev:RTCStatsEvent)=>any)|null;ontrack:((this:RTCPeerConnection,ev:RTCTrackEvent)=>any)|null;readonly peerIdentity:Promise<RTCIdentityAssertion>;readonly pendingLocalDescription:RTCSessionDescription|null;readonly pendingRemoteDescription:RTCSessionDescription|null;readonly remoteDescription:RTCSessionDescription|null;readonly sctp:RTCSctpTransport|null;readonly signalingState:RTCSignalingState;addIceCandidate(candidate:RTCIceCandidateInit|RTCIceCandidate):Promise<void>;addTrack(track:MediaStreamTrack,...streams:MediaStream[]):RTCRtpSender;addTransceiver(trackOrKind:MediaStreamTrack|string,init?:RTCRtpTransceiverInit):RTCRtpTransceiver;close():void;createAnswer(options?:RTCOfferOptions):Promise<RTCSessionDescriptionInit>;createDataChannel(label:string,dataChannelDict?:RTCDataChannelInit):RTCDataChannel;createOffer(options?:RTCOfferOptions):Promise<RTCSessionDescriptionInit>;getConfiguration():RTCConfiguration;getIdentityAssertion():Promise<string>;getReceivers():RTCRtpReceiver[];getSenders():RTCRtpSender[];getStats(selector?:MediaStreamTrack|null):Promise<RTCStatsReport>;getTransceivers():RTCRtpTransceiver[];removeTrack(sender:RTCRtpSender):void;setConfiguration(configuration:RTCConfiguration):void;setIdentityProvider(provider:string,options?:RTCIdentityProviderOptions):void;setLocalDescription(description:RTCSessionDescriptionInit):Promise<void>;setRemoteDescription(description:RTCSessionDescriptionInit):Promise<void>;addEventListener<K extends keyof RTCPeerConnectionEventMap>(type:K,listener:(this:RTCPeerConnection,ev:RTCPeerConnectionEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof RTCPeerConnectionEventMap>(type:K,listener:(this:RTCPeerConnection,ev:RTCPeerConnectionEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var RTCPeerConnection:{prototype:RTCPeerConnection;new(configuration?:RTCConfiguration):RTCPeerConnection;generateCertificate(keygenAlgorithm:AlgorithmIdentifier):Promise<RTCCertificate>;getDefaultIceServers():RTCIceServer[];};interface RTCPeerConnectionIceErrorEvent extends Event{readonly errorCode:number;readonly errorText:string;readonly hostCandidate:string;readonly url:string;}declare var RTCPeerConnectionIceErrorEvent:{prototype:RTCPeerConnectionIceErrorEvent;new(type:string,eventInitDict:RTCPeerConnectionIceErrorEventInit):RTCPeerConnectionIceErrorEvent;};interface RTCPeerConnectionIceEvent extends Event{readonly candidate:RTCIceCandidate|null;readonly url:string|null;}declare var RTCPeerConnectionIceEvent:{prototype:RTCPeerConnectionIceEvent;new(type:string,eventInitDict?:RTCPeerConnectionIceEventInit):RTCPeerConnectionIceEvent;};interface RTCRtpReceiver{readonly rtcpTransport:RTCDtlsTransport|null;readonly track:MediaStreamTrack;readonly transport:RTCDtlsTransport|null;getContributingSources():RTCRtpContributingSource[];getParameters():RTCRtpReceiveParameters;getStats():Promise<RTCStatsReport>;getSynchronizationSources():RTCRtpSynchronizationSource[];}declare var RTCRtpReceiver:{prototype:RTCRtpReceiver;new():RTCRtpReceiver;getCapabilities(kind:string):RTCRtpCapabilities|null;};interface RTCRtpSender{readonly dtmf:RTCDTMFSender|null;readonly rtcpTransport:RTCDtlsTransport|null;readonly track:MediaStreamTrack|null;readonly transport:RTCDtlsTransport|null;getParameters():RTCRtpSendParameters;getStats():Promise<RTCStatsReport>;replaceTrack(withTrack:MediaStreamTrack|null):Promise<void>;setParameters(parameters:RTCRtpSendParameters):Promise<void>;setStreams(...streams:MediaStream[]):void;}declare var RTCRtpSender:{prototype:RTCRtpSender;new():RTCRtpSender;getCapabilities(kind:string):RTCRtpCapabilities|null;};interface RTCRtpTransceiver{readonly currentDirection:RTCRtpTransceiverDirection|null;direction:RTCRtpTransceiverDirection;readonly mid:string|null;readonly receiver:RTCRtpReceiver;readonly sender:RTCRtpSender;setCodecPreferences(codecs:RTCRtpCodecCapability[]):void;stop():void;}declare var RTCRtpTransceiver:{prototype:RTCRtpTransceiver;new():RTCRtpTransceiver;};interface RTCSctpTransportEventMap{"statechange":Event;}interface RTCSctpTransport extends EventTarget{readonly maxChannels:number|null;readonly maxMessageSize:number;onstatechange:((this:RTCSctpTransport,ev:Event)=>any)|null;readonly state:RTCSctpTransportState;readonly transport:RTCDtlsTransport;addEventListener<K extends keyof RTCSctpTransportEventMap>(type:K,listener:(this:RTCSctpTransport,ev:RTCSctpTransportEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof RTCSctpTransportEventMap>(type:K,listener:(this:RTCSctpTransport,ev:RTCSctpTransportEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var RTCSctpTransport:{prototype:RTCSctpTransport;new():RTCSctpTransport;};interface RTCSessionDescription{readonly sdp:string;readonly type:RTCSdpType;toJSON():any;}declare var RTCSessionDescription:{prototype:RTCSessionDescription;new(descriptionInitDict?:RTCSessionDescriptionInit):RTCSessionDescription;};interface RTCSrtpSdesTransportEventMap{"error":Event;}interface RTCSrtpSdesTransport extends EventTarget{onerror:((this:RTCSrtpSdesTransport,ev:Event)=>any)|null;readonly transport:RTCIceTransport;addEventListener<K extends keyof RTCSrtpSdesTransportEventMap>(type:K,listener:(this:RTCSrtpSdesTransport,ev:RTCSrtpSdesTransportEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof RTCSrtpSdesTransportEventMap>(type:K,listener:(this:RTCSrtpSdesTransport,ev:RTCSrtpSdesTransportEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var RTCSrtpSdesTransport:{prototype:RTCSrtpSdesTransport;new(transport:RTCIceTransport,encryptParameters:RTCSrtpSdesParameters,decryptParameters:RTCSrtpSdesParameters):RTCSrtpSdesTransport;getLocalParameters():RTCSrtpSdesParameters[];};interface RTCSsrcConflictEvent extends Event{readonly ssrc:number;}declare var RTCSsrcConflictEvent:{prototype:RTCSsrcConflictEvent;new():RTCSsrcConflictEvent;};interface RTCStatsEvent extends Event{readonly report:RTCStatsReport;}declare var RTCStatsEvent:{prototype:RTCStatsEvent;new(type:string,eventInitDict:RTCStatsEventInit):RTCStatsEvent;};interface RTCStatsProvider extends EventTarget{getStats():Promise<RTCStatsReport>;msGetStats():Promise<RTCStatsReport>;}declare var RTCStatsProvider:{prototype:RTCStatsProvider;new():RTCStatsProvider;};interface RTCStatsReport{forEach(callbackfn:(value:any,key:string,parent:RTCStatsReport)=>void,thisArg?:any):void;}declare var RTCStatsReport:{prototype:RTCStatsReport;new():RTCStatsReport;};interface RTCTrackEvent extends Event{readonly receiver:RTCRtpReceiver;readonly streams:ReadonlyArray<MediaStream>;readonly track:MediaStreamTrack;readonly transceiver:RTCRtpTransceiver;}declare var RTCTrackEvent:{prototype:RTCTrackEvent;new(type:string,eventInitDict:RTCTrackEventInit):RTCTrackEvent;};interface RadioNodeList extends NodeList{value:string;}declare var RadioNodeList:{prototype:RadioNodeList;new():RadioNodeList;};interface RandomSource{getRandomValues<T extends Int8Array|Uint8ClampedArray|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array>(array:T):T;}declare var RandomSource:{prototype:RandomSource;new():RandomSource;};interface Range extends AbstractRange{readonly commonAncestorContainer:Node;cloneContents():DocumentFragment;cloneRange():Range;collapse(toStart?:boolean):void;compareBoundaryPoints(how:number,sourceRange:Range):number;comparePoint(node:Node,offset:number):number;createContextualFragment(fragment:string):DocumentFragment;deleteContents():void;detach():void;extractContents():DocumentFragment;getBoundingClientRect():DOMRect;getClientRects():DOMRectList;insertNode(node:Node):void;intersectsNode(node:Node):boolean;isPointInRange(node:Node,offset:number):boolean;selectNode(node:Node):void;selectNodeContents(node:Node):void;setEnd(node:Node,offset:number):void;setEndAfter(node:Node):void;setEndBefore(node:Node):void;setStart(node:Node,offset:number):void;setStartAfter(node:Node):void;setStartBefore(node:Node):void;surroundContents(newParent:Node):void;toString():string;readonly END_TO_END:number;readonly END_TO_START:number;readonly START_TO_END:number;readonly START_TO_START:number;}declare var Range:{prototype:Range;new():Range;readonly END_TO_END:number;readonly END_TO_START:number;readonly START_TO_END:number;readonly START_TO_START:number;toString():string;};interface ReadableByteStreamController{readonly byobRequest:ReadableStreamBYOBRequest|undefined;readonly desiredSize:number|null;close():void;enqueue(chunk:ArrayBufferView):void;error(error?:any):void;}interface ReadableStream<R=any>{readonly locked:boolean;cancel(reason?:any):Promise<void>;getReader(options:{mode:"byob"}):ReadableStreamBYOBReader;getReader():ReadableStreamDefaultReader<R>;pipeThrough<T>({writable,readable}:{writable:WritableStream<R>,readable:ReadableStream<T>},options?:PipeOptions):ReadableStream<T>;pipeTo(dest:WritableStream<R>,options?:PipeOptions):Promise<void>;tee():[ReadableStream<R>,ReadableStream<R>];}declare var ReadableStream:{prototype:ReadableStream;new(underlyingSource:UnderlyingByteSource,strategy?:{highWaterMark?:number,size?:undefined}):ReadableStream<Uint8Array>;new<R=any>(underlyingSource?:UnderlyingSource<R>,strategy?:QueuingStrategy<R>):ReadableStream<R>;};interface ReadableStreamBYOBReader{readonly closed:Promise<void>;cancel(reason?:any):Promise<void>;read<T extends ArrayBufferView>(view:T):Promise<ReadableStreamReadResult<T>>;releaseLock():void;}interface ReadableStreamBYOBRequest{readonly view:ArrayBufferView;respond(bytesWritten:number):void;respondWithNewView(view:ArrayBufferView):void;}interface ReadableStreamDefaultController<R=any>{readonly desiredSize:number|null;close():void;enqueue(chunk:R):void;error(error?:any):void;}interface ReadableStreamDefaultReader<R=any>{readonly closed:Promise<void>;cancel(reason?:any):Promise<void>;read():Promise<ReadableStreamReadResult<R>>;releaseLock():void;}interface ReadableStreamReader<R=any>{cancel():Promise<void>;read():Promise<ReadableStreamReadResult<R>>;releaseLock():void;}declare var ReadableStreamReader:{prototype:ReadableStreamReader;new():ReadableStreamReader;};interface Request extends Body{readonly cache:RequestCache;readonly credentials:RequestCredentials;readonly destination:RequestDestination;readonly headers:Headers;readonly integrity:string;readonly isHistoryNavigation:boolean;readonly isReloadNavigation:boolean;readonly keepalive:boolean;readonly method:string;readonly mode:RequestMode;readonly redirect:RequestRedirect;readonly referrer:string;readonly referrerPolicy:ReferrerPolicy;readonly signal:AbortSignal;readonly url:string;clone():Request;}declare var Request:{prototype:Request;new(input:RequestInfo,init?:RequestInit):Request;};interface Response extends Body{readonly headers:Headers;readonly ok:boolean;readonly redirected:boolean;readonly status:number;readonly statusText:string;readonly trailer:Promise<Headers>;readonly type:ResponseType;readonly url:string;clone():Response;}declare var Response:{prototype:Response;new(body?:BodyInit|null,init?:ResponseInit):Response;error():Response;redirect(url:string,status?:number):Response;};interface SVGAElement extends SVGGraphicsElement,SVGURIReference{readonly target:SVGAnimatedString;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGAElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGAElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGAElement:{prototype:SVGAElement;new():SVGAElement;};interface SVGAngle{readonly unitType:number;value:number;valueAsString:string;valueInSpecifiedUnits:number;convertToSpecifiedUnits(unitType:number):void;newValueSpecifiedUnits(unitType:number,valueInSpecifiedUnits:number):void;readonly SVG_ANGLETYPE_DEG:number;readonly SVG_ANGLETYPE_GRAD:number;readonly SVG_ANGLETYPE_RAD:number;readonly SVG_ANGLETYPE_UNKNOWN:number;readonly SVG_ANGLETYPE_UNSPECIFIED:number;}declare var SVGAngle:{prototype:SVGAngle;new():SVGAngle;readonly SVG_ANGLETYPE_DEG:number;readonly SVG_ANGLETYPE_GRAD:number;readonly SVG_ANGLETYPE_RAD:number;readonly SVG_ANGLETYPE_UNKNOWN:number;readonly SVG_ANGLETYPE_UNSPECIFIED:number;};interface SVGAnimateElement extends SVGAnimationElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGAnimateElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGAnimateElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGAnimateElement:{prototype:SVGAnimateElement;new():SVGAnimateElement;};interface SVGAnimateMotionElement extends SVGAnimationElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGAnimateMotionElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGAnimateMotionElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGAnimateMotionElement:{prototype:SVGAnimateMotionElement;new():SVGAnimateMotionElement;};interface SVGAnimateTransformElement extends SVGAnimationElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGAnimateTransformElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGAnimateTransformElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGAnimateTransformElement:{prototype:SVGAnimateTransformElement;new():SVGAnimateTransformElement;};interface SVGAnimatedAngle{readonly animVal:SVGAngle;readonly baseVal:SVGAngle;}declare var SVGAnimatedAngle:{prototype:SVGAnimatedAngle;new():SVGAnimatedAngle;};interface SVGAnimatedBoolean{readonly animVal:boolean;baseVal:boolean;}declare var SVGAnimatedBoolean:{prototype:SVGAnimatedBoolean;new():SVGAnimatedBoolean;};interface SVGAnimatedEnumeration{readonly animVal:number;baseVal:number;}declare var SVGAnimatedEnumeration:{prototype:SVGAnimatedEnumeration;new():SVGAnimatedEnumeration;};interface SVGAnimatedInteger{readonly animVal:number;baseVal:number;}declare var SVGAnimatedInteger:{prototype:SVGAnimatedInteger;new():SVGAnimatedInteger;};interface SVGAnimatedLength{readonly animVal:SVGLength;readonly baseVal:SVGLength;}declare var SVGAnimatedLength:{prototype:SVGAnimatedLength;new():SVGAnimatedLength;};interface SVGAnimatedLengthList{readonly animVal:SVGLengthList;readonly baseVal:SVGLengthList;}declare var SVGAnimatedLengthList:{prototype:SVGAnimatedLengthList;new():SVGAnimatedLengthList;};interface SVGAnimatedNumber{readonly animVal:number;baseVal:number;}declare var SVGAnimatedNumber:{prototype:SVGAnimatedNumber;new():SVGAnimatedNumber;};interface SVGAnimatedNumberList{readonly animVal:SVGNumberList;readonly baseVal:SVGNumberList;}declare var SVGAnimatedNumberList:{prototype:SVGAnimatedNumberList;new():SVGAnimatedNumberList;};interface SVGAnimatedPoints{readonly animatedPoints:SVGPointList;readonly points:SVGPointList;}interface SVGAnimatedPreserveAspectRatio{readonly animVal:SVGPreserveAspectRatio;readonly baseVal:SVGPreserveAspectRatio;}declare var SVGAnimatedPreserveAspectRatio:{prototype:SVGAnimatedPreserveAspectRatio;new():SVGAnimatedPreserveAspectRatio;};interface SVGAnimatedRect{readonly animVal:DOMRectReadOnly;readonly baseVal:DOMRect;}declare var SVGAnimatedRect:{prototype:SVGAnimatedRect;new():SVGAnimatedRect;};interface SVGAnimatedString{readonly animVal:string;baseVal:string;}declare var SVGAnimatedString:{prototype:SVGAnimatedString;new():SVGAnimatedString;};interface SVGAnimatedTransformList{readonly animVal:SVGTransformList;readonly baseVal:SVGTransformList;}declare var SVGAnimatedTransformList:{prototype:SVGAnimatedTransformList;new():SVGAnimatedTransformList;};interface SVGAnimationElement extends SVGElement{readonly targetElement:SVGElement;getCurrentTime():number;getSimpleDuration():number;getStartTime():number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGAnimationElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGAnimationElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGAnimationElement:{prototype:SVGAnimationElement;new():SVGAnimationElement;};interface SVGCircleElement extends SVGGeometryElement{readonly cx:SVGAnimatedLength;readonly cy:SVGAnimatedLength;readonly r:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGCircleElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGCircleElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGCircleElement:{prototype:SVGCircleElement;new():SVGCircleElement;};interface SVGClipPathElement extends SVGElement{readonly clipPathUnits:SVGAnimatedEnumeration;readonly transform:SVGAnimatedTransformList;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGClipPathElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGClipPathElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGClipPathElement:{prototype:SVGClipPathElement;new():SVGClipPathElement;};interface SVGComponentTransferFunctionElement extends SVGElement{readonly amplitude:SVGAnimatedNumber;readonly exponent:SVGAnimatedNumber;readonly intercept:SVGAnimatedNumber;readonly offset:SVGAnimatedNumber;readonly slope:SVGAnimatedNumber;readonly tableValues:SVGAnimatedNumberList;readonly type:SVGAnimatedEnumeration;readonly SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE:number;readonly SVG_FECOMPONENTTRANSFER_TYPE_GAMMA:number;readonly SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY:number;readonly SVG_FECOMPONENTTRANSFER_TYPE_LINEAR:number;readonly SVG_FECOMPONENTTRANSFER_TYPE_TABLE:number;readonly SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGComponentTransferFunctionElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGComponentTransferFunctionElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGComponentTransferFunctionElement:{prototype:SVGComponentTransferFunctionElement;new():SVGComponentTransferFunctionElement;readonly SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE:number;readonly SVG_FECOMPONENTTRANSFER_TYPE_GAMMA:number;readonly SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY:number;readonly SVG_FECOMPONENTTRANSFER_TYPE_LINEAR:number;readonly SVG_FECOMPONENTTRANSFER_TYPE_TABLE:number;readonly SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN:number;};interface SVGCursorElement extends SVGElement{readonly x:SVGAnimatedLength;readonly y:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGCursorElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGCursorElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGCursorElement:{prototype:SVGCursorElement;new():SVGCursorElement;};interface SVGDefsElement extends SVGGraphicsElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGDefsElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGDefsElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGDefsElement:{prototype:SVGDefsElement;new():SVGDefsElement;};interface SVGDescElement extends SVGElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGDescElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGDescElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGDescElement:{prototype:SVGDescElement;new():SVGDescElement;};interface SVGElementEventMap extends ElementEventMap,GlobalEventHandlersEventMap,DocumentAndElementEventHandlersEventMap{}interface SVGElement extends Element,DocumentAndElementEventHandlers,DocumentAndElementEventHandlers,ElementCSSInlineStyle,GlobalEventHandlers,GlobalEventHandlers,HTMLOrSVGElement,SVGElementInstance{readonly className:any;readonly ownerSVGElement:SVGSVGElement|null;readonly viewportElement:SVGElement|null;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGElement:{prototype:SVGElement;new():SVGElement;};interface SVGElementInstance extends EventTarget{readonly correspondingElement:SVGElement;readonly correspondingUseElement:SVGUseElement;}declare var SVGElementInstance:{prototype:SVGElementInstance;new():SVGElementInstance;};interface SVGElementInstanceList{readonly length:number;item(index:number):SVGElementInstance;}declare var SVGElementInstanceList:{prototype:SVGElementInstanceList;new():SVGElementInstanceList;};interface SVGEllipseElement extends SVGGeometryElement{readonly cx:SVGAnimatedLength;readonly cy:SVGAnimatedLength;readonly rx:SVGAnimatedLength;readonly ry:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGEllipseElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGEllipseElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGEllipseElement:{prototype:SVGEllipseElement;new():SVGEllipseElement;};interface SVGFEBlendElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly in1:SVGAnimatedString;readonly in2:SVGAnimatedString;readonly mode:SVGAnimatedEnumeration;readonly SVG_FEBLEND_MODE_COLOR:number;readonly SVG_FEBLEND_MODE_COLOR_BURN:number;readonly SVG_FEBLEND_MODE_COLOR_DODGE:number;readonly SVG_FEBLEND_MODE_DARKEN:number;readonly SVG_FEBLEND_MODE_DIFFERENCE:number;readonly SVG_FEBLEND_MODE_EXCLUSION:number;readonly SVG_FEBLEND_MODE_HARD_LIGHT:number;readonly SVG_FEBLEND_MODE_HUE:number;readonly SVG_FEBLEND_MODE_LIGHTEN:number;readonly SVG_FEBLEND_MODE_LUMINOSITY:number;readonly SVG_FEBLEND_MODE_MULTIPLY:number;readonly SVG_FEBLEND_MODE_NORMAL:number;readonly SVG_FEBLEND_MODE_OVERLAY:number;readonly SVG_FEBLEND_MODE_SATURATION:number;readonly SVG_FEBLEND_MODE_SCREEN:number;readonly SVG_FEBLEND_MODE_SOFT_LIGHT:number;readonly SVG_FEBLEND_MODE_UNKNOWN:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEBlendElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEBlendElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEBlendElement:{prototype:SVGFEBlendElement;new():SVGFEBlendElement;readonly SVG_FEBLEND_MODE_COLOR:number;readonly SVG_FEBLEND_MODE_COLOR_BURN:number;readonly SVG_FEBLEND_MODE_COLOR_DODGE:number;readonly SVG_FEBLEND_MODE_DARKEN:number;readonly SVG_FEBLEND_MODE_DIFFERENCE:number;readonly SVG_FEBLEND_MODE_EXCLUSION:number;readonly SVG_FEBLEND_MODE_HARD_LIGHT:number;readonly SVG_FEBLEND_MODE_HUE:number;readonly SVG_FEBLEND_MODE_LIGHTEN:number;readonly SVG_FEBLEND_MODE_LUMINOSITY:number;readonly SVG_FEBLEND_MODE_MULTIPLY:number;readonly SVG_FEBLEND_MODE_NORMAL:number;readonly SVG_FEBLEND_MODE_OVERLAY:number;readonly SVG_FEBLEND_MODE_SATURATION:number;readonly SVG_FEBLEND_MODE_SCREEN:number;readonly SVG_FEBLEND_MODE_SOFT_LIGHT:number;readonly SVG_FEBLEND_MODE_UNKNOWN:number;};interface SVGFEColorMatrixElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly in1:SVGAnimatedString;readonly type:SVGAnimatedEnumeration;readonly values:SVGAnimatedNumberList;readonly SVG_FECOLORMATRIX_TYPE_HUEROTATE:number;readonly SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA:number;readonly SVG_FECOLORMATRIX_TYPE_MATRIX:number;readonly SVG_FECOLORMATRIX_TYPE_SATURATE:number;readonly SVG_FECOLORMATRIX_TYPE_UNKNOWN:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEColorMatrixElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEColorMatrixElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEColorMatrixElement:{prototype:SVGFEColorMatrixElement;new():SVGFEColorMatrixElement;readonly SVG_FECOLORMATRIX_TYPE_HUEROTATE:number;readonly SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA:number;readonly SVG_FECOLORMATRIX_TYPE_MATRIX:number;readonly SVG_FECOLORMATRIX_TYPE_SATURATE:number;readonly SVG_FECOLORMATRIX_TYPE_UNKNOWN:number;};interface SVGFEComponentTransferElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly in1:SVGAnimatedString;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEComponentTransferElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEComponentTransferElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEComponentTransferElement:{prototype:SVGFEComponentTransferElement;new():SVGFEComponentTransferElement;};interface SVGFECompositeElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly in1:SVGAnimatedString;readonly in2:SVGAnimatedString;readonly k1:SVGAnimatedNumber;readonly k2:SVGAnimatedNumber;readonly k3:SVGAnimatedNumber;readonly k4:SVGAnimatedNumber;readonly operator:SVGAnimatedEnumeration;readonly SVG_FECOMPOSITE_OPERATOR_ARITHMETIC:number;readonly SVG_FECOMPOSITE_OPERATOR_ATOP:number;readonly SVG_FECOMPOSITE_OPERATOR_IN:number;readonly SVG_FECOMPOSITE_OPERATOR_OUT:number;readonly SVG_FECOMPOSITE_OPERATOR_OVER:number;readonly SVG_FECOMPOSITE_OPERATOR_UNKNOWN:number;readonly SVG_FECOMPOSITE_OPERATOR_XOR:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFECompositeElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFECompositeElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFECompositeElement:{prototype:SVGFECompositeElement;new():SVGFECompositeElement;readonly SVG_FECOMPOSITE_OPERATOR_ARITHMETIC:number;readonly SVG_FECOMPOSITE_OPERATOR_ATOP:number;readonly SVG_FECOMPOSITE_OPERATOR_IN:number;readonly SVG_FECOMPOSITE_OPERATOR_OUT:number;readonly SVG_FECOMPOSITE_OPERATOR_OVER:number;readonly SVG_FECOMPOSITE_OPERATOR_UNKNOWN:number;readonly SVG_FECOMPOSITE_OPERATOR_XOR:number;};interface SVGFEConvolveMatrixElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly bias:SVGAnimatedNumber;readonly divisor:SVGAnimatedNumber;readonly edgeMode:SVGAnimatedEnumeration;readonly in1:SVGAnimatedString;readonly kernelMatrix:SVGAnimatedNumberList;readonly kernelUnitLengthX:SVGAnimatedNumber;readonly kernelUnitLengthY:SVGAnimatedNumber;readonly orderX:SVGAnimatedInteger;readonly orderY:SVGAnimatedInteger;readonly preserveAlpha:SVGAnimatedBoolean;readonly targetX:SVGAnimatedInteger;readonly targetY:SVGAnimatedInteger;readonly SVG_EDGEMODE_DUPLICATE:number;readonly SVG_EDGEMODE_NONE:number;readonly SVG_EDGEMODE_UNKNOWN:number;readonly SVG_EDGEMODE_WRAP:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEConvolveMatrixElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEConvolveMatrixElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEConvolveMatrixElement:{prototype:SVGFEConvolveMatrixElement;new():SVGFEConvolveMatrixElement;readonly SVG_EDGEMODE_DUPLICATE:number;readonly SVG_EDGEMODE_NONE:number;readonly SVG_EDGEMODE_UNKNOWN:number;readonly SVG_EDGEMODE_WRAP:number;};interface SVGFEDiffuseLightingElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly diffuseConstant:SVGAnimatedNumber;readonly in1:SVGAnimatedString;readonly kernelUnitLengthX:SVGAnimatedNumber;readonly kernelUnitLengthY:SVGAnimatedNumber;readonly surfaceScale:SVGAnimatedNumber;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEDiffuseLightingElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEDiffuseLightingElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEDiffuseLightingElement:{prototype:SVGFEDiffuseLightingElement;new():SVGFEDiffuseLightingElement;};interface SVGFEDisplacementMapElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly in1:SVGAnimatedString;readonly in2:SVGAnimatedString;readonly scale:SVGAnimatedNumber;readonly xChannelSelector:SVGAnimatedEnumeration;readonly yChannelSelector:SVGAnimatedEnumeration;readonly SVG_CHANNEL_A:number;readonly SVG_CHANNEL_B:number;readonly SVG_CHANNEL_G:number;readonly SVG_CHANNEL_R:number;readonly SVG_CHANNEL_UNKNOWN:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEDisplacementMapElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEDisplacementMapElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEDisplacementMapElement:{prototype:SVGFEDisplacementMapElement;new():SVGFEDisplacementMapElement;readonly SVG_CHANNEL_A:number;readonly SVG_CHANNEL_B:number;readonly SVG_CHANNEL_G:number;readonly SVG_CHANNEL_R:number;readonly SVG_CHANNEL_UNKNOWN:number;};interface SVGFEDistantLightElement extends SVGElement{readonly azimuth:SVGAnimatedNumber;readonly elevation:SVGAnimatedNumber;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEDistantLightElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEDistantLightElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEDistantLightElement:{prototype:SVGFEDistantLightElement;new():SVGFEDistantLightElement;};interface SVGFEDropShadowElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly dx:SVGAnimatedNumber;readonly dy:SVGAnimatedNumber;readonly in1:SVGAnimatedString;readonly stdDeviationX:SVGAnimatedNumber;readonly stdDeviationY:SVGAnimatedNumber;setStdDeviation(stdDeviationX:number,stdDeviationY:number):void;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEDropShadowElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEDropShadowElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEDropShadowElement:{prototype:SVGFEDropShadowElement;new():SVGFEDropShadowElement;};interface SVGFEFloodElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEFloodElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEFloodElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEFloodElement:{prototype:SVGFEFloodElement;new():SVGFEFloodElement;};interface SVGFEFuncAElement extends SVGComponentTransferFunctionElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEFuncAElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEFuncAElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEFuncAElement:{prototype:SVGFEFuncAElement;new():SVGFEFuncAElement;};interface SVGFEFuncBElement extends SVGComponentTransferFunctionElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEFuncBElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEFuncBElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEFuncBElement:{prototype:SVGFEFuncBElement;new():SVGFEFuncBElement;};interface SVGFEFuncGElement extends SVGComponentTransferFunctionElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEFuncGElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEFuncGElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEFuncGElement:{prototype:SVGFEFuncGElement;new():SVGFEFuncGElement;};interface SVGFEFuncRElement extends SVGComponentTransferFunctionElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEFuncRElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEFuncRElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEFuncRElement:{prototype:SVGFEFuncRElement;new():SVGFEFuncRElement;};interface SVGFEGaussianBlurElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly in1:SVGAnimatedString;readonly stdDeviationX:SVGAnimatedNumber;readonly stdDeviationY:SVGAnimatedNumber;setStdDeviation(stdDeviationX:number,stdDeviationY:number):void;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEGaussianBlurElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEGaussianBlurElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEGaussianBlurElement:{prototype:SVGFEGaussianBlurElement;new():SVGFEGaussianBlurElement;};interface SVGFEImageElement extends SVGElement,SVGFilterPrimitiveStandardAttributes,SVGURIReference{readonly preserveAspectRatio:SVGAnimatedPreserveAspectRatio;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEImageElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEImageElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEImageElement:{prototype:SVGFEImageElement;new():SVGFEImageElement;};interface SVGFEMergeElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEMergeElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEMergeElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEMergeElement:{prototype:SVGFEMergeElement;new():SVGFEMergeElement;};interface SVGFEMergeNodeElement extends SVGElement{readonly in1:SVGAnimatedString;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEMergeNodeElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEMergeNodeElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEMergeNodeElement:{prototype:SVGFEMergeNodeElement;new():SVGFEMergeNodeElement;};interface SVGFEMorphologyElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly in1:SVGAnimatedString;readonly operator:SVGAnimatedEnumeration;readonly radiusX:SVGAnimatedNumber;readonly radiusY:SVGAnimatedNumber;readonly SVG_MORPHOLOGY_OPERATOR_DILATE:number;readonly SVG_MORPHOLOGY_OPERATOR_ERODE:number;readonly SVG_MORPHOLOGY_OPERATOR_UNKNOWN:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEMorphologyElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEMorphologyElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEMorphologyElement:{prototype:SVGFEMorphologyElement;new():SVGFEMorphologyElement;readonly SVG_MORPHOLOGY_OPERATOR_DILATE:number;readonly SVG_MORPHOLOGY_OPERATOR_ERODE:number;readonly SVG_MORPHOLOGY_OPERATOR_UNKNOWN:number;};interface SVGFEOffsetElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly dx:SVGAnimatedNumber;readonly dy:SVGAnimatedNumber;readonly in1:SVGAnimatedString;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEOffsetElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEOffsetElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEOffsetElement:{prototype:SVGFEOffsetElement;new():SVGFEOffsetElement;};interface SVGFEPointLightElement extends SVGElement{readonly x:SVGAnimatedNumber;readonly y:SVGAnimatedNumber;readonly z:SVGAnimatedNumber;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEPointLightElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFEPointLightElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFEPointLightElement:{prototype:SVGFEPointLightElement;new():SVGFEPointLightElement;};interface SVGFESpecularLightingElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly in1:SVGAnimatedString;readonly kernelUnitLengthX:SVGAnimatedNumber;readonly kernelUnitLengthY:SVGAnimatedNumber;readonly specularConstant:SVGAnimatedNumber;readonly specularExponent:SVGAnimatedNumber;readonly surfaceScale:SVGAnimatedNumber;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFESpecularLightingElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFESpecularLightingElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFESpecularLightingElement:{prototype:SVGFESpecularLightingElement;new():SVGFESpecularLightingElement;};interface SVGFESpotLightElement extends SVGElement{readonly limitingConeAngle:SVGAnimatedNumber;readonly pointsAtX:SVGAnimatedNumber;readonly pointsAtY:SVGAnimatedNumber;readonly pointsAtZ:SVGAnimatedNumber;readonly specularExponent:SVGAnimatedNumber;readonly x:SVGAnimatedNumber;readonly y:SVGAnimatedNumber;readonly z:SVGAnimatedNumber;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFESpotLightElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFESpotLightElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFESpotLightElement:{prototype:SVGFESpotLightElement;new():SVGFESpotLightElement;};interface SVGFETileElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly in1:SVGAnimatedString;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFETileElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFETileElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFETileElement:{prototype:SVGFETileElement;new():SVGFETileElement;};interface SVGFETurbulenceElement extends SVGElement,SVGFilterPrimitiveStandardAttributes{readonly baseFrequencyX:SVGAnimatedNumber;readonly baseFrequencyY:SVGAnimatedNumber;readonly numOctaves:SVGAnimatedInteger;readonly seed:SVGAnimatedNumber;readonly stitchTiles:SVGAnimatedEnumeration;readonly type:SVGAnimatedEnumeration;readonly SVG_STITCHTYPE_NOSTITCH:number;readonly SVG_STITCHTYPE_STITCH:number;readonly SVG_STITCHTYPE_UNKNOWN:number;readonly SVG_TURBULENCE_TYPE_FRACTALNOISE:number;readonly SVG_TURBULENCE_TYPE_TURBULENCE:number;readonly SVG_TURBULENCE_TYPE_UNKNOWN:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFETurbulenceElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFETurbulenceElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFETurbulenceElement:{prototype:SVGFETurbulenceElement;new():SVGFETurbulenceElement;readonly SVG_STITCHTYPE_NOSTITCH:number;readonly SVG_STITCHTYPE_STITCH:number;readonly SVG_STITCHTYPE_UNKNOWN:number;readonly SVG_TURBULENCE_TYPE_FRACTALNOISE:number;readonly SVG_TURBULENCE_TYPE_TURBULENCE:number;readonly SVG_TURBULENCE_TYPE_UNKNOWN:number;};interface SVGFilterElement extends SVGElement,SVGURIReference{readonly filterUnits:SVGAnimatedEnumeration;readonly height:SVGAnimatedLength;readonly primitiveUnits:SVGAnimatedEnumeration;readonly width:SVGAnimatedLength;readonly x:SVGAnimatedLength;readonly y:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFilterElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGFilterElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGFilterElement:{prototype:SVGFilterElement;new():SVGFilterElement;};interface SVGFilterPrimitiveStandardAttributes{readonly height:SVGAnimatedLength;readonly result:SVGAnimatedString;readonly width:SVGAnimatedLength;readonly x:SVGAnimatedLength;readonly y:SVGAnimatedLength;}interface SVGFitToViewBox{readonly preserveAspectRatio:SVGAnimatedPreserveAspectRatio;readonly viewBox:SVGAnimatedRect;}interface SVGForeignObjectElement extends SVGGraphicsElement{readonly height:SVGAnimatedLength;readonly width:SVGAnimatedLength;readonly x:SVGAnimatedLength;readonly y:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGForeignObjectElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGForeignObjectElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGForeignObjectElement:{prototype:SVGForeignObjectElement;new():SVGForeignObjectElement;};interface SVGGElement extends SVGGraphicsElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGGElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGGElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGGElement:{prototype:SVGGElement;new():SVGGElement;};interface SVGGeometryElement extends SVGGraphicsElement{readonly pathLength:SVGAnimatedNumber;getPointAtLength(distance:number):DOMPoint;getTotalLength():number;isPointInFill(point?:DOMPointInit):boolean;isPointInStroke(point?:DOMPointInit):boolean;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGGeometryElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGGeometryElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGGeometryElement:{prototype:SVGGeometryElement;new():SVGGeometryElement;};interface SVGGradientElement extends SVGElement,SVGURIReference{readonly gradientTransform:SVGAnimatedTransformList;readonly gradientUnits:SVGAnimatedEnumeration;readonly spreadMethod:SVGAnimatedEnumeration;readonly SVG_SPREADMETHOD_PAD:number;readonly SVG_SPREADMETHOD_REFLECT:number;readonly SVG_SPREADMETHOD_REPEAT:number;readonly SVG_SPREADMETHOD_UNKNOWN:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGGradientElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGGradientElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGGradientElement:{prototype:SVGGradientElement;new():SVGGradientElement;readonly SVG_SPREADMETHOD_PAD:number;readonly SVG_SPREADMETHOD_REFLECT:number;readonly SVG_SPREADMETHOD_REPEAT:number;readonly SVG_SPREADMETHOD_UNKNOWN:number;};interface SVGGraphicsElement extends SVGElement,SVGTests{readonly transform:SVGAnimatedTransformList;getBBox(options?:SVGBoundingBoxOptions):DOMRect;getCTM():DOMMatrix|null;getScreenCTM():DOMMatrix|null;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGGraphicsElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGGraphicsElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGGraphicsElement:{prototype:SVGGraphicsElement;new():SVGGraphicsElement;};interface SVGImageElement extends SVGGraphicsElement,SVGURIReference{readonly height:SVGAnimatedLength;readonly preserveAspectRatio:SVGAnimatedPreserveAspectRatio;readonly width:SVGAnimatedLength;readonly x:SVGAnimatedLength;readonly y:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGImageElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGImageElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGImageElement:{prototype:SVGImageElement;new():SVGImageElement;};interface SVGLength{readonly unitType:number;value:number;valueAsString:string;valueInSpecifiedUnits:number;convertToSpecifiedUnits(unitType:number):void;newValueSpecifiedUnits(unitType:number,valueInSpecifiedUnits:number):void;readonly SVG_LENGTHTYPE_CM:number;readonly SVG_LENGTHTYPE_EMS:number;readonly SVG_LENGTHTYPE_EXS:number;readonly SVG_LENGTHTYPE_IN:number;readonly SVG_LENGTHTYPE_MM:number;readonly SVG_LENGTHTYPE_NUMBER:number;readonly SVG_LENGTHTYPE_PC:number;readonly SVG_LENGTHTYPE_PERCENTAGE:number;readonly SVG_LENGTHTYPE_PT:number;readonly SVG_LENGTHTYPE_PX:number;readonly SVG_LENGTHTYPE_UNKNOWN:number;}declare var SVGLength:{prototype:SVGLength;new():SVGLength;readonly SVG_LENGTHTYPE_CM:number;readonly SVG_LENGTHTYPE_EMS:number;readonly SVG_LENGTHTYPE_EXS:number;readonly SVG_LENGTHTYPE_IN:number;readonly SVG_LENGTHTYPE_MM:number;readonly SVG_LENGTHTYPE_NUMBER:number;readonly SVG_LENGTHTYPE_PC:number;readonly SVG_LENGTHTYPE_PERCENTAGE:number;readonly SVG_LENGTHTYPE_PT:number;readonly SVG_LENGTHTYPE_PX:number;readonly SVG_LENGTHTYPE_UNKNOWN:number;};interface SVGLengthList{readonly length:number;readonly numberOfItems:number;appendItem(newItem:SVGLength):SVGLength;clear():void;getItem(index:number):SVGLength;initialize(newItem:SVGLength):SVGLength;insertItemBefore(newItem:SVGLength,index:number):SVGLength;removeItem(index:number):SVGLength;replaceItem(newItem:SVGLength,index:number):SVGLength;[index:number]:SVGLength;}declare var SVGLengthList:{prototype:SVGLengthList;new():SVGLengthList;};interface SVGLineElement extends SVGGeometryElement{readonly x1:SVGAnimatedLength;readonly x2:SVGAnimatedLength;readonly y1:SVGAnimatedLength;readonly y2:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGLineElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGLineElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGLineElement:{prototype:SVGLineElement;new():SVGLineElement;};interface SVGLinearGradientElement extends SVGGradientElement{readonly x1:SVGAnimatedLength;readonly x2:SVGAnimatedLength;readonly y1:SVGAnimatedLength;readonly y2:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGLinearGradientElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGLinearGradientElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGLinearGradientElement:{prototype:SVGLinearGradientElement;new():SVGLinearGradientElement;};interface SVGMarkerElement extends SVGElement,SVGFitToViewBox{readonly markerHeight:SVGAnimatedLength;readonly markerUnits:SVGAnimatedEnumeration;readonly markerWidth:SVGAnimatedLength;readonly orientAngle:SVGAnimatedAngle;readonly orientType:SVGAnimatedEnumeration;readonly refX:SVGAnimatedLength;readonly refY:SVGAnimatedLength;setOrientToAngle(angle:SVGAngle):void;setOrientToAuto():void;readonly SVG_MARKERUNITS_STROKEWIDTH:number;readonly SVG_MARKERUNITS_UNKNOWN:number;readonly SVG_MARKERUNITS_USERSPACEONUSE:number;readonly SVG_MARKER_ORIENT_ANGLE:number;readonly SVG_MARKER_ORIENT_AUTO:number;readonly SVG_MARKER_ORIENT_UNKNOWN:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGMarkerElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGMarkerElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGMarkerElement:{prototype:SVGMarkerElement;new():SVGMarkerElement;readonly SVG_MARKERUNITS_STROKEWIDTH:number;readonly SVG_MARKERUNITS_UNKNOWN:number;readonly SVG_MARKERUNITS_USERSPACEONUSE:number;readonly SVG_MARKER_ORIENT_ANGLE:number;readonly SVG_MARKER_ORIENT_AUTO:number;readonly SVG_MARKER_ORIENT_UNKNOWN:number;};interface SVGMaskElement extends SVGElement{readonly height:SVGAnimatedLength;readonly maskContentUnits:SVGAnimatedEnumeration;readonly maskUnits:SVGAnimatedEnumeration;readonly width:SVGAnimatedLength;readonly x:SVGAnimatedLength;readonly y:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGMaskElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGMaskElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGMaskElement:{prototype:SVGMaskElement;new():SVGMaskElement;};interface SVGMetadataElement extends SVGElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGMetadataElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGMetadataElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGMetadataElement:{prototype:SVGMetadataElement;new():SVGMetadataElement;};interface SVGNumber{value:number;}declare var SVGNumber:{prototype:SVGNumber;new():SVGNumber;};interface SVGNumberList{readonly length:number;readonly numberOfItems:number;appendItem(newItem:SVGNumber):SVGNumber;clear():void;getItem(index:number):SVGNumber;initialize(newItem:SVGNumber):SVGNumber;insertItemBefore(newItem:SVGNumber,index:number):SVGNumber;removeItem(index:number):SVGNumber;replaceItem(newItem:SVGNumber,index:number):SVGNumber;[index:number]:SVGNumber;}declare var SVGNumberList:{prototype:SVGNumberList;new():SVGNumberList;};interface SVGPathElement extends SVGGraphicsElement{readonly pathSegList:SVGPathSegList;createSVGPathSegArcAbs(x:number,y:number,r1:number,r2:number,angle:number,largeArcFlag:boolean,sweepFlag:boolean):SVGPathSegArcAbs;createSVGPathSegArcRel(x:number,y:number,r1:number,r2:number,angle:number,largeArcFlag:boolean,sweepFlag:boolean):SVGPathSegArcRel;createSVGPathSegClosePath():SVGPathSegClosePath;createSVGPathSegCurvetoCubicAbs(x:number,y:number,x1:number,y1:number,x2:number,y2:number):SVGPathSegCurvetoCubicAbs;createSVGPathSegCurvetoCubicRel(x:number,y:number,x1:number,y1:number,x2:number,y2:number):SVGPathSegCurvetoCubicRel;createSVGPathSegCurvetoCubicSmoothAbs(x:number,y:number,x2:number,y2:number):SVGPathSegCurvetoCubicSmoothAbs;createSVGPathSegCurvetoCubicSmoothRel(x:number,y:number,x2:number,y2:number):SVGPathSegCurvetoCubicSmoothRel;createSVGPathSegCurvetoQuadraticAbs(x:number,y:number,x1:number,y1:number):SVGPathSegCurvetoQuadraticAbs;createSVGPathSegCurvetoQuadraticRel(x:number,y:number,x1:number,y1:number):SVGPathSegCurvetoQuadraticRel;createSVGPathSegCurvetoQuadraticSmoothAbs(x:number,y:number):SVGPathSegCurvetoQuadraticSmoothAbs;createSVGPathSegCurvetoQuadraticSmoothRel(x:number,y:number):SVGPathSegCurvetoQuadraticSmoothRel;createSVGPathSegLinetoAbs(x:number,y:number):SVGPathSegLinetoAbs;createSVGPathSegLinetoHorizontalAbs(x:number):SVGPathSegLinetoHorizontalAbs;createSVGPathSegLinetoHorizontalRel(x:number):SVGPathSegLinetoHorizontalRel;createSVGPathSegLinetoRel(x:number,y:number):SVGPathSegLinetoRel;createSVGPathSegLinetoVerticalAbs(y:number):SVGPathSegLinetoVerticalAbs;createSVGPathSegLinetoVerticalRel(y:number):SVGPathSegLinetoVerticalRel;createSVGPathSegMovetoAbs(x:number,y:number):SVGPathSegMovetoAbs;createSVGPathSegMovetoRel(x:number,y:number):SVGPathSegMovetoRel;getPathSegAtLength(distance:number):number;getPointAtLength(distance:number):SVGPoint;getTotalLength():number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGPathElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGPathElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGPathElement:{prototype:SVGPathElement;new():SVGPathElement;};interface SVGPathSeg{readonly pathSegType:number;readonly pathSegTypeAsLetter:string;readonly PATHSEG_ARC_ABS:number;readonly PATHSEG_ARC_REL:number;readonly PATHSEG_CLOSEPATH:number;readonly PATHSEG_CURVETO_CUBIC_ABS:number;readonly PATHSEG_CURVETO_CUBIC_REL:number;readonly PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:number;readonly PATHSEG_CURVETO_CUBIC_SMOOTH_REL:number;readonly PATHSEG_CURVETO_QUADRATIC_ABS:number;readonly PATHSEG_CURVETO_QUADRATIC_REL:number;readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:number;readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:number;readonly PATHSEG_LINETO_ABS:number;readonly PATHSEG_LINETO_HORIZONTAL_ABS:number;readonly PATHSEG_LINETO_HORIZONTAL_REL:number;readonly PATHSEG_LINETO_REL:number;readonly PATHSEG_LINETO_VERTICAL_ABS:number;readonly PATHSEG_LINETO_VERTICAL_REL:number;readonly PATHSEG_MOVETO_ABS:number;readonly PATHSEG_MOVETO_REL:number;readonly PATHSEG_UNKNOWN:number;}declare var SVGPathSeg:{prototype:SVGPathSeg;new():SVGPathSeg;readonly PATHSEG_ARC_ABS:number;readonly PATHSEG_ARC_REL:number;readonly PATHSEG_CLOSEPATH:number;readonly PATHSEG_CURVETO_CUBIC_ABS:number;readonly PATHSEG_CURVETO_CUBIC_REL:number;readonly PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:number;readonly PATHSEG_CURVETO_CUBIC_SMOOTH_REL:number;readonly PATHSEG_CURVETO_QUADRATIC_ABS:number;readonly PATHSEG_CURVETO_QUADRATIC_REL:number;readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:number;readonly PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:number;readonly PATHSEG_LINETO_ABS:number;readonly PATHSEG_LINETO_HORIZONTAL_ABS:number;readonly PATHSEG_LINETO_HORIZONTAL_REL:number;readonly PATHSEG_LINETO_REL:number;readonly PATHSEG_LINETO_VERTICAL_ABS:number;readonly PATHSEG_LINETO_VERTICAL_REL:number;readonly PATHSEG_MOVETO_ABS:number;readonly PATHSEG_MOVETO_REL:number;readonly PATHSEG_UNKNOWN:number;};interface SVGPathSegArcAbs extends SVGPathSeg{angle:number;largeArcFlag:boolean;r1:number;r2:number;sweepFlag:boolean;x:number;y:number;}declare var SVGPathSegArcAbs:{prototype:SVGPathSegArcAbs;new():SVGPathSegArcAbs;};interface SVGPathSegArcRel extends SVGPathSeg{angle:number;largeArcFlag:boolean;r1:number;r2:number;sweepFlag:boolean;x:number;y:number;}declare var SVGPathSegArcRel:{prototype:SVGPathSegArcRel;new():SVGPathSegArcRel;};interface SVGPathSegClosePath extends SVGPathSeg{}declare var SVGPathSegClosePath:{prototype:SVGPathSegClosePath;new():SVGPathSegClosePath;};interface SVGPathSegCurvetoCubicAbs extends SVGPathSeg{x:number;x1:number;x2:number;y:number;y1:number;y2:number;}declare var SVGPathSegCurvetoCubicAbs:{prototype:SVGPathSegCurvetoCubicAbs;new():SVGPathSegCurvetoCubicAbs;};interface SVGPathSegCurvetoCubicRel extends SVGPathSeg{x:number;x1:number;x2:number;y:number;y1:number;y2:number;}declare var SVGPathSegCurvetoCubicRel:{prototype:SVGPathSegCurvetoCubicRel;new():SVGPathSegCurvetoCubicRel;};interface SVGPathSegCurvetoCubicSmoothAbs extends SVGPathSeg{x:number;x2:number;y:number;y2:number;}declare var SVGPathSegCurvetoCubicSmoothAbs:{prototype:SVGPathSegCurvetoCubicSmoothAbs;new():SVGPathSegCurvetoCubicSmoothAbs;};interface SVGPathSegCurvetoCubicSmoothRel extends SVGPathSeg{x:number;x2:number;y:number;y2:number;}declare var SVGPathSegCurvetoCubicSmoothRel:{prototype:SVGPathSegCurvetoCubicSmoothRel;new():SVGPathSegCurvetoCubicSmoothRel;};interface SVGPathSegCurvetoQuadraticAbs extends SVGPathSeg{x:number;x1:number;y:number;y1:number;}declare var SVGPathSegCurvetoQuadraticAbs:{prototype:SVGPathSegCurvetoQuadraticAbs;new():SVGPathSegCurvetoQuadraticAbs;};interface SVGPathSegCurvetoQuadraticRel extends SVGPathSeg{x:number;x1:number;y:number;y1:number;}declare var SVGPathSegCurvetoQuadraticRel:{prototype:SVGPathSegCurvetoQuadraticRel;new():SVGPathSegCurvetoQuadraticRel;};interface SVGPathSegCurvetoQuadraticSmoothAbs extends SVGPathSeg{x:number;y:number;}declare var SVGPathSegCurvetoQuadraticSmoothAbs:{prototype:SVGPathSegCurvetoQuadraticSmoothAbs;new():SVGPathSegCurvetoQuadraticSmoothAbs;};interface SVGPathSegCurvetoQuadraticSmoothRel extends SVGPathSeg{x:number;y:number;}declare var SVGPathSegCurvetoQuadraticSmoothRel:{prototype:SVGPathSegCurvetoQuadraticSmoothRel;new():SVGPathSegCurvetoQuadraticSmoothRel;};interface SVGPathSegLinetoAbs extends SVGPathSeg{x:number;y:number;}declare var SVGPathSegLinetoAbs:{prototype:SVGPathSegLinetoAbs;new():SVGPathSegLinetoAbs;};interface SVGPathSegLinetoHorizontalAbs extends SVGPathSeg{x:number;}declare var SVGPathSegLinetoHorizontalAbs:{prototype:SVGPathSegLinetoHorizontalAbs;new():SVGPathSegLinetoHorizontalAbs;};interface SVGPathSegLinetoHorizontalRel extends SVGPathSeg{x:number;}declare var SVGPathSegLinetoHorizontalRel:{prototype:SVGPathSegLinetoHorizontalRel;new():SVGPathSegLinetoHorizontalRel;};interface SVGPathSegLinetoRel extends SVGPathSeg{x:number;y:number;}declare var SVGPathSegLinetoRel:{prototype:SVGPathSegLinetoRel;new():SVGPathSegLinetoRel;};interface SVGPathSegLinetoVerticalAbs extends SVGPathSeg{y:number;}declare var SVGPathSegLinetoVerticalAbs:{prototype:SVGPathSegLinetoVerticalAbs;new():SVGPathSegLinetoVerticalAbs;};interface SVGPathSegLinetoVerticalRel extends SVGPathSeg{y:number;}declare var SVGPathSegLinetoVerticalRel:{prototype:SVGPathSegLinetoVerticalRel;new():SVGPathSegLinetoVerticalRel;};interface SVGPathSegList{readonly numberOfItems:number;appendItem(newItem:SVGPathSeg):SVGPathSeg;clear():void;getItem(index:number):SVGPathSeg;initialize(newItem:SVGPathSeg):SVGPathSeg;insertItemBefore(newItem:SVGPathSeg,index:number):SVGPathSeg;removeItem(index:number):SVGPathSeg;replaceItem(newItem:SVGPathSeg,index:number):SVGPathSeg;}declare var SVGPathSegList:{prototype:SVGPathSegList;new():SVGPathSegList;};interface SVGPathSegMovetoAbs extends SVGPathSeg{x:number;y:number;}declare var SVGPathSegMovetoAbs:{prototype:SVGPathSegMovetoAbs;new():SVGPathSegMovetoAbs;};interface SVGPathSegMovetoRel extends SVGPathSeg{x:number;y:number;}declare var SVGPathSegMovetoRel:{prototype:SVGPathSegMovetoRel;new():SVGPathSegMovetoRel;};interface SVGPatternElement extends SVGElement,SVGFitToViewBox,SVGURIReference{readonly height:SVGAnimatedLength;readonly patternContentUnits:SVGAnimatedEnumeration;readonly patternTransform:SVGAnimatedTransformList;readonly patternUnits:SVGAnimatedEnumeration;readonly width:SVGAnimatedLength;readonly x:SVGAnimatedLength;readonly y:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGPatternElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGPatternElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGPatternElement:{prototype:SVGPatternElement;new():SVGPatternElement;};interface SVGPointList{readonly length:number;readonly numberOfItems:number;appendItem(newItem:DOMPoint):DOMPoint;clear():void;getItem(index:number):DOMPoint;initialize(newItem:DOMPoint):DOMPoint;insertItemBefore(newItem:DOMPoint,index:number):DOMPoint;removeItem(index:number):DOMPoint;replaceItem(newItem:DOMPoint,index:number):DOMPoint;[index:number]:DOMPoint;}declare var SVGPointList:{prototype:SVGPointList;new():SVGPointList;};interface SVGPolygonElement extends SVGGeometryElement,SVGAnimatedPoints{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGPolygonElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGPolygonElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGPolygonElement:{prototype:SVGPolygonElement;new():SVGPolygonElement;};interface SVGPolylineElement extends SVGGeometryElement,SVGAnimatedPoints{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGPolylineElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGPolylineElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGPolylineElement:{prototype:SVGPolylineElement;new():SVGPolylineElement;};interface SVGPreserveAspectRatio{align:number;meetOrSlice:number;readonly SVG_MEETORSLICE_MEET:number;readonly SVG_MEETORSLICE_SLICE:number;readonly SVG_MEETORSLICE_UNKNOWN:number;readonly SVG_PRESERVEASPECTRATIO_NONE:number;readonly SVG_PRESERVEASPECTRATIO_UNKNOWN:number;readonly SVG_PRESERVEASPECTRATIO_XMAXYMAX:number;readonly SVG_PRESERVEASPECTRATIO_XMAXYMID:number;readonly SVG_PRESERVEASPECTRATIO_XMAXYMIN:number;readonly SVG_PRESERVEASPECTRATIO_XMIDYMAX:number;readonly SVG_PRESERVEASPECTRATIO_XMIDYMID:number;readonly SVG_PRESERVEASPECTRATIO_XMIDYMIN:number;readonly SVG_PRESERVEASPECTRATIO_XMINYMAX:number;readonly SVG_PRESERVEASPECTRATIO_XMINYMID:number;readonly SVG_PRESERVEASPECTRATIO_XMINYMIN:number;}declare var SVGPreserveAspectRatio:{prototype:SVGPreserveAspectRatio;new():SVGPreserveAspectRatio;readonly SVG_MEETORSLICE_MEET:number;readonly SVG_MEETORSLICE_SLICE:number;readonly SVG_MEETORSLICE_UNKNOWN:number;readonly SVG_PRESERVEASPECTRATIO_NONE:number;readonly SVG_PRESERVEASPECTRATIO_UNKNOWN:number;readonly SVG_PRESERVEASPECTRATIO_XMAXYMAX:number;readonly SVG_PRESERVEASPECTRATIO_XMAXYMID:number;readonly SVG_PRESERVEASPECTRATIO_XMAXYMIN:number;readonly SVG_PRESERVEASPECTRATIO_XMIDYMAX:number;readonly SVG_PRESERVEASPECTRATIO_XMIDYMID:number;readonly SVG_PRESERVEASPECTRATIO_XMIDYMIN:number;readonly SVG_PRESERVEASPECTRATIO_XMINYMAX:number;readonly SVG_PRESERVEASPECTRATIO_XMINYMID:number;readonly SVG_PRESERVEASPECTRATIO_XMINYMIN:number;};interface SVGRadialGradientElement extends SVGGradientElement{readonly cx:SVGAnimatedLength;readonly cy:SVGAnimatedLength;readonly fr:SVGAnimatedLength;readonly fx:SVGAnimatedLength;readonly fy:SVGAnimatedLength;readonly r:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGRadialGradientElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGRadialGradientElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGRadialGradientElement:{prototype:SVGRadialGradientElement;new():SVGRadialGradientElement;};interface SVGRectElement extends SVGGeometryElement{readonly height:SVGAnimatedLength;readonly rx:SVGAnimatedLength;readonly ry:SVGAnimatedLength;readonly width:SVGAnimatedLength;readonly x:SVGAnimatedLength;readonly y:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGRectElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGRectElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGRectElement:{prototype:SVGRectElement;new():SVGRectElement;};interface SVGSVGElementEventMap extends SVGElementEventMap{"SVGUnload":Event;"SVGZoom":SVGZoomEvent;}interface SVGSVGElement extends SVGGraphicsElement,DocumentEvent,SVGFitToViewBox,SVGZoomAndPan{contentScriptType:string;contentStyleType:string;currentScale:number;readonly currentTranslate:SVGPoint;readonly height:SVGAnimatedLength;onunload:((this:SVGSVGElement,ev:Event)=>any)|null;onzoom:((this:SVGSVGElement,ev:SVGZoomEvent)=>any)|null;readonly pixelUnitToMillimeterX:number;readonly pixelUnitToMillimeterY:number;readonly screenPixelToMillimeterX:number;readonly screenPixelToMillimeterY:number;readonly viewport:SVGRect;readonly width:SVGAnimatedLength;readonly x:SVGAnimatedLength;readonly y:SVGAnimatedLength;animationsPaused():boolean;checkEnclosure(element:SVGElement,rect:SVGRect):boolean;checkIntersection(element:SVGElement,rect:SVGRect):boolean;createSVGAngle():SVGAngle;createSVGLength():SVGLength;createSVGMatrix():SVGMatrix;createSVGNumber():SVGNumber;createSVGPoint():SVGPoint;createSVGRect():SVGRect;createSVGTransform():SVGTransform;createSVGTransformFromMatrix(matrix:SVGMatrix):SVGTransform;deselectAll():void;forceRedraw():void;getComputedStyle(elt:Element,pseudoElt?:string|null):CSSStyleDeclaration;getCurrentTime():number;getElementById(elementId:string):Element;getEnclosureList(rect:SVGRect,referenceElement:SVGElement):NodeListOf<SVGCircleElement|SVGEllipseElement|SVGImageElement|SVGLineElement|SVGPathElement|SVGPolygonElement|SVGPolylineElement|SVGRectElement|SVGTextElement|SVGUseElement>;getIntersectionList(rect:SVGRect,referenceElement:SVGElement):NodeListOf<SVGCircleElement|SVGEllipseElement|SVGImageElement|SVGLineElement|SVGPathElement|SVGPolygonElement|SVGPolylineElement|SVGRectElement|SVGTextElement|SVGUseElement>;pauseAnimations():void;setCurrentTime(seconds:number):void;suspendRedraw(maxWaitMilliseconds:number):number;unpauseAnimations():void;unsuspendRedraw(suspendHandleID:number):void;unsuspendRedrawAll():void;addEventListener<K extends keyof SVGSVGElementEventMap>(type:K,listener:(this:SVGSVGElement,ev:SVGSVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGSVGElementEventMap>(type:K,listener:(this:SVGSVGElement,ev:SVGSVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGSVGElement:{prototype:SVGSVGElement;new():SVGSVGElement;readonly SVG_ZOOMANDPAN_DISABLE:number;readonly SVG_ZOOMANDPAN_MAGNIFY:number;readonly SVG_ZOOMANDPAN_UNKNOWN:number;};interface SVGScriptElement extends SVGElement,SVGURIReference{type:string;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGScriptElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGScriptElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGScriptElement:{prototype:SVGScriptElement;new():SVGScriptElement;};interface SVGStopElement extends SVGElement{readonly offset:SVGAnimatedNumber;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGStopElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGStopElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGStopElement:{prototype:SVGStopElement;new():SVGStopElement;};interface SVGStringList{readonly length:number;readonly numberOfItems:number;appendItem(newItem:string):string;clear():void;getItem(index:number):string;initialize(newItem:string):string;insertItemBefore(newItem:string,index:number):string;removeItem(index:number):string;replaceItem(newItem:string,index:number):string;[index:number]:string;}declare var SVGStringList:{prototype:SVGStringList;new():SVGStringList;};interface SVGStyleElement extends SVGElement{disabled:boolean;media:string;title:string;type:string;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGStyleElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGStyleElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGStyleElement:{prototype:SVGStyleElement;new():SVGStyleElement;};interface SVGSwitchElement extends SVGGraphicsElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGSwitchElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGSwitchElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGSwitchElement:{prototype:SVGSwitchElement;new():SVGSwitchElement;};interface SVGSymbolElement extends SVGElement,SVGFitToViewBox{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGSymbolElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGSymbolElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGSymbolElement:{prototype:SVGSymbolElement;new():SVGSymbolElement;};interface SVGTSpanElement extends SVGTextPositioningElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTSpanElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTSpanElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGTSpanElement:{prototype:SVGTSpanElement;new():SVGTSpanElement;};interface SVGTests{readonly requiredExtensions:SVGStringList;readonly systemLanguage:SVGStringList;}interface SVGTextContentElement extends SVGGraphicsElement{readonly lengthAdjust:SVGAnimatedEnumeration;readonly textLength:SVGAnimatedLength;getCharNumAtPosition(point?:DOMPointInit):number;getComputedTextLength():number;getEndPositionOfChar(charnum:number):DOMPoint;getExtentOfChar(charnum:number):DOMRect;getNumberOfChars():number;getRotationOfChar(charnum:number):number;getStartPositionOfChar(charnum:number):DOMPoint;getSubStringLength(charnum:number,nchars:number):number;selectSubString(charnum:number,nchars:number):void;readonly LENGTHADJUST_SPACING:number;readonly LENGTHADJUST_SPACINGANDGLYPHS:number;readonly LENGTHADJUST_UNKNOWN:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTextContentElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTextContentElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGTextContentElement:{prototype:SVGTextContentElement;new():SVGTextContentElement;readonly LENGTHADJUST_SPACING:number;readonly LENGTHADJUST_SPACINGANDGLYPHS:number;readonly LENGTHADJUST_UNKNOWN:number;};interface SVGTextElement extends SVGTextPositioningElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTextElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTextElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGTextElement:{prototype:SVGTextElement;new():SVGTextElement;};interface SVGTextPathElement extends SVGTextContentElement,SVGURIReference{readonly method:SVGAnimatedEnumeration;readonly spacing:SVGAnimatedEnumeration;readonly startOffset:SVGAnimatedLength;readonly TEXTPATH_METHODTYPE_ALIGN:number;readonly TEXTPATH_METHODTYPE_STRETCH:number;readonly TEXTPATH_METHODTYPE_UNKNOWN:number;readonly TEXTPATH_SPACINGTYPE_AUTO:number;readonly TEXTPATH_SPACINGTYPE_EXACT:number;readonly TEXTPATH_SPACINGTYPE_UNKNOWN:number;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTextPathElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTextPathElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGTextPathElement:{prototype:SVGTextPathElement;new():SVGTextPathElement;readonly TEXTPATH_METHODTYPE_ALIGN:number;readonly TEXTPATH_METHODTYPE_STRETCH:number;readonly TEXTPATH_METHODTYPE_UNKNOWN:number;readonly TEXTPATH_SPACINGTYPE_AUTO:number;readonly TEXTPATH_SPACINGTYPE_EXACT:number;readonly TEXTPATH_SPACINGTYPE_UNKNOWN:number;};interface SVGTextPositioningElement extends SVGTextContentElement{readonly dx:SVGAnimatedLengthList;readonly dy:SVGAnimatedLengthList;readonly rotate:SVGAnimatedNumberList;readonly x:SVGAnimatedLengthList;readonly y:SVGAnimatedLengthList;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTextPositioningElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTextPositioningElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGTextPositioningElement:{prototype:SVGTextPositioningElement;new():SVGTextPositioningElement;};interface SVGTitleElement extends SVGElement{addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTitleElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGTitleElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGTitleElement:{prototype:SVGTitleElement;new():SVGTitleElement;};interface SVGTransform{readonly angle:number;readonly matrix:SVGMatrix;readonly type:number;setMatrix(matrix:SVGMatrix):void;setRotate(angle:number,cx:number,cy:number):void;setScale(sx:number,sy:number):void;setSkewX(angle:number):void;setSkewY(angle:number):void;setTranslate(tx:number,ty:number):void;readonly SVG_TRANSFORM_MATRIX:number;readonly SVG_TRANSFORM_ROTATE:number;readonly SVG_TRANSFORM_SCALE:number;readonly SVG_TRANSFORM_SKEWX:number;readonly SVG_TRANSFORM_SKEWY:number;readonly SVG_TRANSFORM_TRANSLATE:number;readonly SVG_TRANSFORM_UNKNOWN:number;}declare var SVGTransform:{prototype:SVGTransform;new():SVGTransform;readonly SVG_TRANSFORM_MATRIX:number;readonly SVG_TRANSFORM_ROTATE:number;readonly SVG_TRANSFORM_SCALE:number;readonly SVG_TRANSFORM_SKEWX:number;readonly SVG_TRANSFORM_SKEWY:number;readonly SVG_TRANSFORM_TRANSLATE:number;readonly SVG_TRANSFORM_UNKNOWN:number;};interface SVGTransformList{readonly numberOfItems:number;appendItem(newItem:SVGTransform):SVGTransform;clear():void;consolidate():SVGTransform;createSVGTransformFromMatrix(matrix:SVGMatrix):SVGTransform;getItem(index:number):SVGTransform;initialize(newItem:SVGTransform):SVGTransform;insertItemBefore(newItem:SVGTransform,index:number):SVGTransform;removeItem(index:number):SVGTransform;replaceItem(newItem:SVGTransform,index:number):SVGTransform;}declare var SVGTransformList:{prototype:SVGTransformList;new():SVGTransformList;};interface SVGURIReference{readonly href:SVGAnimatedString;}interface SVGUnitTypes{readonly SVG_UNIT_TYPE_OBJECTBOUNDINGBOX:number;readonly SVG_UNIT_TYPE_UNKNOWN:number;readonly SVG_UNIT_TYPE_USERSPACEONUSE:number;}declare var SVGUnitTypes:{prototype:SVGUnitTypes;new():SVGUnitTypes;readonly SVG_UNIT_TYPE_OBJECTBOUNDINGBOX:number;readonly SVG_UNIT_TYPE_UNKNOWN:number;readonly SVG_UNIT_TYPE_USERSPACEONUSE:number;};interface SVGUseElement extends SVGGraphicsElement,SVGURIReference{readonly animatedInstanceRoot:SVGElementInstance|null;readonly height:SVGAnimatedLength;readonly instanceRoot:SVGElementInstance|null;readonly width:SVGAnimatedLength;readonly x:SVGAnimatedLength;readonly y:SVGAnimatedLength;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGUseElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGUseElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGUseElement:{prototype:SVGUseElement;new():SVGUseElement;};interface SVGViewElement extends SVGElement,SVGFitToViewBox,SVGZoomAndPan{readonly viewTarget:SVGStringList;addEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGViewElement,ev:SVGElementEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SVGElementEventMap>(type:K,listener:(this:SVGViewElement,ev:SVGElementEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SVGViewElement:{prototype:SVGViewElement;new():SVGViewElement;readonly SVG_ZOOMANDPAN_DISABLE:number;readonly SVG_ZOOMANDPAN_MAGNIFY:number;readonly SVG_ZOOMANDPAN_UNKNOWN:number;};interface SVGZoomAndPan{readonly zoomAndPan:number;}declare var SVGZoomAndPan:{readonly SVG_ZOOMANDPAN_DISABLE:number;readonly SVG_ZOOMANDPAN_MAGNIFY:number;readonly SVG_ZOOMANDPAN_UNKNOWN:number;};interface SVGZoomEvent extends UIEvent{readonly newScale:number;readonly newTranslate:SVGPoint;readonly previousScale:number;readonly previousTranslate:SVGPoint;readonly zoomRectScreen:SVGRect;}declare var SVGZoomEvent:{prototype:SVGZoomEvent;new():SVGZoomEvent;};interface ScopedCredential{readonly id:ArrayBuffer;readonly type:ScopedCredentialType;}declare var ScopedCredential:{prototype:ScopedCredential;new():ScopedCredential;};interface ScopedCredentialInfo{readonly credential:ScopedCredential;readonly publicKey:CryptoKey;}declare var ScopedCredentialInfo:{prototype:ScopedCredentialInfo;new():ScopedCredentialInfo;};interface Screen{readonly availHeight:number;readonly availWidth:number;readonly colorDepth:number;readonly height:number;readonly orientation:ScreenOrientation;readonly pixelDepth:number;readonly width:number;}declare var Screen:{prototype:Screen;new():Screen;};interface ScreenOrientationEventMap{"change":Event;}interface ScreenOrientation extends EventTarget{readonly angle:number;onchange:((this:ScreenOrientation,ev:Event)=>any)|null;readonly type:OrientationType;lock(orientation:OrientationLockType):Promise<void>;unlock():void;addEventListener<K extends keyof ScreenOrientationEventMap>(type:K,listener:(this:ScreenOrientation,ev:ScreenOrientationEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ScreenOrientationEventMap>(type:K,listener:(this:ScreenOrientation,ev:ScreenOrientationEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ScreenOrientation:{prototype:ScreenOrientation;new():ScreenOrientation;};interface ScriptProcessorNodeEventMap{"audioprocess":AudioProcessingEvent;}interface ScriptProcessorNode extends AudioNode{readonly bufferSize:number;onaudioprocess:((this:ScriptProcessorNode,ev:AudioProcessingEvent)=>any)|null;addEventListener<K extends keyof ScriptProcessorNodeEventMap>(type:K,listener:(this:ScriptProcessorNode,ev:ScriptProcessorNodeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ScriptProcessorNodeEventMap>(type:K,listener:(this:ScriptProcessorNode,ev:ScriptProcessorNodeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ScriptProcessorNode:{prototype:ScriptProcessorNode;new():ScriptProcessorNode;};interface SecurityPolicyViolationEvent extends Event{readonly blockedURI:string;readonly columnNumber:number;readonly documentURI:string;readonly effectiveDirective:string;readonly lineNumber:number;readonly originalPolicy:string;readonly referrer:string;readonly sourceFile:string;readonly statusCode:number;readonly violatedDirective:string;}declare var SecurityPolicyViolationEvent:{prototype:SecurityPolicyViolationEvent;new(type:string,eventInitDict?:SecurityPolicyViolationEventInit):SecurityPolicyViolationEvent;};interface Selection{readonly anchorNode:Node|null;readonly anchorOffset:number;readonly focusNode:Node|null;readonly focusOffset:number;readonly isCollapsed:boolean;readonly rangeCount:number;readonly type:string;addRange(range:Range):void;collapse(node:Node|null,offset?:number):void;collapseToEnd():void;collapseToStart():void;containsNode(node:Node,allowPartialContainment?:boolean):boolean;deleteFromDocument():void;empty():void;extend(node:Node,offset?:number):void;getRangeAt(index:number):Range;removeAllRanges():void;removeRange(range:Range):void;selectAllChildren(node:Node):void;setBaseAndExtent(anchorNode:Node,anchorOffset:number,focusNode:Node,focusOffset:number):void;setPosition(node:Node|null,offset?:number):void;toString():string;}declare var Selection:{prototype:Selection;new():Selection;toString():string;};interface ServiceUIFrameContext{getCachedFrameMessage(key:string):string;postFrameMessage(key:string,data:string):void;}declare var ServiceUIFrameContext:ServiceUIFrameContext;interface ServiceWorkerEventMap extends AbstractWorkerEventMap{"statechange":Event;}interface ServiceWorker extends EventTarget,AbstractWorker{onstatechange:((this:ServiceWorker,ev:Event)=>any)|null;readonly scriptURL:string;readonly state:ServiceWorkerState;postMessage(message:any,transfer:Transferable[]):void;postMessage(message:any,options?:PostMessageOptions):void;addEventListener<K extends keyof ServiceWorkerEventMap>(type:K,listener:(this:ServiceWorker,ev:ServiceWorkerEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ServiceWorkerEventMap>(type:K,listener:(this:ServiceWorker,ev:ServiceWorkerEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ServiceWorker:{prototype:ServiceWorker;new():ServiceWorker;};interface ServiceWorkerContainerEventMap{"controllerchange":Event;"message":MessageEvent;"messageerror":MessageEvent;}interface ServiceWorkerContainer extends EventTarget{readonly controller:ServiceWorker|null;oncontrollerchange:((this:ServiceWorkerContainer,ev:Event)=>any)|null;onmessage:((this:ServiceWorkerContainer,ev:MessageEvent)=>any)|null;onmessageerror:((this:ServiceWorkerContainer,ev:MessageEvent)=>any)|null;readonly ready:Promise<ServiceWorkerRegistration>;getRegistration(clientURL?:string):Promise<ServiceWorkerRegistration|undefined>;getRegistrations():Promise<ReadonlyArray<ServiceWorkerRegistration>>;register(scriptURL:string,options?:RegistrationOptions):Promise<ServiceWorkerRegistration>;startMessages():void;addEventListener<K extends keyof ServiceWorkerContainerEventMap>(type:K,listener:(this:ServiceWorkerContainer,ev:ServiceWorkerContainerEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ServiceWorkerContainerEventMap>(type:K,listener:(this:ServiceWorkerContainer,ev:ServiceWorkerContainerEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ServiceWorkerContainer:{prototype:ServiceWorkerContainer;new():ServiceWorkerContainer;};interface ServiceWorkerMessageEvent extends Event{readonly data:any;readonly lastEventId:string;readonly origin:string;readonly ports:ReadonlyArray<MessagePort>|null;readonly source:ServiceWorker|MessagePort|null;}declare var ServiceWorkerMessageEvent:{prototype:ServiceWorkerMessageEvent;new(type:string,eventInitDict?:ServiceWorkerMessageEventInit):ServiceWorkerMessageEvent;};interface ServiceWorkerRegistrationEventMap{"updatefound":Event;}interface ServiceWorkerRegistration extends EventTarget{readonly active:ServiceWorker|null;readonly installing:ServiceWorker|null;readonly navigationPreload:NavigationPreloadManager;onupdatefound:((this:ServiceWorkerRegistration,ev:Event)=>any)|null;readonly pushManager:PushManager;readonly scope:string;readonly sync:SyncManager;readonly updateViaCache:ServiceWorkerUpdateViaCache;readonly waiting:ServiceWorker|null;getNotifications(filter?:GetNotificationOptions):Promise<Notification[]>;showNotification(title:string,options?:NotificationOptions):Promise<void>;unregister():Promise<boolean>;update():Promise<void>;addEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type:K,listener:(this:ServiceWorkerRegistration,ev:ServiceWorkerRegistrationEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type:K,listener:(this:ServiceWorkerRegistration,ev:ServiceWorkerRegistrationEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ServiceWorkerRegistration:{prototype:ServiceWorkerRegistration;new():ServiceWorkerRegistration;};interface ShadowRoot extends DocumentFragment,DocumentOrShadowRoot,InnerHTML{readonly host:Element;readonly mode:ShadowRootMode;}declare var ShadowRoot:{prototype:ShadowRoot;new():ShadowRoot;};interface SharedWorker extends EventTarget,AbstractWorker{readonly port:MessagePort;addEventListener<K extends keyof AbstractWorkerEventMap>(type:K,listener:(this:SharedWorker,ev:AbstractWorkerEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AbstractWorkerEventMap>(type:K,listener:(this:SharedWorker,ev:AbstractWorkerEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SharedWorker:{prototype:SharedWorker;new(scriptURL:string,options?:string|WorkerOptions):SharedWorker;};interface Slotable{readonly assignedSlot:HTMLSlotElement|null;}interface SourceBufferEventMap{"abort":Event;"error":Event;"update":Event;"updateend":Event;"updatestart":Event;}interface SourceBuffer extends EventTarget{appendWindowEnd:number;appendWindowStart:number;readonly buffered:TimeRanges;mode:AppendMode;onabort:((this:SourceBuffer,ev:Event)=>any)|null;onerror:((this:SourceBuffer,ev:Event)=>any)|null;onupdate:((this:SourceBuffer,ev:Event)=>any)|null;onupdateend:((this:SourceBuffer,ev:Event)=>any)|null;onupdatestart:((this:SourceBuffer,ev:Event)=>any)|null;timestampOffset:number;readonly updating:boolean;abort():void;appendBuffer(data:BufferSource):void;remove(start:number,end:number):void;addEventListener<K extends keyof SourceBufferEventMap>(type:K,listener:(this:SourceBuffer,ev:SourceBufferEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SourceBufferEventMap>(type:K,listener:(this:SourceBuffer,ev:SourceBufferEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SourceBuffer:{prototype:SourceBuffer;new():SourceBuffer;};interface SourceBufferListEventMap{"addsourcebuffer":Event;"removesourcebuffer":Event;}interface SourceBufferList extends EventTarget{readonly length:number;onaddsourcebuffer:((this:SourceBufferList,ev:Event)=>any)|null;onremovesourcebuffer:((this:SourceBufferList,ev:Event)=>any)|null;addEventListener<K extends keyof SourceBufferListEventMap>(type:K,listener:(this:SourceBufferList,ev:SourceBufferListEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SourceBufferListEventMap>(type:K,listener:(this:SourceBufferList,ev:SourceBufferListEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;[index:number]:SourceBuffer;}declare var SourceBufferList:{prototype:SourceBufferList;new():SourceBufferList;};interface SpeechGrammar{src:string;weight:number;}declare var SpeechGrammar:{prototype:SpeechGrammar;new():SpeechGrammar;};interface SpeechGrammarList{readonly length:number;addFromString(string:string,weight?:number):void;addFromURI(src:string,weight?:number):void;item(index:number):SpeechGrammar;[index:number]:SpeechGrammar;}declare var SpeechGrammarList:{prototype:SpeechGrammarList;new():SpeechGrammarList;};interface SpeechRecognitionEventMap{"audioend":Event;"audiostart":Event;"end":Event;"error":Event;"nomatch":SpeechRecognitionEvent;"result":SpeechRecognitionEvent;"soundend":Event;"soundstart":Event;"speechend":Event;"speechstart":Event;"start":Event;}interface SpeechRecognition extends EventTarget{continuous:boolean;grammars:SpeechGrammarList;interimResults:boolean;lang:string;maxAlternatives:number;onaudioend:((this:SpeechRecognition,ev:Event)=>any)|null;onaudiostart:((this:SpeechRecognition,ev:Event)=>any)|null;onend:((this:SpeechRecognition,ev:Event)=>any)|null;onerror:((this:SpeechRecognition,ev:Event)=>any)|null;onnomatch:((this:SpeechRecognition,ev:SpeechRecognitionEvent)=>any)|null;onresult:((this:SpeechRecognition,ev:SpeechRecognitionEvent)=>any)|null;onsoundend:((this:SpeechRecognition,ev:Event)=>any)|null;onsoundstart:((this:SpeechRecognition,ev:Event)=>any)|null;onspeechend:((this:SpeechRecognition,ev:Event)=>any)|null;onspeechstart:((this:SpeechRecognition,ev:Event)=>any)|null;onstart:((this:SpeechRecognition,ev:Event)=>any)|null;abort():void;start():void;stop():void;addEventListener<K extends keyof SpeechRecognitionEventMap>(type:K,listener:(this:SpeechRecognition,ev:SpeechRecognitionEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SpeechRecognitionEventMap>(type:K,listener:(this:SpeechRecognition,ev:SpeechRecognitionEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SpeechRecognition:{prototype:SpeechRecognition;new():SpeechRecognition;};interface SpeechRecognitionAlternative{readonly confidence:number;readonly transcript:string;}declare var SpeechRecognitionAlternative:{prototype:SpeechRecognitionAlternative;new():SpeechRecognitionAlternative;};interface SpeechRecognitionEvent extends Event{readonly resultIndex:number;readonly results:SpeechRecognitionResultList;}declare var SpeechRecognitionEvent:{prototype:SpeechRecognitionEvent;new():SpeechRecognitionEvent;};interface SpeechRecognitionResult{readonly isFinal:boolean;readonly length:number;item(index:number):SpeechRecognitionAlternative;[index:number]:SpeechRecognitionAlternative;}declare var SpeechRecognitionResult:{prototype:SpeechRecognitionResult;new():SpeechRecognitionResult;};interface SpeechRecognitionResultList{readonly length:number;item(index:number):SpeechRecognitionResult;[index:number]:SpeechRecognitionResult;}declare var SpeechRecognitionResultList:{prototype:SpeechRecognitionResultList;new():SpeechRecognitionResultList;};interface SpeechSynthesisEventMap{"voiceschanged":Event;}interface SpeechSynthesis extends EventTarget{onvoiceschanged:((this:SpeechSynthesis,ev:Event)=>any)|null;readonly paused:boolean;readonly pending:boolean;readonly speaking:boolean;cancel():void;getVoices():SpeechSynthesisVoice[];pause():void;resume():void;speak(utterance:SpeechSynthesisUtterance):void;addEventListener<K extends keyof SpeechSynthesisEventMap>(type:K,listener:(this:SpeechSynthesis,ev:SpeechSynthesisEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SpeechSynthesisEventMap>(type:K,listener:(this:SpeechSynthesis,ev:SpeechSynthesisEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SpeechSynthesis:{prototype:SpeechSynthesis;new():SpeechSynthesis;};interface SpeechSynthesisErrorEvent extends SpeechSynthesisEvent{readonly error:SpeechSynthesisErrorCode;}declare var SpeechSynthesisErrorEvent:{prototype:SpeechSynthesisErrorEvent;new(type:string,eventInitDict:SpeechSynthesisErrorEventInit):SpeechSynthesisErrorEvent;};interface SpeechSynthesisEvent extends Event{readonly charIndex:number;readonly charLength:number;readonly elapsedTime:number;readonly name:string;readonly utterance:SpeechSynthesisUtterance;}declare var SpeechSynthesisEvent:{prototype:SpeechSynthesisEvent;new(type:string,eventInitDict:SpeechSynthesisEventInit):SpeechSynthesisEvent;};interface SpeechSynthesisUtteranceEventMap{"boundary":SpeechSynthesisEvent;"end":SpeechSynthesisEvent;"error":SpeechSynthesisErrorEvent;"mark":SpeechSynthesisEvent;"pause":SpeechSynthesisEvent;"resume":SpeechSynthesisEvent;"start":SpeechSynthesisEvent;}interface SpeechSynthesisUtterance extends EventTarget{lang:string;onboundary:((this:SpeechSynthesisUtterance,ev:SpeechSynthesisEvent)=>any)|null;onend:((this:SpeechSynthesisUtterance,ev:SpeechSynthesisEvent)=>any)|null;onerror:((this:SpeechSynthesisUtterance,ev:SpeechSynthesisErrorEvent)=>any)|null;onmark:((this:SpeechSynthesisUtterance,ev:SpeechSynthesisEvent)=>any)|null;onpause:((this:SpeechSynthesisUtterance,ev:SpeechSynthesisEvent)=>any)|null;onresume:((this:SpeechSynthesisUtterance,ev:SpeechSynthesisEvent)=>any)|null;onstart:((this:SpeechSynthesisUtterance,ev:SpeechSynthesisEvent)=>any)|null;pitch:number;rate:number;text:string;voice:SpeechSynthesisVoice|null;volume:number;addEventListener<K extends keyof SpeechSynthesisUtteranceEventMap>(type:K,listener:(this:SpeechSynthesisUtterance,ev:SpeechSynthesisUtteranceEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SpeechSynthesisUtteranceEventMap>(type:K,listener:(this:SpeechSynthesisUtterance,ev:SpeechSynthesisUtteranceEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SpeechSynthesisUtterance:{prototype:SpeechSynthesisUtterance;new(text?:string):SpeechSynthesisUtterance;};interface SpeechSynthesisVoice{readonly default:boolean;readonly lang:string;readonly localService:boolean;readonly name:string;readonly voiceURI:string;}declare var SpeechSynthesisVoice:{prototype:SpeechSynthesisVoice;new():SpeechSynthesisVoice;};interface StaticRange extends AbstractRange{}declare var StaticRange:{prototype:StaticRange;new(init:StaticRangeInit):StaticRange;};interface StereoPannerNode extends AudioNode{readonly pan:AudioParam;}declare var StereoPannerNode:{prototype:StereoPannerNode;new(context:BaseAudioContext,options?:StereoPannerOptions):StereoPannerNode;};interface Storage{readonly length:number;clear():void;getItem(key:string):string|null;key(index:number):string|null;removeItem(key:string):void;setItem(key:string,value:string):void;[name:string]:any;}declare var Storage:{prototype:Storage;new():Storage;};interface StorageEvent extends Event{readonly key:string|null;readonly newValue:string|null;readonly oldValue:string|null;readonly storageArea:Storage|null;readonly url:string;}declare var StorageEvent:{prototype:StorageEvent;new(type:string,eventInitDict?:StorageEventInit):StorageEvent;};interface StorageManager{estimate():Promise<StorageEstimate>;persist():Promise<boolean>;persisted():Promise<boolean>;}declare var StorageManager:{prototype:StorageManager;new():StorageManager;};interface StyleMedia{readonly type:string;matchMedium(mediaquery:string):boolean;}declare var StyleMedia:{prototype:StyleMedia;new():StyleMedia;};interface StyleSheet{disabled:boolean;readonly href:string|null;readonly media:MediaList;readonly ownerNode:Element|ProcessingInstruction|null;readonly parentStyleSheet:CSSStyleSheet|null;readonly title:string|null;readonly type:string;}declare var StyleSheet:{prototype:StyleSheet;new():StyleSheet;};interface StyleSheetList{readonly length:number;item(index:number):CSSStyleSheet|null;[index:number]:CSSStyleSheet;}declare var StyleSheetList:{prototype:StyleSheetList;new():StyleSheetList;};interface SubtleCrypto{decrypt(algorithm:AlgorithmIdentifier|RsaOaepParams|AesCtrParams|AesCbcParams|AesCmacParams|AesGcmParams|AesCfbParams,key:CryptoKey,data:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer):PromiseLike<ArrayBuffer>;deriveBits(algorithm:AlgorithmIdentifier|EcdhKeyDeriveParams|DhKeyDeriveParams|ConcatParams|HkdfCtrParams|Pbkdf2Params,baseKey:CryptoKey,length:number):PromiseLike<ArrayBuffer>;deriveKey(algorithm:AlgorithmIdentifier|EcdhKeyDeriveParams|DhKeyDeriveParams|ConcatParams|HkdfCtrParams|Pbkdf2Params,baseKey:CryptoKey,derivedKeyType:string|AesDerivedKeyParams|HmacImportParams|ConcatParams|HkdfCtrParams|Pbkdf2Params,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;digest(algorithm:AlgorithmIdentifier,data:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer):PromiseLike<ArrayBuffer>;encrypt(algorithm:AlgorithmIdentifier|RsaOaepParams|AesCtrParams|AesCbcParams|AesCmacParams|AesGcmParams|AesCfbParams,key:CryptoKey,data:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer):PromiseLike<ArrayBuffer>;exportKey(format:"jwk",key:CryptoKey):PromiseLike<JsonWebKey>;exportKey(format:"raw"|"pkcs8"|"spki",key:CryptoKey):PromiseLike<ArrayBuffer>;exportKey(format:string,key:CryptoKey):PromiseLike<JsonWebKey|ArrayBuffer>;generateKey(algorithm:AlgorithmIdentifier,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKeyPair|CryptoKey>;generateKey(algorithm:RsaHashedKeyGenParams|EcKeyGenParams|DhKeyGenParams,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKeyPair>;generateKey(algorithm:AesKeyGenParams|HmacKeyGenParams|Pbkdf2Params,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;importKey(format:"jwk",keyData:JsonWebKey,algorithm:AlgorithmIdentifier|RsaHashedImportParams|EcKeyImportParams|HmacImportParams|DhImportKeyParams|AesKeyAlgorithm,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;importKey(format:"raw"|"pkcs8"|"spki",keyData:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer,algorithm:AlgorithmIdentifier|RsaHashedImportParams|EcKeyImportParams|HmacImportParams|DhImportKeyParams|AesKeyAlgorithm,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;importKey(format:string,keyData:JsonWebKey|Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer,algorithm:AlgorithmIdentifier|RsaHashedImportParams|EcKeyImportParams|HmacImportParams|DhImportKeyParams|AesKeyAlgorithm,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;sign(algorithm:AlgorithmIdentifier|RsaPssParams|EcdsaParams|AesCmacParams,key:CryptoKey,data:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer):PromiseLike<ArrayBuffer>;unwrapKey(format:"raw"|"pkcs8"|"spki"|"jwk"|string,wrappedKey:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer,unwrappingKey:CryptoKey,unwrapAlgorithm:AlgorithmIdentifier|RsaOaepParams|AesCtrParams|AesCbcParams|AesCmacParams|AesGcmParams|AesCfbParams,unwrappedKeyAlgorithm:AlgorithmIdentifier|RsaHashedImportParams|EcKeyImportParams|HmacImportParams|DhImportKeyParams|AesKeyAlgorithm,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;verify(algorithm:AlgorithmIdentifier|RsaPssParams|EcdsaParams|AesCmacParams,key:CryptoKey,signature:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer,data:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer):PromiseLike<boolean>;wrapKey(format:"raw"|"pkcs8"|"spki"|"jwk"|string,key:CryptoKey,wrappingKey:CryptoKey,wrapAlgorithm:AlgorithmIdentifier|RsaOaepParams|AesCtrParams|AesCbcParams|AesCmacParams|AesGcmParams|AesCfbParams):PromiseLike<ArrayBuffer>;}declare var SubtleCrypto:{prototype:SubtleCrypto;new():SubtleCrypto;};interface SyncManager{getTags():Promise<string[]>;register(tag:string):Promise<void>;}declare var SyncManager:{prototype:SyncManager;new():SyncManager;};interface Text extends CharacterData,Slotable{readonly assignedSlot:HTMLSlotElement|null;readonly wholeText:string;splitText(offset:number):Text;}declare var Text:{prototype:Text;new(data?:string):Text;};interface TextDecoder extends TextDecoderCommon{decode(input?:BufferSource,options?:TextDecodeOptions):string;}declare var TextDecoder:{prototype:TextDecoder;new(label?:string,options?:TextDecoderOptions):TextDecoder;};interface TextDecoderCommon{readonly encoding:string;readonly fatal:boolean;readonly ignoreBOM:boolean;}interface TextDecoderStream extends GenericTransformStream,TextDecoderCommon{readonly readable:ReadableStream<string>;readonly writable:WritableStream<BufferSource>;}declare var TextDecoderStream:{prototype:TextDecoderStream;new(label?:string,options?:TextDecoderOptions):TextDecoderStream;};interface TextEncoder extends TextEncoderCommon{encode(input?:string):Uint8Array;encodeInto(source:string,destination:Uint8Array):TextEncoderEncodeIntoResult;}declare var TextEncoder:{prototype:TextEncoder;new():TextEncoder;};interface TextEncoderCommon{readonly encoding:string;}interface TextEncoderStream extends GenericTransformStream,TextEncoderCommon{readonly readable:ReadableStream<Uint8Array>;readonly writable:WritableStream<string>;}declare var TextEncoderStream:{prototype:TextEncoderStream;new():TextEncoderStream;};interface TextEvent extends UIEvent{readonly data:string;initTextEvent(typeArg:string,canBubbleArg:boolean,cancelableArg:boolean,viewArg:Window,dataArg:string,inputMethod:number,locale:string):void;readonly DOM_INPUT_METHOD_DROP:number;readonly DOM_INPUT_METHOD_HANDWRITING:number;readonly DOM_INPUT_METHOD_IME:number;readonly DOM_INPUT_METHOD_KEYBOARD:number;readonly DOM_INPUT_METHOD_MULTIMODAL:number;readonly DOM_INPUT_METHOD_OPTION:number;readonly DOM_INPUT_METHOD_PASTE:number;readonly DOM_INPUT_METHOD_SCRIPT:number;readonly DOM_INPUT_METHOD_UNKNOWN:number;readonly DOM_INPUT_METHOD_VOICE:number;}declare var TextEvent:{prototype:TextEvent;new():TextEvent;readonly DOM_INPUT_METHOD_DROP:number;readonly DOM_INPUT_METHOD_HANDWRITING:number;readonly DOM_INPUT_METHOD_IME:number;readonly DOM_INPUT_METHOD_KEYBOARD:number;readonly DOM_INPUT_METHOD_MULTIMODAL:number;readonly DOM_INPUT_METHOD_OPTION:number;readonly DOM_INPUT_METHOD_PASTE:number;readonly DOM_INPUT_METHOD_SCRIPT:number;readonly DOM_INPUT_METHOD_UNKNOWN:number;readonly DOM_INPUT_METHOD_VOICE:number;};interface TextMetrics{readonly actualBoundingBoxAscent:number;readonly actualBoundingBoxDescent:number;readonly actualBoundingBoxLeft:number;readonly actualBoundingBoxRight:number;readonly alphabeticBaseline:number;readonly emHeightAscent:number;readonly emHeightDescent:number;readonly fontBoundingBoxAscent:number;readonly fontBoundingBoxDescent:number;readonly hangingBaseline:number;readonly ideographicBaseline:number;readonly width:number;}declare var TextMetrics:{prototype:TextMetrics;new():TextMetrics;};interface TextTrackEventMap{"cuechange":Event;}interface TextTrack extends EventTarget{readonly activeCues:TextTrackCueList|null;readonly cues:TextTrackCueList|null;readonly id:string;readonly inBandMetadataTrackDispatchType:string;readonly kind:TextTrackKind;readonly label:string;readonly language:string;mode:TextTrackMode;oncuechange:((this:TextTrack,ev:Event)=>any)|null;readonly sourceBuffer:SourceBuffer|null;addCue(cue:TextTrackCue):void;removeCue(cue:TextTrackCue):void;addEventListener<K extends keyof TextTrackEventMap>(type:K,listener:(this:TextTrack,ev:TextTrackEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof TextTrackEventMap>(type:K,listener:(this:TextTrack,ev:TextTrackEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var TextTrack:{prototype:TextTrack;new():TextTrack;};interface TextTrackCueEventMap{"enter":Event;"exit":Event;}interface TextTrackCue extends EventTarget{endTime:number;id:string;onenter:((this:TextTrackCue,ev:Event)=>any)|null;onexit:((this:TextTrackCue,ev:Event)=>any)|null;pauseOnExit:boolean;startTime:number;readonly track:TextTrack|null;addEventListener<K extends keyof TextTrackCueEventMap>(type:K,listener:(this:TextTrackCue,ev:TextTrackCueEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof TextTrackCueEventMap>(type:K,listener:(this:TextTrackCue,ev:TextTrackCueEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var TextTrackCue:{prototype:TextTrackCue;new():TextTrackCue;};interface TextTrackCueList{readonly length:number;getCueById(id:string):TextTrackCue|null;[index:number]:TextTrackCue;}declare var TextTrackCueList:{prototype:TextTrackCueList;new():TextTrackCueList;};interface TextTrackListEventMap{"addtrack":TrackEvent;"change":Event;"removetrack":TrackEvent;}interface TextTrackList extends EventTarget{readonly length:number;onaddtrack:((this:TextTrackList,ev:TrackEvent)=>any)|null;onchange:((this:TextTrackList,ev:Event)=>any)|null;onremovetrack:((this:TextTrackList,ev:TrackEvent)=>any)|null;getTrackById(id:string):TextTrack|null;addEventListener<K extends keyof TextTrackListEventMap>(type:K,listener:(this:TextTrackList,ev:TextTrackListEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof TextTrackListEventMap>(type:K,listener:(this:TextTrackList,ev:TextTrackListEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;[index:number]:TextTrack;}declare var TextTrackList:{prototype:TextTrackList;new():TextTrackList;};interface TimeRanges{readonly length:number;end(index:number):number;start(index:number):number;}declare var TimeRanges:{prototype:TimeRanges;new():TimeRanges;};interface Touch{readonly altitudeAngle:number;readonly azimuthAngle:number;readonly clientX:number;readonly clientY:number;readonly force:number;readonly identifier:number;readonly pageX:number;readonly pageY:number;readonly radiusX:number;readonly radiusY:number;readonly rotationAngle:number;readonly screenX:number;readonly screenY:number;readonly target:EventTarget;readonly touchType:TouchType;}declare var Touch:{prototype:Touch;new(touchInitDict:TouchInit):Touch;};interface TouchEvent extends UIEvent{readonly altKey:boolean;readonly changedTouches:TouchList;readonly ctrlKey:boolean;readonly metaKey:boolean;readonly shiftKey:boolean;readonly targetTouches:TouchList;readonly touches:TouchList;}declare var TouchEvent:{prototype:TouchEvent;new(type:string,eventInitDict?:TouchEventInit):TouchEvent;};interface TouchList{readonly length:number;item(index:number):Touch|null;[index:number]:Touch;}declare var TouchList:{prototype:TouchList;new():TouchList;};interface TrackEvent extends Event{readonly track:TextTrack|null;}declare var TrackEvent:{prototype:TrackEvent;new(type:string,eventInitDict?:TrackEventInit):TrackEvent;};interface TransformStream<I=any,O=any>{readonly readable:ReadableStream<O>;readonly writable:WritableStream<I>;}declare var TransformStream:{prototype:TransformStream;new<I=any,O=any>(transformer?:Transformer<I,O>,writableStrategy?:QueuingStrategy<I>,readableStrategy?:QueuingStrategy<O>):TransformStream<I,O>;};interface TransformStreamDefaultController<O=any>{readonly desiredSize:number|null;enqueue(chunk:O):void;error(reason?:any):void;terminate():void;}interface TransitionEvent extends Event{readonly elapsedTime:number;readonly propertyName:string;readonly pseudoElement:string;}declare var TransitionEvent:{prototype:TransitionEvent;new(type:string,transitionEventInitDict?:TransitionEventInit):TransitionEvent;};interface TreeWalker{currentNode:Node;readonly filter:NodeFilter|null;readonly root:Node;readonly whatToShow:number;firstChild():Node|null;lastChild():Node|null;nextNode():Node|null;nextSibling():Node|null;parentNode():Node|null;previousNode():Node|null;previousSibling():Node|null;}declare var TreeWalker:{prototype:TreeWalker;new():TreeWalker;};interface UIEvent extends Event{readonly detail:number;readonly view:Window|null;readonly which:number;}declare var UIEvent:{prototype:UIEvent;new(type:string,eventInitDict?:UIEventInit):UIEvent;};interface URL{hash:string;host:string;hostname:string;href:string;toString():string;readonly origin:string;password:string;pathname:string;port:string;protocol:string;search:string;readonly searchParams:URLSearchParams;username:string;toJSON():string;}declare var URL:{prototype:URL;new(url:string,base?:string|URL):URL;createObjectURL(object:any):string;revokeObjectURL(url:string):void;};type webkitURL=URL;declare var webkitURL:typeof URL;interface URLSearchParams{append(name:string,value:string):void;delete(name:string):void;get(name:string):string|null;getAll(name:string):string[];has(name:string):boolean;set(name:string,value:string):void;sort():void;toString():string;forEach(callbackfn:(value:string,key:string,parent:URLSearchParams)=>void,thisArg?:any):void;}declare var URLSearchParams:{prototype:URLSearchParams;new(init?:string[][]|Record<string,string>|string|URLSearchParams):URLSearchParams;toString():string;};interface VRDisplay extends EventTarget{readonly capabilities:VRDisplayCapabilities;depthFar:number;depthNear:number;readonly displayId:number;readonly displayName:string;readonly isConnected:boolean;readonly isPresenting:boolean;readonly stageParameters:VRStageParameters|null;cancelAnimationFrame(handle:number):void;exitPresent():Promise<void>;getEyeParameters(whichEye:string):VREyeParameters;getFrameData(frameData:VRFrameData):boolean;getLayers():VRLayer[];getPose():VRPose;requestAnimationFrame(callback:FrameRequestCallback):number;requestPresent(layers:VRLayer[]):Promise<void>;resetPose():void;submitFrame(pose?:VRPose):void;}declare var VRDisplay:{prototype:VRDisplay;new():VRDisplay;};interface VRDisplayCapabilities{readonly canPresent:boolean;readonly hasExternalDisplay:boolean;readonly hasOrientation:boolean;readonly hasPosition:boolean;readonly maxLayers:number;}declare var VRDisplayCapabilities:{prototype:VRDisplayCapabilities;new():VRDisplayCapabilities;};interface VRDisplayEvent extends Event{readonly display:VRDisplay;readonly reason:VRDisplayEventReason|null;}declare var VRDisplayEvent:{prototype:VRDisplayEvent;new(type:string,eventInitDict:VRDisplayEventInit):VRDisplayEvent;};interface VREyeParameters{readonly fieldOfView:VRFieldOfView;readonly offset:Float32Array;readonly renderHeight:number;readonly renderWidth:number;}declare var VREyeParameters:{prototype:VREyeParameters;new():VREyeParameters;};interface VRFieldOfView{readonly downDegrees:number;readonly leftDegrees:number;readonly rightDegrees:number;readonly upDegrees:number;}declare var VRFieldOfView:{prototype:VRFieldOfView;new():VRFieldOfView;};interface VRFrameData{readonly leftProjectionMatrix:Float32Array;readonly leftViewMatrix:Float32Array;readonly pose:VRPose;readonly rightProjectionMatrix:Float32Array;readonly rightViewMatrix:Float32Array;readonly timestamp:number;}declare var VRFrameData:{prototype:VRFrameData;new():VRFrameData;};interface VRPose{readonly angularAcceleration:Float32Array|null;readonly angularVelocity:Float32Array|null;readonly linearAcceleration:Float32Array|null;readonly linearVelocity:Float32Array|null;readonly orientation:Float32Array|null;readonly position:Float32Array|null;readonly timestamp:number;}declare var VRPose:{prototype:VRPose;new():VRPose;};interface VTTCue extends TextTrackCue{align:AlignSetting;line:LineAndPositionSetting;lineAlign:LineAlignSetting;position:LineAndPositionSetting;positionAlign:PositionAlignSetting;region:VTTRegion|null;size:number;snapToLines:boolean;text:string;vertical:DirectionSetting;getCueAsHTML():DocumentFragment;addEventListener<K extends keyof TextTrackCueEventMap>(type:K,listener:(this:VTTCue,ev:TextTrackCueEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof TextTrackCueEventMap>(type:K,listener:(this:VTTCue,ev:TextTrackCueEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var VTTCue:{prototype:VTTCue;new(startTime:number,endTime:number,text:string):VTTCue;};interface VTTRegion{id:string;lines:number;regionAnchorX:number;regionAnchorY:number;scroll:ScrollSetting;viewportAnchorX:number;viewportAnchorY:number;width:number;}declare var VTTRegion:{prototype:VTTRegion;new():VTTRegion;};interface ValidityState{readonly badInput:boolean;readonly customError:boolean;readonly patternMismatch:boolean;readonly rangeOverflow:boolean;readonly rangeUnderflow:boolean;readonly stepMismatch:boolean;readonly tooLong:boolean;readonly tooShort:boolean;readonly typeMismatch:boolean;readonly valid:boolean;readonly valueMissing:boolean;}declare var ValidityState:{prototype:ValidityState;new():ValidityState;};interface VideoPlaybackQuality{readonly creationTime:number;readonly droppedVideoFrames:number;readonly totalVideoFrames:number;}declare var VideoPlaybackQuality:{prototype:VideoPlaybackQuality;new():VideoPlaybackQuality;};interface WEBGL_color_buffer_float{readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT:GLenum;readonly RGBA32F_EXT:GLenum;readonly UNSIGNED_NORMALIZED_EXT:GLenum;}interface WEBGL_compressed_texture_astc{getSupportedProfiles():string[];readonly COMPRESSED_RGBA_ASTC_10x10_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_10x5_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_10x6_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_10x8_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_12x10_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_12x12_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_4x4_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_5x4_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_5x5_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_6x5_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_6x6_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_8x5_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_8x6_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_8x8_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:GLenum;}interface WEBGL_compressed_texture_s3tc{readonly COMPRESSED_RGBA_S3TC_DXT1_EXT:GLenum;readonly COMPRESSED_RGBA_S3TC_DXT3_EXT:GLenum;readonly COMPRESSED_RGBA_S3TC_DXT5_EXT:GLenum;readonly COMPRESSED_RGB_S3TC_DXT1_EXT:GLenum;}interface WEBGL_compressed_texture_s3tc_srgb{readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:GLenum;readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:GLenum;readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:GLenum;readonly COMPRESSED_SRGB_S3TC_DXT1_EXT:GLenum;}interface WEBGL_debug_renderer_info{readonly UNMASKED_RENDERER_WEBGL:GLenum;readonly UNMASKED_VENDOR_WEBGL:GLenum;}interface WEBGL_debug_shaders{getTranslatedShaderSource(shader:WebGLShader):string;}interface WEBGL_depth_texture{readonly UNSIGNED_INT_24_8_WEBGL:GLenum;}interface WEBGL_draw_buffers{drawBuffersWEBGL(buffers:GLenum[]):void;readonly COLOR_ATTACHMENT0_WEBGL:GLenum;readonly COLOR_ATTACHMENT10_WEBGL:GLenum;readonly COLOR_ATTACHMENT11_WEBGL:GLenum;readonly COLOR_ATTACHMENT12_WEBGL:GLenum;readonly COLOR_ATTACHMENT13_WEBGL:GLenum;readonly COLOR_ATTACHMENT14_WEBGL:GLenum;readonly COLOR_ATTACHMENT15_WEBGL:GLenum;readonly COLOR_ATTACHMENT1_WEBGL:GLenum;readonly COLOR_ATTACHMENT2_WEBGL:GLenum;readonly COLOR_ATTACHMENT3_WEBGL:GLenum;readonly COLOR_ATTACHMENT4_WEBGL:GLenum;readonly COLOR_ATTACHMENT5_WEBGL:GLenum;readonly COLOR_ATTACHMENT6_WEBGL:GLenum;readonly COLOR_ATTACHMENT7_WEBGL:GLenum;readonly COLOR_ATTACHMENT8_WEBGL:GLenum;readonly COLOR_ATTACHMENT9_WEBGL:GLenum;readonly DRAW_BUFFER0_WEBGL:GLenum;readonly DRAW_BUFFER10_WEBGL:GLenum;readonly DRAW_BUFFER11_WEBGL:GLenum;readonly DRAW_BUFFER12_WEBGL:GLenum;readonly DRAW_BUFFER13_WEBGL:GLenum;readonly DRAW_BUFFER14_WEBGL:GLenum;readonly DRAW_BUFFER15_WEBGL:GLenum;readonly DRAW_BUFFER1_WEBGL:GLenum;readonly DRAW_BUFFER2_WEBGL:GLenum;readonly DRAW_BUFFER3_WEBGL:GLenum;readonly DRAW_BUFFER4_WEBGL:GLenum;readonly DRAW_BUFFER5_WEBGL:GLenum;readonly DRAW_BUFFER6_WEBGL:GLenum;readonly DRAW_BUFFER7_WEBGL:GLenum;readonly DRAW_BUFFER8_WEBGL:GLenum;readonly DRAW_BUFFER9_WEBGL:GLenum;readonly MAX_COLOR_ATTACHMENTS_WEBGL:GLenum;readonly MAX_DRAW_BUFFERS_WEBGL:GLenum;}interface WEBGL_lose_context{loseContext():void;restoreContext():void;}interface WaveShaperNode extends AudioNode{curve:Float32Array|null;oversample:OverSampleType;}declare var WaveShaperNode:{prototype:WaveShaperNode;new(context:BaseAudioContext,options?:WaveShaperOptions):WaveShaperNode;};interface WebAuthentication{getAssertion(assertionChallenge:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer|null,options?:AssertionOptions):Promise<WebAuthnAssertion>;makeCredential(accountInformation:Account,cryptoParameters:ScopedCredentialParameters[],attestationChallenge:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer|null,options?:ScopedCredentialOptions):Promise<ScopedCredentialInfo>;}declare var WebAuthentication:{prototype:WebAuthentication;new():WebAuthentication;};interface WebAuthnAssertion{readonly authenticatorData:ArrayBuffer;readonly clientData:ArrayBuffer;readonly credential:ScopedCredential;readonly signature:ArrayBuffer;}declare var WebAuthnAssertion:{prototype:WebAuthnAssertion;new():WebAuthnAssertion;};interface WebGL2RenderingContext extends WebGL2RenderingContextBase,WebGL2RenderingContextOverloads,WebGLRenderingContextBase{}declare var WebGL2RenderingContext:{prototype:WebGL2RenderingContext;new():WebGL2RenderingContext;readonly ACTIVE_ATTRIBUTES:GLenum;readonly ACTIVE_TEXTURE:GLenum;readonly ACTIVE_UNIFORMS:GLenum;readonly ALIASED_LINE_WIDTH_RANGE:GLenum;readonly ALIASED_POINT_SIZE_RANGE:GLenum;readonly ALPHA:GLenum;readonly ALPHA_BITS:GLenum;readonly ALWAYS:GLenum;readonly ARRAY_BUFFER:GLenum;readonly ARRAY_BUFFER_BINDING:GLenum;readonly ATTACHED_SHADERS:GLenum;readonly BACK:GLenum;readonly BLEND:GLenum;readonly BLEND_COLOR:GLenum;readonly BLEND_DST_ALPHA:GLenum;readonly BLEND_DST_RGB:GLenum;readonly BLEND_EQUATION:GLenum;readonly BLEND_EQUATION_ALPHA:GLenum;readonly BLEND_EQUATION_RGB:GLenum;readonly BLEND_SRC_ALPHA:GLenum;readonly BLEND_SRC_RGB:GLenum;readonly BLUE_BITS:GLenum;readonly BOOL:GLenum;readonly BOOL_VEC2:GLenum;readonly BOOL_VEC3:GLenum;readonly BOOL_VEC4:GLenum;readonly BROWSER_DEFAULT_WEBGL:GLenum;readonly BUFFER_SIZE:GLenum;readonly BUFFER_USAGE:GLenum;readonly BYTE:GLenum;readonly CCW:GLenum;readonly CLAMP_TO_EDGE:GLenum;readonly COLOR_ATTACHMENT0:GLenum;readonly COLOR_BUFFER_BIT:GLenum;readonly COLOR_CLEAR_VALUE:GLenum;readonly COLOR_WRITEMASK:GLenum;readonly COMPILE_STATUS:GLenum;readonly COMPRESSED_TEXTURE_FORMATS:GLenum;readonly CONSTANT_ALPHA:GLenum;readonly CONSTANT_COLOR:GLenum;readonly CONTEXT_LOST_WEBGL:GLenum;readonly CULL_FACE:GLenum;readonly CULL_FACE_MODE:GLenum;readonly CURRENT_PROGRAM:GLenum;readonly CURRENT_VERTEX_ATTRIB:GLenum;readonly CW:GLenum;readonly DECR:GLenum;readonly DECR_WRAP:GLenum;readonly DELETE_STATUS:GLenum;readonly DEPTH_ATTACHMENT:GLenum;readonly DEPTH_BITS:GLenum;readonly DEPTH_BUFFER_BIT:GLenum;readonly DEPTH_CLEAR_VALUE:GLenum;readonly DEPTH_COMPONENT:GLenum;readonly DEPTH_COMPONENT16:GLenum;readonly DEPTH_FUNC:GLenum;readonly DEPTH_RANGE:GLenum;readonly DEPTH_STENCIL:GLenum;readonly DEPTH_STENCIL_ATTACHMENT:GLenum;readonly DEPTH_TEST:GLenum;readonly DEPTH_WRITEMASK:GLenum;readonly DITHER:GLenum;readonly DONT_CARE:GLenum;readonly DST_ALPHA:GLenum;readonly DST_COLOR:GLenum;readonly DYNAMIC_DRAW:GLenum;readonly ELEMENT_ARRAY_BUFFER:GLenum;readonly ELEMENT_ARRAY_BUFFER_BINDING:GLenum;readonly EQUAL:GLenum;readonly FASTEST:GLenum;readonly FLOAT:GLenum;readonly FLOAT_MAT2:GLenum;readonly FLOAT_MAT3:GLenum;readonly FLOAT_MAT4:GLenum;readonly FLOAT_VEC2:GLenum;readonly FLOAT_VEC3:GLenum;readonly FLOAT_VEC4:GLenum;readonly FRAGMENT_SHADER:GLenum;readonly FRAMEBUFFER:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:GLenum;readonly FRAMEBUFFER_BINDING:GLenum;readonly FRAMEBUFFER_COMPLETE:GLenum;readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT:GLenum;readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS:GLenum;readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:GLenum;readonly FRAMEBUFFER_UNSUPPORTED:GLenum;readonly FRONT:GLenum;readonly FRONT_AND_BACK:GLenum;readonly FRONT_FACE:GLenum;readonly FUNC_ADD:GLenum;readonly FUNC_REVERSE_SUBTRACT:GLenum;readonly FUNC_SUBTRACT:GLenum;readonly GENERATE_MIPMAP_HINT:GLenum;readonly GEQUAL:GLenum;readonly GREATER:GLenum;readonly GREEN_BITS:GLenum;readonly HIGH_FLOAT:GLenum;readonly HIGH_INT:GLenum;readonly IMPLEMENTATION_COLOR_READ_FORMAT:GLenum;readonly IMPLEMENTATION_COLOR_READ_TYPE:GLenum;readonly INCR:GLenum;readonly INCR_WRAP:GLenum;readonly INT:GLenum;readonly INT_VEC2:GLenum;readonly INT_VEC3:GLenum;readonly INT_VEC4:GLenum;readonly INVALID_ENUM:GLenum;readonly INVALID_FRAMEBUFFER_OPERATION:GLenum;readonly INVALID_OPERATION:GLenum;readonly INVALID_VALUE:GLenum;readonly INVERT:GLenum;readonly KEEP:GLenum;readonly LEQUAL:GLenum;readonly LESS:GLenum;readonly LINEAR:GLenum;readonly LINEAR_MIPMAP_LINEAR:GLenum;readonly LINEAR_MIPMAP_NEAREST:GLenum;readonly LINES:GLenum;readonly LINE_LOOP:GLenum;readonly LINE_STRIP:GLenum;readonly LINE_WIDTH:GLenum;readonly LINK_STATUS:GLenum;readonly LOW_FLOAT:GLenum;readonly LOW_INT:GLenum;readonly LUMINANCE:GLenum;readonly LUMINANCE_ALPHA:GLenum;readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_CUBE_MAP_TEXTURE_SIZE:GLenum;readonly MAX_FRAGMENT_UNIFORM_VECTORS:GLenum;readonly MAX_RENDERBUFFER_SIZE:GLenum;readonly MAX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_TEXTURE_SIZE:GLenum;readonly MAX_VARYING_VECTORS:GLenum;readonly MAX_VERTEX_ATTRIBS:GLenum;readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_VERTEX_UNIFORM_VECTORS:GLenum;readonly MAX_VIEWPORT_DIMS:GLenum;readonly MEDIUM_FLOAT:GLenum;readonly MEDIUM_INT:GLenum;readonly MIRRORED_REPEAT:GLenum;readonly NEAREST:GLenum;readonly NEAREST_MIPMAP_LINEAR:GLenum;readonly NEAREST_MIPMAP_NEAREST:GLenum;readonly NEVER:GLenum;readonly NICEST:GLenum;readonly NONE:GLenum;readonly NOTEQUAL:GLenum;readonly NO_ERROR:GLenum;readonly ONE:GLenum;readonly ONE_MINUS_CONSTANT_ALPHA:GLenum;readonly ONE_MINUS_CONSTANT_COLOR:GLenum;readonly ONE_MINUS_DST_ALPHA:GLenum;readonly ONE_MINUS_DST_COLOR:GLenum;readonly ONE_MINUS_SRC_ALPHA:GLenum;readonly ONE_MINUS_SRC_COLOR:GLenum;readonly OUT_OF_MEMORY:GLenum;readonly PACK_ALIGNMENT:GLenum;readonly POINTS:GLenum;readonly POLYGON_OFFSET_FACTOR:GLenum;readonly POLYGON_OFFSET_FILL:GLenum;readonly POLYGON_OFFSET_UNITS:GLenum;readonly RED_BITS:GLenum;readonly RENDERBUFFER:GLenum;readonly RENDERBUFFER_ALPHA_SIZE:GLenum;readonly RENDERBUFFER_BINDING:GLenum;readonly RENDERBUFFER_BLUE_SIZE:GLenum;readonly RENDERBUFFER_DEPTH_SIZE:GLenum;readonly RENDERBUFFER_GREEN_SIZE:GLenum;readonly RENDERBUFFER_HEIGHT:GLenum;readonly RENDERBUFFER_INTERNAL_FORMAT:GLenum;readonly RENDERBUFFER_RED_SIZE:GLenum;readonly RENDERBUFFER_STENCIL_SIZE:GLenum;readonly RENDERBUFFER_WIDTH:GLenum;readonly RENDERER:GLenum;readonly REPEAT:GLenum;readonly REPLACE:GLenum;readonly RGB:GLenum;readonly RGB565:GLenum;readonly RGB5_A1:GLenum;readonly RGBA:GLenum;readonly RGBA4:GLenum;readonly SAMPLER_2D:GLenum;readonly SAMPLER_CUBE:GLenum;readonly SAMPLES:GLenum;readonly SAMPLE_ALPHA_TO_COVERAGE:GLenum;readonly SAMPLE_BUFFERS:GLenum;readonly SAMPLE_COVERAGE:GLenum;readonly SAMPLE_COVERAGE_INVERT:GLenum;readonly SAMPLE_COVERAGE_VALUE:GLenum;readonly SCISSOR_BOX:GLenum;readonly SCISSOR_TEST:GLenum;readonly SHADER_TYPE:GLenum;readonly SHADING_LANGUAGE_VERSION:GLenum;readonly SHORT:GLenum;readonly SRC_ALPHA:GLenum;readonly SRC_ALPHA_SATURATE:GLenum;readonly SRC_COLOR:GLenum;readonly STATIC_DRAW:GLenum;readonly STENCIL_ATTACHMENT:GLenum;readonly STENCIL_BACK_FAIL:GLenum;readonly STENCIL_BACK_FUNC:GLenum;readonly STENCIL_BACK_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_BACK_PASS_DEPTH_PASS:GLenum;readonly STENCIL_BACK_REF:GLenum;readonly STENCIL_BACK_VALUE_MASK:GLenum;readonly STENCIL_BACK_WRITEMASK:GLenum;readonly STENCIL_BITS:GLenum;readonly STENCIL_BUFFER_BIT:GLenum;readonly STENCIL_CLEAR_VALUE:GLenum;readonly STENCIL_FAIL:GLenum;readonly STENCIL_FUNC:GLenum;readonly STENCIL_INDEX8:GLenum;readonly STENCIL_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_PASS_DEPTH_PASS:GLenum;readonly STENCIL_REF:GLenum;readonly STENCIL_TEST:GLenum;readonly STENCIL_VALUE_MASK:GLenum;readonly STENCIL_WRITEMASK:GLenum;readonly STREAM_DRAW:GLenum;readonly SUBPIXEL_BITS:GLenum;readonly TEXTURE:GLenum;readonly TEXTURE0:GLenum;readonly TEXTURE1:GLenum;readonly TEXTURE10:GLenum;readonly TEXTURE11:GLenum;readonly TEXTURE12:GLenum;readonly TEXTURE13:GLenum;readonly TEXTURE14:GLenum;readonly TEXTURE15:GLenum;readonly TEXTURE16:GLenum;readonly TEXTURE17:GLenum;readonly TEXTURE18:GLenum;readonly TEXTURE19:GLenum;readonly TEXTURE2:GLenum;readonly TEXTURE20:GLenum;readonly TEXTURE21:GLenum;readonly TEXTURE22:GLenum;readonly TEXTURE23:GLenum;readonly TEXTURE24:GLenum;readonly TEXTURE25:GLenum;readonly TEXTURE26:GLenum;readonly TEXTURE27:GLenum;readonly TEXTURE28:GLenum;readonly TEXTURE29:GLenum;readonly TEXTURE3:GLenum;readonly TEXTURE30:GLenum;readonly TEXTURE31:GLenum;readonly TEXTURE4:GLenum;readonly TEXTURE5:GLenum;readonly TEXTURE6:GLenum;readonly TEXTURE7:GLenum;readonly TEXTURE8:GLenum;readonly TEXTURE9:GLenum;readonly TEXTURE_2D:GLenum;readonly TEXTURE_BINDING_2D:GLenum;readonly TEXTURE_BINDING_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Z:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Z:GLenum;readonly TEXTURE_MAG_FILTER:GLenum;readonly TEXTURE_MIN_FILTER:GLenum;readonly TEXTURE_WRAP_S:GLenum;readonly TEXTURE_WRAP_T:GLenum;readonly TRIANGLES:GLenum;readonly TRIANGLE_FAN:GLenum;readonly TRIANGLE_STRIP:GLenum;readonly UNPACK_ALIGNMENT:GLenum;readonly UNPACK_COLORSPACE_CONVERSION_WEBGL:GLenum;readonly UNPACK_FLIP_Y_WEBGL:GLenum;readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL:GLenum;readonly UNSIGNED_BYTE:GLenum;readonly UNSIGNED_INT:GLenum;readonly UNSIGNED_SHORT:GLenum;readonly UNSIGNED_SHORT_4_4_4_4:GLenum;readonly UNSIGNED_SHORT_5_5_5_1:GLenum;readonly UNSIGNED_SHORT_5_6_5:GLenum;readonly VALIDATE_STATUS:GLenum;readonly VENDOR:GLenum;readonly VERSION:GLenum;readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:GLenum;readonly VERTEX_ATTRIB_ARRAY_ENABLED:GLenum;readonly VERTEX_ATTRIB_ARRAY_NORMALIZED:GLenum;readonly VERTEX_ATTRIB_ARRAY_POINTER:GLenum;readonly VERTEX_ATTRIB_ARRAY_SIZE:GLenum;readonly VERTEX_ATTRIB_ARRAY_STRIDE:GLenum;readonly VERTEX_ATTRIB_ARRAY_TYPE:GLenum;readonly VERTEX_SHADER:GLenum;readonly VIEWPORT:GLenum;readonly ZERO:GLenum;readonly ACTIVE_UNIFORM_BLOCKS:GLenum;readonly ALREADY_SIGNALED:GLenum;readonly ANY_SAMPLES_PASSED:GLenum;readonly ANY_SAMPLES_PASSED_CONSERVATIVE:GLenum;readonly COLOR:GLenum;readonly COLOR_ATTACHMENT1:GLenum;readonly COLOR_ATTACHMENT10:GLenum;readonly COLOR_ATTACHMENT11:GLenum;readonly COLOR_ATTACHMENT12:GLenum;readonly COLOR_ATTACHMENT13:GLenum;readonly COLOR_ATTACHMENT14:GLenum;readonly COLOR_ATTACHMENT15:GLenum;readonly COLOR_ATTACHMENT2:GLenum;readonly COLOR_ATTACHMENT3:GLenum;readonly COLOR_ATTACHMENT4:GLenum;readonly COLOR_ATTACHMENT5:GLenum;readonly COLOR_ATTACHMENT6:GLenum;readonly COLOR_ATTACHMENT7:GLenum;readonly COLOR_ATTACHMENT8:GLenum;readonly COLOR_ATTACHMENT9:GLenum;readonly COMPARE_REF_TO_TEXTURE:GLenum;readonly CONDITION_SATISFIED:GLenum;readonly COPY_READ_BUFFER:GLenum;readonly COPY_READ_BUFFER_BINDING:GLenum;readonly COPY_WRITE_BUFFER:GLenum;readonly COPY_WRITE_BUFFER_BINDING:GLenum;readonly CURRENT_QUERY:GLenum;readonly DEPTH:GLenum;readonly DEPTH24_STENCIL8:GLenum;readonly DEPTH32F_STENCIL8:GLenum;readonly DEPTH_COMPONENT24:GLenum;readonly DEPTH_COMPONENT32F:GLenum;readonly DRAW_BUFFER0:GLenum;readonly DRAW_BUFFER1:GLenum;readonly DRAW_BUFFER10:GLenum;readonly DRAW_BUFFER11:GLenum;readonly DRAW_BUFFER12:GLenum;readonly DRAW_BUFFER13:GLenum;readonly DRAW_BUFFER14:GLenum;readonly DRAW_BUFFER15:GLenum;readonly DRAW_BUFFER2:GLenum;readonly DRAW_BUFFER3:GLenum;readonly DRAW_BUFFER4:GLenum;readonly DRAW_BUFFER5:GLenum;readonly DRAW_BUFFER6:GLenum;readonly DRAW_BUFFER7:GLenum;readonly DRAW_BUFFER8:GLenum;readonly DRAW_BUFFER9:GLenum;readonly DRAW_FRAMEBUFFER:GLenum;readonly DRAW_FRAMEBUFFER_BINDING:GLenum;readonly DYNAMIC_COPY:GLenum;readonly DYNAMIC_READ:GLenum;readonly FLOAT_32_UNSIGNED_INT_24_8_REV:GLenum;readonly FLOAT_MAT2x3:GLenum;readonly FLOAT_MAT2x4:GLenum;readonly FLOAT_MAT3x2:GLenum;readonly FLOAT_MAT3x4:GLenum;readonly FLOAT_MAT4x2:GLenum;readonly FLOAT_MAT4x3:GLenum;readonly FRAGMENT_SHADER_DERIVATIVE_HINT:GLenum;readonly FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:GLenum;readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_RED_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:GLenum;readonly FRAMEBUFFER_DEFAULT:GLenum;readonly FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:GLenum;readonly HALF_FLOAT:GLenum;readonly INTERLEAVED_ATTRIBS:GLenum;readonly INT_2_10_10_10_REV:GLenum;readonly INT_SAMPLER_2D:GLenum;readonly INT_SAMPLER_2D_ARRAY:GLenum;readonly INT_SAMPLER_3D:GLenum;readonly INT_SAMPLER_CUBE:GLenum;readonly INVALID_INDEX:GLenum;readonly MAX:GLenum;readonly MAX_3D_TEXTURE_SIZE:GLenum;readonly MAX_ARRAY_TEXTURE_LAYERS:GLenum;readonly MAX_CLIENT_WAIT_TIMEOUT_WEBGL:GLenum;readonly MAX_COLOR_ATTACHMENTS:GLenum;readonly MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:GLenum;readonly MAX_COMBINED_UNIFORM_BLOCKS:GLenum;readonly MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:GLenum;readonly MAX_DRAW_BUFFERS:GLenum;readonly MAX_ELEMENTS_INDICES:GLenum;readonly MAX_ELEMENTS_VERTICES:GLenum;readonly MAX_ELEMENT_INDEX:GLenum;readonly MAX_FRAGMENT_INPUT_COMPONENTS:GLenum;readonly MAX_FRAGMENT_UNIFORM_BLOCKS:GLenum;readonly MAX_FRAGMENT_UNIFORM_COMPONENTS:GLenum;readonly MAX_PROGRAM_TEXEL_OFFSET:GLenum;readonly MAX_SAMPLES:GLenum;readonly MAX_SERVER_WAIT_TIMEOUT:GLenum;readonly MAX_TEXTURE_LOD_BIAS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:GLenum;readonly MAX_UNIFORM_BLOCK_SIZE:GLenum;readonly MAX_UNIFORM_BUFFER_BINDINGS:GLenum;readonly MAX_VARYING_COMPONENTS:GLenum;readonly MAX_VERTEX_OUTPUT_COMPONENTS:GLenum;readonly MAX_VERTEX_UNIFORM_BLOCKS:GLenum;readonly MAX_VERTEX_UNIFORM_COMPONENTS:GLenum;readonly MIN:GLenum;readonly MIN_PROGRAM_TEXEL_OFFSET:GLenum;readonly OBJECT_TYPE:GLenum;readonly PACK_ROW_LENGTH:GLenum;readonly PACK_SKIP_PIXELS:GLenum;readonly PACK_SKIP_ROWS:GLenum;readonly PIXEL_PACK_BUFFER:GLenum;readonly PIXEL_PACK_BUFFER_BINDING:GLenum;readonly PIXEL_UNPACK_BUFFER:GLenum;readonly PIXEL_UNPACK_BUFFER_BINDING:GLenum;readonly QUERY_RESULT:GLenum;readonly QUERY_RESULT_AVAILABLE:GLenum;readonly R11F_G11F_B10F:GLenum;readonly R16F:GLenum;readonly R16I:GLenum;readonly R16UI:GLenum;readonly R32F:GLenum;readonly R32I:GLenum;readonly R32UI:GLenum;readonly R8:GLenum;readonly R8I:GLenum;readonly R8UI:GLenum;readonly R8_SNORM:GLenum;readonly RASTERIZER_DISCARD:GLenum;readonly READ_BUFFER:GLenum;readonly READ_FRAMEBUFFER:GLenum;readonly READ_FRAMEBUFFER_BINDING:GLenum;readonly RED:GLenum;readonly RED_INTEGER:GLenum;readonly RENDERBUFFER_SAMPLES:GLenum;readonly RG:GLenum;readonly RG16F:GLenum;readonly RG16I:GLenum;readonly RG16UI:GLenum;readonly RG32F:GLenum;readonly RG32I:GLenum;readonly RG32UI:GLenum;readonly RG8:GLenum;readonly RG8I:GLenum;readonly RG8UI:GLenum;readonly RG8_SNORM:GLenum;readonly RGB10_A2:GLenum;readonly RGB10_A2UI:GLenum;readonly RGB16F:GLenum;readonly RGB16I:GLenum;readonly RGB16UI:GLenum;readonly RGB32F:GLenum;readonly RGB32I:GLenum;readonly RGB32UI:GLenum;readonly RGB8:GLenum;readonly RGB8I:GLenum;readonly RGB8UI:GLenum;readonly RGB8_SNORM:GLenum;readonly RGB9_E5:GLenum;readonly RGBA16F:GLenum;readonly RGBA16I:GLenum;readonly RGBA16UI:GLenum;readonly RGBA32F:GLenum;readonly RGBA32I:GLenum;readonly RGBA32UI:GLenum;readonly RGBA8:GLenum;readonly RGBA8I:GLenum;readonly RGBA8UI:GLenum;readonly RGBA8_SNORM:GLenum;readonly RGBA_INTEGER:GLenum;readonly RGB_INTEGER:GLenum;readonly RG_INTEGER:GLenum;readonly SAMPLER_2D_ARRAY:GLenum;readonly SAMPLER_2D_ARRAY_SHADOW:GLenum;readonly SAMPLER_2D_SHADOW:GLenum;readonly SAMPLER_3D:GLenum;readonly SAMPLER_BINDING:GLenum;readonly SAMPLER_CUBE_SHADOW:GLenum;readonly SEPARATE_ATTRIBS:GLenum;readonly SIGNALED:GLenum;readonly SIGNED_NORMALIZED:GLenum;readonly SRGB:GLenum;readonly SRGB8:GLenum;readonly SRGB8_ALPHA8:GLenum;readonly STATIC_COPY:GLenum;readonly STATIC_READ:GLenum;readonly STENCIL:GLenum;readonly STREAM_COPY:GLenum;readonly STREAM_READ:GLenum;readonly SYNC_CONDITION:GLenum;readonly SYNC_FENCE:GLenum;readonly SYNC_FLAGS:GLenum;readonly SYNC_FLUSH_COMMANDS_BIT:GLenum;readonly SYNC_GPU_COMMANDS_COMPLETE:GLenum;readonly SYNC_STATUS:GLenum;readonly TEXTURE_2D_ARRAY:GLenum;readonly TEXTURE_3D:GLenum;readonly TEXTURE_BASE_LEVEL:GLenum;readonly TEXTURE_BINDING_2D_ARRAY:GLenum;readonly TEXTURE_BINDING_3D:GLenum;readonly TEXTURE_COMPARE_FUNC:GLenum;readonly TEXTURE_COMPARE_MODE:GLenum;readonly TEXTURE_IMMUTABLE_FORMAT:GLenum;readonly TEXTURE_IMMUTABLE_LEVELS:GLenum;readonly TEXTURE_MAX_LEVEL:GLenum;readonly TEXTURE_MAX_LOD:GLenum;readonly TEXTURE_MIN_LOD:GLenum;readonly TEXTURE_WRAP_R:GLenum;readonly TIMEOUT_EXPIRED:GLenum;readonly TIMEOUT_IGNORED:GLint64;readonly TRANSFORM_FEEDBACK:GLenum;readonly TRANSFORM_FEEDBACK_ACTIVE:GLenum;readonly TRANSFORM_FEEDBACK_BINDING:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_BINDING:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_MODE:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_SIZE:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_START:GLenum;readonly TRANSFORM_FEEDBACK_PAUSED:GLenum;readonly TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:GLenum;readonly TRANSFORM_FEEDBACK_VARYINGS:GLenum;readonly UNIFORM_ARRAY_STRIDE:GLenum;readonly UNIFORM_BLOCK_ACTIVE_UNIFORMS:GLenum;readonly UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:GLenum;readonly UNIFORM_BLOCK_BINDING:GLenum;readonly UNIFORM_BLOCK_DATA_SIZE:GLenum;readonly UNIFORM_BLOCK_INDEX:GLenum;readonly UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:GLenum;readonly UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:GLenum;readonly UNIFORM_BUFFER:GLenum;readonly UNIFORM_BUFFER_BINDING:GLenum;readonly UNIFORM_BUFFER_OFFSET_ALIGNMENT:GLenum;readonly UNIFORM_BUFFER_SIZE:GLenum;readonly UNIFORM_BUFFER_START:GLenum;readonly UNIFORM_IS_ROW_MAJOR:GLenum;readonly UNIFORM_MATRIX_STRIDE:GLenum;readonly UNIFORM_OFFSET:GLenum;readonly UNIFORM_SIZE:GLenum;readonly UNIFORM_TYPE:GLenum;readonly UNPACK_IMAGE_HEIGHT:GLenum;readonly UNPACK_ROW_LENGTH:GLenum;readonly UNPACK_SKIP_IMAGES:GLenum;readonly UNPACK_SKIP_PIXELS:GLenum;readonly UNPACK_SKIP_ROWS:GLenum;readonly UNSIGNALED:GLenum;readonly UNSIGNED_INT_10F_11F_11F_REV:GLenum;readonly UNSIGNED_INT_24_8:GLenum;readonly UNSIGNED_INT_2_10_10_10_REV:GLenum;readonly UNSIGNED_INT_5_9_9_9_REV:GLenum;readonly UNSIGNED_INT_SAMPLER_2D:GLenum;readonly UNSIGNED_INT_SAMPLER_2D_ARRAY:GLenum;readonly UNSIGNED_INT_SAMPLER_3D:GLenum;readonly UNSIGNED_INT_SAMPLER_CUBE:GLenum;readonly UNSIGNED_INT_VEC2:GLenum;readonly UNSIGNED_INT_VEC3:GLenum;readonly UNSIGNED_INT_VEC4:GLenum;readonly UNSIGNED_NORMALIZED:GLenum;readonly VERTEX_ARRAY_BINDING:GLenum;readonly VERTEX_ATTRIB_ARRAY_DIVISOR:GLenum;readonly VERTEX_ATTRIB_ARRAY_INTEGER:GLenum;readonly WAIT_FAILED:GLenum;};interface WebGL2RenderingContextBase{beginQuery(target:GLenum,query:WebGLQuery):void;beginTransformFeedback(primitiveMode:GLenum):void;bindBufferBase(target:GLenum,index:GLuint,buffer:WebGLBuffer|null):void;bindBufferRange(target:GLenum,index:GLuint,buffer:WebGLBuffer|null,offset:GLintptr,size:GLsizeiptr):void;bindSampler(unit:GLuint,sampler:WebGLSampler|null):void;bindTransformFeedback(target:GLenum,tf:WebGLTransformFeedback|null):void;bindVertexArray(array:WebGLVertexArrayObject|null):void;blitFramebuffer(srcX0:GLint,srcY0:GLint,srcX1:GLint,srcY1:GLint,dstX0:GLint,dstY0:GLint,dstX1:GLint,dstY1:GLint,mask:GLbitfield,filter:GLenum):void;clearBufferfi(buffer:GLenum,drawbuffer:GLint,depth:GLfloat,stencil:GLint):void;clearBufferfv(buffer:GLenum,drawbuffer:GLint,values:Float32List,srcOffset?:GLuint):void;clearBufferiv(buffer:GLenum,drawbuffer:GLint,values:Int32List,srcOffset?:GLuint):void;clearBufferuiv(buffer:GLenum,drawbuffer:GLint,values:Uint32List,srcOffset?:GLuint):void;clientWaitSync(sync:WebGLSync,flags:GLbitfield,timeout:GLuint64):GLenum;compressedTexImage3D(target:GLenum,level:GLint,internalformat:GLenum,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,imageSize:GLsizei,offset:GLintptr):void;compressedTexImage3D(target:GLenum,level:GLint,internalformat:GLenum,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,srcData:ArrayBufferView,srcOffset?:GLuint,srcLengthOverride?:GLuint):void;compressedTexSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,format:GLenum,imageSize:GLsizei,offset:GLintptr):void;compressedTexSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,format:GLenum,srcData:ArrayBufferView,srcOffset?:GLuint,srcLengthOverride?:GLuint):void;copyBufferSubData(readTarget:GLenum,writeTarget:GLenum,readOffset:GLintptr,writeOffset:GLintptr,size:GLsizeiptr):void;copyTexSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;createQuery():WebGLQuery|null;createSampler():WebGLSampler|null;createTransformFeedback():WebGLTransformFeedback|null;createVertexArray():WebGLVertexArrayObject|null;deleteQuery(query:WebGLQuery|null):void;deleteSampler(sampler:WebGLSampler|null):void;deleteSync(sync:WebGLSync|null):void;deleteTransformFeedback(tf:WebGLTransformFeedback|null):void;deleteVertexArray(vertexArray:WebGLVertexArrayObject|null):void;drawArraysInstanced(mode:GLenum,first:GLint,count:GLsizei,instanceCount:GLsizei):void;drawBuffers(buffers:GLenum[]):void;drawElementsInstanced(mode:GLenum,count:GLsizei,type:GLenum,offset:GLintptr,instanceCount:GLsizei):void;drawRangeElements(mode:GLenum,start:GLuint,end:GLuint,count:GLsizei,type:GLenum,offset:GLintptr):void;endQuery(target:GLenum):void;endTransformFeedback():void;fenceSync(condition:GLenum,flags:GLbitfield):WebGLSync|null;framebufferTextureLayer(target:GLenum,attachment:GLenum,texture:WebGLTexture|null,level:GLint,layer:GLint):void;getActiveUniformBlockName(program:WebGLProgram,uniformBlockIndex:GLuint):string|null;getActiveUniformBlockParameter(program:WebGLProgram,uniformBlockIndex:GLuint,pname:GLenum):any;getActiveUniforms(program:WebGLProgram,uniformIndices:GLuint[],pname:GLenum):any;getBufferSubData(target:GLenum,srcByteOffset:GLintptr,dstBuffer:ArrayBufferView,dstOffset?:GLuint,length?:GLuint):void;getFragDataLocation(program:WebGLProgram,name:string):GLint;getIndexedParameter(target:GLenum,index:GLuint):any;getInternalformatParameter(target:GLenum,internalformat:GLenum,pname:GLenum):any;getQuery(target:GLenum,pname:GLenum):WebGLQuery|null;getQueryParameter(query:WebGLQuery,pname:GLenum):any;getSamplerParameter(sampler:WebGLSampler,pname:GLenum):any;getSyncParameter(sync:WebGLSync,pname:GLenum):any;getTransformFeedbackVarying(program:WebGLProgram,index:GLuint):WebGLActiveInfo|null;getUniformBlockIndex(program:WebGLProgram,uniformBlockName:string):GLuint;getUniformIndices(program:WebGLProgram,uniformNames:string[]):GLuint[]|null;invalidateFramebuffer(target:GLenum,attachments:GLenum[]):void;invalidateSubFramebuffer(target:GLenum,attachments:GLenum[],x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;isQuery(query:WebGLQuery|null):GLboolean;isSampler(sampler:WebGLSampler|null):GLboolean;isSync(sync:WebGLSync|null):GLboolean;isTransformFeedback(tf:WebGLTransformFeedback|null):GLboolean;isVertexArray(vertexArray:WebGLVertexArrayObject|null):GLboolean;pauseTransformFeedback():void;readBuffer(src:GLenum):void;renderbufferStorageMultisample(target:GLenum,samples:GLsizei,internalformat:GLenum,width:GLsizei,height:GLsizei):void;resumeTransformFeedback():void;samplerParameterf(sampler:WebGLSampler,pname:GLenum,param:GLfloat):void;samplerParameteri(sampler:WebGLSampler,pname:GLenum,param:GLint):void;texImage3D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,format:GLenum,type:GLenum,pboOffset:GLintptr):void;texImage3D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;texImage3D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,format:GLenum,type:GLenum,srcData:ArrayBufferView|null):void;texImage3D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,format:GLenum,type:GLenum,srcData:ArrayBufferView,srcOffset:GLuint):void;texStorage2D(target:GLenum,levels:GLsizei,internalformat:GLenum,width:GLsizei,height:GLsizei):void;texStorage3D(target:GLenum,levels:GLsizei,internalformat:GLenum,width:GLsizei,height:GLsizei,depth:GLsizei):void;texSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,format:GLenum,type:GLenum,pboOffset:GLintptr):void;texSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,format:GLenum,type:GLenum,source:TexImageSource):void;texSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,format:GLenum,type:GLenum,srcData:ArrayBufferView|null,srcOffset?:GLuint):void;transformFeedbackVaryings(program:WebGLProgram,varyings:string[],bufferMode:GLenum):void;uniform1ui(location:WebGLUniformLocation|null,v0:GLuint):void;uniform1uiv(location:WebGLUniformLocation|null,data:Uint32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform2ui(location:WebGLUniformLocation|null,v0:GLuint,v1:GLuint):void;uniform2uiv(location:WebGLUniformLocation|null,data:Uint32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform3ui(location:WebGLUniformLocation|null,v0:GLuint,v1:GLuint,v2:GLuint):void;uniform3uiv(location:WebGLUniformLocation|null,data:Uint32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform4ui(location:WebGLUniformLocation|null,v0:GLuint,v1:GLuint,v2:GLuint,v3:GLuint):void;uniform4uiv(location:WebGLUniformLocation|null,data:Uint32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformBlockBinding(program:WebGLProgram,uniformBlockIndex:GLuint,uniformBlockBinding:GLuint):void;uniformMatrix2x3fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix2x4fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix3x2fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix3x4fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix4x2fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix4x3fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;vertexAttribDivisor(index:GLuint,divisor:GLuint):void;vertexAttribI4i(index:GLuint,x:GLint,y:GLint,z:GLint,w:GLint):void;vertexAttribI4iv(index:GLuint,values:Int32List):void;vertexAttribI4ui(index:GLuint,x:GLuint,y:GLuint,z:GLuint,w:GLuint):void;vertexAttribI4uiv(index:GLuint,values:Uint32List):void;vertexAttribIPointer(index:GLuint,size:GLint,type:GLenum,stride:GLsizei,offset:GLintptr):void;waitSync(sync:WebGLSync,flags:GLbitfield,timeout:GLint64):void;readonly ACTIVE_UNIFORM_BLOCKS:GLenum;readonly ALREADY_SIGNALED:GLenum;readonly ANY_SAMPLES_PASSED:GLenum;readonly ANY_SAMPLES_PASSED_CONSERVATIVE:GLenum;readonly COLOR:GLenum;readonly COLOR_ATTACHMENT1:GLenum;readonly COLOR_ATTACHMENT10:GLenum;readonly COLOR_ATTACHMENT11:GLenum;readonly COLOR_ATTACHMENT12:GLenum;readonly COLOR_ATTACHMENT13:GLenum;readonly COLOR_ATTACHMENT14:GLenum;readonly COLOR_ATTACHMENT15:GLenum;readonly COLOR_ATTACHMENT2:GLenum;readonly COLOR_ATTACHMENT3:GLenum;readonly COLOR_ATTACHMENT4:GLenum;readonly COLOR_ATTACHMENT5:GLenum;readonly COLOR_ATTACHMENT6:GLenum;readonly COLOR_ATTACHMENT7:GLenum;readonly COLOR_ATTACHMENT8:GLenum;readonly COLOR_ATTACHMENT9:GLenum;readonly COMPARE_REF_TO_TEXTURE:GLenum;readonly CONDITION_SATISFIED:GLenum;readonly COPY_READ_BUFFER:GLenum;readonly COPY_READ_BUFFER_BINDING:GLenum;readonly COPY_WRITE_BUFFER:GLenum;readonly COPY_WRITE_BUFFER_BINDING:GLenum;readonly CURRENT_QUERY:GLenum;readonly DEPTH:GLenum;readonly DEPTH24_STENCIL8:GLenum;readonly DEPTH32F_STENCIL8:GLenum;readonly DEPTH_COMPONENT24:GLenum;readonly DEPTH_COMPONENT32F:GLenum;readonly DRAW_BUFFER0:GLenum;readonly DRAW_BUFFER1:GLenum;readonly DRAW_BUFFER10:GLenum;readonly DRAW_BUFFER11:GLenum;readonly DRAW_BUFFER12:GLenum;readonly DRAW_BUFFER13:GLenum;readonly DRAW_BUFFER14:GLenum;readonly DRAW_BUFFER15:GLenum;readonly DRAW_BUFFER2:GLenum;readonly DRAW_BUFFER3:GLenum;readonly DRAW_BUFFER4:GLenum;readonly DRAW_BUFFER5:GLenum;readonly DRAW_BUFFER6:GLenum;readonly DRAW_BUFFER7:GLenum;readonly DRAW_BUFFER8:GLenum;readonly DRAW_BUFFER9:GLenum;readonly DRAW_FRAMEBUFFER:GLenum;readonly DRAW_FRAMEBUFFER_BINDING:GLenum;readonly DYNAMIC_COPY:GLenum;readonly DYNAMIC_READ:GLenum;readonly FLOAT_32_UNSIGNED_INT_24_8_REV:GLenum;readonly FLOAT_MAT2x3:GLenum;readonly FLOAT_MAT2x4:GLenum;readonly FLOAT_MAT3x2:GLenum;readonly FLOAT_MAT3x4:GLenum;readonly FLOAT_MAT4x2:GLenum;readonly FLOAT_MAT4x3:GLenum;readonly FRAGMENT_SHADER_DERIVATIVE_HINT:GLenum;readonly FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:GLenum;readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_RED_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:GLenum;readonly FRAMEBUFFER_DEFAULT:GLenum;readonly FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:GLenum;readonly HALF_FLOAT:GLenum;readonly INTERLEAVED_ATTRIBS:GLenum;readonly INT_2_10_10_10_REV:GLenum;readonly INT_SAMPLER_2D:GLenum;readonly INT_SAMPLER_2D_ARRAY:GLenum;readonly INT_SAMPLER_3D:GLenum;readonly INT_SAMPLER_CUBE:GLenum;readonly INVALID_INDEX:GLenum;readonly MAX:GLenum;readonly MAX_3D_TEXTURE_SIZE:GLenum;readonly MAX_ARRAY_TEXTURE_LAYERS:GLenum;readonly MAX_CLIENT_WAIT_TIMEOUT_WEBGL:GLenum;readonly MAX_COLOR_ATTACHMENTS:GLenum;readonly MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:GLenum;readonly MAX_COMBINED_UNIFORM_BLOCKS:GLenum;readonly MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:GLenum;readonly MAX_DRAW_BUFFERS:GLenum;readonly MAX_ELEMENTS_INDICES:GLenum;readonly MAX_ELEMENTS_VERTICES:GLenum;readonly MAX_ELEMENT_INDEX:GLenum;readonly MAX_FRAGMENT_INPUT_COMPONENTS:GLenum;readonly MAX_FRAGMENT_UNIFORM_BLOCKS:GLenum;readonly MAX_FRAGMENT_UNIFORM_COMPONENTS:GLenum;readonly MAX_PROGRAM_TEXEL_OFFSET:GLenum;readonly MAX_SAMPLES:GLenum;readonly MAX_SERVER_WAIT_TIMEOUT:GLenum;readonly MAX_TEXTURE_LOD_BIAS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:GLenum;readonly MAX_UNIFORM_BLOCK_SIZE:GLenum;readonly MAX_UNIFORM_BUFFER_BINDINGS:GLenum;readonly MAX_VARYING_COMPONENTS:GLenum;readonly MAX_VERTEX_OUTPUT_COMPONENTS:GLenum;readonly MAX_VERTEX_UNIFORM_BLOCKS:GLenum;readonly MAX_VERTEX_UNIFORM_COMPONENTS:GLenum;readonly MIN:GLenum;readonly MIN_PROGRAM_TEXEL_OFFSET:GLenum;readonly OBJECT_TYPE:GLenum;readonly PACK_ROW_LENGTH:GLenum;readonly PACK_SKIP_PIXELS:GLenum;readonly PACK_SKIP_ROWS:GLenum;readonly PIXEL_PACK_BUFFER:GLenum;readonly PIXEL_PACK_BUFFER_BINDING:GLenum;readonly PIXEL_UNPACK_BUFFER:GLenum;readonly PIXEL_UNPACK_BUFFER_BINDING:GLenum;readonly QUERY_RESULT:GLenum;readonly QUERY_RESULT_AVAILABLE:GLenum;readonly R11F_G11F_B10F:GLenum;readonly R16F:GLenum;readonly R16I:GLenum;readonly R16UI:GLenum;readonly R32F:GLenum;readonly R32I:GLenum;readonly R32UI:GLenum;readonly R8:GLenum;readonly R8I:GLenum;readonly R8UI:GLenum;readonly R8_SNORM:GLenum;readonly RASTERIZER_DISCARD:GLenum;readonly READ_BUFFER:GLenum;readonly READ_FRAMEBUFFER:GLenum;readonly READ_FRAMEBUFFER_BINDING:GLenum;readonly RED:GLenum;readonly RED_INTEGER:GLenum;readonly RENDERBUFFER_SAMPLES:GLenum;readonly RG:GLenum;readonly RG16F:GLenum;readonly RG16I:GLenum;readonly RG16UI:GLenum;readonly RG32F:GLenum;readonly RG32I:GLenum;readonly RG32UI:GLenum;readonly RG8:GLenum;readonly RG8I:GLenum;readonly RG8UI:GLenum;readonly RG8_SNORM:GLenum;readonly RGB10_A2:GLenum;readonly RGB10_A2UI:GLenum;readonly RGB16F:GLenum;readonly RGB16I:GLenum;readonly RGB16UI:GLenum;readonly RGB32F:GLenum;readonly RGB32I:GLenum;readonly RGB32UI:GLenum;readonly RGB8:GLenum;readonly RGB8I:GLenum;readonly RGB8UI:GLenum;readonly RGB8_SNORM:GLenum;readonly RGB9_E5:GLenum;readonly RGBA16F:GLenum;readonly RGBA16I:GLenum;readonly RGBA16UI:GLenum;readonly RGBA32F:GLenum;readonly RGBA32I:GLenum;readonly RGBA32UI:GLenum;readonly RGBA8:GLenum;readonly RGBA8I:GLenum;readonly RGBA8UI:GLenum;readonly RGBA8_SNORM:GLenum;readonly RGBA_INTEGER:GLenum;readonly RGB_INTEGER:GLenum;readonly RG_INTEGER:GLenum;readonly SAMPLER_2D_ARRAY:GLenum;readonly SAMPLER_2D_ARRAY_SHADOW:GLenum;readonly SAMPLER_2D_SHADOW:GLenum;readonly SAMPLER_3D:GLenum;readonly SAMPLER_BINDING:GLenum;readonly SAMPLER_CUBE_SHADOW:GLenum;readonly SEPARATE_ATTRIBS:GLenum;readonly SIGNALED:GLenum;readonly SIGNED_NORMALIZED:GLenum;readonly SRGB:GLenum;readonly SRGB8:GLenum;readonly SRGB8_ALPHA8:GLenum;readonly STATIC_COPY:GLenum;readonly STATIC_READ:GLenum;readonly STENCIL:GLenum;readonly STREAM_COPY:GLenum;readonly STREAM_READ:GLenum;readonly SYNC_CONDITION:GLenum;readonly SYNC_FENCE:GLenum;readonly SYNC_FLAGS:GLenum;readonly SYNC_FLUSH_COMMANDS_BIT:GLenum;readonly SYNC_GPU_COMMANDS_COMPLETE:GLenum;readonly SYNC_STATUS:GLenum;readonly TEXTURE_2D_ARRAY:GLenum;readonly TEXTURE_3D:GLenum;readonly TEXTURE_BASE_LEVEL:GLenum;readonly TEXTURE_BINDING_2D_ARRAY:GLenum;readonly TEXTURE_BINDING_3D:GLenum;readonly TEXTURE_COMPARE_FUNC:GLenum;readonly TEXTURE_COMPARE_MODE:GLenum;readonly TEXTURE_IMMUTABLE_FORMAT:GLenum;readonly TEXTURE_IMMUTABLE_LEVELS:GLenum;readonly TEXTURE_MAX_LEVEL:GLenum;readonly TEXTURE_MAX_LOD:GLenum;readonly TEXTURE_MIN_LOD:GLenum;readonly TEXTURE_WRAP_R:GLenum;readonly TIMEOUT_EXPIRED:GLenum;readonly TIMEOUT_IGNORED:GLint64;readonly TRANSFORM_FEEDBACK:GLenum;readonly TRANSFORM_FEEDBACK_ACTIVE:GLenum;readonly TRANSFORM_FEEDBACK_BINDING:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_BINDING:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_MODE:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_SIZE:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_START:GLenum;readonly TRANSFORM_FEEDBACK_PAUSED:GLenum;readonly TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:GLenum;readonly TRANSFORM_FEEDBACK_VARYINGS:GLenum;readonly UNIFORM_ARRAY_STRIDE:GLenum;readonly UNIFORM_BLOCK_ACTIVE_UNIFORMS:GLenum;readonly UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:GLenum;readonly UNIFORM_BLOCK_BINDING:GLenum;readonly UNIFORM_BLOCK_DATA_SIZE:GLenum;readonly UNIFORM_BLOCK_INDEX:GLenum;readonly UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:GLenum;readonly UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:GLenum;readonly UNIFORM_BUFFER:GLenum;readonly UNIFORM_BUFFER_BINDING:GLenum;readonly UNIFORM_BUFFER_OFFSET_ALIGNMENT:GLenum;readonly UNIFORM_BUFFER_SIZE:GLenum;readonly UNIFORM_BUFFER_START:GLenum;readonly UNIFORM_IS_ROW_MAJOR:GLenum;readonly UNIFORM_MATRIX_STRIDE:GLenum;readonly UNIFORM_OFFSET:GLenum;readonly UNIFORM_SIZE:GLenum;readonly UNIFORM_TYPE:GLenum;readonly UNPACK_IMAGE_HEIGHT:GLenum;readonly UNPACK_ROW_LENGTH:GLenum;readonly UNPACK_SKIP_IMAGES:GLenum;readonly UNPACK_SKIP_PIXELS:GLenum;readonly UNPACK_SKIP_ROWS:GLenum;readonly UNSIGNALED:GLenum;readonly UNSIGNED_INT_10F_11F_11F_REV:GLenum;readonly UNSIGNED_INT_24_8:GLenum;readonly UNSIGNED_INT_2_10_10_10_REV:GLenum;readonly UNSIGNED_INT_5_9_9_9_REV:GLenum;readonly UNSIGNED_INT_SAMPLER_2D:GLenum;readonly UNSIGNED_INT_SAMPLER_2D_ARRAY:GLenum;readonly UNSIGNED_INT_SAMPLER_3D:GLenum;readonly UNSIGNED_INT_SAMPLER_CUBE:GLenum;readonly UNSIGNED_INT_VEC2:GLenum;readonly UNSIGNED_INT_VEC3:GLenum;readonly UNSIGNED_INT_VEC4:GLenum;readonly UNSIGNED_NORMALIZED:GLenum;readonly VERTEX_ARRAY_BINDING:GLenum;readonly VERTEX_ATTRIB_ARRAY_DIVISOR:GLenum;readonly VERTEX_ATTRIB_ARRAY_INTEGER:GLenum;readonly WAIT_FAILED:GLenum;}interface WebGL2RenderingContextOverloads{bufferData(target:GLenum,size:GLsizeiptr,usage:GLenum):void;bufferData(target:GLenum,srcData:BufferSource|null,usage:GLenum):void;bufferData(target:GLenum,srcData:ArrayBufferView,usage:GLenum,srcOffset:GLuint,length?:GLuint):void;bufferSubData(target:GLenum,dstByteOffset:GLintptr,srcData:BufferSource):void;bufferSubData(target:GLenum,dstByteOffset:GLintptr,srcData:ArrayBufferView,srcOffset:GLuint,length?:GLuint):void;compressedTexImage2D(target:GLenum,level:GLint,internalformat:GLenum,width:GLsizei,height:GLsizei,border:GLint,imageSize:GLsizei,offset:GLintptr):void;compressedTexImage2D(target:GLenum,level:GLint,internalformat:GLenum,width:GLsizei,height:GLsizei,border:GLint,srcData:ArrayBufferView,srcOffset?:GLuint,srcLengthOverride?:GLuint):void;compressedTexSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,imageSize:GLsizei,offset:GLintptr):void;compressedTexSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,srcData:ArrayBufferView,srcOffset?:GLuint,srcLengthOverride?:GLuint):void;readPixels(x:GLint,y:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,dstData:ArrayBufferView|null):void;readPixels(x:GLint,y:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,offset:GLintptr):void;readPixels(x:GLint,y:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,dstData:ArrayBufferView,dstOffset:GLuint):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,border:GLint,format:GLenum,type:GLenum,pixels:ArrayBufferView|null):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,border:GLint,format:GLenum,type:GLenum,pboOffset:GLintptr):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,border:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,border:GLint,format:GLenum,type:GLenum,srcData:ArrayBufferView,srcOffset:GLuint):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,pixels:ArrayBufferView|null):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,pboOffset:GLintptr):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,source:TexImageSource):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,srcData:ArrayBufferView,srcOffset:GLuint):void;uniform1fv(location:WebGLUniformLocation|null,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform1iv(location:WebGLUniformLocation|null,data:Int32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform2fv(location:WebGLUniformLocation|null,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform2iv(location:WebGLUniformLocation|null,data:Int32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform3fv(location:WebGLUniformLocation|null,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform3iv(location:WebGLUniformLocation|null,data:Int32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform4fv(location:WebGLUniformLocation|null,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform4iv(location:WebGLUniformLocation|null,data:Int32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix2fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix3fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix4fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;}interface WebGLActiveInfo{readonly name:string;readonly size:GLint;readonly type:GLenum;}declare var WebGLActiveInfo:{prototype:WebGLActiveInfo;new():WebGLActiveInfo;};interface WebGLBuffer extends WebGLObject{}declare var WebGLBuffer:{prototype:WebGLBuffer;new():WebGLBuffer;};interface WebGLContextEvent extends Event{readonly statusMessage:string;}declare var WebGLContextEvent:{prototype:WebGLContextEvent;new(type:string,eventInit?:WebGLContextEventInit):WebGLContextEvent;};interface WebGLFramebuffer extends WebGLObject{}declare var WebGLFramebuffer:{prototype:WebGLFramebuffer;new():WebGLFramebuffer;};interface WebGLObject{}declare var WebGLObject:{prototype:WebGLObject;new():WebGLObject;};interface WebGLProgram extends WebGLObject{}declare var WebGLProgram:{prototype:WebGLProgram;new():WebGLProgram;};interface WebGLQuery extends WebGLObject{}declare var WebGLQuery:{prototype:WebGLQuery;new():WebGLQuery;};interface WebGLRenderbuffer extends WebGLObject{}declare var WebGLRenderbuffer:{prototype:WebGLRenderbuffer;new():WebGLRenderbuffer;};interface WebGLRenderingContext extends WebGLRenderingContextBase,WebGLRenderingContextOverloads{}declare var WebGLRenderingContext:{prototype:WebGLRenderingContext;new():WebGLRenderingContext;readonly ACTIVE_ATTRIBUTES:GLenum;readonly ACTIVE_TEXTURE:GLenum;readonly ACTIVE_UNIFORMS:GLenum;readonly ALIASED_LINE_WIDTH_RANGE:GLenum;readonly ALIASED_POINT_SIZE_RANGE:GLenum;readonly ALPHA:GLenum;readonly ALPHA_BITS:GLenum;readonly ALWAYS:GLenum;readonly ARRAY_BUFFER:GLenum;readonly ARRAY_BUFFER_BINDING:GLenum;readonly ATTACHED_SHADERS:GLenum;readonly BACK:GLenum;readonly BLEND:GLenum;readonly BLEND_COLOR:GLenum;readonly BLEND_DST_ALPHA:GLenum;readonly BLEND_DST_RGB:GLenum;readonly BLEND_EQUATION:GLenum;readonly BLEND_EQUATION_ALPHA:GLenum;readonly BLEND_EQUATION_RGB:GLenum;readonly BLEND_SRC_ALPHA:GLenum;readonly BLEND_SRC_RGB:GLenum;readonly BLUE_BITS:GLenum;readonly BOOL:GLenum;readonly BOOL_VEC2:GLenum;readonly BOOL_VEC3:GLenum;readonly BOOL_VEC4:GLenum;readonly BROWSER_DEFAULT_WEBGL:GLenum;readonly BUFFER_SIZE:GLenum;readonly BUFFER_USAGE:GLenum;readonly BYTE:GLenum;readonly CCW:GLenum;readonly CLAMP_TO_EDGE:GLenum;readonly COLOR_ATTACHMENT0:GLenum;readonly COLOR_BUFFER_BIT:GLenum;readonly COLOR_CLEAR_VALUE:GLenum;readonly COLOR_WRITEMASK:GLenum;readonly COMPILE_STATUS:GLenum;readonly COMPRESSED_TEXTURE_FORMATS:GLenum;readonly CONSTANT_ALPHA:GLenum;readonly CONSTANT_COLOR:GLenum;readonly CONTEXT_LOST_WEBGL:GLenum;readonly CULL_FACE:GLenum;readonly CULL_FACE_MODE:GLenum;readonly CURRENT_PROGRAM:GLenum;readonly CURRENT_VERTEX_ATTRIB:GLenum;readonly CW:GLenum;readonly DECR:GLenum;readonly DECR_WRAP:GLenum;readonly DELETE_STATUS:GLenum;readonly DEPTH_ATTACHMENT:GLenum;readonly DEPTH_BITS:GLenum;readonly DEPTH_BUFFER_BIT:GLenum;readonly DEPTH_CLEAR_VALUE:GLenum;readonly DEPTH_COMPONENT:GLenum;readonly DEPTH_COMPONENT16:GLenum;readonly DEPTH_FUNC:GLenum;readonly DEPTH_RANGE:GLenum;readonly DEPTH_STENCIL:GLenum;readonly DEPTH_STENCIL_ATTACHMENT:GLenum;readonly DEPTH_TEST:GLenum;readonly DEPTH_WRITEMASK:GLenum;readonly DITHER:GLenum;readonly DONT_CARE:GLenum;readonly DST_ALPHA:GLenum;readonly DST_COLOR:GLenum;readonly DYNAMIC_DRAW:GLenum;readonly ELEMENT_ARRAY_BUFFER:GLenum;readonly ELEMENT_ARRAY_BUFFER_BINDING:GLenum;readonly EQUAL:GLenum;readonly FASTEST:GLenum;readonly FLOAT:GLenum;readonly FLOAT_MAT2:GLenum;readonly FLOAT_MAT3:GLenum;readonly FLOAT_MAT4:GLenum;readonly FLOAT_VEC2:GLenum;readonly FLOAT_VEC3:GLenum;readonly FLOAT_VEC4:GLenum;readonly FRAGMENT_SHADER:GLenum;readonly FRAMEBUFFER:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:GLenum;readonly FRAMEBUFFER_BINDING:GLenum;readonly FRAMEBUFFER_COMPLETE:GLenum;readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT:GLenum;readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS:GLenum;readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:GLenum;readonly FRAMEBUFFER_UNSUPPORTED:GLenum;readonly FRONT:GLenum;readonly FRONT_AND_BACK:GLenum;readonly FRONT_FACE:GLenum;readonly FUNC_ADD:GLenum;readonly FUNC_REVERSE_SUBTRACT:GLenum;readonly FUNC_SUBTRACT:GLenum;readonly GENERATE_MIPMAP_HINT:GLenum;readonly GEQUAL:GLenum;readonly GREATER:GLenum;readonly GREEN_BITS:GLenum;readonly HIGH_FLOAT:GLenum;readonly HIGH_INT:GLenum;readonly IMPLEMENTATION_COLOR_READ_FORMAT:GLenum;readonly IMPLEMENTATION_COLOR_READ_TYPE:GLenum;readonly INCR:GLenum;readonly INCR_WRAP:GLenum;readonly INT:GLenum;readonly INT_VEC2:GLenum;readonly INT_VEC3:GLenum;readonly INT_VEC4:GLenum;readonly INVALID_ENUM:GLenum;readonly INVALID_FRAMEBUFFER_OPERATION:GLenum;readonly INVALID_OPERATION:GLenum;readonly INVALID_VALUE:GLenum;readonly INVERT:GLenum;readonly KEEP:GLenum;readonly LEQUAL:GLenum;readonly LESS:GLenum;readonly LINEAR:GLenum;readonly LINEAR_MIPMAP_LINEAR:GLenum;readonly LINEAR_MIPMAP_NEAREST:GLenum;readonly LINES:GLenum;readonly LINE_LOOP:GLenum;readonly LINE_STRIP:GLenum;readonly LINE_WIDTH:GLenum;readonly LINK_STATUS:GLenum;readonly LOW_FLOAT:GLenum;readonly LOW_INT:GLenum;readonly LUMINANCE:GLenum;readonly LUMINANCE_ALPHA:GLenum;readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_CUBE_MAP_TEXTURE_SIZE:GLenum;readonly MAX_FRAGMENT_UNIFORM_VECTORS:GLenum;readonly MAX_RENDERBUFFER_SIZE:GLenum;readonly MAX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_TEXTURE_SIZE:GLenum;readonly MAX_VARYING_VECTORS:GLenum;readonly MAX_VERTEX_ATTRIBS:GLenum;readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_VERTEX_UNIFORM_VECTORS:GLenum;readonly MAX_VIEWPORT_DIMS:GLenum;readonly MEDIUM_FLOAT:GLenum;readonly MEDIUM_INT:GLenum;readonly MIRRORED_REPEAT:GLenum;readonly NEAREST:GLenum;readonly NEAREST_MIPMAP_LINEAR:GLenum;readonly NEAREST_MIPMAP_NEAREST:GLenum;readonly NEVER:GLenum;readonly NICEST:GLenum;readonly NONE:GLenum;readonly NOTEQUAL:GLenum;readonly NO_ERROR:GLenum;readonly ONE:GLenum;readonly ONE_MINUS_CONSTANT_ALPHA:GLenum;readonly ONE_MINUS_CONSTANT_COLOR:GLenum;readonly ONE_MINUS_DST_ALPHA:GLenum;readonly ONE_MINUS_DST_COLOR:GLenum;readonly ONE_MINUS_SRC_ALPHA:GLenum;readonly ONE_MINUS_SRC_COLOR:GLenum;readonly OUT_OF_MEMORY:GLenum;readonly PACK_ALIGNMENT:GLenum;readonly POINTS:GLenum;readonly POLYGON_OFFSET_FACTOR:GLenum;readonly POLYGON_OFFSET_FILL:GLenum;readonly POLYGON_OFFSET_UNITS:GLenum;readonly RED_BITS:GLenum;readonly RENDERBUFFER:GLenum;readonly RENDERBUFFER_ALPHA_SIZE:GLenum;readonly RENDERBUFFER_BINDING:GLenum;readonly RENDERBUFFER_BLUE_SIZE:GLenum;readonly RENDERBUFFER_DEPTH_SIZE:GLenum;readonly RENDERBUFFER_GREEN_SIZE:GLenum;readonly RENDERBUFFER_HEIGHT:GLenum;readonly RENDERBUFFER_INTERNAL_FORMAT:GLenum;readonly RENDERBUFFER_RED_SIZE:GLenum;readonly RENDERBUFFER_STENCIL_SIZE:GLenum;readonly RENDERBUFFER_WIDTH:GLenum;readonly RENDERER:GLenum;readonly REPEAT:GLenum;readonly REPLACE:GLenum;readonly RGB:GLenum;readonly RGB565:GLenum;readonly RGB5_A1:GLenum;readonly RGBA:GLenum;readonly RGBA4:GLenum;readonly SAMPLER_2D:GLenum;readonly SAMPLER_CUBE:GLenum;readonly SAMPLES:GLenum;readonly SAMPLE_ALPHA_TO_COVERAGE:GLenum;readonly SAMPLE_BUFFERS:GLenum;readonly SAMPLE_COVERAGE:GLenum;readonly SAMPLE_COVERAGE_INVERT:GLenum;readonly SAMPLE_COVERAGE_VALUE:GLenum;readonly SCISSOR_BOX:GLenum;readonly SCISSOR_TEST:GLenum;readonly SHADER_TYPE:GLenum;readonly SHADING_LANGUAGE_VERSION:GLenum;readonly SHORT:GLenum;readonly SRC_ALPHA:GLenum;readonly SRC_ALPHA_SATURATE:GLenum;readonly SRC_COLOR:GLenum;readonly STATIC_DRAW:GLenum;readonly STENCIL_ATTACHMENT:GLenum;readonly STENCIL_BACK_FAIL:GLenum;readonly STENCIL_BACK_FUNC:GLenum;readonly STENCIL_BACK_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_BACK_PASS_DEPTH_PASS:GLenum;readonly STENCIL_BACK_REF:GLenum;readonly STENCIL_BACK_VALUE_MASK:GLenum;readonly STENCIL_BACK_WRITEMASK:GLenum;readonly STENCIL_BITS:GLenum;readonly STENCIL_BUFFER_BIT:GLenum;readonly STENCIL_CLEAR_VALUE:GLenum;readonly STENCIL_FAIL:GLenum;readonly STENCIL_FUNC:GLenum;readonly STENCIL_INDEX8:GLenum;readonly STENCIL_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_PASS_DEPTH_PASS:GLenum;readonly STENCIL_REF:GLenum;readonly STENCIL_TEST:GLenum;readonly STENCIL_VALUE_MASK:GLenum;readonly STENCIL_WRITEMASK:GLenum;readonly STREAM_DRAW:GLenum;readonly SUBPIXEL_BITS:GLenum;readonly TEXTURE:GLenum;readonly TEXTURE0:GLenum;readonly TEXTURE1:GLenum;readonly TEXTURE10:GLenum;readonly TEXTURE11:GLenum;readonly TEXTURE12:GLenum;readonly TEXTURE13:GLenum;readonly TEXTURE14:GLenum;readonly TEXTURE15:GLenum;readonly TEXTURE16:GLenum;readonly TEXTURE17:GLenum;readonly TEXTURE18:GLenum;readonly TEXTURE19:GLenum;readonly TEXTURE2:GLenum;readonly TEXTURE20:GLenum;readonly TEXTURE21:GLenum;readonly TEXTURE22:GLenum;readonly TEXTURE23:GLenum;readonly TEXTURE24:GLenum;readonly TEXTURE25:GLenum;readonly TEXTURE26:GLenum;readonly TEXTURE27:GLenum;readonly TEXTURE28:GLenum;readonly TEXTURE29:GLenum;readonly TEXTURE3:GLenum;readonly TEXTURE30:GLenum;readonly TEXTURE31:GLenum;readonly TEXTURE4:GLenum;readonly TEXTURE5:GLenum;readonly TEXTURE6:GLenum;readonly TEXTURE7:GLenum;readonly TEXTURE8:GLenum;readonly TEXTURE9:GLenum;readonly TEXTURE_2D:GLenum;readonly TEXTURE_BINDING_2D:GLenum;readonly TEXTURE_BINDING_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Z:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Z:GLenum;readonly TEXTURE_MAG_FILTER:GLenum;readonly TEXTURE_MIN_FILTER:GLenum;readonly TEXTURE_WRAP_S:GLenum;readonly TEXTURE_WRAP_T:GLenum;readonly TRIANGLES:GLenum;readonly TRIANGLE_FAN:GLenum;readonly TRIANGLE_STRIP:GLenum;readonly UNPACK_ALIGNMENT:GLenum;readonly UNPACK_COLORSPACE_CONVERSION_WEBGL:GLenum;readonly UNPACK_FLIP_Y_WEBGL:GLenum;readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL:GLenum;readonly UNSIGNED_BYTE:GLenum;readonly UNSIGNED_INT:GLenum;readonly UNSIGNED_SHORT:GLenum;readonly UNSIGNED_SHORT_4_4_4_4:GLenum;readonly UNSIGNED_SHORT_5_5_5_1:GLenum;readonly UNSIGNED_SHORT_5_6_5:GLenum;readonly VALIDATE_STATUS:GLenum;readonly VENDOR:GLenum;readonly VERSION:GLenum;readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:GLenum;readonly VERTEX_ATTRIB_ARRAY_ENABLED:GLenum;readonly VERTEX_ATTRIB_ARRAY_NORMALIZED:GLenum;readonly VERTEX_ATTRIB_ARRAY_POINTER:GLenum;readonly VERTEX_ATTRIB_ARRAY_SIZE:GLenum;readonly VERTEX_ATTRIB_ARRAY_STRIDE:GLenum;readonly VERTEX_ATTRIB_ARRAY_TYPE:GLenum;readonly VERTEX_SHADER:GLenum;readonly VIEWPORT:GLenum;readonly ZERO:GLenum;};interface WebGLRenderingContextBase{readonly canvas:HTMLCanvasElement|OffscreenCanvas;readonly drawingBufferHeight:GLsizei;readonly drawingBufferWidth:GLsizei;activeTexture(texture:GLenum):void;attachShader(program:WebGLProgram,shader:WebGLShader):void;bindAttribLocation(program:WebGLProgram,index:GLuint,name:string):void;bindBuffer(target:GLenum,buffer:WebGLBuffer|null):void;bindFramebuffer(target:GLenum,framebuffer:WebGLFramebuffer|null):void;bindRenderbuffer(target:GLenum,renderbuffer:WebGLRenderbuffer|null):void;bindTexture(target:GLenum,texture:WebGLTexture|null):void;blendColor(red:GLclampf,green:GLclampf,blue:GLclampf,alpha:GLclampf):void;blendEquation(mode:GLenum):void;blendEquationSeparate(modeRGB:GLenum,modeAlpha:GLenum):void;blendFunc(sfactor:GLenum,dfactor:GLenum):void;blendFuncSeparate(srcRGB:GLenum,dstRGB:GLenum,srcAlpha:GLenum,dstAlpha:GLenum):void;checkFramebufferStatus(target:GLenum):GLenum;clear(mask:GLbitfield):void;clearColor(red:GLclampf,green:GLclampf,blue:GLclampf,alpha:GLclampf):void;clearDepth(depth:GLclampf):void;clearStencil(s:GLint):void;colorMask(red:GLboolean,green:GLboolean,blue:GLboolean,alpha:GLboolean):void;compileShader(shader:WebGLShader):void;copyTexImage2D(target:GLenum,level:GLint,internalformat:GLenum,x:GLint,y:GLint,width:GLsizei,height:GLsizei,border:GLint):void;copyTexSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;createBuffer():WebGLBuffer|null;createFramebuffer():WebGLFramebuffer|null;createProgram():WebGLProgram|null;createRenderbuffer():WebGLRenderbuffer|null;createShader(type:GLenum):WebGLShader|null;createTexture():WebGLTexture|null;cullFace(mode:GLenum):void;deleteBuffer(buffer:WebGLBuffer|null):void;deleteFramebuffer(framebuffer:WebGLFramebuffer|null):void;deleteProgram(program:WebGLProgram|null):void;deleteRenderbuffer(renderbuffer:WebGLRenderbuffer|null):void;deleteShader(shader:WebGLShader|null):void;deleteTexture(texture:WebGLTexture|null):void;depthFunc(func:GLenum):void;depthMask(flag:GLboolean):void;depthRange(zNear:GLclampf,zFar:GLclampf):void;detachShader(program:WebGLProgram,shader:WebGLShader):void;disable(cap:GLenum):void;disableVertexAttribArray(index:GLuint):void;drawArrays(mode:GLenum,first:GLint,count:GLsizei):void;drawElements(mode:GLenum,count:GLsizei,type:GLenum,offset:GLintptr):void;enable(cap:GLenum):void;enableVertexAttribArray(index:GLuint):void;finish():void;flush():void;framebufferRenderbuffer(target:GLenum,attachment:GLenum,renderbuffertarget:GLenum,renderbuffer:WebGLRenderbuffer|null):void;framebufferTexture2D(target:GLenum,attachment:GLenum,textarget:GLenum,texture:WebGLTexture|null,level:GLint):void;frontFace(mode:GLenum):void;generateMipmap(target:GLenum):void;getActiveAttrib(program:WebGLProgram,index:GLuint):WebGLActiveInfo|null;getActiveUniform(program:WebGLProgram,index:GLuint):WebGLActiveInfo|null;getAttachedShaders(program:WebGLProgram):WebGLShader[]|null;getAttribLocation(program:WebGLProgram,name:string):GLint;getBufferParameter(target:GLenum,pname:GLenum):any;getContextAttributes():WebGLContextAttributes|null;getError():GLenum;getExtension(extensionName:"EXT_blend_minmax"):EXT_blend_minmax|null;getExtension(extensionName:"EXT_texture_filter_anisotropic"):EXT_texture_filter_anisotropic|null;getExtension(extensionName:"EXT_frag_depth"):EXT_frag_depth|null;getExtension(extensionName:"EXT_shader_texture_lod"):EXT_shader_texture_lod|null;getExtension(extensionName:"EXT_sRGB"):EXT_sRGB|null;getExtension(extensionName:"OES_vertex_array_object"):OES_vertex_array_object|null;getExtension(extensionName:"WEBGL_color_buffer_float"):WEBGL_color_buffer_float|null;getExtension(extensionName:"WEBGL_compressed_texture_astc"):WEBGL_compressed_texture_astc|null;getExtension(extensionName:"WEBGL_compressed_texture_s3tc_srgb"):WEBGL_compressed_texture_s3tc_srgb|null;getExtension(extensionName:"WEBGL_debug_shaders"):WEBGL_debug_shaders|null;getExtension(extensionName:"WEBGL_draw_buffers"):WEBGL_draw_buffers|null;getExtension(extensionName:"WEBGL_lose_context"):WEBGL_lose_context|null;getExtension(extensionName:"WEBGL_depth_texture"):WEBGL_depth_texture|null;getExtension(extensionName:"WEBGL_debug_renderer_info"):WEBGL_debug_renderer_info|null;getExtension(extensionName:"WEBGL_compressed_texture_s3tc"):WEBGL_compressed_texture_s3tc|null;getExtension(extensionName:"OES_texture_half_float_linear"):OES_texture_half_float_linear|null;getExtension(extensionName:"OES_texture_half_float"):OES_texture_half_float|null;getExtension(extensionName:"OES_texture_float_linear"):OES_texture_float_linear|null;getExtension(extensionName:"OES_texture_float"):OES_texture_float|null;getExtension(extensionName:"OES_standard_derivatives"):OES_standard_derivatives|null;getExtension(extensionName:"OES_element_index_uint"):OES_element_index_uint|null;getExtension(extensionName:"ANGLE_instanced_arrays"):ANGLE_instanced_arrays|null;getExtension(extensionName:string):any;getFramebufferAttachmentParameter(target:GLenum,attachment:GLenum,pname:GLenum):any;getParameter(pname:GLenum):any;getProgramInfoLog(program:WebGLProgram):string|null;getProgramParameter(program:WebGLProgram,pname:GLenum):any;getRenderbufferParameter(target:GLenum,pname:GLenum):any;getShaderInfoLog(shader:WebGLShader):string|null;getShaderParameter(shader:WebGLShader,pname:GLenum):any;getShaderPrecisionFormat(shadertype:GLenum,precisiontype:GLenum):WebGLShaderPrecisionFormat|null;getShaderSource(shader:WebGLShader):string|null;getSupportedExtensions():string[]|null;getTexParameter(target:GLenum,pname:GLenum):any;getUniform(program:WebGLProgram,location:WebGLUniformLocation):any;getUniformLocation(program:WebGLProgram,name:string):WebGLUniformLocation|null;getVertexAttrib(index:GLuint,pname:GLenum):any;getVertexAttribOffset(index:GLuint,pname:GLenum):GLintptr;hint(target:GLenum,mode:GLenum):void;isBuffer(buffer:WebGLBuffer|null):GLboolean;isContextLost():boolean;isEnabled(cap:GLenum):GLboolean;isFramebuffer(framebuffer:WebGLFramebuffer|null):GLboolean;isProgram(program:WebGLProgram|null):GLboolean;isRenderbuffer(renderbuffer:WebGLRenderbuffer|null):GLboolean;isShader(shader:WebGLShader|null):GLboolean;isTexture(texture:WebGLTexture|null):GLboolean;lineWidth(width:GLfloat):void;linkProgram(program:WebGLProgram):void;pixelStorei(pname:GLenum,param:GLint|GLboolean):void;polygonOffset(factor:GLfloat,units:GLfloat):void;renderbufferStorage(target:GLenum,internalformat:GLenum,width:GLsizei,height:GLsizei):void;sampleCoverage(value:GLclampf,invert:GLboolean):void;scissor(x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;shaderSource(shader:WebGLShader,source:string):void;stencilFunc(func:GLenum,ref:GLint,mask:GLuint):void;stencilFuncSeparate(face:GLenum,func:GLenum,ref:GLint,mask:GLuint):void;stencilMask(mask:GLuint):void;stencilMaskSeparate(face:GLenum,mask:GLuint):void;stencilOp(fail:GLenum,zfail:GLenum,zpass:GLenum):void;stencilOpSeparate(face:GLenum,fail:GLenum,zfail:GLenum,zpass:GLenum):void;texParameterf(target:GLenum,pname:GLenum,param:GLfloat):void;texParameteri(target:GLenum,pname:GLenum,param:GLint):void;uniform1f(location:WebGLUniformLocation|null,x:GLfloat):void;uniform1i(location:WebGLUniformLocation|null,x:GLint):void;uniform2f(location:WebGLUniformLocation|null,x:GLfloat,y:GLfloat):void;uniform2i(location:WebGLUniformLocation|null,x:GLint,y:GLint):void;uniform3f(location:WebGLUniformLocation|null,x:GLfloat,y:GLfloat,z:GLfloat):void;uniform3i(location:WebGLUniformLocation|null,x:GLint,y:GLint,z:GLint):void;uniform4f(location:WebGLUniformLocation|null,x:GLfloat,y:GLfloat,z:GLfloat,w:GLfloat):void;uniform4i(location:WebGLUniformLocation|null,x:GLint,y:GLint,z:GLint,w:GLint):void;useProgram(program:WebGLProgram|null):void;validateProgram(program:WebGLProgram):void;vertexAttrib1f(index:GLuint,x:GLfloat):void;vertexAttrib1fv(index:GLuint,values:Float32List):void;vertexAttrib2f(index:GLuint,x:GLfloat,y:GLfloat):void;vertexAttrib2fv(index:GLuint,values:Float32List):void;vertexAttrib3f(index:GLuint,x:GLfloat,y:GLfloat,z:GLfloat):void;vertexAttrib3fv(index:GLuint,values:Float32List):void;vertexAttrib4f(index:GLuint,x:GLfloat,y:GLfloat,z:GLfloat,w:GLfloat):void;vertexAttrib4fv(index:GLuint,values:Float32List):void;vertexAttribPointer(index:GLuint,size:GLint,type:GLenum,normalized:GLboolean,stride:GLsizei,offset:GLintptr):void;viewport(x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;readonly ACTIVE_ATTRIBUTES:GLenum;readonly ACTIVE_TEXTURE:GLenum;readonly ACTIVE_UNIFORMS:GLenum;readonly ALIASED_LINE_WIDTH_RANGE:GLenum;readonly ALIASED_POINT_SIZE_RANGE:GLenum;readonly ALPHA:GLenum;readonly ALPHA_BITS:GLenum;readonly ALWAYS:GLenum;readonly ARRAY_BUFFER:GLenum;readonly ARRAY_BUFFER_BINDING:GLenum;readonly ATTACHED_SHADERS:GLenum;readonly BACK:GLenum;readonly BLEND:GLenum;readonly BLEND_COLOR:GLenum;readonly BLEND_DST_ALPHA:GLenum;readonly BLEND_DST_RGB:GLenum;readonly BLEND_EQUATION:GLenum;readonly BLEND_EQUATION_ALPHA:GLenum;readonly BLEND_EQUATION_RGB:GLenum;readonly BLEND_SRC_ALPHA:GLenum;readonly BLEND_SRC_RGB:GLenum;readonly BLUE_BITS:GLenum;readonly BOOL:GLenum;readonly BOOL_VEC2:GLenum;readonly BOOL_VEC3:GLenum;readonly BOOL_VEC4:GLenum;readonly BROWSER_DEFAULT_WEBGL:GLenum;readonly BUFFER_SIZE:GLenum;readonly BUFFER_USAGE:GLenum;readonly BYTE:GLenum;readonly CCW:GLenum;readonly CLAMP_TO_EDGE:GLenum;readonly COLOR_ATTACHMENT0:GLenum;readonly COLOR_BUFFER_BIT:GLenum;readonly COLOR_CLEAR_VALUE:GLenum;readonly COLOR_WRITEMASK:GLenum;readonly COMPILE_STATUS:GLenum;readonly COMPRESSED_TEXTURE_FORMATS:GLenum;readonly CONSTANT_ALPHA:GLenum;readonly CONSTANT_COLOR:GLenum;readonly CONTEXT_LOST_WEBGL:GLenum;readonly CULL_FACE:GLenum;readonly CULL_FACE_MODE:GLenum;readonly CURRENT_PROGRAM:GLenum;readonly CURRENT_VERTEX_ATTRIB:GLenum;readonly CW:GLenum;readonly DECR:GLenum;readonly DECR_WRAP:GLenum;readonly DELETE_STATUS:GLenum;readonly DEPTH_ATTACHMENT:GLenum;readonly DEPTH_BITS:GLenum;readonly DEPTH_BUFFER_BIT:GLenum;readonly DEPTH_CLEAR_VALUE:GLenum;readonly DEPTH_COMPONENT:GLenum;readonly DEPTH_COMPONENT16:GLenum;readonly DEPTH_FUNC:GLenum;readonly DEPTH_RANGE:GLenum;readonly DEPTH_STENCIL:GLenum;readonly DEPTH_STENCIL_ATTACHMENT:GLenum;readonly DEPTH_TEST:GLenum;readonly DEPTH_WRITEMASK:GLenum;readonly DITHER:GLenum;readonly DONT_CARE:GLenum;readonly DST_ALPHA:GLenum;readonly DST_COLOR:GLenum;readonly DYNAMIC_DRAW:GLenum;readonly ELEMENT_ARRAY_BUFFER:GLenum;readonly ELEMENT_ARRAY_BUFFER_BINDING:GLenum;readonly EQUAL:GLenum;readonly FASTEST:GLenum;readonly FLOAT:GLenum;readonly FLOAT_MAT2:GLenum;readonly FLOAT_MAT3:GLenum;readonly FLOAT_MAT4:GLenum;readonly FLOAT_VEC2:GLenum;readonly FLOAT_VEC3:GLenum;readonly FLOAT_VEC4:GLenum;readonly FRAGMENT_SHADER:GLenum;readonly FRAMEBUFFER:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:GLenum;readonly FRAMEBUFFER_BINDING:GLenum;readonly FRAMEBUFFER_COMPLETE:GLenum;readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT:GLenum;readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS:GLenum;readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:GLenum;readonly FRAMEBUFFER_UNSUPPORTED:GLenum;readonly FRONT:GLenum;readonly FRONT_AND_BACK:GLenum;readonly FRONT_FACE:GLenum;readonly FUNC_ADD:GLenum;readonly FUNC_REVERSE_SUBTRACT:GLenum;readonly FUNC_SUBTRACT:GLenum;readonly GENERATE_MIPMAP_HINT:GLenum;readonly GEQUAL:GLenum;readonly GREATER:GLenum;readonly GREEN_BITS:GLenum;readonly HIGH_FLOAT:GLenum;readonly HIGH_INT:GLenum;readonly IMPLEMENTATION_COLOR_READ_FORMAT:GLenum;readonly IMPLEMENTATION_COLOR_READ_TYPE:GLenum;readonly INCR:GLenum;readonly INCR_WRAP:GLenum;readonly INT:GLenum;readonly INT_VEC2:GLenum;readonly INT_VEC3:GLenum;readonly INT_VEC4:GLenum;readonly INVALID_ENUM:GLenum;readonly INVALID_FRAMEBUFFER_OPERATION:GLenum;readonly INVALID_OPERATION:GLenum;readonly INVALID_VALUE:GLenum;readonly INVERT:GLenum;readonly KEEP:GLenum;readonly LEQUAL:GLenum;readonly LESS:GLenum;readonly LINEAR:GLenum;readonly LINEAR_MIPMAP_LINEAR:GLenum;readonly LINEAR_MIPMAP_NEAREST:GLenum;readonly LINES:GLenum;readonly LINE_LOOP:GLenum;readonly LINE_STRIP:GLenum;readonly LINE_WIDTH:GLenum;readonly LINK_STATUS:GLenum;readonly LOW_FLOAT:GLenum;readonly LOW_INT:GLenum;readonly LUMINANCE:GLenum;readonly LUMINANCE_ALPHA:GLenum;readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_CUBE_MAP_TEXTURE_SIZE:GLenum;readonly MAX_FRAGMENT_UNIFORM_VECTORS:GLenum;readonly MAX_RENDERBUFFER_SIZE:GLenum;readonly MAX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_TEXTURE_SIZE:GLenum;readonly MAX_VARYING_VECTORS:GLenum;readonly MAX_VERTEX_ATTRIBS:GLenum;readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_VERTEX_UNIFORM_VECTORS:GLenum;readonly MAX_VIEWPORT_DIMS:GLenum;readonly MEDIUM_FLOAT:GLenum;readonly MEDIUM_INT:GLenum;readonly MIRRORED_REPEAT:GLenum;readonly NEAREST:GLenum;readonly NEAREST_MIPMAP_LINEAR:GLenum;readonly NEAREST_MIPMAP_NEAREST:GLenum;readonly NEVER:GLenum;readonly NICEST:GLenum;readonly NONE:GLenum;readonly NOTEQUAL:GLenum;readonly NO_ERROR:GLenum;readonly ONE:GLenum;readonly ONE_MINUS_CONSTANT_ALPHA:GLenum;readonly ONE_MINUS_CONSTANT_COLOR:GLenum;readonly ONE_MINUS_DST_ALPHA:GLenum;readonly ONE_MINUS_DST_COLOR:GLenum;readonly ONE_MINUS_SRC_ALPHA:GLenum;readonly ONE_MINUS_SRC_COLOR:GLenum;readonly OUT_OF_MEMORY:GLenum;readonly PACK_ALIGNMENT:GLenum;readonly POINTS:GLenum;readonly POLYGON_OFFSET_FACTOR:GLenum;readonly POLYGON_OFFSET_FILL:GLenum;readonly POLYGON_OFFSET_UNITS:GLenum;readonly RED_BITS:GLenum;readonly RENDERBUFFER:GLenum;readonly RENDERBUFFER_ALPHA_SIZE:GLenum;readonly RENDERBUFFER_BINDING:GLenum;readonly RENDERBUFFER_BLUE_SIZE:GLenum;readonly RENDERBUFFER_DEPTH_SIZE:GLenum;readonly RENDERBUFFER_GREEN_SIZE:GLenum;readonly RENDERBUFFER_HEIGHT:GLenum;readonly RENDERBUFFER_INTERNAL_FORMAT:GLenum;readonly RENDERBUFFER_RED_SIZE:GLenum;readonly RENDERBUFFER_STENCIL_SIZE:GLenum;readonly RENDERBUFFER_WIDTH:GLenum;readonly RENDERER:GLenum;readonly REPEAT:GLenum;readonly REPLACE:GLenum;readonly RGB:GLenum;readonly RGB565:GLenum;readonly RGB5_A1:GLenum;readonly RGBA:GLenum;readonly RGBA4:GLenum;readonly SAMPLER_2D:GLenum;readonly SAMPLER_CUBE:GLenum;readonly SAMPLES:GLenum;readonly SAMPLE_ALPHA_TO_COVERAGE:GLenum;readonly SAMPLE_BUFFERS:GLenum;readonly SAMPLE_COVERAGE:GLenum;readonly SAMPLE_COVERAGE_INVERT:GLenum;readonly SAMPLE_COVERAGE_VALUE:GLenum;readonly SCISSOR_BOX:GLenum;readonly SCISSOR_TEST:GLenum;readonly SHADER_TYPE:GLenum;readonly SHADING_LANGUAGE_VERSION:GLenum;readonly SHORT:GLenum;readonly SRC_ALPHA:GLenum;readonly SRC_ALPHA_SATURATE:GLenum;readonly SRC_COLOR:GLenum;readonly STATIC_DRAW:GLenum;readonly STENCIL_ATTACHMENT:GLenum;readonly STENCIL_BACK_FAIL:GLenum;readonly STENCIL_BACK_FUNC:GLenum;readonly STENCIL_BACK_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_BACK_PASS_DEPTH_PASS:GLenum;readonly STENCIL_BACK_REF:GLenum;readonly STENCIL_BACK_VALUE_MASK:GLenum;readonly STENCIL_BACK_WRITEMASK:GLenum;readonly STENCIL_BITS:GLenum;readonly STENCIL_BUFFER_BIT:GLenum;readonly STENCIL_CLEAR_VALUE:GLenum;readonly STENCIL_FAIL:GLenum;readonly STENCIL_FUNC:GLenum;readonly STENCIL_INDEX8:GLenum;readonly STENCIL_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_PASS_DEPTH_PASS:GLenum;readonly STENCIL_REF:GLenum;readonly STENCIL_TEST:GLenum;readonly STENCIL_VALUE_MASK:GLenum;readonly STENCIL_WRITEMASK:GLenum;readonly STREAM_DRAW:GLenum;readonly SUBPIXEL_BITS:GLenum;readonly TEXTURE:GLenum;readonly TEXTURE0:GLenum;readonly TEXTURE1:GLenum;readonly TEXTURE10:GLenum;readonly TEXTURE11:GLenum;readonly TEXTURE12:GLenum;readonly TEXTURE13:GLenum;readonly TEXTURE14:GLenum;readonly TEXTURE15:GLenum;readonly TEXTURE16:GLenum;readonly TEXTURE17:GLenum;readonly TEXTURE18:GLenum;readonly TEXTURE19:GLenum;readonly TEXTURE2:GLenum;readonly TEXTURE20:GLenum;readonly TEXTURE21:GLenum;readonly TEXTURE22:GLenum;readonly TEXTURE23:GLenum;readonly TEXTURE24:GLenum;readonly TEXTURE25:GLenum;readonly TEXTURE26:GLenum;readonly TEXTURE27:GLenum;readonly TEXTURE28:GLenum;readonly TEXTURE29:GLenum;readonly TEXTURE3:GLenum;readonly TEXTURE30:GLenum;readonly TEXTURE31:GLenum;readonly TEXTURE4:GLenum;readonly TEXTURE5:GLenum;readonly TEXTURE6:GLenum;readonly TEXTURE7:GLenum;readonly TEXTURE8:GLenum;readonly TEXTURE9:GLenum;readonly TEXTURE_2D:GLenum;readonly TEXTURE_BINDING_2D:GLenum;readonly TEXTURE_BINDING_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Z:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Z:GLenum;readonly TEXTURE_MAG_FILTER:GLenum;readonly TEXTURE_MIN_FILTER:GLenum;readonly TEXTURE_WRAP_S:GLenum;readonly TEXTURE_WRAP_T:GLenum;readonly TRIANGLES:GLenum;readonly TRIANGLE_FAN:GLenum;readonly TRIANGLE_STRIP:GLenum;readonly UNPACK_ALIGNMENT:GLenum;readonly UNPACK_COLORSPACE_CONVERSION_WEBGL:GLenum;readonly UNPACK_FLIP_Y_WEBGL:GLenum;readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL:GLenum;readonly UNSIGNED_BYTE:GLenum;readonly UNSIGNED_INT:GLenum;readonly UNSIGNED_SHORT:GLenum;readonly UNSIGNED_SHORT_4_4_4_4:GLenum;readonly UNSIGNED_SHORT_5_5_5_1:GLenum;readonly UNSIGNED_SHORT_5_6_5:GLenum;readonly VALIDATE_STATUS:GLenum;readonly VENDOR:GLenum;readonly VERSION:GLenum;readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:GLenum;readonly VERTEX_ATTRIB_ARRAY_ENABLED:GLenum;readonly VERTEX_ATTRIB_ARRAY_NORMALIZED:GLenum;readonly VERTEX_ATTRIB_ARRAY_POINTER:GLenum;readonly VERTEX_ATTRIB_ARRAY_SIZE:GLenum;readonly VERTEX_ATTRIB_ARRAY_STRIDE:GLenum;readonly VERTEX_ATTRIB_ARRAY_TYPE:GLenum;readonly VERTEX_SHADER:GLenum;readonly VIEWPORT:GLenum;readonly ZERO:GLenum;}interface WebGLRenderingContextOverloads{bufferData(target:GLenum,size:GLsizeiptr,usage:GLenum):void;bufferData(target:GLenum,data:BufferSource|null,usage:GLenum):void;bufferSubData(target:GLenum,offset:GLintptr,data:BufferSource):void;compressedTexImage2D(target:GLenum,level:GLint,internalformat:GLenum,width:GLsizei,height:GLsizei,border:GLint,data:ArrayBufferView):void;compressedTexSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,data:ArrayBufferView):void;readPixels(x:GLint,y:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,pixels:ArrayBufferView|null):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,border:GLint,format:GLenum,type:GLenum,pixels:ArrayBufferView|null):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,pixels:ArrayBufferView|null):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;uniform1fv(location:WebGLUniformLocation|null,v:Float32List):void;uniform1iv(location:WebGLUniformLocation|null,v:Int32List):void;uniform2fv(location:WebGLUniformLocation|null,v:Float32List):void;uniform2iv(location:WebGLUniformLocation|null,v:Int32List):void;uniform3fv(location:WebGLUniformLocation|null,v:Float32List):void;uniform3iv(location:WebGLUniformLocation|null,v:Int32List):void;uniform4fv(location:WebGLUniformLocation|null,v:Float32List):void;uniform4iv(location:WebGLUniformLocation|null,v:Int32List):void;uniformMatrix2fv(location:WebGLUniformLocation|null,transpose:GLboolean,value:Float32List):void;uniformMatrix3fv(location:WebGLUniformLocation|null,transpose:GLboolean,value:Float32List):void;uniformMatrix4fv(location:WebGLUniformLocation|null,transpose:GLboolean,value:Float32List):void;}interface WebGLSampler extends WebGLObject{}declare var WebGLSampler:{prototype:WebGLSampler;new():WebGLSampler;};interface WebGLShader extends WebGLObject{}declare var WebGLShader:{prototype:WebGLShader;new():WebGLShader;};interface WebGLShaderPrecisionFormat{readonly precision:GLint;readonly rangeMax:GLint;readonly rangeMin:GLint;}declare var WebGLShaderPrecisionFormat:{prototype:WebGLShaderPrecisionFormat;new():WebGLShaderPrecisionFormat;};interface WebGLSync extends WebGLObject{}declare var WebGLSync:{prototype:WebGLSync;new():WebGLSync;};interface WebGLTexture extends WebGLObject{}declare var WebGLTexture:{prototype:WebGLTexture;new():WebGLTexture;};interface WebGLTransformFeedback extends WebGLObject{}declare var WebGLTransformFeedback:{prototype:WebGLTransformFeedback;new():WebGLTransformFeedback;};interface WebGLUniformLocation{}declare var WebGLUniformLocation:{prototype:WebGLUniformLocation;new():WebGLUniformLocation;};interface WebGLVertexArrayObject extends WebGLObject{}declare var WebGLVertexArrayObject:{prototype:WebGLVertexArrayObject;new():WebGLVertexArrayObject;};interface WebGLVertexArrayObjectOES extends WebGLObject{}interface WebKitPoint{x:number;y:number;}declare var WebKitPoint:{prototype:WebKitPoint;new(x?:number,y?:number):WebKitPoint;};interface WebSocketEventMap{"close":CloseEvent;"error":Event;"message":MessageEvent;"open":Event;}interface WebSocket extends EventTarget{binaryType:BinaryType;readonly bufferedAmount:number;readonly extensions:string;onclose:((this:WebSocket,ev:CloseEvent)=>any)|null;onerror:((this:WebSocket,ev:Event)=>any)|null;onmessage:((this:WebSocket,ev:MessageEvent)=>any)|null;onopen:((this:WebSocket,ev:Event)=>any)|null;readonly protocol:string;readonly readyState:number;readonly url:string;close(code?:number,reason?:string):void;send(data:string|ArrayBufferLike|Blob|ArrayBufferView):void;readonly CLOSED:number;readonly CLOSING:number;readonly CONNECTING:number;readonly OPEN:number;addEventListener<K extends keyof WebSocketEventMap>(type:K,listener:(this:WebSocket,ev:WebSocketEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof WebSocketEventMap>(type:K,listener:(this:WebSocket,ev:WebSocketEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var WebSocket:{prototype:WebSocket;new(url:string,protocols?:string|string[]):WebSocket;readonly CLOSED:number;readonly CLOSING:number;readonly CONNECTING:number;readonly OPEN:number;};interface WheelEvent extends MouseEvent{readonly deltaMode:number;readonly deltaX:number;readonly deltaY:number;readonly deltaZ:number;readonly DOM_DELTA_LINE:number;readonly DOM_DELTA_PAGE:number;readonly DOM_DELTA_PIXEL:number;}declare var WheelEvent:{prototype:WheelEvent;new(type:string,eventInitDict?:WheelEventInit):WheelEvent;readonly DOM_DELTA_LINE:number;readonly DOM_DELTA_PAGE:number;readonly DOM_DELTA_PIXEL:number;};interface WindowEventMap extends GlobalEventHandlersEventMap,WindowEventHandlersEventMap{"abort":UIEvent;"afterprint":Event;"beforeprint":Event;"beforeunload":BeforeUnloadEvent;"blur":FocusEvent;"canplay":Event;"canplaythrough":Event;"change":Event;"click":MouseEvent;"compassneedscalibration":Event;"contextmenu":MouseEvent;"dblclick":MouseEvent;"devicelight":DeviceLightEvent;"devicemotion":DeviceMotionEvent;"deviceorientation":DeviceOrientationEvent;"deviceorientationabsolute":DeviceOrientationEvent;"drag":DragEvent;"dragend":DragEvent;"dragenter":DragEvent;"dragleave":DragEvent;"dragover":DragEvent;"dragstart":DragEvent;"drop":DragEvent;"durationchange":Event;"emptied":Event;"ended":Event;"error":ErrorEvent;"focus":FocusEvent;"hashchange":HashChangeEvent;"input":Event;"invalid":Event;"keydown":KeyboardEvent;"keypress":KeyboardEvent;"keyup":KeyboardEvent;"load":Event;"loadeddata":Event;"loadedmetadata":Event;"loadstart":Event;"message":MessageEvent;"mousedown":MouseEvent;"mouseenter":MouseEvent;"mouseleave":MouseEvent;"mousemove":MouseEvent;"mouseout":MouseEvent;"mouseover":MouseEvent;"mouseup":MouseEvent;"mousewheel":Event;"MSGestureChange":Event;"MSGestureDoubleTap":Event;"MSGestureEnd":Event;"MSGestureHold":Event;"MSGestureStart":Event;"MSGestureTap":Event;"MSInertiaStart":Event;"MSPointerCancel":Event;"MSPointerDown":Event;"MSPointerEnter":Event;"MSPointerLeave":Event;"MSPointerMove":Event;"MSPointerOut":Event;"MSPointerOver":Event;"MSPointerUp":Event;"offline":Event;"online":Event;"orientationchange":Event;"pagehide":PageTransitionEvent;"pageshow":PageTransitionEvent;"pause":Event;"play":Event;"playing":Event;"popstate":PopStateEvent;"progress":ProgressEvent<Window>;"ratechange":Event;"readystatechange":ProgressEvent<Window>;"reset":Event;"resize":UIEvent;"scroll":Event;"seeked":Event;"seeking":Event;"select":Event;"stalled":Event;"storage":StorageEvent;"submit":Event;"suspend":Event;"timeupdate":Event;"unload":Event;"volumechange":Event;"vrdisplayactivate":Event;"vrdisplayblur":Event;"vrdisplayconnect":Event;"vrdisplaydeactivate":Event;"vrdisplaydisconnect":Event;"vrdisplayfocus":Event;"vrdisplaypointerrestricted":Event;"vrdisplaypointerunrestricted":Event;"vrdisplaypresentchange":Event;"waiting":Event;}interface Window extends EventTarget,AnimationFrameProvider,GlobalEventHandlers,WindowEventHandlers,WindowLocalStorage,WindowOrWorkerGlobalScope,WindowSessionStorage{readonly applicationCache:ApplicationCache;readonly clientInformation:Navigator;readonly closed:boolean;customElements:CustomElementRegistry;defaultStatus:string;readonly devicePixelRatio:number;readonly doNotTrack:string;readonly document:Document;readonly event:Event|undefined;readonly external:External;readonly frameElement:Element;readonly frames:Window;readonly history:History;readonly innerHeight:number;readonly innerWidth:number;readonly length:number;location:Location;readonly locationbar:BarProp;readonly menubar:BarProp;readonly msContentScript:ExtensionScriptApis;name:string;readonly navigator:Navigator;offscreenBuffering:string|boolean;oncompassneedscalibration:((this:Window,ev:Event)=>any)|null;ondevicelight:((this:Window,ev:DeviceLightEvent)=>any)|null;ondevicemotion:((this:Window,ev:DeviceMotionEvent)=>any)|null;ondeviceorientation:((this:Window,ev:DeviceOrientationEvent)=>any)|null;ondeviceorientationabsolute:((this:Window,ev:DeviceOrientationEvent)=>any)|null;onmousewheel:((this:Window,ev:Event)=>any)|null;onmsgesturechange:((this:Window,ev:Event)=>any)|null;onmsgesturedoubletap:((this:Window,ev:Event)=>any)|null;onmsgestureend:((this:Window,ev:Event)=>any)|null;onmsgesturehold:((this:Window,ev:Event)=>any)|null;onmsgesturestart:((this:Window,ev:Event)=>any)|null;onmsgesturetap:((this:Window,ev:Event)=>any)|null;onmsinertiastart:((this:Window,ev:Event)=>any)|null;onmspointercancel:((this:Window,ev:Event)=>any)|null;onmspointerdown:((this:Window,ev:Event)=>any)|null;onmspointerenter:((this:Window,ev:Event)=>any)|null;onmspointerleave:((this:Window,ev:Event)=>any)|null;onmspointermove:((this:Window,ev:Event)=>any)|null;onmspointerout:((this:Window,ev:Event)=>any)|null;onmspointerover:((this:Window,ev:Event)=>any)|null;onmspointerup:((this:Window,ev:Event)=>any)|null;onorientationchange:((this:Window,ev:Event)=>any)|null;onreadystatechange:((this:Window,ev:ProgressEvent<Window>)=>any)|null;onvrdisplayactivate:((this:Window,ev:Event)=>any)|null;onvrdisplayblur:((this:Window,ev:Event)=>any)|null;onvrdisplayconnect:((this:Window,ev:Event)=>any)|null;onvrdisplaydeactivate:((this:Window,ev:Event)=>any)|null;onvrdisplaydisconnect:((this:Window,ev:Event)=>any)|null;onvrdisplayfocus:((this:Window,ev:Event)=>any)|null;onvrdisplaypointerrestricted:((this:Window,ev:Event)=>any)|null;onvrdisplaypointerunrestricted:((this:Window,ev:Event)=>any)|null;onvrdisplaypresentchange:((this:Window,ev:Event)=>any)|null;opener:any;readonly orientation:string|number;readonly outerHeight:number;readonly outerWidth:number;readonly pageXOffset:number;readonly pageYOffset:number;readonly parent:Window;readonly personalbar:BarProp;readonly screen:Screen;readonly screenLeft:number;readonly screenTop:number;readonly screenX:number;readonly screenY:number;readonly scrollX:number;readonly scrollY:number;readonly scrollbars:BarProp;readonly self:Window&typeof globalThis;readonly speechSynthesis:SpeechSynthesis;status:string;readonly statusbar:BarProp;readonly styleMedia:StyleMedia;readonly toolbar:BarProp;readonly top:Window;readonly window:Window&typeof globalThis;alert(message?:any):void;blur():void;captureEvents():void;close():void;confirm(message?:string):boolean;departFocus(navigationReason:NavigationReason,origin:FocusNavigationOrigin):void;focus():void;getComputedStyle(elt:Element,pseudoElt?:string|null):CSSStyleDeclaration;getMatchedCSSRules(elt:Element,pseudoElt?:string|null):CSSRuleList;getSelection():Selection|null;matchMedia(query:string):MediaQueryList;moveBy(x:number,y:number):void;moveTo(x:number,y:number):void;msWriteProfilerMark(profilerMarkName:string):void;open(url?:string,target?:string,features?:string,replace?:boolean):Window|null;postMessage(message:any,targetOrigin:string,transfer?:Transferable[]):void;print():void;prompt(message?:string,_default?:string):string|null;releaseEvents():void;resizeBy(x:number,y:number):void;resizeTo(x:number,y:number):void;scroll(options?:ScrollToOptions):void;scroll(x:number,y:number):void;scrollBy(options?:ScrollToOptions):void;scrollBy(x:number,y:number):void;scrollTo(options?:ScrollToOptions):void;scrollTo(x:number,y:number):void;stop():void;webkitCancelAnimationFrame(handle:number):void;webkitConvertPointFromNodeToPage(node:Node,pt:WebKitPoint):WebKitPoint;webkitConvertPointFromPageToNode(node:Node,pt:WebKitPoint):WebKitPoint;webkitRequestAnimationFrame(callback:FrameRequestCallback):number;addEventListener<K extends keyof WindowEventMap>(type:K,listener:(this:Window,ev:WindowEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof WindowEventMap>(type:K,listener:(this:Window,ev:WindowEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;[index:number]:Window;}declare var Window:{prototype:Window;new():Window;};interface WindowEventHandlersEventMap{"afterprint":Event;"beforeprint":Event;"beforeunload":BeforeUnloadEvent;"hashchange":HashChangeEvent;"languagechange":Event;"message":MessageEvent;"messageerror":MessageEvent;"offline":Event;"online":Event;"pagehide":PageTransitionEvent;"pageshow":PageTransitionEvent;"popstate":PopStateEvent;"rejectionhandled":PromiseRejectionEvent;"storage":StorageEvent;"unhandledrejection":PromiseRejectionEvent;"unload":Event;}interface WindowEventHandlers{onafterprint:((this:WindowEventHandlers,ev:Event)=>any)|null;onbeforeprint:((this:WindowEventHandlers,ev:Event)=>any)|null;onbeforeunload:((this:WindowEventHandlers,ev:BeforeUnloadEvent)=>any)|null;onhashchange:((this:WindowEventHandlers,ev:HashChangeEvent)=>any)|null;onlanguagechange:((this:WindowEventHandlers,ev:Event)=>any)|null;onmessage:((this:WindowEventHandlers,ev:MessageEvent)=>any)|null;onmessageerror:((this:WindowEventHandlers,ev:MessageEvent)=>any)|null;onoffline:((this:WindowEventHandlers,ev:Event)=>any)|null;ononline:((this:WindowEventHandlers,ev:Event)=>any)|null;onpagehide:((this:WindowEventHandlers,ev:PageTransitionEvent)=>any)|null;onpageshow:((this:WindowEventHandlers,ev:PageTransitionEvent)=>any)|null;onpopstate:((this:WindowEventHandlers,ev:PopStateEvent)=>any)|null;onrejectionhandled:((this:WindowEventHandlers,ev:PromiseRejectionEvent)=>any)|null;onstorage:((this:WindowEventHandlers,ev:StorageEvent)=>any)|null;onunhandledrejection:((this:WindowEventHandlers,ev:PromiseRejectionEvent)=>any)|null;onunload:((this:WindowEventHandlers,ev:Event)=>any)|null;addEventListener<K extends keyof WindowEventHandlersEventMap>(type:K,listener:(this:WindowEventHandlers,ev:WindowEventHandlersEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof WindowEventHandlersEventMap>(type:K,listener:(this:WindowEventHandlers,ev:WindowEventHandlersEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}interface WindowLocalStorage{readonly localStorage:Storage;}interface WindowOrWorkerGlobalScope{readonly caches:CacheStorage;readonly crypto:Crypto;readonly indexedDB:IDBFactory;readonly isSecureContext:boolean;readonly origin:string;readonly performance:Performance;atob(data:string):string;btoa(data:string):string;clearInterval(handle?:number):void;clearTimeout(handle?:number):void;createImageBitmap(image:ImageBitmapSource,options?:ImageBitmapOptions):Promise<ImageBitmap>;createImageBitmap(image:ImageBitmapSource,sx:number,sy:number,sw:number,sh:number,options?:ImageBitmapOptions):Promise<ImageBitmap>;fetch(input:RequestInfo,init?:RequestInit):Promise<Response>;queueMicrotask(callback:VoidFunction):void;setInterval(handler:TimerHandler,timeout?:number,...arguments:any[]):number;setTimeout(handler:TimerHandler,timeout?:number,...arguments:any[]):number;}interface WindowSessionStorage{readonly sessionStorage:Storage;}interface WorkerEventMap extends AbstractWorkerEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface Worker extends EventTarget,AbstractWorker{onmessage:((this:Worker,ev:MessageEvent)=>any)|null;onmessageerror:((this:Worker,ev:MessageEvent)=>any)|null;postMessage(message:any,transfer:Transferable[]):void;postMessage(message:any,options?:PostMessageOptions):void;terminate():void;addEventListener<K extends keyof WorkerEventMap>(type:K,listener:(this:Worker,ev:WorkerEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof WorkerEventMap>(type:K,listener:(this:Worker,ev:WorkerEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var Worker:{prototype:Worker;new(stringUrl:string|URL,options?:WorkerOptions):Worker;};interface Worklet{addModule(moduleURL:string,options?:WorkletOptions):Promise<void>;}declare var Worklet:{prototype:Worklet;new():Worklet;};interface WritableStream<W=any>{readonly locked:boolean;abort(reason?:any):Promise<void>;getWriter():WritableStreamDefaultWriter<W>;}declare var WritableStream:{prototype:WritableStream;new<W=any>(underlyingSink?:UnderlyingSink<W>,strategy?:QueuingStrategy<W>):WritableStream<W>;};interface WritableStreamDefaultController{error(error?:any):void;}interface WritableStreamDefaultWriter<W=any>{readonly closed:Promise<void>;readonly desiredSize:number|null;readonly ready:Promise<void>;abort(reason?:any):Promise<void>;close():Promise<void>;releaseLock():void;write(chunk:W):Promise<void>;}interface XMLDocument extends Document{addEventListener<K extends keyof DocumentEventMap>(type:K,listener:(this:XMLDocument,ev:DocumentEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof DocumentEventMap>(type:K,listener:(this:XMLDocument,ev:DocumentEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var XMLDocument:{prototype:XMLDocument;new():XMLDocument;};interface XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap{"readystatechange":Event;}interface XMLHttpRequest extends XMLHttpRequestEventTarget{onreadystatechange:((this:XMLHttpRequest,ev:Event)=>any)|null;readonly readyState:number;readonly response:any;readonly responseText:string;responseType:XMLHttpRequestResponseType;readonly responseURL:string;readonly responseXML:Document|null;readonly status:number;readonly statusText:string;timeout:number;readonly upload:XMLHttpRequestUpload;withCredentials:boolean;abort():void;getAllResponseHeaders():string;getResponseHeader(name:string):string|null;open(method:string,url:string):void;open(method:string,url:string,async:boolean,username?:string|null,password?:string|null):void;overrideMimeType(mime:string):void;send(body?:Document|BodyInit|null):void;setRequestHeader(name:string,value:string):void;readonly DONE:number;readonly HEADERS_RECEIVED:number;readonly LOADING:number;readonly OPENED:number;readonly UNSENT:number;addEventListener<K extends keyof XMLHttpRequestEventMap>(type:K,listener:(this:XMLHttpRequest,ev:XMLHttpRequestEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof XMLHttpRequestEventMap>(type:K,listener:(this:XMLHttpRequest,ev:XMLHttpRequestEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var XMLHttpRequest:{prototype:XMLHttpRequest;new():XMLHttpRequest;readonly DONE:number;readonly HEADERS_RECEIVED:number;readonly LOADING:number;readonly OPENED:number;readonly UNSENT:number;};interface XMLHttpRequestEventTargetEventMap{"abort":ProgressEvent<XMLHttpRequestEventTarget>;"error":ProgressEvent<XMLHttpRequestEventTarget>;"load":ProgressEvent<XMLHttpRequestEventTarget>;"loadend":ProgressEvent<XMLHttpRequestEventTarget>;"loadstart":ProgressEvent<XMLHttpRequestEventTarget>;"progress":ProgressEvent<XMLHttpRequestEventTarget>;"timeout":ProgressEvent<XMLHttpRequestEventTarget>;}interface XMLHttpRequestEventTarget extends EventTarget{onabort:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;onerror:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;onload:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;onloadend:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;onloadstart:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;onprogress:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;ontimeout:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type:K,listener:(this:XMLHttpRequestEventTarget,ev:XMLHttpRequestEventTargetEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type:K,listener:(this:XMLHttpRequestEventTarget,ev:XMLHttpRequestEventTargetEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var XMLHttpRequestEventTarget:{prototype:XMLHttpRequestEventTarget;new():XMLHttpRequestEventTarget;};interface XMLHttpRequestUpload extends XMLHttpRequestEventTarget{addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type:K,listener:(this:XMLHttpRequestUpload,ev:XMLHttpRequestEventTargetEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type:K,listener:(this:XMLHttpRequestUpload,ev:XMLHttpRequestEventTargetEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var XMLHttpRequestUpload:{prototype:XMLHttpRequestUpload;new():XMLHttpRequestUpload;};interface XMLSerializer{serializeToString(root:Node):string;}declare var XMLSerializer:{prototype:XMLSerializer;new():XMLSerializer;};interface XPathEvaluator extends XPathEvaluatorBase{}declare var XPathEvaluator:{prototype:XPathEvaluator;new():XPathEvaluator;};interface XPathEvaluatorBase{createExpression(expression:string,resolver?:XPathNSResolver|null):XPathExpression;createNSResolver(nodeResolver:Node):XPathNSResolver;evaluate(expression:string,contextNode:Node,resolver?:XPathNSResolver|null,type?:number,result?:XPathResult|null):XPathResult;}interface XPathExpression{evaluate(contextNode:Node,type?:number,result?:XPathResult|null):XPathResult;}declare var XPathExpression:{prototype:XPathExpression;new():XPathExpression;};interface XPathResult{readonly booleanValue:boolean;readonly invalidIteratorState:boolean;readonly numberValue:number;readonly resultType:number;readonly singleNodeValue:Node|null;readonly snapshotLength:number;readonly stringValue:string;iterateNext():Node|null;snapshotItem(index:number):Node|null;readonly ANY_TYPE:number;readonly ANY_UNORDERED_NODE_TYPE:number;readonly BOOLEAN_TYPE:number;readonly FIRST_ORDERED_NODE_TYPE:number;readonly NUMBER_TYPE:number;readonly ORDERED_NODE_ITERATOR_TYPE:number;readonly ORDERED_NODE_SNAPSHOT_TYPE:number;readonly STRING_TYPE:number;readonly UNORDERED_NODE_ITERATOR_TYPE:number;readonly UNORDERED_NODE_SNAPSHOT_TYPE:number;}declare var XPathResult:{prototype:XPathResult;new():XPathResult;readonly ANY_TYPE:number;readonly ANY_UNORDERED_NODE_TYPE:number;readonly BOOLEAN_TYPE:number;readonly FIRST_ORDERED_NODE_TYPE:number;readonly NUMBER_TYPE:number;readonly ORDERED_NODE_ITERATOR_TYPE:number;readonly ORDERED_NODE_SNAPSHOT_TYPE:number;readonly STRING_TYPE:number;readonly UNORDERED_NODE_ITERATOR_TYPE:number;readonly UNORDERED_NODE_SNAPSHOT_TYPE:number;};interface XSLTProcessor{clearParameters():void;getParameter(namespaceURI:string,localName:string):any;importStylesheet(style:Node):void;removeParameter(namespaceURI:string,localName:string):void;reset():void;setParameter(namespaceURI:string,localName:string,value:any):void;transformToDocument(source:Node):Document;transformToFragment(source:Node,document:Document):DocumentFragment;}declare var XSLTProcessor:{prototype:XSLTProcessor;new():XSLTProcessor;};interface webkitRTCPeerConnection extends RTCPeerConnection{addEventListener<K extends keyof RTCPeerConnectionEventMap>(type:K,listener:(this:webkitRTCPeerConnection,ev:RTCPeerConnectionEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof RTCPeerConnectionEventMap>(type:K,listener:(this:webkitRTCPeerConnection,ev:RTCPeerConnectionEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var webkitRTCPeerConnection:{prototype:webkitRTCPeerConnection;new(configuration:RTCConfiguration):webkitRTCPeerConnection;};declare type EventListenerOrEventListenerObject=EventListener|EventListenerObject;interface Console{memory:any;assert(condition?:boolean,...data:any[]):void;clear():void;count(label?:string):void;countReset(label?:string):void;debug(...data:any[]):void;dir(item?:any,options?:any):void;dirxml(...data:any[]):void;error(...data:any[]):void;exception(message?:string,...optionalParams:any[]):void;group(...data:any[]):void;groupCollapsed(...data:any[]):void;groupEnd():void;info(...data:any[]):void;log(...data:any[]):void;table(tabularData?:any,properties?:string[]):void;time(label?:string):void;timeEnd(label?:string):void;timeLog(label?:string,...data:any[]):void;timeStamp(label?:string):void;trace(...data:any[]):void;warn(...data:any[]):void;}declare var console:Console;declare namespace CSS{function escape(ident:string):string;function supports(property:string,value:string):boolean;function supports(conditionText:string):boolean;}declare namespace WebAssembly{interface CompileError{}var CompileError:{prototype:CompileError;new():CompileError;};interface Global{value:any;valueOf():any;}var Global:{prototype:Global;new(descriptor:GlobalDescriptor,v?:any):Global;};interface Instance{readonly exports:Exports;}var Instance:{prototype:Instance;new(module:Module,importObject?:Imports):Instance;};interface LinkError{}var LinkError:{prototype:LinkError;new():LinkError;};interface Memory{readonly buffer:ArrayBuffer;grow(delta:number):number;}var Memory:{prototype:Memory;new(descriptor:MemoryDescriptor):Memory;};interface Module{}var Module:{prototype:Module;new(bytes:BufferSource):Module;customSections(moduleObject:Module,sectionName:string):ArrayBuffer[];exports(moduleObject:Module):ModuleExportDescriptor[];imports(moduleObject:Module):ModuleImportDescriptor[];};interface RuntimeError{}var RuntimeError:{prototype:RuntimeError;new():RuntimeError;};interface Table{readonly length:number;get(index:number):Function|null;grow(delta:number):number;set(index:number,value:Function|null):void;}var Table:{prototype:Table;new(descriptor:TableDescriptor):Table;};interface GlobalDescriptor{mutable?:boolean;value:ValueType;}interface MemoryDescriptor{initial:number;maximum?:number;}interface ModuleExportDescriptor{kind:ImportExportKind;name:string;}interface ModuleImportDescriptor{kind:ImportExportKind;module:string;name:string;}interface TableDescriptor{element:TableKind;initial:number;maximum?:number;}interface WebAssemblyInstantiatedSource{instance:Instance;module:Module;}type ImportExportKind="function"|"global"|"memory"|"table";type TableKind="anyfunc";type ValueType="f32"|"f64"|"i32"|"i64";type ExportValue=Function|Global|Memory|Table;type Exports=Record<string,ExportValue>;type ImportValue=ExportValue|number;type ModuleImports=Record<string,ImportValue>;type Imports=Record<string,ModuleImports>;function compile(bytes:BufferSource):Promise<Module>;function compileStreaming(source:Response|Promise<Response>):Promise<Module>;function instantiate(bytes:BufferSource,importObject?:Imports):Promise<WebAssemblyInstantiatedSource>;function instantiate(moduleObject:Module,importObject?:Imports):Promise<Instance>;function instantiateStreaming(response:Response|PromiseLike<Response>,importObject?:Imports):Promise<WebAssemblyInstantiatedSource>;function validate(bytes:BufferSource):boolean;}interface BlobCallback{(blob:Blob|null):void;}interface CustomElementConstructor{new(...params:any[]):HTMLElement;}interface DecodeErrorCallback{(error:DOMException):void;}interface DecodeSuccessCallback{(decodedData:AudioBuffer):void;}interface EventHandlerNonNull{(event:Event):any;}interface ForEachCallback{(keyId:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer|null,status:MediaKeyStatus):void;}interface FrameRequestCallback{(time:number):void;}interface FunctionStringCallback{(data:string):void;}interface IntersectionObserverCallback{(entries:IntersectionObserverEntry[],observer:IntersectionObserver):void;}interface MSLaunchUriCallback{():void;}interface MutationCallback{(mutations:MutationRecord[],observer:MutationObserver):void;}interface NavigatorUserMediaErrorCallback{(error:MediaStreamError):void;}interface NavigatorUserMediaSuccessCallback{(stream:MediaStream):void;}interface NotificationPermissionCallback{(permission:NotificationPermission):void;}interface OnBeforeUnloadEventHandlerNonNull{(event:Event):string|null;}interface OnErrorEventHandlerNonNull{(event:Event|string,source?:string,lineno?:number,colno?:number,error?:Error):any;}interface PerformanceObserverCallback{(entries:PerformanceObserverEntryList,observer:PerformanceObserver):void;}interface PositionCallback{(position:Position):void;}interface PositionErrorCallback{(positionError:PositionError):void;}interface QueuingStrategySizeCallback<T=any>{(chunk:T):number;}interface RTCPeerConnectionErrorCallback{(error:DOMException):void;}interface RTCSessionDescriptionCallback{(description:RTCSessionDescriptionInit):void;}interface RTCStatsCallback{(report:RTCStatsReport):void;}interface ReadableByteStreamControllerCallback{(controller:ReadableByteStreamController):void|PromiseLike<void>;}interface ReadableStreamDefaultControllerCallback<R>{(controller:ReadableStreamDefaultController<R>):void|PromiseLike<void>;}interface ReadableStreamErrorCallback{(reason:any):void|PromiseLike<void>;}interface TransformStreamDefaultControllerCallback<O>{(controller:TransformStreamDefaultController<O>):void|PromiseLike<void>;}interface TransformStreamDefaultControllerTransformCallback<I,O>{(chunk:I,controller:TransformStreamDefaultController<O>):void|PromiseLike<void>;}interface VoidFunction{():void;}interface WritableStreamDefaultControllerCloseCallback{():void|PromiseLike<void>;}interface WritableStreamDefaultControllerStartCallback{(controller:WritableStreamDefaultController):void|PromiseLike<void>;}interface WritableStreamDefaultControllerWriteCallback<W>{(chunk:W,controller:WritableStreamDefaultController):void|PromiseLike<void>;}interface WritableStreamErrorCallback{(reason:any):void|PromiseLike<void>;}interface HTMLElementTagNameMap{"a":HTMLAnchorElement;"abbr":HTMLElement;"address":HTMLElement;"applet":HTMLAppletElement;"area":HTMLAreaElement;"article":HTMLElement;"aside":HTMLElement;"audio":HTMLAudioElement;"b":HTMLElement;"base":HTMLBaseElement;"basefont":HTMLBaseFontElement;"bdi":HTMLElement;"bdo":HTMLElement;"blockquote":HTMLQuoteElement;"body":HTMLBodyElement;"br":HTMLBRElement;"button":HTMLButtonElement;"canvas":HTMLCanvasElement;"caption":HTMLTableCaptionElement;"cite":HTMLElement;"code":HTMLElement;"col":HTMLTableColElement;"colgroup":HTMLTableColElement;"data":HTMLDataElement;"datalist":HTMLDataListElement;"dd":HTMLElement;"del":HTMLModElement;"details":HTMLDetailsElement;"dfn":HTMLElement;"dialog":HTMLDialogElement;"dir":HTMLDirectoryElement;"div":HTMLDivElement;"dl":HTMLDListElement;"dt":HTMLElement;"em":HTMLElement;"embed":HTMLEmbedElement;"fieldset":HTMLFieldSetElement;"figcaption":HTMLElement;"figure":HTMLElement;"font":HTMLFontElement;"footer":HTMLElement;"form":HTMLFormElement;"frame":HTMLFrameElement;"frameset":HTMLFrameSetElement;"h1":HTMLHeadingElement;"h2":HTMLHeadingElement;"h3":HTMLHeadingElement;"h4":HTMLHeadingElement;"h5":HTMLHeadingElement;"h6":HTMLHeadingElement;"head":HTMLHeadElement;"header":HTMLElement;"hgroup":HTMLElement;"hr":HTMLHRElement;"html":HTMLHtmlElement;"i":HTMLElement;"iframe":HTMLIFrameElement;"img":HTMLImageElement;"input":HTMLInputElement;"ins":HTMLModElement;"kbd":HTMLElement;"label":HTMLLabelElement;"legend":HTMLLegendElement;"li":HTMLLIElement;"link":HTMLLinkElement;"main":HTMLElement;"map":HTMLMapElement;"mark":HTMLElement;"marquee":HTMLMarqueeElement;"menu":HTMLMenuElement;"meta":HTMLMetaElement;"meter":HTMLMeterElement;"nav":HTMLElement;"noscript":HTMLElement;"object":HTMLObjectElement;"ol":HTMLOListElement;"optgroup":HTMLOptGroupElement;"option":HTMLOptionElement;"output":HTMLOutputElement;"p":HTMLParagraphElement;"param":HTMLParamElement;"picture":HTMLPictureElement;"pre":HTMLPreElement;"progress":HTMLProgressElement;"q":HTMLQuoteElement;"rp":HTMLElement;"rt":HTMLElement;"ruby":HTMLElement;"s":HTMLElement;"samp":HTMLElement;"script":HTMLScriptElement;"section":HTMLElement;"select":HTMLSelectElement;"slot":HTMLSlotElement;"small":HTMLElement;"source":HTMLSourceElement;"span":HTMLSpanElement;"strong":HTMLElement;"style":HTMLStyleElement;"sub":HTMLElement;"summary":HTMLElement;"sup":HTMLElement;"table":HTMLTableElement;"tbody":HTMLTableSectionElement;"td":HTMLTableDataCellElement;"template":HTMLTemplateElement;"textarea":HTMLTextAreaElement;"tfoot":HTMLTableSectionElement;"th":HTMLTableHeaderCellElement;"thead":HTMLTableSectionElement;"time":HTMLTimeElement;"title":HTMLTitleElement;"tr":HTMLTableRowElement;"track":HTMLTrackElement;"u":HTMLElement;"ul":HTMLUListElement;"var":HTMLElement;"video":HTMLVideoElement;"wbr":HTMLElement;}interface HTMLElementDeprecatedTagNameMap{"listing":HTMLPreElement;"xmp":HTMLPreElement;}interface SVGElementTagNameMap{"a":SVGAElement;"circle":SVGCircleElement;"clipPath":SVGClipPathElement;"defs":SVGDefsElement;"desc":SVGDescElement;"ellipse":SVGEllipseElement;"feBlend":SVGFEBlendElement;"feColorMatrix":SVGFEColorMatrixElement;"feComponentTransfer":SVGFEComponentTransferElement;"feComposite":SVGFECompositeElement;"feConvolveMatrix":SVGFEConvolveMatrixElement;"feDiffuseLighting":SVGFEDiffuseLightingElement;"feDisplacementMap":SVGFEDisplacementMapElement;"feDistantLight":SVGFEDistantLightElement;"feFlood":SVGFEFloodElement;"feFuncA":SVGFEFuncAElement;"feFuncB":SVGFEFuncBElement;"feFuncG":SVGFEFuncGElement;"feFuncR":SVGFEFuncRElement;"feGaussianBlur":SVGFEGaussianBlurElement;"feImage":SVGFEImageElement;"feMerge":SVGFEMergeElement;"feMergeNode":SVGFEMergeNodeElement;"feMorphology":SVGFEMorphologyElement;"feOffset":SVGFEOffsetElement;"fePointLight":SVGFEPointLightElement;"feSpecularLighting":SVGFESpecularLightingElement;"feSpotLight":SVGFESpotLightElement;"feTile":SVGFETileElement;"feTurbulence":SVGFETurbulenceElement;"filter":SVGFilterElement;"foreignObject":SVGForeignObjectElement;"g":SVGGElement;"image":SVGImageElement;"line":SVGLineElement;"linearGradient":SVGLinearGradientElement;"marker":SVGMarkerElement;"mask":SVGMaskElement;"metadata":SVGMetadataElement;"path":SVGPathElement;"pattern":SVGPatternElement;"polygon":SVGPolygonElement;"polyline":SVGPolylineElement;"radialGradient":SVGRadialGradientElement;"rect":SVGRectElement;"script":SVGScriptElement;"stop":SVGStopElement;"style":SVGStyleElement;"svg":SVGSVGElement;"switch":SVGSwitchElement;"symbol":SVGSymbolElement;"text":SVGTextElement;"textPath":SVGTextPathElement;"title":SVGTitleElement;"tspan":SVGTSpanElement;"use":SVGUseElement;"view":SVGViewElement;}type ElementTagNameMap=HTMLElementTagNameMap&Pick<SVGElementTagNameMap,Exclude<keyof SVGElementTagNameMap,keyof HTMLElementTagNameMap>>;declare var Audio:{new(src?:string):HTMLAudioElement;};declare var Image:{new(width?:number,height?:number):HTMLImageElement;};declare var Option:{new(text?:string,value?:string,defaultSelected?:boolean,selected?:boolean):HTMLOptionElement;};declare var applicationCache:ApplicationCache;declare var clientInformation:Navigator;declare var closed:boolean;declare var customElements:CustomElementRegistry;declare var defaultStatus:string;declare var devicePixelRatio:number;declare var doNotTrack:string;declare var document:Document;declare var event:Event|undefined;declare var external:External;declare var frameElement:Element;declare var frames:Window;declare var history:History;declare var innerHeight:number;declare var innerWidth:number;declare var length:number;declare var location:Location;declare var locationbar:BarProp;declare var menubar:BarProp;declare var msContentScript:ExtensionScriptApis;declare const name:never;declare var navigator:Navigator;declare var offscreenBuffering:string|boolean;declare var oncompassneedscalibration:((this:Window,ev:Event)=>any)|null;declare var ondevicelight:((this:Window,ev:DeviceLightEvent)=>any)|null;declare var ondevicemotion:((this:Window,ev:DeviceMotionEvent)=>any)|null;declare var ondeviceorientation:((this:Window,ev:DeviceOrientationEvent)=>any)|null;declare var ondeviceorientationabsolute:((this:Window,ev:DeviceOrientationEvent)=>any)|null;declare var onmousewheel:((this:Window,ev:Event)=>any)|null;declare var onmsgesturechange:((this:Window,ev:Event)=>any)|null;declare var onmsgesturedoubletap:((this:Window,ev:Event)=>any)|null;declare var onmsgestureend:((this:Window,ev:Event)=>any)|null;declare var onmsgesturehold:((this:Window,ev:Event)=>any)|null;declare var onmsgesturestart:((this:Window,ev:Event)=>any)|null;declare var onmsgesturetap:((this:Window,ev:Event)=>any)|null;declare var onmsinertiastart:((this:Window,ev:Event)=>any)|null;declare var onmspointercancel:((this:Window,ev:Event)=>any)|null;declare var onmspointerdown:((this:Window,ev:Event)=>any)|null;declare var onmspointerenter:((this:Window,ev:Event)=>any)|null;declare var onmspointerleave:((this:Window,ev:Event)=>any)|null;declare var onmspointermove:((this:Window,ev:Event)=>any)|null;declare var onmspointerout:((this:Window,ev:Event)=>any)|null;declare var onmspointerover:((this:Window,ev:Event)=>any)|null;declare var onmspointerup:((this:Window,ev:Event)=>any)|null;declare var onorientationchange:((this:Window,ev:Event)=>any)|null;declare var onreadystatechange:((this:Window,ev:ProgressEvent<Window>)=>any)|null;declare var onvrdisplayactivate:((this:Window,ev:Event)=>any)|null;declare var onvrdisplayblur:((this:Window,ev:Event)=>any)|null;declare var onvrdisplayconnect:((this:Window,ev:Event)=>any)|null;declare var onvrdisplaydeactivate:((this:Window,ev:Event)=>any)|null;declare var onvrdisplaydisconnect:((this:Window,ev:Event)=>any)|null;declare var onvrdisplayfocus:((this:Window,ev:Event)=>any)|null;declare var onvrdisplaypointerrestricted:((this:Window,ev:Event)=>any)|null;declare var onvrdisplaypointerunrestricted:((this:Window,ev:Event)=>any)|null;declare var onvrdisplaypresentchange:((this:Window,ev:Event)=>any)|null;declare var opener:any;declare var orientation:string|number;declare var outerHeight:number;declare var outerWidth:number;declare var pageXOffset:number;declare var pageYOffset:number;declare var parent:Window;declare var personalbar:BarProp;declare var screen:Screen;declare var screenLeft:number;declare var screenTop:number;declare var screenX:number;declare var screenY:number;declare var scrollX:number;declare var scrollY:number;declare var scrollbars:BarProp;declare var self:Window&typeof globalThis;declare var speechSynthesis:SpeechSynthesis;declare var status:string;declare var statusbar:BarProp;declare var styleMedia:StyleMedia;declare var toolbar:BarProp;declare var top:Window;declare var window:Window&typeof globalThis;declare function alert(message?:any):void;declare function blur():void;declare function captureEvents():void;declare function close():void;declare function confirm(message?:string):boolean;declare function departFocus(navigationReason:NavigationReason,origin:FocusNavigationOrigin):void;declare function focus():void;declare function getComputedStyle(elt:Element,pseudoElt?:string|null):CSSStyleDeclaration;declare function getMatchedCSSRules(elt:Element,pseudoElt?:string|null):CSSRuleList;declare function getSelection():Selection|null;declare function matchMedia(query:string):MediaQueryList;declare function moveBy(x:number,y:number):void;declare function moveTo(x:number,y:number):void;declare function msWriteProfilerMark(profilerMarkName:string):void;declare function open(url?:string,target?:string,features?:string,replace?:boolean):Window|null;declare function postMessage(message:any,targetOrigin:string,transfer?:Transferable[]):void;declare function print():void;declare function prompt(message?:string,_default?:string):string|null;declare function releaseEvents():void;declare function resizeBy(x:number,y:number):void;declare function resizeTo(x:number,y:number):void;declare function scroll(options?:ScrollToOptions):void;declare function scroll(x:number,y:number):void;declare function scrollBy(options?:ScrollToOptions):void;declare function scrollBy(x:number,y:number):void;declare function scrollTo(options?:ScrollToOptions):void;declare function scrollTo(x:number,y:number):void;declare function stop():void;declare function webkitCancelAnimationFrame(handle:number):void;declare function webkitConvertPointFromNodeToPage(node:Node,pt:WebKitPoint):WebKitPoint;declare function webkitConvertPointFromPageToNode(node:Node,pt:WebKitPoint):WebKitPoint;declare function webkitRequestAnimationFrame(callback:FrameRequestCallback):number;declare function toString():string;declare function dispatchEvent(event:Event):boolean;declare var sessionStorage:Storage;declare var localStorage:Storage;declare var onabort:((this:Window,ev:UIEvent)=>any)|null;declare var onanimationcancel:((this:Window,ev:AnimationEvent)=>any)|null;declare var onanimationend:((this:Window,ev:AnimationEvent)=>any)|null;declare var onanimationiteration:((this:Window,ev:AnimationEvent)=>any)|null;declare var onanimationstart:((this:Window,ev:AnimationEvent)=>any)|null;declare var onauxclick:((this:Window,ev:MouseEvent)=>any)|null;declare var onblur:((this:Window,ev:FocusEvent)=>any)|null;declare var oncancel:((this:Window,ev:Event)=>any)|null;declare var oncanplay:((this:Window,ev:Event)=>any)|null;declare var oncanplaythrough:((this:Window,ev:Event)=>any)|null;declare var onchange:((this:Window,ev:Event)=>any)|null;declare var onclick:((this:Window,ev:MouseEvent)=>any)|null;declare var onclose:((this:Window,ev:Event)=>any)|null;declare var oncontextmenu:((this:Window,ev:MouseEvent)=>any)|null;declare var oncuechange:((this:Window,ev:Event)=>any)|null;declare var ondblclick:((this:Window,ev:MouseEvent)=>any)|null;declare var ondrag:((this:Window,ev:DragEvent)=>any)|null;declare var ondragend:((this:Window,ev:DragEvent)=>any)|null;declare var ondragenter:((this:Window,ev:DragEvent)=>any)|null;declare var ondragexit:((this:Window,ev:Event)=>any)|null;declare var ondragleave:((this:Window,ev:DragEvent)=>any)|null;declare var ondragover:((this:Window,ev:DragEvent)=>any)|null;declare var ondragstart:((this:Window,ev:DragEvent)=>any)|null;declare var ondrop:((this:Window,ev:DragEvent)=>any)|null;declare var ondurationchange:((this:Window,ev:Event)=>any)|null;declare var onemptied:((this:Window,ev:Event)=>any)|null;declare var onended:((this:Window,ev:Event)=>any)|null;declare var onerror:OnErrorEventHandler;declare var onfocus:((this:Window,ev:FocusEvent)=>any)|null;declare var ongotpointercapture:((this:Window,ev:PointerEvent)=>any)|null;declare var oninput:((this:Window,ev:Event)=>any)|null;declare var oninvalid:((this:Window,ev:Event)=>any)|null;declare var onkeydown:((this:Window,ev:KeyboardEvent)=>any)|null;declare var onkeypress:((this:Window,ev:KeyboardEvent)=>any)|null;declare var onkeyup:((this:Window,ev:KeyboardEvent)=>any)|null;declare var onload:((this:Window,ev:Event)=>any)|null;declare var onloadeddata:((this:Window,ev:Event)=>any)|null;declare var onloadedmetadata:((this:Window,ev:Event)=>any)|null;declare var onloadstart:((this:Window,ev:Event)=>any)|null;declare var onlostpointercapture:((this:Window,ev:PointerEvent)=>any)|null;declare var onmousedown:((this:Window,ev:MouseEvent)=>any)|null;declare var onmouseenter:((this:Window,ev:MouseEvent)=>any)|null;declare var onmouseleave:((this:Window,ev:MouseEvent)=>any)|null;declare var onmousemove:((this:Window,ev:MouseEvent)=>any)|null;declare var onmouseout:((this:Window,ev:MouseEvent)=>any)|null;declare var onmouseover:((this:Window,ev:MouseEvent)=>any)|null;declare var onmouseup:((this:Window,ev:MouseEvent)=>any)|null;declare var onpause:((this:Window,ev:Event)=>any)|null;declare var onplay:((this:Window,ev:Event)=>any)|null;declare var onplaying:((this:Window,ev:Event)=>any)|null;declare var onpointercancel:((this:Window,ev:PointerEvent)=>any)|null;declare var onpointerdown:((this:Window,ev:PointerEvent)=>any)|null;declare var onpointerenter:((this:Window,ev:PointerEvent)=>any)|null;declare var onpointerleave:((this:Window,ev:PointerEvent)=>any)|null;declare var onpointermove:((this:Window,ev:PointerEvent)=>any)|null;declare var onpointerout:((this:Window,ev:PointerEvent)=>any)|null;declare var onpointerover:((this:Window,ev:PointerEvent)=>any)|null;declare var onpointerup:((this:Window,ev:PointerEvent)=>any)|null;declare var onprogress:((this:Window,ev:ProgressEvent)=>any)|null;declare var onratechange:((this:Window,ev:Event)=>any)|null;declare var onreset:((this:Window,ev:Event)=>any)|null;declare var onresize:((this:Window,ev:UIEvent)=>any)|null;declare var onscroll:((this:Window,ev:Event)=>any)|null;declare var onsecuritypolicyviolation:((this:Window,ev:SecurityPolicyViolationEvent)=>any)|null;declare var onseeked:((this:Window,ev:Event)=>any)|null;declare var onseeking:((this:Window,ev:Event)=>any)|null;declare var onselect:((this:Window,ev:Event)=>any)|null;declare var onselectionchange:((this:Window,ev:Event)=>any)|null;declare var onselectstart:((this:Window,ev:Event)=>any)|null;declare var onstalled:((this:Window,ev:Event)=>any)|null;declare var onsubmit:((this:Window,ev:Event)=>any)|null;declare var onsuspend:((this:Window,ev:Event)=>any)|null;declare var ontimeupdate:((this:Window,ev:Event)=>any)|null;declare var ontoggle:((this:Window,ev:Event)=>any)|null;declare var ontouchcancel:((this:Window,ev:TouchEvent)=>any)|null|undefined;declare var ontouchend:((this:Window,ev:TouchEvent)=>any)|null|undefined;declare var ontouchmove:((this:Window,ev:TouchEvent)=>any)|null|undefined;declare var ontouchstart:((this:Window,ev:TouchEvent)=>any)|null|undefined;declare var ontransitioncancel:((this:Window,ev:TransitionEvent)=>any)|null;declare var ontransitionend:((this:Window,ev:TransitionEvent)=>any)|null;declare var ontransitionrun:((this:Window,ev:TransitionEvent)=>any)|null;declare var ontransitionstart:((this:Window,ev:TransitionEvent)=>any)|null;declare var onvolumechange:((this:Window,ev:Event)=>any)|null;declare var onwaiting:((this:Window,ev:Event)=>any)|null;declare var onwheel:((this:Window,ev:WheelEvent)=>any)|null;declare function cancelAnimationFrame(handle:number):void;declare function requestAnimationFrame(callback:FrameRequestCallback):number;declare var caches:CacheStorage;declare var crypto:Crypto;declare var indexedDB:IDBFactory;declare var isSecureContext:boolean;declare var origin:string;declare var performance:Performance;declare function atob(data:string):string;declare function btoa(data:string):string;declare function clearInterval(handle?:number):void;declare function clearTimeout(handle?:number):void;declare function createImageBitmap(image:ImageBitmapSource,options?:ImageBitmapOptions):Promise<ImageBitmap>;declare function createImageBitmap(image:ImageBitmapSource,sx:number,sy:number,sw:number,sh:number,options?:ImageBitmapOptions):Promise<ImageBitmap>;declare function fetch(input:RequestInfo,init?:RequestInit):Promise<Response>;declare function queueMicrotask(callback:VoidFunction):void;declare function setInterval(handler:TimerHandler,timeout?:number,...arguments:any[]):number;declare function setTimeout(handler:TimerHandler,timeout?:number,...arguments:any[]):number;declare var onafterprint:((this:Window,ev:Event)=>any)|null;declare var onbeforeprint:((this:Window,ev:Event)=>any)|null;declare var onbeforeunload:((this:Window,ev:BeforeUnloadEvent)=>any)|null;declare var onhashchange:((this:Window,ev:HashChangeEvent)=>any)|null;declare var onlanguagechange:((this:Window,ev:Event)=>any)|null;declare var onmessage:((this:Window,ev:MessageEvent)=>any)|null;declare var onmessageerror:((this:Window,ev:MessageEvent)=>any)|null;declare var onoffline:((this:Window,ev:Event)=>any)|null;declare var ononline:((this:Window,ev:Event)=>any)|null;declare var onpagehide:((this:Window,ev:PageTransitionEvent)=>any)|null;declare var onpageshow:((this:Window,ev:PageTransitionEvent)=>any)|null;declare var onpopstate:((this:Window,ev:PopStateEvent)=>any)|null;declare var onrejectionhandled:((this:Window,ev:PromiseRejectionEvent)=>any)|null;declare var onstorage:((this:Window,ev:StorageEvent)=>any)|null;declare var onunhandledrejection:((this:Window,ev:PromiseRejectionEvent)=>any)|null;declare var onunload:((this:Window,ev:Event)=>any)|null;declare function addEventListener<K extends keyof WindowEventMap>(type:K,listener:(this:Window,ev:WindowEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;declare function addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;declare function removeEventListener<K extends keyof WindowEventMap>(type:K,listener:(this:Window,ev:WindowEventMap[K])=>any,options?:boolean|EventListenerOptions):void;declare function removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;type HeadersInit=Headers|string[][]|Record<string,string>;type BodyInit=Blob|BufferSource|FormData|URLSearchParams|ReadableStream<Uint8Array>|string;type RequestInfo=Request|string;type BlobPart=BufferSource|Blob|string;type DOMHighResTimeStamp=number;type RenderingContext=CanvasRenderingContext2D|ImageBitmapRenderingContext|WebGLRenderingContext|WebGL2RenderingContext;type HTMLOrSVGImageElement=HTMLImageElement|SVGImageElement;type CanvasImageSource=HTMLOrSVGImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap|OffscreenCanvas;type OffscreenRenderingContext=OffscreenCanvasRenderingContext2D|ImageBitmapRenderingContext|WebGLRenderingContext|WebGL2RenderingContext;type MessageEventSource=WindowProxy|MessagePort|ServiceWorker;type HTMLOrSVGScriptElement=HTMLScriptElement|SVGScriptElement;type ImageBitmapSource=CanvasImageSource|Blob|ImageData;type MediaProvider=MediaStream|MediaSource|Blob;type OnErrorEventHandler=OnErrorEventHandlerNonNull|null;type OnBeforeUnloadEventHandler=OnBeforeUnloadEventHandlerNonNull|null;type TimerHandler=string|Function;type ConstrainULong=number|ConstrainULongRange;type ConstrainDouble=number|ConstrainDoubleRange;type ConstrainBoolean=boolean|ConstrainBooleanParameters;type ConstrainDOMString=string|string[]|ConstrainDOMStringParameters;type PerformanceEntryList=PerformanceEntry[];type ReadableStreamReadResult<T>=ReadableStreamReadValueResult<T>|ReadableStreamReadDoneResult<T>;type VibratePattern=number|number[];type COSEAlgorithmIdentifier=number;type AuthenticatorSelectionList=AAGUID[];type AAGUID=BufferSource;type AuthenticationExtensionsSupported=string[];type UvmEntry=number[];type UvmEntries=UvmEntry[];type AlgorithmIdentifier=string|Algorithm;type HashAlgorithmIdentifier=AlgorithmIdentifier;type BigInteger=Uint8Array;type NamedCurve=string;type GLenum=number;type GLboolean=boolean;type GLbitfield=number;type GLint=number;type GLsizei=number;type GLintptr=number;type GLsizeiptr=number;type GLuint=number;type GLfloat=number;type GLclampf=number;type TexImageSource=ImageBitmap|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|OffscreenCanvas;type Float32List=Float32Array|GLfloat[];type Int32List=Int32Array|GLint[];type GLint64=number;type GLuint64=number;type Uint32List=Uint32Array|GLuint[];type BufferSource=ArrayBufferView|ArrayBuffer;type DOMTimeStamp=number;type LineAndPositionSetting=number|AutoKeyword;type FormDataEntryValue=File|string;type InsertPosition="beforebegin"|"afterbegin"|"beforeend"|"afterend";type IDBValidKey=number|string|Date|BufferSource|IDBArrayKey;type MutationRecordType="attributes"|"characterData"|"childList";type IDBKeyPath=string;type Transferable=ArrayBuffer|MessagePort|ImageBitmap|OffscreenCanvas;type RTCIceGatherCandidate=RTCIceCandidateDictionary|RTCIceCandidateComplete;type RTCTransport=RTCDtlsTransport|RTCSrtpSdesTransport;type MouseWheelEvent=WheelEvent;type WindowProxy=Window;type AlignSetting="center"|"end"|"left"|"right"|"start";type AnimationPlayState="finished"|"idle"|"paused"|"running";type AppendMode="segments"|"sequence";type AttestationConveyancePreference="direct"|"indirect"|"none";type AudioContextLatencyCategory="balanced"|"interactive"|"playback";type AudioContextState="closed"|"running"|"suspended";type AuthenticatorAttachment="cross-platform"|"platform";type AuthenticatorTransport="ble"|"internal"|"nfc"|"usb";type AutoKeyword="auto";type AutomationRate="a-rate"|"k-rate";type BinaryType="arraybuffer"|"blob";type BiquadFilterType="allpass"|"bandpass"|"highpass"|"highshelf"|"lowpass"|"lowshelf"|"notch"|"peaking";type CanPlayTypeResult=""|"maybe"|"probably";type CanvasDirection="inherit"|"ltr"|"rtl";type CanvasFillRule="evenodd"|"nonzero";type CanvasLineCap="butt"|"round"|"square";type CanvasLineJoin="bevel"|"miter"|"round";type CanvasTextAlign="center"|"end"|"left"|"right"|"start";type CanvasTextBaseline="alphabetic"|"bottom"|"hanging"|"ideographic"|"middle"|"top";type ChannelCountMode="clamped-max"|"explicit"|"max";type ChannelInterpretation="discrete"|"speakers";type ClientTypes="all"|"sharedworker"|"window"|"worker";type ColorSpaceConversion="default"|"none";type CompositeOperation="accumulate"|"add"|"replace";type CompositeOperationOrAuto="accumulate"|"add"|"auto"|"replace";type CredentialMediationRequirement="optional"|"required"|"silent";type DirectionSetting=""|"lr"|"rl";type DisplayCaptureSurfaceType="application"|"browser"|"monitor"|"window";type DistanceModelType="exponential"|"inverse"|"linear";type DocumentReadyState="complete"|"interactive"|"loading";type EndOfStreamError="decode"|"network";type EndingType="native"|"transparent";type FillMode="auto"|"backwards"|"both"|"forwards"|"none";type FullscreenNavigationUI="auto"|"hide"|"show";type GamepadHand=""|"left"|"right";type GamepadHapticActuatorType="vibration";type GamepadMappingType=""|"standard";type IDBCursorDirection="next"|"nextunique"|"prev"|"prevunique";type IDBRequestReadyState="done"|"pending";type IDBTransactionMode="readonly"|"readwrite"|"versionchange";type ImageOrientation="flipY"|"none";type ImageSmoothingQuality="high"|"low"|"medium";type IterationCompositeOperation="accumulate"|"replace";type KeyFormat="jwk"|"pkcs8"|"raw"|"spki";type KeyType="private"|"public"|"secret";type KeyUsage="decrypt"|"deriveBits"|"deriveKey"|"encrypt"|"sign"|"unwrapKey"|"verify"|"wrapKey";type LineAlignSetting="center"|"end"|"start";type ListeningState="active"|"disambiguation"|"inactive";type MSCredentialType="FIDO_2_0";type MSTransportType="BT"|"Embedded"|"NFC"|"USB";type MSWebViewPermissionState="allow"|"defer"|"deny"|"unknown";type MSWebViewPermissionType="geolocation"|"media"|"pointerlock"|"unlimitedIndexedDBQuota"|"webnotifications";type MediaDeviceKind="audioinput"|"audiooutput"|"videoinput";type MediaKeyMessageType="individualization-request"|"license-release"|"license-renewal"|"license-request";type MediaKeySessionType="persistent-license"|"temporary";type MediaKeyStatus="expired"|"internal-error"|"output-downscaled"|"output-restricted"|"released"|"status-pending"|"usable";type MediaKeysRequirement="not-allowed"|"optional"|"required";type MediaStreamTrackState="ended"|"live";type NavigationReason="down"|"left"|"right"|"up";type NavigationType="back_forward"|"navigate"|"prerender"|"reload";type NotificationDirection="auto"|"ltr"|"rtl";type NotificationPermission="default"|"denied"|"granted";type OffscreenRenderingContextId="2d"|"bitmaprenderer"|"webgl"|"webgl2";type OrientationLockType="any"|"landscape"|"landscape-primary"|"landscape-secondary"|"natural"|"portrait"|"portrait-primary"|"portrait-secondary";type OrientationType="landscape-primary"|"landscape-secondary"|"portrait-primary"|"portrait-secondary";type OscillatorType="custom"|"sawtooth"|"sine"|"square"|"triangle";type OverSampleType="2x"|"4x"|"none";type PanningModelType="HRTF"|"equalpower";type PaymentComplete="fail"|"success"|"unknown";type PaymentShippingType="delivery"|"pickup"|"shipping";type PermissionName="accelerometer"|"ambient-light-sensor"|"background-sync"|"bluetooth"|"camera"|"clipboard"|"device-info"|"geolocation"|"gyroscope"|"magnetometer"|"microphone"|"midi"|"notifications"|"persistent-storage"|"push"|"speaker";type PermissionState="denied"|"granted"|"prompt";type PlaybackDirection="alternate"|"alternate-reverse"|"normal"|"reverse";type PositionAlignSetting="auto"|"center"|"line-left"|"line-right";type PremultiplyAlpha="default"|"none"|"premultiply";type PublicKeyCredentialType="public-key";type PushEncryptionKeyName="auth"|"p256dh";type PushPermissionState="denied"|"granted"|"prompt";type RTCBundlePolicy="balanced"|"max-bundle"|"max-compat";type RTCDataChannelState="closed"|"closing"|"connecting"|"open";type RTCDegradationPreference="balanced"|"maintain-framerate"|"maintain-resolution";type RTCDtlsRole="auto"|"client"|"server";type RTCDtlsTransportState="closed"|"connected"|"connecting"|"failed"|"new";type RTCDtxStatus="disabled"|"enabled";type RTCErrorDetailType="data-channel-failure"|"dtls-failure"|"fingerprint-failure"|"hardware-encoder-error"|"hardware-encoder-not-available"|"idp-bad-script-failure"|"idp-execution-failure"|"idp-load-failure"|"idp-need-login"|"idp-timeout"|"idp-tls-failure"|"idp-token-expired"|"idp-token-invalid"|"sctp-failure"|"sdp-syntax-error";type RTCIceCandidateType="host"|"prflx"|"relay"|"srflx";type RTCIceComponent="rtcp"|"rtp";type RTCIceConnectionState="checking"|"closed"|"completed"|"connected"|"disconnected"|"failed"|"new";type RTCIceCredentialType="oauth"|"password";type RTCIceGatherPolicy="all"|"nohost"|"relay";type RTCIceGathererState="complete"|"gathering"|"new";type RTCIceGatheringState="complete"|"gathering"|"new";type RTCIceProtocol="tcp"|"udp";type RTCIceRole="controlled"|"controlling"|"unknown";type RTCIceTcpCandidateType="active"|"passive"|"so";type RTCIceTransportPolicy="all"|"relay";type RTCIceTransportState="checking"|"closed"|"completed"|"connected"|"disconnected"|"failed"|"new";type RTCPeerConnectionState="closed"|"connected"|"connecting"|"disconnected"|"failed"|"new";type RTCPriorityType="high"|"low"|"medium"|"very-low";type RTCRtcpMuxPolicy="negotiate"|"require";type RTCRtpTransceiverDirection="inactive"|"recvonly"|"sendonly"|"sendrecv"|"stopped";type RTCSctpTransportState="closed"|"connected"|"connecting";type RTCSdpType="answer"|"offer"|"pranswer"|"rollback";type RTCSignalingState="closed"|"have-local-offer"|"have-local-pranswer"|"have-remote-offer"|"have-remote-pranswer"|"stable";type RTCStatsIceCandidatePairState="cancelled"|"failed"|"frozen"|"inprogress"|"succeeded"|"waiting";type RTCStatsIceCandidateType="host"|"peerreflexive"|"relayed"|"serverreflexive";type RTCStatsType="candidatepair"|"datachannel"|"inboundrtp"|"localcandidate"|"outboundrtp"|"remotecandidate"|"session"|"track"|"transport";type ReadyState="closed"|"ended"|"open";type ReferrerPolicy=""|"no-referrer"|"no-referrer-when-downgrade"|"origin"|"origin-when-cross-origin"|"same-origin"|"strict-origin"|"strict-origin-when-cross-origin"|"unsafe-url";type RequestCache="default"|"force-cache"|"no-cache"|"no-store"|"only-if-cached"|"reload";type RequestCredentials="include"|"omit"|"same-origin";type RequestDestination=""|"audio"|"audioworklet"|"document"|"embed"|"font"|"image"|"manifest"|"object"|"paintworklet"|"report"|"script"|"sharedworker"|"style"|"track"|"video"|"worker"|"xslt";type RequestMode="cors"|"navigate"|"no-cors"|"same-origin";type RequestRedirect="error"|"follow"|"manual";type ResizeQuality="high"|"low"|"medium"|"pixelated";type ResponseType="basic"|"cors"|"default"|"error"|"opaque"|"opaqueredirect";type ScopedCredentialType="ScopedCred";type ScrollBehavior="auto"|"smooth";type ScrollLogicalPosition="center"|"end"|"nearest"|"start";type ScrollRestoration="auto"|"manual";type ScrollSetting=""|"up";type SelectionMode="end"|"preserve"|"select"|"start";type ServiceWorkerState="activated"|"activating"|"installed"|"installing"|"parsed"|"redundant";type ServiceWorkerUpdateViaCache="all"|"imports"|"none";type ShadowRootMode="closed"|"open";type SpeechSynthesisErrorCode="audio-busy"|"audio-hardware"|"canceled"|"interrupted"|"invalid-argument"|"language-unavailable"|"network"|"not-allowed"|"synthesis-failed"|"synthesis-unavailable"|"text-too-long"|"voice-unavailable";type SupportedType="application/xhtml+xml"|"application/xml"|"image/svg+xml"|"text/html"|"text/xml";type TextTrackKind="captions"|"chapters"|"descriptions"|"metadata"|"subtitles";type TextTrackMode="disabled"|"hidden"|"showing";type TouchType="direct"|"stylus";type Transport="ble"|"nfc"|"usb";type UserVerificationRequirement="discouraged"|"preferred"|"required";type VRDisplayEventReason="mounted"|"navigation"|"requested"|"unmounted";type VideoFacingModeEnum="environment"|"left"|"right"|"user";type VisibilityState="hidden"|"visible";type WebGLPowerPreference="default"|"high-performance"|"low-power";type WorkerType="classic"|"module";type XMLHttpRequestResponseType=""|"arraybuffer"|"blob"|"document"|"json"|"text";`
    }, {
        fileName: "lib.dom.iterable.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface AudioParam{setValueCurveAtTime(values:Iterable<number>,startTime:number,duration:number):AudioParam;}interface AudioParamMap extends ReadonlyMap<string,AudioParam>{}interface BaseAudioContext{createIIRFilter(feedforward:Iterable<number>,feedback:Iterable<number>):IIRFilterNode;createPeriodicWave(real:Iterable<number>,imag:Iterable<number>,constraints?:PeriodicWaveConstraints):PeriodicWave;}interface CSSRuleList{[Symbol.iterator]():IterableIterator<CSSRule>;}interface CSSStyleDeclaration{[Symbol.iterator]():IterableIterator<string>;}interface Cache{addAll(requests:Iterable<RequestInfo>):Promise<void>;}interface CanvasPathDrawingStyles{setLineDash(segments:Iterable<number>):void;}interface ClientRectList{[Symbol.iterator]():IterableIterator<ClientRect>;}interface DOMRectList{[Symbol.iterator]():IterableIterator<DOMRect>;}interface DOMStringList{[Symbol.iterator]():IterableIterator<string>;}interface DOMTokenList{[Symbol.iterator]():IterableIterator<string>;entries():IterableIterator<[number,string]>;keys():IterableIterator<number>;values():IterableIterator<string>;}interface DataTransferItemList{[Symbol.iterator]():IterableIterator<DataTransferItem>;}interface FileList{[Symbol.iterator]():IterableIterator<File>;}interface FormData{[Symbol.iterator]():IterableIterator<[string,FormDataEntryValue]>;entries():IterableIterator<[string,FormDataEntryValue]>;keys():IterableIterator<string>;values():IterableIterator<FormDataEntryValue>;}interface HTMLAllCollection{[Symbol.iterator]():IterableIterator<Element>;}interface HTMLCollectionBase{[Symbol.iterator]():IterableIterator<Element>;}interface HTMLCollectionOf<T extends Element>{[Symbol.iterator]():IterableIterator<T>;}interface HTMLFormElement{[Symbol.iterator]():IterableIterator<Element>;}interface HTMLSelectElement{[Symbol.iterator]():IterableIterator<Element>;}interface Headers{[Symbol.iterator]():IterableIterator<[string,string]>;entries():IterableIterator<[string,string]>;keys():IterableIterator<string>;values():IterableIterator<string>;}interface IDBObjectStore{createIndex(name:string,keyPath:string|Iterable<string>,options?:IDBIndexParameters):IDBIndex;}interface MediaKeyStatusMap{[Symbol.iterator]():IterableIterator<[BufferSource,MediaKeyStatus]>;entries():IterableIterator<[BufferSource,MediaKeyStatus]>;keys():IterableIterator<BufferSource>;values():IterableIterator<MediaKeyStatus>;}interface MediaList{[Symbol.iterator]():IterableIterator<string>;}interface MimeTypeArray{[Symbol.iterator]():IterableIterator<MimeType>;}interface NamedNodeMap{[Symbol.iterator]():IterableIterator<Attr>;}interface Navigator{requestMediaKeySystemAccess(keySystem:string,supportedConfigurations:Iterable<MediaKeySystemConfiguration>):Promise<MediaKeySystemAccess>;}interface NodeList{[Symbol.iterator]():IterableIterator<Node>;entries():IterableIterator<[number,Node]>;keys():IterableIterator<number>;values():IterableIterator<Node>;}interface NodeListOf<TNode extends Node>{[Symbol.iterator]():IterableIterator<TNode>;entries():IterableIterator<[number,TNode]>;keys():IterableIterator<number>;values():IterableIterator<TNode>;}interface Plugin{[Symbol.iterator]():IterableIterator<MimeType>;}interface PluginArray{[Symbol.iterator]():IterableIterator<Plugin>;}interface RTCRtpTransceiver{setCodecPreferences(codecs:Iterable<RTCRtpCodecCapability>):void;}interface RTCStatsReport extends ReadonlyMap<string,any>{}interface SVGLengthList{[Symbol.iterator]():IterableIterator<SVGLength>;}interface SVGNumberList{[Symbol.iterator]():IterableIterator<SVGNumber>;}interface SVGPointList{[Symbol.iterator]():IterableIterator<DOMPoint>;}interface SVGStringList{[Symbol.iterator]():IterableIterator<string>;}interface SourceBufferList{[Symbol.iterator]():IterableIterator<SourceBuffer>;}interface SpeechGrammarList{[Symbol.iterator]():IterableIterator<SpeechGrammar>;}interface SpeechRecognitionResult{[Symbol.iterator]():IterableIterator<SpeechRecognitionAlternative>;}interface SpeechRecognitionResultList{[Symbol.iterator]():IterableIterator<SpeechRecognitionResult>;}interface StyleSheetList{[Symbol.iterator]():IterableIterator<CSSStyleSheet>;}interface TextTrackCueList{[Symbol.iterator]():IterableIterator<TextTrackCue>;}interface TextTrackList{[Symbol.iterator]():IterableIterator<TextTrack>;}interface TouchList{[Symbol.iterator]():IterableIterator<Touch>;}interface URLSearchParams{[Symbol.iterator]():IterableIterator<[string,string]>;entries():IterableIterator<[string,string]>;keys():IterableIterator<string>;values():IterableIterator<string>;}interface VRDisplay{requestPresent(layers:Iterable<VRLayer>):Promise<void>;}interface WEBGL_draw_buffers{drawBuffersWEBGL(buffers:Iterable<GLenum>):void;}interface WebAuthentication{makeCredential(accountInformation:Account,cryptoParameters:Iterable<ScopedCredentialParameters>,attestationChallenge:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer|null,options?:ScopedCredentialOptions):Promise<ScopedCredentialInfo>;}interface WebGL2RenderingContextBase{clearBufferfv(buffer:GLenum,drawbuffer:GLint,values:Iterable<GLfloat>,srcOffset?:GLuint):void;clearBufferiv(buffer:GLenum,drawbuffer:GLint,values:Iterable<GLint>,srcOffset?:GLuint):void;clearBufferuiv(buffer:GLenum,drawbuffer:GLint,values:Iterable<GLuint>,srcOffset?:GLuint):void;drawBuffers(buffers:Iterable<GLenum>):void;getActiveUniforms(program:WebGLProgram,uniformIndices:Iterable<GLuint>,pname:GLenum):any;getUniformIndices(program:WebGLProgram,uniformNames:Iterable<string>):Iterable<GLuint>|null;invalidateFramebuffer(target:GLenum,attachments:Iterable<GLenum>):void;invalidateSubFramebuffer(target:GLenum,attachments:Iterable<GLenum>,x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;transformFeedbackVaryings(program:WebGLProgram,varyings:Iterable<string>,bufferMode:GLenum):void;uniform1uiv(location:WebGLUniformLocation|null,data:Iterable<GLuint>,srcOffset?:GLuint,srcLength?:GLuint):void;uniform2uiv(location:WebGLUniformLocation|null,data:Iterable<GLuint>,srcOffset?:GLuint,srcLength?:GLuint):void;uniform3uiv(location:WebGLUniformLocation|null,data:Iterable<GLuint>,srcOffset?:GLuint,srcLength?:GLuint):void;uniform4uiv(location:WebGLUniformLocation|null,data:Iterable<GLuint>,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix2x3fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix2x4fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix3x2fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix3x4fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix4x2fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix4x3fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;vertexAttribI4iv(index:GLuint,values:Iterable<GLint>):void;vertexAttribI4uiv(index:GLuint,values:Iterable<GLuint>):void;}interface WebGL2RenderingContextOverloads{uniform1fv(location:WebGLUniformLocation|null,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniform1iv(location:WebGLUniformLocation|null,data:Iterable<GLint>,srcOffset?:GLuint,srcLength?:GLuint):void;uniform2fv(location:WebGLUniformLocation|null,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniform2iv(location:WebGLUniformLocation|null,data:Iterable<GLint>,srcOffset?:GLuint,srcLength?:GLuint):void;uniform3fv(location:WebGLUniformLocation|null,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniform3iv(location:WebGLUniformLocation|null,data:Iterable<GLint>,srcOffset?:GLuint,srcLength?:GLuint):void;uniform4fv(location:WebGLUniformLocation|null,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniform4iv(location:WebGLUniformLocation|null,data:Iterable<GLint>,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix2fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix3fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix4fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Iterable<GLfloat>,srcOffset?:GLuint,srcLength?:GLuint):void;}interface WebGLRenderingContextBase{vertexAttrib1fv(index:GLuint,values:Iterable<GLfloat>):void;vertexAttrib2fv(index:GLuint,values:Iterable<GLfloat>):void;vertexAttrib3fv(index:GLuint,values:Iterable<GLfloat>):void;vertexAttrib4fv(index:GLuint,values:Iterable<GLfloat>):void;}interface WebGLRenderingContextOverloads{uniform1fv(location:WebGLUniformLocation|null,v:Iterable<GLfloat>):void;uniform1iv(location:WebGLUniformLocation|null,v:Iterable<GLint>):void;uniform2fv(location:WebGLUniformLocation|null,v:Iterable<GLfloat>):void;uniform2iv(location:WebGLUniformLocation|null,v:Iterable<GLint>):void;uniform3fv(location:WebGLUniformLocation|null,v:Iterable<GLfloat>):void;uniform3iv(location:WebGLUniformLocation|null,v:Iterable<GLint>):void;uniform4fv(location:WebGLUniformLocation|null,v:Iterable<GLfloat>):void;uniform4iv(location:WebGLUniformLocation|null,v:Iterable<GLint>):void;uniformMatrix2fv(location:WebGLUniformLocation|null,transpose:GLboolean,value:Iterable<GLfloat>):void;uniformMatrix3fv(location:WebGLUniformLocation|null,transpose:GLboolean,value:Iterable<GLfloat>):void;uniformMatrix4fv(location:WebGLUniformLocation|null,transpose:GLboolean,value:Iterable<GLfloat>):void;}`
    }, {
        fileName: "lib.es2015.collection.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface Map<K,V>{clear():void;delete(key:K):boolean;forEach(callbackfn:(value:V,key:K,map:Map<K,V>)=>void,thisArg?:any):void;get(key:K):V|undefined;has(key:K):boolean;set(key:K,value:V):this;readonly size:number;}interface MapConstructor{new():Map<any,any>;new<K,V>(entries?:readonly(readonly[K,V])[]|null):Map<K,V>;readonly prototype:Map<any,any>;}declare var Map:MapConstructor;interface ReadonlyMap<K,V>{forEach(callbackfn:(value:V,key:K,map:ReadonlyMap<K,V>)=>void,thisArg?:any):void;get(key:K):V|undefined;has(key:K):boolean;readonly size:number;}interface WeakMap<K extends object,V>{delete(key:K):boolean;get(key:K):V|undefined;has(key:K):boolean;set(key:K,value:V):this;}interface WeakMapConstructor{new<K extends object=object,V=any>(entries?:readonly[K,V][]|null):WeakMap<K,V>;readonly prototype:WeakMap<object,any>;}declare var WeakMap:WeakMapConstructor;interface Set<T>{add(value:T):this;clear():void;delete(value:T):boolean;forEach(callbackfn:(value:T,value2:T,set:Set<T>)=>void,thisArg?:any):void;has(value:T):boolean;readonly size:number;}interface SetConstructor{new<T=any>(values?:readonly T[]|null):Set<T>;readonly prototype:Set<any>;}declare var Set:SetConstructor;interface ReadonlySet<T>{forEach(callbackfn:(value:T,value2:T,set:ReadonlySet<T>)=>void,thisArg?:any):void;has(value:T):boolean;readonly size:number;}interface WeakSet<T extends object>{add(value:T):this;delete(value:T):boolean;has(value:T):boolean;}interface WeakSetConstructor{new<T extends object=object>(values?:readonly T[]|null):WeakSet<T>;readonly prototype:WeakSet<object>;}declare var WeakSet:WeakSetConstructor;`
    }, {
        fileName: "lib.es2015.core.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface Array<T>{find<S extends T>(predicate:(this:void,value:T,index:number,obj:T[])=>value is S,thisArg?:any):S|undefined;find(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):T|undefined;findIndex(predicate:(value:T,index:number,obj:T[])=>unknown,thisArg?:any):number;fill(value:T,start?:number,end?:number):this;copyWithin(target:number,start:number,end?:number):this;}interface ArrayConstructor{from<T>(arrayLike:ArrayLike<T>):T[];from<T,U>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>U,thisArg?:any):U[];of<T>(...items:T[]):T[];}interface DateConstructor{new(value:number|string|Date):Date;}interface Function{readonly name:string;}interface Math{clz32(x:number):number;imul(x:number,y:number):number;sign(x:number):number;log10(x:number):number;log2(x:number):number;log1p(x:number):number;expm1(x:number):number;cosh(x:number):number;sinh(x:number):number;tanh(x:number):number;acosh(x:number):number;asinh(x:number):number;atanh(x:number):number;hypot(...values:number[]):number;trunc(x:number):number;fround(x:number):number;cbrt(x:number):number;}interface NumberConstructor{readonly EPSILON:number;isFinite(number:unknown):boolean;isInteger(number:unknown):boolean;isNaN(number:unknown):boolean;isSafeInteger(number:unknown):boolean;readonly MAX_SAFE_INTEGER:number;readonly MIN_SAFE_INTEGER:number;parseFloat(string:string):number;parseInt(string:string,radix?:number):number;}interface ObjectConstructor{assign<T,U>(target:T,source:U):T&U;assign<T,U,V>(target:T,source1:U,source2:V):T&U&V;assign<T,U,V,W>(target:T,source1:U,source2:V,source3:W):T&U&V&W;assign(target:object,...sources:any[]):any;getOwnPropertySymbols(o:any):symbol[];keys(o:{}):string[];is(value1:any,value2:any):boolean;setPrototypeOf(o:any,proto:object|null):any;}interface ReadonlyArray<T>{find<S extends T>(predicate:(this:void,value:T,index:number,obj:readonly T[])=>value is S,thisArg?:any):S|undefined;find(predicate:(value:T,index:number,obj:readonly T[])=>unknown,thisArg?:any):T|undefined;findIndex(predicate:(value:T,index:number,obj:readonly T[])=>unknown,thisArg?:any):number;}interface RegExp{readonly flags:string;readonly sticky:boolean;readonly unicode:boolean;}interface RegExpConstructor{new(pattern:RegExp|string,flags?:string):RegExp;(pattern:RegExp|string,flags?:string):RegExp;}interface String{codePointAt(pos:number):number|undefined;includes(searchString:string,position?:number):boolean;endsWith(searchString:string,endPosition?:number):boolean;normalize(form:"NFC"|"NFD"|"NFKC"|"NFKD"):string;normalize(form?:string):string;repeat(count:number):string;startsWith(searchString:string,position?:number):boolean;anchor(name:string):string;big():string;blink():string;bold():string;fixed():string;fontcolor(color:string):string;fontsize(size:number):string;fontsize(size:string):string;italics():string;link(url:string):string;small():string;strike():string;sub():string;sup():string;}interface StringConstructor{fromCodePoint(...codePoints:number[]):string;raw(template:TemplateStringsArray,...substitutions:any[]):string;}`
    }, {
        fileName: "lib.es2015.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es5" />\n/// <reference lib="es2015.core" />\n/// <reference lib="es2015.collection" />\n/// <reference lib="es2015.iterable" />\n/// <reference lib="es2015.generator" />\n/// <reference lib="es2015.promise" />\n/// <reference lib="es2015.proxy" />\n/// <reference lib="es2015.reflect" />\n/// <reference lib="es2015.symbol" />\n/// <reference lib="es2015.symbol.wellknown" />\n`
    }, {
        fileName: "lib.es2015.generator.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015.iterable" />\ninterface Generator<T=unknown,TReturn=any,TNext=unknown>extends Iterator<T,TReturn,TNext>{next(...args:[]|[TNext]):IteratorResult<T,TReturn>;return(value:TReturn):IteratorResult<T,TReturn>;throw(e:any):IteratorResult<T,TReturn>;[Symbol.iterator]():Generator<T,TReturn,TNext>;}interface GeneratorFunction{new(...args:any[]):Generator;(...args:any[]):Generator;readonly length:number;readonly name:string;readonly prototype:Generator;}interface GeneratorFunctionConstructor{new(...args:string[]):GeneratorFunction;(...args:string[]):GeneratorFunction;readonly length:number;readonly name:string;readonly prototype:GeneratorFunction;}`
    }, {
        fileName: "lib.es2015.iterable.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015.symbol" />\ninterface SymbolConstructor{readonly iterator:symbol;}interface IteratorYieldResult<TYield>{done?:false;value:TYield;}interface IteratorReturnResult<TReturn>{done:true;value:TReturn;}type IteratorResult<T,TReturn=any>=IteratorYieldResult<T>|IteratorReturnResult<TReturn>;interface Iterator<T,TReturn=any,TNext=undefined>{next(...args:[]|[TNext]):IteratorResult<T,TReturn>;return?(value?:TReturn):IteratorResult<T,TReturn>;throw?(e?:any):IteratorResult<T,TReturn>;}interface Iterable<T>{[Symbol.iterator]():Iterator<T>;}interface IterableIterator<T>extends Iterator<T>{[Symbol.iterator]():IterableIterator<T>;}interface Array<T>{[Symbol.iterator]():IterableIterator<T>;entries():IterableIterator<[number,T]>;keys():IterableIterator<number>;values():IterableIterator<T>;}interface ArrayConstructor{from<T>(iterable:Iterable<T>|ArrayLike<T>):T[];from<T,U>(iterable:Iterable<T>|ArrayLike<T>,mapfn:(v:T,k:number)=>U,thisArg?:any):U[];}interface ReadonlyArray<T>{[Symbol.iterator]():IterableIterator<T>;entries():IterableIterator<[number,T]>;keys():IterableIterator<number>;values():IterableIterator<T>;}interface IArguments{[Symbol.iterator]():IterableIterator<any>;}interface Map<K,V>{[Symbol.iterator]():IterableIterator<[K,V]>;entries():IterableIterator<[K,V]>;keys():IterableIterator<K>;values():IterableIterator<V>;}interface ReadonlyMap<K,V>{[Symbol.iterator]():IterableIterator<[K,V]>;entries():IterableIterator<[K,V]>;keys():IterableIterator<K>;values():IterableIterator<V>;}interface MapConstructor{new<K,V>(iterable:Iterable<readonly[K,V]>):Map<K,V>;}interface WeakMap<K extends object,V>{}interface WeakMapConstructor{new<K extends object,V>(iterable:Iterable<[K,V]>):WeakMap<K,V>;}interface Set<T>{[Symbol.iterator]():IterableIterator<T>;entries():IterableIterator<[T,T]>;keys():IterableIterator<T>;values():IterableIterator<T>;}interface ReadonlySet<T>{[Symbol.iterator]():IterableIterator<T>;entries():IterableIterator<[T,T]>;keys():IterableIterator<T>;values():IterableIterator<T>;}interface SetConstructor{new<T>(iterable?:Iterable<T>|null):Set<T>;}interface WeakSet<T extends object>{}interface WeakSetConstructor{new<T extends object=object>(iterable:Iterable<T>):WeakSet<T>;}interface Promise<T>{}interface PromiseConstructor{all<T>(values:Iterable<T|PromiseLike<T>>):Promise<T[]>;race<T>(values:Iterable<T>):Promise<T extends PromiseLike<infer U>?U:T>;race<T>(values:Iterable<T|PromiseLike<T>>):Promise<T>;}declare namespace Reflect{function enumerate(target:object):IterableIterator<any>;}interface String{[Symbol.iterator]():IterableIterator<string>;}interface Int8Array{[Symbol.iterator]():IterableIterator<number>;entries():IterableIterator<[number,number]>;keys():IterableIterator<number>;values():IterableIterator<number>;}interface Int8ArrayConstructor{new(elements:Iterable<number>):Int8Array;from(arrayLike:Iterable<number>,mapfn?:(v:number,k:number)=>number,thisArg?:any):Int8Array;}interface Uint8Array{[Symbol.iterator]():IterableIterator<number>;entries():IterableIterator<[number,number]>;keys():IterableIterator<number>;values():IterableIterator<number>;}interface Uint8ArrayConstructor{new(elements:Iterable<number>):Uint8Array;from(arrayLike:Iterable<number>,mapfn?:(v:number,k:number)=>number,thisArg?:any):Uint8Array;}interface Uint8ClampedArray{[Symbol.iterator]():IterableIterator<number>;entries():IterableIterator<[number,number]>;keys():IterableIterator<number>;values():IterableIterator<number>;}interface Uint8ClampedArrayConstructor{new(elements:Iterable<number>):Uint8ClampedArray;from(arrayLike:Iterable<number>,mapfn?:(v:number,k:number)=>number,thisArg?:any):Uint8ClampedArray;}interface Int16Array{[Symbol.iterator]():IterableIterator<number>;entries():IterableIterator<[number,number]>;keys():IterableIterator<number>;values():IterableIterator<number>;}interface Int16ArrayConstructor{new(elements:Iterable<number>):Int16Array;from(arrayLike:Iterable<number>,mapfn?:(v:number,k:number)=>number,thisArg?:any):Int16Array;}interface Uint16Array{[Symbol.iterator]():IterableIterator<number>;entries():IterableIterator<[number,number]>;keys():IterableIterator<number>;values():IterableIterator<number>;}interface Uint16ArrayConstructor{new(elements:Iterable<number>):Uint16Array;from(arrayLike:Iterable<number>,mapfn?:(v:number,k:number)=>number,thisArg?:any):Uint16Array;}interface Int32Array{[Symbol.iterator]():IterableIterator<number>;entries():IterableIterator<[number,number]>;keys():IterableIterator<number>;values():IterableIterator<number>;}interface Int32ArrayConstructor{new(elements:Iterable<number>):Int32Array;from(arrayLike:Iterable<number>,mapfn?:(v:number,k:number)=>number,thisArg?:any):Int32Array;}interface Uint32Array{[Symbol.iterator]():IterableIterator<number>;entries():IterableIterator<[number,number]>;keys():IterableIterator<number>;values():IterableIterator<number>;}interface Uint32ArrayConstructor{new(elements:Iterable<number>):Uint32Array;from(arrayLike:Iterable<number>,mapfn?:(v:number,k:number)=>number,thisArg?:any):Uint32Array;}interface Float32Array{[Symbol.iterator]():IterableIterator<number>;entries():IterableIterator<[number,number]>;keys():IterableIterator<number>;values():IterableIterator<number>;}interface Float32ArrayConstructor{new(elements:Iterable<number>):Float32Array;from(arrayLike:Iterable<number>,mapfn?:(v:number,k:number)=>number,thisArg?:any):Float32Array;}interface Float64Array{[Symbol.iterator]():IterableIterator<number>;entries():IterableIterator<[number,number]>;keys():IterableIterator<number>;values():IterableIterator<number>;}interface Float64ArrayConstructor{new(elements:Iterable<number>):Float64Array;from(arrayLike:Iterable<number>,mapfn?:(v:number,k:number)=>number,thisArg?:any):Float64Array;}`
    }, {
        fileName: "lib.es2015.promise.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface PromiseConstructor{readonly prototype:Promise<any>;new<T>(executor:(resolve:(value?:T|PromiseLike<T>)=>void,reject:(reason?:any)=>void)=>void):Promise<T>;all<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>(values:readonly[T1|PromiseLike<T1>,T2|PromiseLike<T2>,T3|PromiseLike<T3>,T4|PromiseLike<T4>,T5|PromiseLike<T5>,T6|PromiseLike<T6>,T7|PromiseLike<T7>,T8|PromiseLike<T8>,T9|PromiseLike<T9>,T10|PromiseLike<T10>]):Promise<[T1,T2,T3,T4,T5,T6,T7,T8,T9,T10]>;all<T1,T2,T3,T4,T5,T6,T7,T8,T9>(values:readonly[T1|PromiseLike<T1>,T2|PromiseLike<T2>,T3|PromiseLike<T3>,T4|PromiseLike<T4>,T5|PromiseLike<T5>,T6|PromiseLike<T6>,T7|PromiseLike<T7>,T8|PromiseLike<T8>,T9|PromiseLike<T9>]):Promise<[T1,T2,T3,T4,T5,T6,T7,T8,T9]>;all<T1,T2,T3,T4,T5,T6,T7,T8>(values:readonly[T1|PromiseLike<T1>,T2|PromiseLike<T2>,T3|PromiseLike<T3>,T4|PromiseLike<T4>,T5|PromiseLike<T5>,T6|PromiseLike<T6>,T7|PromiseLike<T7>,T8|PromiseLike<T8>]):Promise<[T1,T2,T3,T4,T5,T6,T7,T8]>;all<T1,T2,T3,T4,T5,T6,T7>(values:readonly[T1|PromiseLike<T1>,T2|PromiseLike<T2>,T3|PromiseLike<T3>,T4|PromiseLike<T4>,T5|PromiseLike<T5>,T6|PromiseLike<T6>,T7|PromiseLike<T7>]):Promise<[T1,T2,T3,T4,T5,T6,T7]>;all<T1,T2,T3,T4,T5,T6>(values:readonly[T1|PromiseLike<T1>,T2|PromiseLike<T2>,T3|PromiseLike<T3>,T4|PromiseLike<T4>,T5|PromiseLike<T5>,T6|PromiseLike<T6>]):Promise<[T1,T2,T3,T4,T5,T6]>;all<T1,T2,T3,T4,T5>(values:readonly[T1|PromiseLike<T1>,T2|PromiseLike<T2>,T3|PromiseLike<T3>,T4|PromiseLike<T4>,T5|PromiseLike<T5>]):Promise<[T1,T2,T3,T4,T5]>;all<T1,T2,T3,T4>(values:readonly[T1|PromiseLike<T1>,T2|PromiseLike<T2>,T3|PromiseLike<T3>,T4|PromiseLike<T4>]):Promise<[T1,T2,T3,T4]>;all<T1,T2,T3>(values:readonly[T1|PromiseLike<T1>,T2|PromiseLike<T2>,T3|PromiseLike<T3>]):Promise<[T1,T2,T3]>;all<T1,T2>(values:readonly[T1|PromiseLike<T1>,T2|PromiseLike<T2>]):Promise<[T1,T2]>;all<T>(values:readonly(T|PromiseLike<T>)[]):Promise<T[]>;race<T>(values:readonly T[]):Promise<T extends PromiseLike<infer U>?U:T>;reject<T=never>(reason?:any):Promise<T>;resolve<T>(value:T|PromiseLike<T>):Promise<T>;resolve():Promise<void>;}declare var Promise:PromiseConstructor;`
    }, {
        fileName: "lib.es2015.proxy.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface ProxyHandler<T extends object>{getPrototypeOf?(target:T):object|null;setPrototypeOf?(target:T,v:any):boolean;isExtensible?(target:T):boolean;preventExtensions?(target:T):boolean;getOwnPropertyDescriptor?(target:T,p:PropertyKey):PropertyDescriptor|undefined;has?(target:T,p:PropertyKey):boolean;get?(target:T,p:PropertyKey,receiver:any):any;set?(target:T,p:PropertyKey,value:any,receiver:any):boolean;deleteProperty?(target:T,p:PropertyKey):boolean;defineProperty?(target:T,p:PropertyKey,attributes:PropertyDescriptor):boolean;enumerate?(target:T):PropertyKey[];ownKeys?(target:T):PropertyKey[];apply?(target:T,thisArg:any,argArray?:any):any;construct?(target:T,argArray:any,newTarget?:any):object;}interface ProxyConstructor{revocable<T extends object>(target:T,handler:ProxyHandler<T>):{proxy:T;revoke:()=>void;};new<T extends object>(target:T,handler:ProxyHandler<T>):T;}declare var Proxy:ProxyConstructor;`
    }, {
        fileName: "lib.es2015.reflect.d.ts",
        text: `/// <reference no-default-lib="true"/>\ndeclare namespace Reflect{function apply(target:Function,thisArgument:any,argumentsList:ArrayLike<any>):any;function construct(target:Function,argumentsList:ArrayLike<any>,newTarget?:any):any;function defineProperty(target:object,propertyKey:PropertyKey,attributes:PropertyDescriptor):boolean;function deleteProperty(target:object,propertyKey:PropertyKey):boolean;function get(target:object,propertyKey:PropertyKey,receiver?:any):any;function getOwnPropertyDescriptor(target:object,propertyKey:PropertyKey):PropertyDescriptor|undefined;function getPrototypeOf(target:object):object;function has(target:object,propertyKey:PropertyKey):boolean;function isExtensible(target:object):boolean;function ownKeys(target:object):PropertyKey[];function preventExtensions(target:object):boolean;function set(target:object,propertyKey:PropertyKey,value:any,receiver?:any):boolean;function setPrototypeOf(target:object,proto:any):boolean;}`
    }, {
        fileName: "lib.es2015.symbol.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface SymbolConstructor{readonly prototype:Symbol;(description?:string|number):symbol;for(key:string):symbol;keyFor(sym:symbol):string|undefined;}declare var Symbol:SymbolConstructor;`
    }, {
        fileName: "lib.es2015.symbol.wellknown.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015.symbol" />\ninterface SymbolConstructor{readonly hasInstance:symbol;readonly isConcatSpreadable:symbol;readonly match:symbol;readonly replace:symbol;readonly search:symbol;readonly species:symbol;readonly split:symbol;readonly toPrimitive:symbol;readonly toStringTag:symbol;readonly unscopables:symbol;}interface Symbol{readonly[Symbol.toStringTag]:string;}interface Array<T>{[Symbol.unscopables]():{copyWithin:boolean;entries:boolean;fill:boolean;find:boolean;findIndex:boolean;keys:boolean;values:boolean;};}interface Date{[Symbol.toPrimitive](hint:"default"):string;[Symbol.toPrimitive](hint:"string"):string;[Symbol.toPrimitive](hint:"number"):number;[Symbol.toPrimitive](hint:string):string|number;}interface Map<K,V>{readonly[Symbol.toStringTag]:string;}interface WeakMap<K extends object,V>{readonly[Symbol.toStringTag]:string;}interface Set<T>{readonly[Symbol.toStringTag]:string;}interface WeakSet<T extends object>{readonly[Symbol.toStringTag]:string;}interface JSON{readonly[Symbol.toStringTag]:string;}interface Function{[Symbol.hasInstance](value:any):boolean;}interface GeneratorFunction{readonly[Symbol.toStringTag]:string;}interface Math{readonly[Symbol.toStringTag]:string;}interface Promise<T>{readonly[Symbol.toStringTag]:string;}interface PromiseConstructor{readonly[Symbol.species]:PromiseConstructor;}interface RegExp{[Symbol.match](string:string):RegExpMatchArray|null;[Symbol.replace](string:string,replaceValue:string):string;[Symbol.replace](string:string,replacer:(substring:string,...args:any[])=>string):string;[Symbol.search](string:string):number;[Symbol.split](string:string,limit?:number):string[];}interface RegExpConstructor{readonly[Symbol.species]:RegExpConstructor;}interface String{match(matcher:{[Symbol.match](string:string):RegExpMatchArray|null;}):RegExpMatchArray|null;replace(searchValue:{[Symbol.replace](string:string,replaceValue:string):string;},replaceValue:string):string;replace(searchValue:{[Symbol.replace](string:string,replacer:(substring:string,...args:any[])=>string):string;},replacer:(substring:string,...args:any[])=>string):string;search(searcher:{[Symbol.search](string:string):number;}):number;split(splitter:{[Symbol.split](string:string,limit?:number):string[];},limit?:number):string[];}interface ArrayBuffer{readonly[Symbol.toStringTag]:string;}interface DataView{readonly[Symbol.toStringTag]:string;}interface Int8Array{readonly[Symbol.toStringTag]:"Int8Array";}interface Uint8Array{readonly[Symbol.toStringTag]:"Uint8Array";}interface Uint8ClampedArray{readonly[Symbol.toStringTag]:"Uint8ClampedArray";}interface Int16Array{readonly[Symbol.toStringTag]:"Int16Array";}interface Uint16Array{readonly[Symbol.toStringTag]:"Uint16Array";}interface Int32Array{readonly[Symbol.toStringTag]:"Int32Array";}interface Uint32Array{readonly[Symbol.toStringTag]:"Uint32Array";}interface Float32Array{readonly[Symbol.toStringTag]:"Float32Array";}interface Float64Array{readonly[Symbol.toStringTag]:"Float64Array";}interface ArrayConstructor{readonly[Symbol.species]:ArrayConstructor;}interface MapConstructor{readonly[Symbol.species]:MapConstructor;}interface SetConstructor{readonly[Symbol.species]:SetConstructor;}interface ArrayBufferConstructor{readonly[Symbol.species]:ArrayBufferConstructor;}`
    }, {
        fileName: "lib.es2016.array.include.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface Array<T>{includes(searchElement:T,fromIndex?:number):boolean;}interface ReadonlyArray<T>{includes(searchElement:T,fromIndex?:number):boolean;}interface Int8Array{includes(searchElement:number,fromIndex?:number):boolean;}interface Uint8Array{includes(searchElement:number,fromIndex?:number):boolean;}interface Uint8ClampedArray{includes(searchElement:number,fromIndex?:number):boolean;}interface Int16Array{includes(searchElement:number,fromIndex?:number):boolean;}interface Uint16Array{includes(searchElement:number,fromIndex?:number):boolean;}interface Int32Array{includes(searchElement:number,fromIndex?:number):boolean;}interface Uint32Array{includes(searchElement:number,fromIndex?:number):boolean;}interface Float32Array{includes(searchElement:number,fromIndex?:number):boolean;}interface Float64Array{includes(searchElement:number,fromIndex?:number):boolean;}`
    }, {
        fileName: "lib.es2016.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015" />\n/// <reference lib="es2016.array.include" />`
    }, {
        fileName: "lib.es2016.full.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2016" />\n/// <reference lib="dom" />\n/// <reference lib="webworker.importscripts" />\n/// <reference lib="scripthost" />\n/// <reference lib="dom.iterable" />`
    }, {
        fileName: "lib.es2017.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2016" />\n/// <reference lib="es2017.object" />\n/// <reference lib="es2017.sharedmemory" />\n/// <reference lib="es2017.string" />\n/// <reference lib="es2017.intl" />\n/// <reference lib="es2017.typedarrays" />\n`
    }, {
        fileName: "lib.es2017.full.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2017" />\n/// <reference lib="dom" />\n/// <reference lib="webworker.importscripts" />\n/// <reference lib="scripthost" />\n/// <reference lib="dom.iterable" />`
    }, {
        fileName: "lib.es2017.intl.d.ts",
        text: `/// <reference no-default-lib="true"/>\ndeclare namespace Intl{type DateTimeFormatPartTypes="day"|"dayPeriod"|"era"|"hour"|"literal"|"minute"|"month"|"second"|"timeZoneName"|"weekday"|"year";interface DateTimeFormatPart{type:DateTimeFormatPartTypes;value:string;}interface DateTimeFormat{formatToParts(date?:Date|number):DateTimeFormatPart[];}}`
    }, {
        fileName: "lib.es2017.object.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface ObjectConstructor{values<T>(o:{[s:string]:T}|ArrayLike<T>):T[];values(o:{}):any[];entries<T>(o:{[s:string]:T}|ArrayLike<T>):[string,T][];entries(o:{}):[string,any][];getOwnPropertyDescriptors<T>(o:T):{[P in keyof T]:TypedPropertyDescriptor<T[P]>}&{[x:string]:PropertyDescriptor};}`
    }, {
        fileName: "lib.es2017.sharedmemory.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015.symbol" />\n/// <reference lib="es2015.symbol.wellknown" />\ninterface SharedArrayBuffer{readonly byteLength:number;length:number;slice(begin:number,end?:number):SharedArrayBuffer;readonly[Symbol.species]:SharedArrayBuffer;readonly[Symbol.toStringTag]:"SharedArrayBuffer";}interface SharedArrayBufferConstructor{readonly prototype:SharedArrayBuffer;new(byteLength:number):SharedArrayBuffer;}declare var SharedArrayBuffer:SharedArrayBufferConstructor;interface ArrayBufferTypes{SharedArrayBuffer:SharedArrayBuffer;}interface Atomics{add(typedArray:Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array,index:number,value:number):number;and(typedArray:Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array,index:number,value:number):number;compareExchange(typedArray:Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array,index:number,expectedValue:number,replacementValue:number):number;exchange(typedArray:Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array,index:number,value:number):number;isLockFree(size:number):boolean;load(typedArray:Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array,index:number):number;or(typedArray:Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array,index:number,value:number):number;store(typedArray:Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array,index:number,value:number):number;sub(typedArray:Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array,index:number,value:number):number;wait(typedArray:Int32Array,index:number,value:number,timeout?:number):"ok"|"not-equal"|"timed-out";notify(typedArray:Int32Array,index:number,count:number):number;xor(typedArray:Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array,index:number,value:number):number;readonly[Symbol.toStringTag]:"Atomics";}declare var Atomics:Atomics;`
    }, {
        fileName: "lib.es2017.string.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface String{padStart(maxLength:number,fillString?:string):string;padEnd(maxLength:number,fillString?:string):string;}`
    }, {
        fileName: "lib.es2017.typedarrays.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface Int8ArrayConstructor{new():Int8Array;}interface Uint8ArrayConstructor{new():Uint8Array;}interface Uint8ClampedArrayConstructor{new():Uint8ClampedArray;}interface Int16ArrayConstructor{new():Int16Array;}interface Uint16ArrayConstructor{new():Uint16Array;}interface Int32ArrayConstructor{new():Int32Array;}interface Uint32ArrayConstructor{new():Uint32Array;}interface Float32ArrayConstructor{new():Float32Array;}interface Float64ArrayConstructor{new():Float64Array;}`
    }, {
        fileName: "lib.es2018.asyncgenerator.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2018.asynciterable" />\ninterface AsyncGenerator<T=unknown,TReturn=any,TNext=unknown>extends AsyncIterator<T,TReturn,TNext>{next(...args:[]|[TNext]):Promise<IteratorResult<T,TReturn>>;return(value:TReturn|PromiseLike<TReturn>):Promise<IteratorResult<T,TReturn>>;throw(e:any):Promise<IteratorResult<T,TReturn>>;[Symbol.asyncIterator]():AsyncGenerator<T,TReturn,TNext>;}interface AsyncGeneratorFunction{new(...args:any[]):AsyncGenerator;(...args:any[]):AsyncGenerator;readonly length:number;readonly name:string;readonly prototype:AsyncGenerator;}interface AsyncGeneratorFunctionConstructor{new(...args:string[]):AsyncGeneratorFunction;(...args:string[]):AsyncGeneratorFunction;readonly length:number;readonly name:string;readonly prototype:AsyncGeneratorFunction;}`
    }, {
        fileName: "lib.es2018.asynciterable.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015.symbol" />\n/// <reference lib="es2015.iterable" />\ninterface SymbolConstructor{readonly asyncIterator:symbol;}interface AsyncIterator<T,TReturn=any,TNext=undefined>{next(...args:[]|[TNext]):Promise<IteratorResult<T,TReturn>>;return?(value?:TReturn|PromiseLike<TReturn>):Promise<IteratorResult<T,TReturn>>;throw?(e?:any):Promise<IteratorResult<T,TReturn>>;}interface AsyncIterable<T>{[Symbol.asyncIterator]():AsyncIterator<T>;}interface AsyncIterableIterator<T>extends AsyncIterator<T>{[Symbol.asyncIterator]():AsyncIterableIterator<T>;}`
    }, {
        fileName: "lib.es2018.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2017" />\n/// <reference lib="es2018.asynciterable" />\n/// <reference lib="es2018.asyncgenerator" />\n/// <reference lib="es2018.promise" />\n/// <reference lib="es2018.regexp" />\n/// <reference lib="es2018.intl" />\n`
    }, {
        fileName: "lib.es2018.full.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2018" />\n/// <reference lib="dom" />\n/// <reference lib="webworker.importscripts" />\n/// <reference lib="scripthost" />\n/// <reference lib="dom.iterable" />`
    }, {
        fileName: "lib.es2018.intl.d.ts",
        text: `/// <reference no-default-lib="true"/>\ndeclare namespace Intl{type LDMLPluralRule="zero"|"one"|"two"|"few"|"many"|"other";type PluralRuleType="cardinal"|"ordinal";interface PluralRulesOptions{localeMatcher?:"lookup"|"best fit";type?:PluralRuleType;minimumIntegerDigits?:number;minimumFractionDigits?:number;maximumFractionDigits?:number;minimumSignificantDigits?:number;maximumSignificantDigits?:number;}interface ResolvedPluralRulesOptions{locale:string;pluralCategories:LDMLPluralRule[];type:PluralRuleType;minimumIntegerDigits:number;minimumFractionDigits:number;maximumFractionDigits:number;minimumSignificantDigits?:number;maximumSignificantDigits?:number;}interface PluralRules{resolvedOptions():ResolvedPluralRulesOptions;select(n:number):LDMLPluralRule;}const PluralRules:{new(locales?:string|string[],options?:PluralRulesOptions):PluralRules;(locales?:string|string[],options?:PluralRulesOptions):PluralRules;supportedLocalesOf(locales:string|string[],options?:PluralRulesOptions,):string[];};}`
    }, {
        fileName: "lib.es2018.promise.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface Promise<T>{finally(onfinally?:(()=>void)|undefined|null):Promise<T>}`
    }, {
        fileName: "lib.es2018.regexp.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface RegExpMatchArray{groups?:{[key:string]:string}}interface RegExpExecArray{groups?:{[key:string]:string}}interface RegExp{readonly dotAll:boolean;}`
    }, {
        fileName: "lib.es2019.array.d.ts",
        text: `/// <reference no-default-lib="true"/>\ntype FlatArray<Arr,Depth extends number>={"done":Arr,"recur":Arr extends ReadonlyArray<infer InnerArr>?FlatArray<InnerArr,[-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20][Depth]>:Arr}[Depth extends-1?"done":"recur"];interface ReadonlyArray<T>{flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This):U[]flat<A,D extends number=1>(this:A,depth?:D):FlatArray<A,D>[]}interface Array<T>{flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This):U[]flat<A,D extends number=1>(this:A,depth?:D):FlatArray<A,D>[]}`
    }, {
        fileName: "lib.es2019.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2018" />\n/// <reference lib="es2019.array" />\n/// <reference lib="es2019.object" />\n/// <reference lib="es2019.string" />\n/// <reference lib="es2019.symbol" />\n`
    }, {
        fileName: "lib.es2019.full.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2019" />\n/// <reference lib="dom" />\n/// <reference lib="webworker.importscripts" />\n/// <reference lib="scripthost" />\n/// <reference lib="dom.iterable" />\n`
    }, {
        fileName: "lib.es2019.object.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015.iterable" />\ninterface ObjectConstructor{fromEntries<T=any>(entries:Iterable<readonly[PropertyKey,T]>):{[k:string]:T};fromEntries(entries:Iterable<readonly any[]>):any;}`
    }, {
        fileName: "lib.es2019.string.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface String{trimEnd():string;trimStart():string;trimLeft():string;trimRight():string;}`
    }, {
        fileName: "lib.es2019.symbol.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface Symbol{readonly description:string|undefined;}`
    }, {
        fileName: "lib.es2020.bigint.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface BigInt{toString(radix?:number):string;toLocaleString():string;valueOf():bigint;readonly[Symbol.toStringTag]:"BigInt";}interface BigIntConstructor{(value?:any):bigint;readonly prototype:BigInt;asIntN(bits:number,int:bigint):bigint;asUintN(bits:number,int:bigint):bigint;}declare var BigInt:BigIntConstructor;interface BigInt64Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;entries():IterableIterator<[number,bigint]>;every(callbackfn:(value:bigint,index:number,array:BigInt64Array)=>boolean,thisArg?:any):boolean;fill(value:bigint,start?:number,end?:number):this;filter(callbackfn:(value:bigint,index:number,array:BigInt64Array)=>any,thisArg?:any):BigInt64Array;find(predicate:(value:bigint,index:number,array:BigInt64Array)=>boolean,thisArg?:any):bigint|undefined;findIndex(predicate:(value:bigint,index:number,array:BigInt64Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:bigint,index:number,array:BigInt64Array)=>void,thisArg?:any):void;includes(searchElement:bigint,fromIndex?:number):boolean;indexOf(searchElement:bigint,fromIndex?:number):number;join(separator?:string):string;keys():IterableIterator<number>;lastIndexOf(searchElement:bigint,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:bigint,index:number,array:BigInt64Array)=>bigint,thisArg?:any):BigInt64Array;reduce(callbackfn:(previousValue:bigint,currentValue:bigint,currentIndex:number,array:BigInt64Array)=>bigint):bigint;reduce<U>(callbackfn:(previousValue:U,currentValue:bigint,currentIndex:number,array:BigInt64Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:bigint,currentValue:bigint,currentIndex:number,array:BigInt64Array)=>bigint):bigint;reduceRight<U>(callbackfn:(previousValue:U,currentValue:bigint,currentIndex:number,array:BigInt64Array)=>U,initialValue:U):U;reverse():this;set(array:ArrayLike<bigint>,offset?:number):void;slice(start?:number,end?:number):BigInt64Array;some(callbackfn:(value:bigint,index:number,array:BigInt64Array)=>boolean,thisArg?:any):boolean;sort(compareFn?:(a:bigint,b:bigint)=>number|bigint):this;subarray(begin?:number,end?:number):BigInt64Array;toLocaleString():string;toString():string;valueOf():BigInt64Array;values():IterableIterator<bigint>;[Symbol.iterator]():IterableIterator<bigint>;readonly[Symbol.toStringTag]:"BigInt64Array";[index:number]:bigint;}interface BigInt64ArrayConstructor{readonly prototype:BigInt64Array;new(length?:number):BigInt64Array;new(array:Iterable<bigint>):BigInt64Array;new(buffer:ArrayBufferLike,byteOffset?:number,length?:number):BigInt64Array;readonly BYTES_PER_ELEMENT:number;of(...items:bigint[]):BigInt64Array;from(arrayLike:ArrayLike<bigint>):BigInt64Array;from<U>(arrayLike:ArrayLike<U>,mapfn:(v:U,k:number)=>bigint,thisArg?:any):BigInt64Array;}declare var BigInt64Array:BigInt64ArrayConstructor;interface BigUint64Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;entries():IterableIterator<[number,bigint]>;every(callbackfn:(value:bigint,index:number,array:BigUint64Array)=>boolean,thisArg?:any):boolean;fill(value:bigint,start?:number,end?:number):this;filter(callbackfn:(value:bigint,index:number,array:BigUint64Array)=>any,thisArg?:any):BigUint64Array;find(predicate:(value:bigint,index:number,array:BigUint64Array)=>boolean,thisArg?:any):bigint|undefined;findIndex(predicate:(value:bigint,index:number,array:BigUint64Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:bigint,index:number,array:BigUint64Array)=>void,thisArg?:any):void;includes(searchElement:bigint,fromIndex?:number):boolean;indexOf(searchElement:bigint,fromIndex?:number):number;join(separator?:string):string;keys():IterableIterator<number>;lastIndexOf(searchElement:bigint,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:bigint,index:number,array:BigUint64Array)=>bigint,thisArg?:any):BigUint64Array;reduce(callbackfn:(previousValue:bigint,currentValue:bigint,currentIndex:number,array:BigUint64Array)=>bigint):bigint;reduce<U>(callbackfn:(previousValue:U,currentValue:bigint,currentIndex:number,array:BigUint64Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:bigint,currentValue:bigint,currentIndex:number,array:BigUint64Array)=>bigint):bigint;reduceRight<U>(callbackfn:(previousValue:U,currentValue:bigint,currentIndex:number,array:BigUint64Array)=>U,initialValue:U):U;reverse():this;set(array:ArrayLike<bigint>,offset?:number):void;slice(start?:number,end?:number):BigUint64Array;some(callbackfn:(value:bigint,index:number,array:BigUint64Array)=>boolean,thisArg?:any):boolean;sort(compareFn?:(a:bigint,b:bigint)=>number|bigint):this;subarray(begin?:number,end?:number):BigUint64Array;toLocaleString():string;toString():string;valueOf():BigUint64Array;values():IterableIterator<bigint>;[Symbol.iterator]():IterableIterator<bigint>;readonly[Symbol.toStringTag]:"BigUint64Array";[index:number]:bigint;}interface BigUint64ArrayConstructor{readonly prototype:BigUint64Array;new(length?:number):BigUint64Array;new(array:Iterable<bigint>):BigUint64Array;new(buffer:ArrayBufferLike,byteOffset?:number,length?:number):BigUint64Array;readonly BYTES_PER_ELEMENT:number;of(...items:bigint[]):BigUint64Array;from(arrayLike:ArrayLike<bigint>):BigUint64Array;from<U>(arrayLike:ArrayLike<U>,mapfn:(v:U,k:number)=>bigint,thisArg?:any):BigUint64Array;}declare var BigUint64Array:BigUint64ArrayConstructor;interface DataView{getBigInt64(byteOffset:number,littleEndian?:boolean):bigint;getBigUint64(byteOffset:number,littleEndian?:boolean):bigint;setBigInt64(byteOffset:number,value:bigint,littleEndian?:boolean):void;setBigUint64(byteOffset:number,value:bigint,littleEndian?:boolean):void;}`
    }, {
        fileName: "lib.es2020.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2019" />\n/// <reference lib="es2020.bigint" />\n/// <reference lib="es2020.promise" />\n/// <reference lib="es2020.string" />\n/// <reference lib="es2020.symbol.wellknown" />\n`
    }, {
        fileName: "lib.es2020.full.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2020" />\n/// <reference lib="dom" />\n/// <reference lib="webworker.importscripts" />\n/// <reference lib="scripthost" />\n/// <reference lib="dom.iterable" />\n`
    }, {
        fileName: "lib.es2020.promise.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface PromiseFulfilledResult<T>{status:"fulfilled";value:T;}interface PromiseRejectedResult{status:"rejected";reason:any;}type PromiseSettledResult<T>=PromiseFulfilledResult<T>|PromiseRejectedResult;interface PromiseConstructor{allSettled<T extends readonly unknown[]|readonly[unknown]>(values:T):Promise<{-readonly[P in keyof T]:PromiseSettledResult<T[P]extends PromiseLike<infer U>?U:T[P]>}>;allSettled<T>(values:Iterable<T>):Promise<PromiseSettledResult<T extends PromiseLike<infer U>?U:T>[]>;}`
    }, {
        fileName: "lib.es2020.string.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015.iterable" />\ninterface String{matchAll(regexp:RegExp):IterableIterator<RegExpMatchArray>;}`
    }, {
        fileName: "lib.es2020.symbol.wellknown.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015.iterable" />\n/// <reference lib="es2015.symbol" />\ninterface SymbolConstructor{readonly matchAll:symbol;}interface RegExp{[Symbol.matchAll](str:string):IterableIterator<RegExpMatchArray>;}`
    }, {
        fileName: "lib.es5.d.ts",
        text: `/// <reference no-default-lib="true"/>\ndeclare var NaN:number;declare var Infinity:number;declare function eval(x:string):any;declare function parseInt(s:string,radix?:number):number;declare function parseFloat(string:string):number;declare function isNaN(number:number):boolean;declare function isFinite(number:number):boolean;declare function decodeURI(encodedURI:string):string;declare function decodeURIComponent(encodedURIComponent:string):string;declare function encodeURI(uri:string):string;declare function encodeURIComponent(uriComponent:string|number|boolean):string;declare function escape(string:string):string;declare function unescape(string:string):string;interface Symbol{toString():string;valueOf():symbol;}declare type PropertyKey=string|number|symbol;interface PropertyDescriptor{configurable?:boolean;enumerable?:boolean;value?:any;writable?:boolean;get?():any;set?(v:any):void;}interface PropertyDescriptorMap{[s:string]:PropertyDescriptor;}interface Object{constructor:Function;toString():string;toLocaleString():string;valueOf():Object;hasOwnProperty(v:PropertyKey):boolean;isPrototypeOf(v:Object):boolean;propertyIsEnumerable(v:PropertyKey):boolean;}interface ObjectConstructor{new(value?:any):Object;():any;(value:any):any;readonly prototype:Object;getPrototypeOf(o:any):any;getOwnPropertyDescriptor(o:any,p:PropertyKey):PropertyDescriptor|undefined;getOwnPropertyNames(o:any):string[];create(o:object|null):any;create(o:object|null,properties:PropertyDescriptorMap&ThisType<any>):any;defineProperty(o:any,p:PropertyKey,attributes:PropertyDescriptor&ThisType<any>):any;defineProperties(o:any,properties:PropertyDescriptorMap&ThisType<any>):any;seal<T>(o:T):T;freeze<T>(a:T[]):readonly T[];freeze<T extends Function>(f:T):T;freeze<T>(o:T):Readonly<T>;preventExtensions<T>(o:T):T;isSealed(o:any):boolean;isFrozen(o:any):boolean;isExtensible(o:any):boolean;keys(o:object):string[];}declare var Object:ObjectConstructor;interface Function{apply(this:Function,thisArg:any,argArray?:any):any;call(this:Function,thisArg:any,...argArray:any[]):any;bind(this:Function,thisArg:any,...argArray:any[]):any;toString():string;prototype:any;readonly length:number;arguments:any;caller:Function;}interface FunctionConstructor{new(...args:string[]):Function;(...args:string[]):Function;readonly prototype:Function;}declare var Function:FunctionConstructor;type ThisParameterType<T>=T extends(this:infer U,...args:any[])=>any?U:unknown;type OmitThisParameter<T>=unknown extends ThisParameterType<T>?T:T extends(...args:infer A)=>infer R?(...args:A)=>R:T;interface CallableFunction extends Function{apply<T,R>(this:(this:T)=>R,thisArg:T):R;apply<T,A extends any[],R>(this:(this:T,...args:A)=>R,thisArg:T,args:A):R;call<T,A extends any[],R>(this:(this:T,...args:A)=>R,thisArg:T,...args:A):R;bind<T>(this:T,thisArg:ThisParameterType<T>):OmitThisParameter<T>;bind<T,A0,A extends any[],R>(this:(this:T,arg0:A0,...args:A)=>R,thisArg:T,arg0:A0):(...args:A)=>R;bind<T,A0,A1,A extends any[],R>(this:(this:T,arg0:A0,arg1:A1,...args:A)=>R,thisArg:T,arg0:A0,arg1:A1):(...args:A)=>R;bind<T,A0,A1,A2,A extends any[],R>(this:(this:T,arg0:A0,arg1:A1,arg2:A2,...args:A)=>R,thisArg:T,arg0:A0,arg1:A1,arg2:A2):(...args:A)=>R;bind<T,A0,A1,A2,A3,A extends any[],R>(this:(this:T,arg0:A0,arg1:A1,arg2:A2,arg3:A3,...args:A)=>R,thisArg:T,arg0:A0,arg1:A1,arg2:A2,arg3:A3):(...args:A)=>R;bind<T,AX,R>(this:(this:T,...args:AX[])=>R,thisArg:T,...args:AX[]):(...args:AX[])=>R;}interface NewableFunction extends Function{apply<T>(this:new()=>T,thisArg:T):void;apply<T,A extends any[]>(this:new(...args:A)=>T,thisArg:T,args:A):void;call<T,A extends any[]>(this:new(...args:A)=>T,thisArg:T,...args:A):void;bind<T>(this:T,thisArg:any):T;bind<A0,A extends any[],R>(this:new(arg0:A0,...args:A)=>R,thisArg:any,arg0:A0):new(...args:A)=>R;bind<A0,A1,A extends any[],R>(this:new(arg0:A0,arg1:A1,...args:A)=>R,thisArg:any,arg0:A0,arg1:A1):new(...args:A)=>R;bind<A0,A1,A2,A extends any[],R>(this:new(arg0:A0,arg1:A1,arg2:A2,...args:A)=>R,thisArg:any,arg0:A0,arg1:A1,arg2:A2):new(...args:A)=>R;bind<A0,A1,A2,A3,A extends any[],R>(this:new(arg0:A0,arg1:A1,arg2:A2,arg3:A3,...args:A)=>R,thisArg:any,arg0:A0,arg1:A1,arg2:A2,arg3:A3):new(...args:A)=>R;bind<AX,R>(this:new(...args:AX[])=>R,thisArg:any,...args:AX[]):new(...args:AX[])=>R;}interface IArguments{[index:number]:any;length:number;callee:Function;}interface String{toString():string;charAt(pos:number):string;charCodeAt(index:number):number;concat(...strings:string[]):string;indexOf(searchString:string,position?:number):number;lastIndexOf(searchString:string,position?:number):number;localeCompare(that:string):number;match(regexp:string|RegExp):RegExpMatchArray|null;replace(searchValue:string|RegExp,replaceValue:string):string;replace(searchValue:string|RegExp,replacer:(substring:string,...args:any[])=>string):string;search(regexp:string|RegExp):number;slice(start?:number,end?:number):string;split(separator:string|RegExp,limit?:number):string[];substring(start:number,end?:number):string;toLowerCase():string;toLocaleLowerCase(locales?:string|string[]):string;toUpperCase():string;toLocaleUpperCase(locales?:string|string[]):string;trim():string;readonly length:number;substr(from:number,length?:number):string;valueOf():string;readonly[index:number]:string;}interface StringConstructor{new(value?:any):String;(value?:any):string;readonly prototype:String;fromCharCode(...codes:number[]):string;}declare var String:StringConstructor;interface Boolean{valueOf():boolean;}interface BooleanConstructor{new(value?:any):Boolean;<T>(value?:T):boolean;readonly prototype:Boolean;}declare var Boolean:BooleanConstructor;interface Number{toString(radix?:number):string;toFixed(fractionDigits?:number):string;toExponential(fractionDigits?:number):string;toPrecision(precision?:number):string;valueOf():number;}interface NumberConstructor{new(value?:any):Number;(value?:any):number;readonly prototype:Number;readonly MAX_VALUE:number;readonly MIN_VALUE:number;readonly NaN:number;readonly NEGATIVE_INFINITY:number;readonly POSITIVE_INFINITY:number;}declare var Number:NumberConstructor;interface TemplateStringsArray extends ReadonlyArray<string>{readonly raw:readonly string[];}interface ImportMeta{}interface Math{readonly E:number;readonly LN10:number;readonly LN2:number;readonly LOG2E:number;readonly LOG10E:number;readonly PI:number;readonly SQRT1_2:number;readonly SQRT2:number;abs(x:number):number;acos(x:number):number;asin(x:number):number;atan(x:number):number;atan2(y:number,x:number):number;ceil(x:number):number;cos(x:number):number;exp(x:number):number;floor(x:number):number;log(x:number):number;max(...values:number[]):number;min(...values:number[]):number;pow(x:number,y:number):number;random():number;round(x:number):number;sin(x:number):number;sqrt(x:number):number;tan(x:number):number;}declare var Math:Math;interface Date{toString():string;toDateString():string;toTimeString():string;toLocaleString():string;toLocaleDateString():string;toLocaleTimeString():string;valueOf():number;getTime():number;getFullYear():number;getUTCFullYear():number;getMonth():number;getUTCMonth():number;getDate():number;getUTCDate():number;getDay():number;getUTCDay():number;getHours():number;getUTCHours():number;getMinutes():number;getUTCMinutes():number;getSeconds():number;getUTCSeconds():number;getMilliseconds():number;getUTCMilliseconds():number;getTimezoneOffset():number;setTime(time:number):number;setMilliseconds(ms:number):number;setUTCMilliseconds(ms:number):number;setSeconds(sec:number,ms?:number):number;setUTCSeconds(sec:number,ms?:number):number;setMinutes(min:number,sec?:number,ms?:number):number;setUTCMinutes(min:number,sec?:number,ms?:number):number;setHours(hours:number,min?:number,sec?:number,ms?:number):number;setUTCHours(hours:number,min?:number,sec?:number,ms?:number):number;setDate(date:number):number;setUTCDate(date:number):number;setMonth(month:number,date?:number):number;setUTCMonth(month:number,date?:number):number;setFullYear(year:number,month?:number,date?:number):number;setUTCFullYear(year:number,month?:number,date?:number):number;toUTCString():string;toISOString():string;toJSON(key?:any):string;}interface DateConstructor{new():Date;new(value:number|string):Date;new(year:number,month:number,date?:number,hours?:number,minutes?:number,seconds?:number,ms?:number):Date;():string;readonly prototype:Date;parse(s:string):number;UTC(year:number,month:number,date?:number,hours?:number,minutes?:number,seconds?:number,ms?:number):number;now():number;}declare var Date:DateConstructor;interface RegExpMatchArray extends Array<string>{index?:number;input?:string;}interface RegExpExecArray extends Array<string>{index:number;input:string;}interface RegExp{exec(string:string):RegExpExecArray|null;test(string:string):boolean;readonly source:string;readonly global:boolean;readonly ignoreCase:boolean;readonly multiline:boolean;lastIndex:number;compile():this;}interface RegExpConstructor{new(pattern:RegExp|string):RegExp;new(pattern:string,flags?:string):RegExp;(pattern:RegExp|string):RegExp;(pattern:string,flags?:string):RegExp;readonly prototype:RegExp;$1:string;$2:string;$3:string;$4:string;$5:string;$6:string;$7:string;$8:string;$9:string;lastMatch:string;}declare var RegExp:RegExpConstructor;interface Error{name:string;message:string;stack?:string;}interface ErrorConstructor{new(message?:string):Error;(message?:string):Error;readonly prototype:Error;}declare var Error:ErrorConstructor;interface EvalError extends Error{}interface EvalErrorConstructor extends ErrorConstructor{new(message?:string):EvalError;(message?:string):EvalError;readonly prototype:EvalError;}declare var EvalError:EvalErrorConstructor;interface RangeError extends Error{}interface RangeErrorConstructor extends ErrorConstructor{new(message?:string):RangeError;(message?:string):RangeError;readonly prototype:RangeError;}declare var RangeError:RangeErrorConstructor;interface ReferenceError extends Error{}interface ReferenceErrorConstructor extends ErrorConstructor{new(message?:string):ReferenceError;(message?:string):ReferenceError;readonly prototype:ReferenceError;}declare var ReferenceError:ReferenceErrorConstructor;interface SyntaxError extends Error{}interface SyntaxErrorConstructor extends ErrorConstructor{new(message?:string):SyntaxError;(message?:string):SyntaxError;readonly prototype:SyntaxError;}declare var SyntaxError:SyntaxErrorConstructor;interface TypeError extends Error{}interface TypeErrorConstructor extends ErrorConstructor{new(message?:string):TypeError;(message?:string):TypeError;readonly prototype:TypeError;}declare var TypeError:TypeErrorConstructor;interface URIError extends Error{}interface URIErrorConstructor extends ErrorConstructor{new(message?:string):URIError;(message?:string):URIError;readonly prototype:URIError;}declare var URIError:URIErrorConstructor;interface JSON{parse(text:string,reviver?:(this:any,key:string,value:any)=>any):any;stringify(value:any,replacer?:(this:any,key:string,value:any)=>any,space?:string|number):string;stringify(value:any,replacer?:(number|string)[]|null,space?:string|number):string;}declare var JSON:JSON;interface ReadonlyArray<T>{readonly length:number;toString():string;toLocaleString():string;concat(...items:ConcatArray<T>[]):T[];concat(...items:(T|ConcatArray<T>)[]):T[];join(separator?:string):string;slice(start?:number,end?:number):T[];indexOf(searchElement:T,fromIndex?:number):number;lastIndexOf(searchElement:T,fromIndex?:number):number;every(callbackfn:(value:T,index:number,array:readonly T[])=>unknown,thisArg?:any):boolean;some(callbackfn:(value:T,index:number,array:readonly T[])=>unknown,thisArg?:any):boolean;forEach(callbackfn:(value:T,index:number,array:readonly T[])=>void,thisArg?:any):void;map<U>(callbackfn:(value:T,index:number,array:readonly T[])=>U,thisArg?:any):U[];filter<S extends T>(callbackfn:(value:T,index:number,array:readonly T[])=>value is S,thisArg?:any):S[];filter(callbackfn:(value:T,index:number,array:readonly T[])=>unknown,thisArg?:any):T[];reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:readonly T[])=>T):T;reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:readonly T[])=>T,initialValue:T):T;reduce<U>(callbackfn:(previousValue:U,currentValue:T,currentIndex:number,array:readonly T[])=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:readonly T[])=>T):T;reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:readonly T[])=>T,initialValue:T):T;reduceRight<U>(callbackfn:(previousValue:U,currentValue:T,currentIndex:number,array:readonly T[])=>U,initialValue:U):U;readonly[n:number]:T;}interface ConcatArray<T>{readonly length:number;readonly[n:number]:T;join(separator?:string):string;slice(start?:number,end?:number):T[];}interface Array<T>{length:number;toString():string;toLocaleString():string;pop():T|undefined;push(...items:T[]):number;concat(...items:ConcatArray<T>[]):T[];concat(...items:(T|ConcatArray<T>)[]):T[];join(separator?:string):string;reverse():T[];shift():T|undefined;slice(start?:number,end?:number):T[];sort(compareFn?:(a:T,b:T)=>number):this;splice(start:number,deleteCount?:number):T[];splice(start:number,deleteCount:number,...items:T[]):T[];unshift(...items:T[]):number;indexOf(searchElement:T,fromIndex?:number):number;lastIndexOf(searchElement:T,fromIndex?:number):number;every(callbackfn:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;some(callbackfn:(value:T,index:number,array:T[])=>unknown,thisArg?:any):boolean;forEach(callbackfn:(value:T,index:number,array:T[])=>void,thisArg?:any):void;map<U>(callbackfn:(value:T,index:number,array:T[])=>U,thisArg?:any):U[];filter<S extends T>(callbackfn:(value:T,index:number,array:T[])=>value is S,thisArg?:any):S[];filter(callbackfn:(value:T,index:number,array:T[])=>unknown,thisArg?:any):T[];reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;reduce(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T,initialValue:T):T;reduce<U>(callbackfn:(previousValue:U,currentValue:T,currentIndex:number,array:T[])=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T):T;reduceRight(callbackfn:(previousValue:T,currentValue:T,currentIndex:number,array:T[])=>T,initialValue:T):T;reduceRight<U>(callbackfn:(previousValue:U,currentValue:T,currentIndex:number,array:T[])=>U,initialValue:U):U;[n:number]:T;}interface ArrayConstructor{new(arrayLength?:number):any[];new<T>(arrayLength:number):T[];new<T>(...items:T[]):T[];(arrayLength?:number):any[];<T>(arrayLength:number):T[];<T>(...items:T[]):T[];isArray(arg:any):arg is any[];readonly prototype:any[];}declare var Array:ArrayConstructor;interface TypedPropertyDescriptor<T>{enumerable?:boolean;configurable?:boolean;writable?:boolean;value?:T;get?:()=>T;set?:(value:T)=>void;}declare type ClassDecorator=<TFunction extends Function>(target:TFunction)=>TFunction|void;declare type PropertyDecorator=(target:Object,propertyKey:string|symbol)=>void;declare type MethodDecorator=<T>(target:Object,propertyKey:string|symbol,descriptor:TypedPropertyDescriptor<T>)=>TypedPropertyDescriptor<T>|void;declare type ParameterDecorator=(target:Object,propertyKey:string|symbol,parameterIndex:number)=>void;declare type PromiseConstructorLike=new<T>(executor:(resolve:(value?:T|PromiseLike<T>)=>void,reject:(reason?:any)=>void)=>void)=>PromiseLike<T>;interface PromiseLike<T>{then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):PromiseLike<TResult1|TResult2>;}interface Promise<T>{then<TResult1=T,TResult2=never>(onfulfilled?:((value:T)=>TResult1|PromiseLike<TResult1>)|undefined|null,onrejected?:((reason:any)=>TResult2|PromiseLike<TResult2>)|undefined|null):Promise<TResult1|TResult2>;catch<TResult=never>(onrejected?:((reason:any)=>TResult|PromiseLike<TResult>)|undefined|null):Promise<T|TResult>;}interface ArrayLike<T>{readonly length:number;readonly[n:number]:T;}type Partial<T>={[P in keyof T]?:T[P];};type Required<T>={[P in keyof T]-?:T[P];};type Readonly<T>={readonly[P in keyof T]:T[P];};type Pick<T,K extends keyof T>={[P in K]:T[P];};type Record<K extends keyof any,T>={[P in K]:T;};type Exclude<T,U>=T extends U?never:T;type Extract<T,U>=T extends U?T:never;type Omit<T,K extends keyof any>=Pick<T,Exclude<keyof T,K>>;type NonNullable<T>=T extends null|undefined?never:T;type Parameters<T extends(...args:any)=>any>=T extends(...args:infer P)=>any?P:never;type ConstructorParameters<T extends new(...args:any)=>any>=T extends new(...args:infer P)=>any?P:never;type ReturnType<T extends(...args:any)=>any>=T extends(...args:any)=>infer R?R:any;type InstanceType<T extends new(...args:any)=>any>=T extends new(...args:any)=>infer R?R:any;interface ThisType<T>{}interface ArrayBuffer{readonly byteLength:number;slice(begin:number,end?:number):ArrayBuffer;}interface ArrayBufferTypes{ArrayBuffer:ArrayBuffer;}type ArrayBufferLike=ArrayBufferTypes[keyof ArrayBufferTypes];interface ArrayBufferConstructor{readonly prototype:ArrayBuffer;new(byteLength:number):ArrayBuffer;isView(arg:any):arg is ArrayBufferView;}declare var ArrayBuffer:ArrayBufferConstructor;interface ArrayBufferView{buffer:ArrayBufferLike;byteLength:number;byteOffset:number;}interface DataView{readonly buffer:ArrayBuffer;readonly byteLength:number;readonly byteOffset:number;getFloat32(byteOffset:number,littleEndian?:boolean):number;getFloat64(byteOffset:number,littleEndian?:boolean):number;getInt8(byteOffset:number):number;getInt16(byteOffset:number,littleEndian?:boolean):number;getInt32(byteOffset:number,littleEndian?:boolean):number;getUint8(byteOffset:number):number;getUint16(byteOffset:number,littleEndian?:boolean):number;getUint32(byteOffset:number,littleEndian?:boolean):number;setFloat32(byteOffset:number,value:number,littleEndian?:boolean):void;setFloat64(byteOffset:number,value:number,littleEndian?:boolean):void;setInt8(byteOffset:number,value:number):void;setInt16(byteOffset:number,value:number,littleEndian?:boolean):void;setInt32(byteOffset:number,value:number,littleEndian?:boolean):void;setUint8(byteOffset:number,value:number):void;setUint16(byteOffset:number,value:number,littleEndian?:boolean):void;setUint32(byteOffset:number,value:number,littleEndian?:boolean):void;}interface DataViewConstructor{new(buffer:ArrayBufferLike,byteOffset?:number,byteLength?:number):DataView;}declare var DataView:DataViewConstructor;interface Int8Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;every(callbackfn:(value:number,index:number,array:Int8Array)=>unknown,thisArg?:any):boolean;fill(value:number,start?:number,end?:number):this;filter(callbackfn:(value:number,index:number,array:Int8Array)=>any,thisArg?:any):Int8Array;find(predicate:(value:number,index:number,obj:Int8Array)=>boolean,thisArg?:any):number|undefined;findIndex(predicate:(value:number,index:number,obj:Int8Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:number,index:number,array:Int8Array)=>void,thisArg?:any):void;indexOf(searchElement:number,fromIndex?:number):number;join(separator?:string):string;lastIndexOf(searchElement:number,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:number,index:number,array:Int8Array)=>number,thisArg?:any):Int8Array;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int8Array)=>number):number;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int8Array)=>number,initialValue:number):number;reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int8Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int8Array)=>number):number;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int8Array)=>number,initialValue:number):number;reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int8Array)=>U,initialValue:U):U;reverse():Int8Array;set(array:ArrayLike<number>,offset?:number):void;slice(start?:number,end?:number):Int8Array;some(callbackfn:(value:number,index:number,array:Int8Array)=>unknown,thisArg?:any):boolean;sort(compareFn?:(a:number,b:number)=>number):this;subarray(begin?:number,end?:number):Int8Array;toLocaleString():string;toString():string;valueOf():Int8Array;[index:number]:number;}interface Int8ArrayConstructor{readonly prototype:Int8Array;new(length:number):Int8Array;new(arrayOrArrayBuffer:ArrayLike<number>|ArrayBufferLike):Int8Array;new(buffer:ArrayBufferLike,byteOffset:number,length?:number):Int8Array;readonly BYTES_PER_ELEMENT:number;of(...items:number[]):Int8Array;from(arrayLike:ArrayLike<number>):Int8Array;from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any):Int8Array;}declare var Int8Array:Int8ArrayConstructor;interface Uint8Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;every(callbackfn:(value:number,index:number,array:Uint8Array)=>unknown,thisArg?:any):boolean;fill(value:number,start?:number,end?:number):this;filter(callbackfn:(value:number,index:number,array:Uint8Array)=>any,thisArg?:any):Uint8Array;find(predicate:(value:number,index:number,obj:Uint8Array)=>boolean,thisArg?:any):number|undefined;findIndex(predicate:(value:number,index:number,obj:Uint8Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:number,index:number,array:Uint8Array)=>void,thisArg?:any):void;indexOf(searchElement:number,fromIndex?:number):number;join(separator?:string):string;lastIndexOf(searchElement:number,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:number,index:number,array:Uint8Array)=>number,thisArg?:any):Uint8Array;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8Array)=>number):number;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8Array)=>number,initialValue:number):number;reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint8Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8Array)=>number):number;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8Array)=>number,initialValue:number):number;reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint8Array)=>U,initialValue:U):U;reverse():Uint8Array;set(array:ArrayLike<number>,offset?:number):void;slice(start?:number,end?:number):Uint8Array;some(callbackfn:(value:number,index:number,array:Uint8Array)=>unknown,thisArg?:any):boolean;sort(compareFn?:(a:number,b:number)=>number):this;subarray(begin?:number,end?:number):Uint8Array;toLocaleString():string;toString():string;valueOf():Uint8Array;[index:number]:number;}interface Uint8ArrayConstructor{readonly prototype:Uint8Array;new(length:number):Uint8Array;new(arrayOrArrayBuffer:ArrayLike<number>|ArrayBufferLike):Uint8Array;new(buffer:ArrayBufferLike,byteOffset:number,length?:number):Uint8Array;readonly BYTES_PER_ELEMENT:number;of(...items:number[]):Uint8Array;from(arrayLike:ArrayLike<number>):Uint8Array;from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any):Uint8Array;}declare var Uint8Array:Uint8ArrayConstructor;interface Uint8ClampedArray{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;every(callbackfn:(value:number,index:number,array:Uint8ClampedArray)=>unknown,thisArg?:any):boolean;fill(value:number,start?:number,end?:number):this;filter(callbackfn:(value:number,index:number,array:Uint8ClampedArray)=>any,thisArg?:any):Uint8ClampedArray;find(predicate:(value:number,index:number,obj:Uint8ClampedArray)=>boolean,thisArg?:any):number|undefined;findIndex(predicate:(value:number,index:number,obj:Uint8ClampedArray)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:number,index:number,array:Uint8ClampedArray)=>void,thisArg?:any):void;indexOf(searchElement:number,fromIndex?:number):number;join(separator?:string):string;lastIndexOf(searchElement:number,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:number,index:number,array:Uint8ClampedArray)=>number,thisArg?:any):Uint8ClampedArray;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8ClampedArray)=>number):number;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8ClampedArray)=>number,initialValue:number):number;reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint8ClampedArray)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8ClampedArray)=>number):number;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint8ClampedArray)=>number,initialValue:number):number;reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint8ClampedArray)=>U,initialValue:U):U;reverse():Uint8ClampedArray;set(array:ArrayLike<number>,offset?:number):void;slice(start?:number,end?:number):Uint8ClampedArray;some(callbackfn:(value:number,index:number,array:Uint8ClampedArray)=>unknown,thisArg?:any):boolean;sort(compareFn?:(a:number,b:number)=>number):this;subarray(begin?:number,end?:number):Uint8ClampedArray;toLocaleString():string;toString():string;valueOf():Uint8ClampedArray;[index:number]:number;}interface Uint8ClampedArrayConstructor{readonly prototype:Uint8ClampedArray;new(length:number):Uint8ClampedArray;new(arrayOrArrayBuffer:ArrayLike<number>|ArrayBufferLike):Uint8ClampedArray;new(buffer:ArrayBufferLike,byteOffset:number,length?:number):Uint8ClampedArray;readonly BYTES_PER_ELEMENT:number;of(...items:number[]):Uint8ClampedArray;from(arrayLike:ArrayLike<number>):Uint8ClampedArray;from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any):Uint8ClampedArray;}declare var Uint8ClampedArray:Uint8ClampedArrayConstructor;interface Int16Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;every(callbackfn:(value:number,index:number,array:Int16Array)=>unknown,thisArg?:any):boolean;fill(value:number,start?:number,end?:number):this;filter(callbackfn:(value:number,index:number,array:Int16Array)=>any,thisArg?:any):Int16Array;find(predicate:(value:number,index:number,obj:Int16Array)=>boolean,thisArg?:any):number|undefined;findIndex(predicate:(value:number,index:number,obj:Int16Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:number,index:number,array:Int16Array)=>void,thisArg?:any):void;indexOf(searchElement:number,fromIndex?:number):number;join(separator?:string):string;lastIndexOf(searchElement:number,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:number,index:number,array:Int16Array)=>number,thisArg?:any):Int16Array;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int16Array)=>number):number;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int16Array)=>number,initialValue:number):number;reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int16Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int16Array)=>number):number;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int16Array)=>number,initialValue:number):number;reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int16Array)=>U,initialValue:U):U;reverse():Int16Array;set(array:ArrayLike<number>,offset?:number):void;slice(start?:number,end?:number):Int16Array;some(callbackfn:(value:number,index:number,array:Int16Array)=>unknown,thisArg?:any):boolean;sort(compareFn?:(a:number,b:number)=>number):this;subarray(begin?:number,end?:number):Int16Array;toLocaleString():string;toString():string;valueOf():Int16Array;[index:number]:number;}interface Int16ArrayConstructor{readonly prototype:Int16Array;new(length:number):Int16Array;new(arrayOrArrayBuffer:ArrayLike<number>|ArrayBufferLike):Int16Array;new(buffer:ArrayBufferLike,byteOffset:number,length?:number):Int16Array;readonly BYTES_PER_ELEMENT:number;of(...items:number[]):Int16Array;from(arrayLike:ArrayLike<number>):Int16Array;from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any):Int16Array;}declare var Int16Array:Int16ArrayConstructor;interface Uint16Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;every(callbackfn:(value:number,index:number,array:Uint16Array)=>unknown,thisArg?:any):boolean;fill(value:number,start?:number,end?:number):this;filter(callbackfn:(value:number,index:number,array:Uint16Array)=>any,thisArg?:any):Uint16Array;find(predicate:(value:number,index:number,obj:Uint16Array)=>boolean,thisArg?:any):number|undefined;findIndex(predicate:(value:number,index:number,obj:Uint16Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:number,index:number,array:Uint16Array)=>void,thisArg?:any):void;indexOf(searchElement:number,fromIndex?:number):number;join(separator?:string):string;lastIndexOf(searchElement:number,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:number,index:number,array:Uint16Array)=>number,thisArg?:any):Uint16Array;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint16Array)=>number):number;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint16Array)=>number,initialValue:number):number;reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint16Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint16Array)=>number):number;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint16Array)=>number,initialValue:number):number;reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint16Array)=>U,initialValue:U):U;reverse():Uint16Array;set(array:ArrayLike<number>,offset?:number):void;slice(start?:number,end?:number):Uint16Array;some(callbackfn:(value:number,index:number,array:Uint16Array)=>unknown,thisArg?:any):boolean;sort(compareFn?:(a:number,b:number)=>number):this;subarray(begin?:number,end?:number):Uint16Array;toLocaleString():string;toString():string;valueOf():Uint16Array;[index:number]:number;}interface Uint16ArrayConstructor{readonly prototype:Uint16Array;new(length:number):Uint16Array;new(arrayOrArrayBuffer:ArrayLike<number>|ArrayBufferLike):Uint16Array;new(buffer:ArrayBufferLike,byteOffset:number,length?:number):Uint16Array;readonly BYTES_PER_ELEMENT:number;of(...items:number[]):Uint16Array;from(arrayLike:ArrayLike<number>):Uint16Array;from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any):Uint16Array;}declare var Uint16Array:Uint16ArrayConstructor;interface Int32Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;every(callbackfn:(value:number,index:number,array:Int32Array)=>unknown,thisArg?:any):boolean;fill(value:number,start?:number,end?:number):this;filter(callbackfn:(value:number,index:number,array:Int32Array)=>any,thisArg?:any):Int32Array;find(predicate:(value:number,index:number,obj:Int32Array)=>boolean,thisArg?:any):number|undefined;findIndex(predicate:(value:number,index:number,obj:Int32Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:number,index:number,array:Int32Array)=>void,thisArg?:any):void;indexOf(searchElement:number,fromIndex?:number):number;join(separator?:string):string;lastIndexOf(searchElement:number,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:number,index:number,array:Int32Array)=>number,thisArg?:any):Int32Array;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int32Array)=>number):number;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int32Array)=>number,initialValue:number):number;reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int32Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int32Array)=>number):number;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Int32Array)=>number,initialValue:number):number;reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Int32Array)=>U,initialValue:U):U;reverse():Int32Array;set(array:ArrayLike<number>,offset?:number):void;slice(start?:number,end?:number):Int32Array;some(callbackfn:(value:number,index:number,array:Int32Array)=>unknown,thisArg?:any):boolean;sort(compareFn?:(a:number,b:number)=>number):this;subarray(begin?:number,end?:number):Int32Array;toLocaleString():string;toString():string;valueOf():Int32Array;[index:number]:number;}interface Int32ArrayConstructor{readonly prototype:Int32Array;new(length:number):Int32Array;new(arrayOrArrayBuffer:ArrayLike<number>|ArrayBufferLike):Int32Array;new(buffer:ArrayBufferLike,byteOffset:number,length?:number):Int32Array;readonly BYTES_PER_ELEMENT:number;of(...items:number[]):Int32Array;from(arrayLike:ArrayLike<number>):Int32Array;from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any):Int32Array;}declare var Int32Array:Int32ArrayConstructor;interface Uint32Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;every(callbackfn:(value:number,index:number,array:Uint32Array)=>unknown,thisArg?:any):boolean;fill(value:number,start?:number,end?:number):this;filter(callbackfn:(value:number,index:number,array:Uint32Array)=>any,thisArg?:any):Uint32Array;find(predicate:(value:number,index:number,obj:Uint32Array)=>boolean,thisArg?:any):number|undefined;findIndex(predicate:(value:number,index:number,obj:Uint32Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:number,index:number,array:Uint32Array)=>void,thisArg?:any):void;indexOf(searchElement:number,fromIndex?:number):number;join(separator?:string):string;lastIndexOf(searchElement:number,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:number,index:number,array:Uint32Array)=>number,thisArg?:any):Uint32Array;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint32Array)=>number):number;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint32Array)=>number,initialValue:number):number;reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint32Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint32Array)=>number):number;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Uint32Array)=>number,initialValue:number):number;reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Uint32Array)=>U,initialValue:U):U;reverse():Uint32Array;set(array:ArrayLike<number>,offset?:number):void;slice(start?:number,end?:number):Uint32Array;some(callbackfn:(value:number,index:number,array:Uint32Array)=>unknown,thisArg?:any):boolean;sort(compareFn?:(a:number,b:number)=>number):this;subarray(begin?:number,end?:number):Uint32Array;toLocaleString():string;toString():string;valueOf():Uint32Array;[index:number]:number;}interface Uint32ArrayConstructor{readonly prototype:Uint32Array;new(length:number):Uint32Array;new(arrayOrArrayBuffer:ArrayLike<number>|ArrayBufferLike):Uint32Array;new(buffer:ArrayBufferLike,byteOffset:number,length?:number):Uint32Array;readonly BYTES_PER_ELEMENT:number;of(...items:number[]):Uint32Array;from(arrayLike:ArrayLike<number>):Uint32Array;from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any):Uint32Array;}declare var Uint32Array:Uint32ArrayConstructor;interface Float32Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;every(callbackfn:(value:number,index:number,array:Float32Array)=>unknown,thisArg?:any):boolean;fill(value:number,start?:number,end?:number):this;filter(callbackfn:(value:number,index:number,array:Float32Array)=>any,thisArg?:any):Float32Array;find(predicate:(value:number,index:number,obj:Float32Array)=>boolean,thisArg?:any):number|undefined;findIndex(predicate:(value:number,index:number,obj:Float32Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:number,index:number,array:Float32Array)=>void,thisArg?:any):void;indexOf(searchElement:number,fromIndex?:number):number;join(separator?:string):string;lastIndexOf(searchElement:number,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:number,index:number,array:Float32Array)=>number,thisArg?:any):Float32Array;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float32Array)=>number):number;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float32Array)=>number,initialValue:number):number;reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Float32Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float32Array)=>number):number;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float32Array)=>number,initialValue:number):number;reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Float32Array)=>U,initialValue:U):U;reverse():Float32Array;set(array:ArrayLike<number>,offset?:number):void;slice(start?:number,end?:number):Float32Array;some(callbackfn:(value:number,index:number,array:Float32Array)=>unknown,thisArg?:any):boolean;sort(compareFn?:(a:number,b:number)=>number):this;subarray(begin?:number,end?:number):Float32Array;toLocaleString():string;toString():string;valueOf():Float32Array;[index:number]:number;}interface Float32ArrayConstructor{readonly prototype:Float32Array;new(length:number):Float32Array;new(arrayOrArrayBuffer:ArrayLike<number>|ArrayBufferLike):Float32Array;new(buffer:ArrayBufferLike,byteOffset:number,length?:number):Float32Array;readonly BYTES_PER_ELEMENT:number;of(...items:number[]):Float32Array;from(arrayLike:ArrayLike<number>):Float32Array;from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any):Float32Array;}declare var Float32Array:Float32ArrayConstructor;interface Float64Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;every(callbackfn:(value:number,index:number,array:Float64Array)=>unknown,thisArg?:any):boolean;fill(value:number,start?:number,end?:number):this;filter(callbackfn:(value:number,index:number,array:Float64Array)=>any,thisArg?:any):Float64Array;find(predicate:(value:number,index:number,obj:Float64Array)=>boolean,thisArg?:any):number|undefined;findIndex(predicate:(value:number,index:number,obj:Float64Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:number,index:number,array:Float64Array)=>void,thisArg?:any):void;indexOf(searchElement:number,fromIndex?:number):number;join(separator?:string):string;lastIndexOf(searchElement:number,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:number,index:number,array:Float64Array)=>number,thisArg?:any):Float64Array;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float64Array)=>number):number;reduce(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float64Array)=>number,initialValue:number):number;reduce<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Float64Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float64Array)=>number):number;reduceRight(callbackfn:(previousValue:number,currentValue:number,currentIndex:number,array:Float64Array)=>number,initialValue:number):number;reduceRight<U>(callbackfn:(previousValue:U,currentValue:number,currentIndex:number,array:Float64Array)=>U,initialValue:U):U;reverse():Float64Array;set(array:ArrayLike<number>,offset?:number):void;slice(start?:number,end?:number):Float64Array;some(callbackfn:(value:number,index:number,array:Float64Array)=>unknown,thisArg?:any):boolean;sort(compareFn?:(a:number,b:number)=>number):this;subarray(begin?:number,end?:number):Float64Array;toString():string;valueOf():Float64Array;[index:number]:number;}interface Float64ArrayConstructor{readonly prototype:Float64Array;new(length:number):Float64Array;new(arrayOrArrayBuffer:ArrayLike<number>|ArrayBufferLike):Float64Array;new(buffer:ArrayBufferLike,byteOffset:number,length?:number):Float64Array;readonly BYTES_PER_ELEMENT:number;of(...items:number[]):Float64Array;from(arrayLike:ArrayLike<number>):Float64Array;from<T>(arrayLike:ArrayLike<T>,mapfn:(v:T,k:number)=>number,thisArg?:any):Float64Array;}declare var Float64Array:Float64ArrayConstructor;declare namespace Intl{interface CollatorOptions{usage?:string;localeMatcher?:string;numeric?:boolean;caseFirst?:string;sensitivity?:string;ignorePunctuation?:boolean;}interface ResolvedCollatorOptions{locale:string;usage:string;sensitivity:string;ignorePunctuation:boolean;collation:string;caseFirst:string;numeric:boolean;}interface Collator{compare(x:string,y:string):number;resolvedOptions():ResolvedCollatorOptions;}var Collator:{new(locales?:string|string[],options?:CollatorOptions):Collator;(locales?:string|string[],options?:CollatorOptions):Collator;supportedLocalesOf(locales:string|string[],options?:CollatorOptions):string[];};interface NumberFormatOptions{localeMatcher?:string;style?:string;currency?:string;currencyDisplay?:string;useGrouping?:boolean;minimumIntegerDigits?:number;minimumFractionDigits?:number;maximumFractionDigits?:number;minimumSignificantDigits?:number;maximumSignificantDigits?:number;}interface ResolvedNumberFormatOptions{locale:string;numberingSystem:string;style:string;currency?:string;currencyDisplay?:string;minimumIntegerDigits:number;minimumFractionDigits:number;maximumFractionDigits:number;minimumSignificantDigits?:number;maximumSignificantDigits?:number;useGrouping:boolean;}interface NumberFormat{format(value:number):string;resolvedOptions():ResolvedNumberFormatOptions;}var NumberFormat:{new(locales?:string|string[],options?:NumberFormatOptions):NumberFormat;(locales?:string|string[],options?:NumberFormatOptions):NumberFormat;supportedLocalesOf(locales:string|string[],options?:NumberFormatOptions):string[];};interface DateTimeFormatOptions{localeMatcher?:string;weekday?:string;era?:string;year?:string;month?:string;day?:string;hour?:string;minute?:string;second?:string;timeZoneName?:string;formatMatcher?:string;hour12?:boolean;timeZone?:string;}interface ResolvedDateTimeFormatOptions{locale:string;calendar:string;numberingSystem:string;timeZone:string;hour12?:boolean;weekday?:string;era?:string;year?:string;month?:string;day?:string;hour?:string;minute?:string;second?:string;timeZoneName?:string;}interface DateTimeFormat{format(date?:Date|number):string;resolvedOptions():ResolvedDateTimeFormatOptions;}var DateTimeFormat:{new(locales?:string|string[],options?:DateTimeFormatOptions):DateTimeFormat;(locales?:string|string[],options?:DateTimeFormatOptions):DateTimeFormat;supportedLocalesOf(locales:string|string[],options?:DateTimeFormatOptions):string[];};}interface String{localeCompare(that:string,locales?:string|string[],options?:Intl.CollatorOptions):number;}interface Number{toLocaleString(locales?:string|string[],options?:Intl.NumberFormatOptions):string;}interface Date{toLocaleString(locales?:string|string[],options?:Intl.DateTimeFormatOptions):string;toLocaleDateString(locales?:string|string[],options?:Intl.DateTimeFormatOptions):string;toLocaleTimeString(locales?:string|string[],options?:Intl.DateTimeFormatOptions):string;}`
    }, {
        fileName: "lib.es6.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015" />\n/// <reference lib="dom" />\n/// <reference lib="dom.iterable" />\n/// <reference lib="webworker.importscripts" />\n/// <reference lib="scripthost" />\n`
    }, {
        fileName: "lib.esnext.array.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface ReadonlyArray<T>{flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This):U[]flat<U>(this:ReadonlyArray<U[][][][]>|ReadonlyArray<ReadonlyArray<U[][][]>>|ReadonlyArray<ReadonlyArray<U[][]>[]>|ReadonlyArray<ReadonlyArray<U[]>[][]>|ReadonlyArray<ReadonlyArray<U>[][][]>|ReadonlyArray<ReadonlyArray<ReadonlyArray<U[][]>>>|ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[][]>>|ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>[][]>|ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[]>[]>|ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>>[]>|ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>[]>>|ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>>>>|ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[]>>>|ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>[]>>|ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>[]>|ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>>>,depth:4):U[];flat<U>(this:ReadonlyArray<U[][][]>|ReadonlyArray<ReadonlyArray<U>[][]>|ReadonlyArray<ReadonlyArray<U[]>[]>|ReadonlyArray<ReadonlyArray<U[][]>>|ReadonlyArray<ReadonlyArray<ReadonlyArray<U[]>>>|ReadonlyArray<ReadonlyArray<ReadonlyArray<U>[]>>|ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>[]>|ReadonlyArray<ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>>,depth:3):U[];flat<U>(this:ReadonlyArray<U[][]>|ReadonlyArray<ReadonlyArray<U[]>>|ReadonlyArray<ReadonlyArray<U>[]>|ReadonlyArray<ReadonlyArray<ReadonlyArray<U>>>,depth:2):U[];flat<U>(this:ReadonlyArray<U[]>|ReadonlyArray<ReadonlyArray<U>>,depth?:1):U[];flat<U>(this:ReadonlyArray<U>,depth:0):U[];flat<U>(depth?:number):any[];}interface Array<T>{flatMap<U,This=undefined>(callback:(this:This,value:T,index:number,array:T[])=>U|ReadonlyArray<U>,thisArg?:This):U[]flat<U>(this:U[][][][][][][][],depth:7):U[];flat<U>(this:U[][][][][][][],depth:6):U[];flat<U>(this:U[][][][][][],depth:5):U[];flat<U>(this:U[][][][][],depth:4):U[];flat<U>(this:U[][][][],depth:3):U[];flat<U>(this:U[][][],depth:2):U[];flat<U>(this:U[][],depth?:1):U[];flat<U>(this:U[],depth:0):U[];flat<U>(depth?:number):any[];}`
    }, {
        fileName: "lib.esnext.asynciterable.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2015.symbol" />\n/// <reference lib="es2015.iterable" />\ninterface SymbolConstructor{readonly asyncIterator:symbol;}interface AsyncIterator<T>{next(value?:any):Promise<IteratorResult<T>>;return?(value?:any):Promise<IteratorResult<T>>;throw?(e?:any):Promise<IteratorResult<T>>;}interface AsyncIterable<T>{[Symbol.asyncIterator]():AsyncIterator<T>;}interface AsyncIterableIterator<T>extends AsyncIterator<T>{[Symbol.asyncIterator]():AsyncIterableIterator<T>;}`
    }, {
        fileName: "lib.esnext.bigint.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface BigInt{toString(radix?:number):string;toLocaleString():string;valueOf():bigint;readonly[Symbol.toStringTag]:"BigInt";}interface BigIntConstructor{(value?:any):bigint;readonly prototype:BigInt;asIntN(bits:number,int:bigint):bigint;asUintN(bits:number,int:bigint):bigint;}declare var BigInt:BigIntConstructor;interface BigInt64Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;entries():IterableIterator<[number,bigint]>;every(callbackfn:(value:bigint,index:number,array:BigInt64Array)=>boolean,thisArg?:any):boolean;fill(value:bigint,start?:number,end?:number):this;filter(callbackfn:(value:bigint,index:number,array:BigInt64Array)=>any,thisArg?:any):BigInt64Array;find(predicate:(value:bigint,index:number,array:BigInt64Array)=>boolean,thisArg?:any):bigint|undefined;findIndex(predicate:(value:bigint,index:number,array:BigInt64Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:bigint,index:number,array:BigInt64Array)=>void,thisArg?:any):void;includes(searchElement:bigint,fromIndex?:number):boolean;indexOf(searchElement:bigint,fromIndex?:number):number;join(separator?:string):string;keys():IterableIterator<number>;lastIndexOf(searchElement:bigint,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:bigint,index:number,array:BigInt64Array)=>bigint,thisArg?:any):BigInt64Array;reduce(callbackfn:(previousValue:bigint,currentValue:bigint,currentIndex:number,array:BigInt64Array)=>bigint):bigint;reduce<U>(callbackfn:(previousValue:U,currentValue:bigint,currentIndex:number,array:BigInt64Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:bigint,currentValue:bigint,currentIndex:number,array:BigInt64Array)=>bigint):bigint;reduceRight<U>(callbackfn:(previousValue:U,currentValue:bigint,currentIndex:number,array:BigInt64Array)=>U,initialValue:U):U;reverse():this;set(array:ArrayLike<bigint>,offset?:number):void;slice(start?:number,end?:number):BigInt64Array;some(callbackfn:(value:bigint,index:number,array:BigInt64Array)=>boolean,thisArg?:any):boolean;sort(compareFn?:(a:bigint,b:bigint)=>number|bigint):this;subarray(begin:number,end?:number):BigInt64Array;toLocaleString():string;toString():string;values():IterableIterator<bigint>;[Symbol.iterator]():IterableIterator<bigint>;readonly[Symbol.toStringTag]:"BigInt64Array";[index:number]:bigint;}interface BigInt64ArrayConstructor{readonly prototype:BigInt64Array;new(length?:number):BigInt64Array;new(array:Iterable<bigint>):BigInt64Array;new(buffer:ArrayBufferLike,byteOffset?:number,length?:number):BigInt64Array;readonly BYTES_PER_ELEMENT:number;of(...items:bigint[]):BigInt64Array;from(arrayLike:ArrayLike<bigint>):BigInt64Array;from<U>(arrayLike:ArrayLike<U>,mapfn:(v:U,k:number)=>bigint,thisArg?:any):BigInt64Array;}declare var BigInt64Array:BigInt64ArrayConstructor;interface BigUint64Array{readonly BYTES_PER_ELEMENT:number;readonly buffer:ArrayBufferLike;readonly byteLength:number;readonly byteOffset:number;copyWithin(target:number,start:number,end?:number):this;entries():IterableIterator<[number,bigint]>;every(callbackfn:(value:bigint,index:number,array:BigUint64Array)=>boolean,thisArg?:any):boolean;fill(value:bigint,start?:number,end?:number):this;filter(callbackfn:(value:bigint,index:number,array:BigUint64Array)=>any,thisArg?:any):BigUint64Array;find(predicate:(value:bigint,index:number,array:BigUint64Array)=>boolean,thisArg?:any):bigint|undefined;findIndex(predicate:(value:bigint,index:number,array:BigUint64Array)=>boolean,thisArg?:any):number;forEach(callbackfn:(value:bigint,index:number,array:BigUint64Array)=>void,thisArg?:any):void;includes(searchElement:bigint,fromIndex?:number):boolean;indexOf(searchElement:bigint,fromIndex?:number):number;join(separator?:string):string;keys():IterableIterator<number>;lastIndexOf(searchElement:bigint,fromIndex?:number):number;readonly length:number;map(callbackfn:(value:bigint,index:number,array:BigUint64Array)=>bigint,thisArg?:any):BigUint64Array;reduce(callbackfn:(previousValue:bigint,currentValue:bigint,currentIndex:number,array:BigUint64Array)=>bigint):bigint;reduce<U>(callbackfn:(previousValue:U,currentValue:bigint,currentIndex:number,array:BigUint64Array)=>U,initialValue:U):U;reduceRight(callbackfn:(previousValue:bigint,currentValue:bigint,currentIndex:number,array:BigUint64Array)=>bigint):bigint;reduceRight<U>(callbackfn:(previousValue:U,currentValue:bigint,currentIndex:number,array:BigUint64Array)=>U,initialValue:U):U;reverse():this;set(array:ArrayLike<bigint>,offset?:number):void;slice(start?:number,end?:number):BigUint64Array;some(callbackfn:(value:bigint,index:number,array:BigUint64Array)=>boolean,thisArg?:any):boolean;sort(compareFn?:(a:bigint,b:bigint)=>number|bigint):this;subarray(begin:number,end?:number):BigUint64Array;toLocaleString():string;toString():string;values():IterableIterator<bigint>;[Symbol.iterator]():IterableIterator<bigint>;readonly[Symbol.toStringTag]:"BigUint64Array";[index:number]:bigint;}interface BigUint64ArrayConstructor{readonly prototype:BigUint64Array;new(length?:number):BigUint64Array;new(array:Iterable<bigint>):BigUint64Array;new(buffer:ArrayBufferLike,byteOffset?:number,length?:number):BigUint64Array;readonly BYTES_PER_ELEMENT:number;of(...items:bigint[]):BigUint64Array;from(arrayLike:ArrayLike<bigint>):BigUint64Array;from<U>(arrayLike:ArrayLike<U>,mapfn:(v:U,k:number)=>bigint,thisArg?:any):BigUint64Array;}declare var BigUint64Array:BigUint64ArrayConstructor;interface DataView{getBigInt64(byteOffset:number,littleEndian?:boolean):bigint;getBigUint64(byteOffset:number,littleEndian?:boolean):bigint;setBigInt64(byteOffset:number,value:bigint,littleEndian?:boolean):void;setBigUint64(byteOffset:number,value:bigint,littleEndian?:boolean):void;}`
    }, {
        fileName: "lib.esnext.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="es2020" />\n/// <reference lib="esnext.intl" />\n/// <reference lib="esnext.string" />\n/// <reference lib="esnext.promise" />\n`
    }, {
        fileName: "lib.esnext.full.d.ts",
        text: `/// <reference no-default-lib="true"/>\n/// <reference lib="esnext" />\n/// <reference lib="dom" />\n/// <reference lib="webworker.importscripts" />\n/// <reference lib="scripthost" />\n/// <reference lib="dom.iterable" />`
    }, {
        fileName: "lib.esnext.intl.d.ts",
        text: `/// <reference no-default-lib="true"/>\ndeclare namespace Intl{type NumberFormatPartTypes="currency"|"decimal"|"fraction"|"group"|"infinity"|"integer"|"literal"|"minusSign"|"nan"|"plusSign"|"percentSign";interface NumberFormatPart{type:NumberFormatPartTypes;value:string;}interface NumberFormat{formatToParts(number?:number):NumberFormatPart[];}}`
    }, {
        fileName: "lib.esnext.promise.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface AggregateError extends Error{errors:any[]}interface AggregateErrorConstructor{new(errors:Iterable<any>,message?:string):AggregateError;(errors:Iterable<any>,message?:string):AggregateError;readonly prototype:AggregateError;}declare var AggregateError:AggregateErrorConstructor;interface PromiseConstructor{any<T>(values:(T|PromiseLike<T>)[]|Iterable<T|PromiseLike<T>>):Promise<T>}`
    }, {
        fileName: "lib.esnext.string.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface String{replaceAll(searchValue:string|RegExp,replaceValue:string):string;replaceAll(searchValue:string|RegExp,replacer:(substring:string,...args:any[])=>string):string;}`
    }, {
        fileName: "lib.esnext.symbol.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface Symbol{readonly description:string;}`
    }, {
        fileName: "lib.scripthost.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface ActiveXObject{new(s:string):any;}declare var ActiveXObject:ActiveXObject;interface ITextWriter{Write(s:string):void;WriteLine(s:string):void;Close():void;}interface TextStreamBase{Column:number;Line:number;Close():void;}interface TextStreamWriter extends TextStreamBase{Write(s:string):void;WriteBlankLines(intLines:number):void;WriteLine(s:string):void;}interface TextStreamReader extends TextStreamBase{Read(characters:number):string;ReadAll():string;ReadLine():string;Skip(characters:number):void;SkipLine():void;AtEndOfLine:boolean;AtEndOfStream:boolean;}declare var WScript:{Echo(s:any):void;StdErr:TextStreamWriter;StdOut:TextStreamWriter;Arguments:{length:number;Item(n:number):string;};ScriptFullName:string;Quit(exitCode?:number):number;BuildVersion:number;FullName:string;Interactive:boolean;Name:string;Path:string;ScriptName:string;StdIn:TextStreamReader;Version:string;ConnectObject(objEventSource:any,strPrefix:string):void;CreateObject(strProgID:string,strPrefix?:string):any;DisconnectObject(obj:any):void;GetObject(strPathname:string,strProgID?:string,strPrefix?:string):any;Sleep(intTime:number):void;};declare var WSH:typeof WScript;declare class SafeArray<T=any>{private constructor();private SafeArray_typekey:SafeArray<T>;}interface Enumerator<T=any>{atEnd():boolean;item():T;moveFirst():void;moveNext():void;}interface EnumeratorConstructor{new<T=any>(safearray:SafeArray<T>):Enumerator<T>;new<T=any>(collection:{Item(index:any):T}):Enumerator<T>;new<T=any>(collection:any):Enumerator<T>;}declare var Enumerator:EnumeratorConstructor;interface VBArray<T=any>{dimensions():number;getItem(dimension1Index:number,...dimensionNIndexes:number[]):T;lbound(dimension?:number):number;ubound(dimension?:number):number;toArray():T[];}interface VBArrayConstructor{new<T=any>(safeArray:SafeArray<T>):VBArray<T>;}declare var VBArray:VBArrayConstructor;declare class VarDate{private constructor();private VarDate_typekey:VarDate;}interface DateConstructor{new(vd:VarDate):Date;}interface Date{getVarDate:()=>VarDate;}`
    }, {
        fileName: "lib.webworker.d.ts",
        text: `/// <reference no-default-lib="true"/>\ninterface AddEventListenerOptions extends EventListenerOptions{once?:boolean;passive?:boolean;}interface AesCbcParams extends Algorithm{iv:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface AesCtrParams extends Algorithm{counter:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;length:number;}interface AesDerivedKeyParams extends Algorithm{length:number;}interface AesGcmParams extends Algorithm{additionalData?:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;iv:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;tagLength?:number;}interface AesKeyAlgorithm extends KeyAlgorithm{length:number;}interface AesKeyGenParams extends Algorithm{length:number;}interface Algorithm{name:string;}interface BlobPropertyBag{endings?:EndingType;type?:string;}interface CacheQueryOptions{ignoreMethod?:boolean;ignoreSearch?:boolean;ignoreVary?:boolean;}interface CanvasRenderingContext2DSettings{alpha?:boolean;desynchronized?:boolean;}interface ClientQueryOptions{includeUncontrolled?:boolean;type?:ClientTypes;}interface CloseEventInit extends EventInit{code?:number;reason?:string;wasClean?:boolean;}interface CryptoKeyPair{privateKey?:CryptoKey;publicKey?:CryptoKey;}interface CustomEventInit<T=any>extends EventInit{detail?:T;}interface DOMMatrix2DInit{a?:number;b?:number;c?:number;d?:number;e?:number;f?:number;m11?:number;m12?:number;m21?:number;m22?:number;m41?:number;m42?:number;}interface DOMMatrixInit extends DOMMatrix2DInit{is2D?:boolean;m13?:number;m14?:number;m23?:number;m24?:number;m31?:number;m32?:number;m33?:number;m34?:number;m43?:number;m44?:number;}interface DOMPointInit{w?:number;x?:number;y?:number;z?:number;}interface DOMQuadInit{p1?:DOMPointInit;p2?:DOMPointInit;p3?:DOMPointInit;p4?:DOMPointInit;}interface DOMRectInit{height?:number;width?:number;x?:number;y?:number;}interface DevicePermissionDescriptor extends PermissionDescriptor{deviceId?:string;name:"camera"|"microphone"|"speaker";}interface EcKeyGenParams extends Algorithm{namedCurve:NamedCurve;}interface EcKeyImportParams extends Algorithm{namedCurve:NamedCurve;}interface EcdhKeyDeriveParams extends Algorithm{public:CryptoKey;}interface EcdsaParams extends Algorithm{hash:HashAlgorithmIdentifier;}interface ErrorEventInit extends EventInit{colno?:number;error?:any;filename?:string;lineno?:number;message?:string;}interface EventInit{bubbles?:boolean;cancelable?:boolean;composed?:boolean;}interface EventListenerOptions{capture?:boolean;}interface EventSourceInit{withCredentials?:boolean;}interface ExtendableEventInit extends EventInit{}interface ExtendableMessageEventInit extends ExtendableEventInit{data?:any;lastEventId?:string;origin?:string;ports?:MessagePort[];source?:Client|ServiceWorker|MessagePort|null;}interface FetchEventInit extends ExtendableEventInit{clientId?:string;preloadResponse?:Promise<any>;replacesClientId?:string;request:Request;resultingClientId?:string;}interface FilePropertyBag extends BlobPropertyBag{lastModified?:number;}interface GetNotificationOptions{tag?:string;}interface HmacImportParams extends Algorithm{hash:HashAlgorithmIdentifier;length?:number;}interface HmacKeyGenParams extends Algorithm{hash:HashAlgorithmIdentifier;length?:number;}interface IDBIndexParameters{multiEntry?:boolean;unique?:boolean;}interface IDBObjectStoreParameters{autoIncrement?:boolean;keyPath?:string|string[]|null;}interface IDBVersionChangeEventInit extends EventInit{newVersion?:number|null;oldVersion?:number;}interface ImageBitmapOptions{colorSpaceConversion?:ColorSpaceConversion;imageOrientation?:ImageOrientation;premultiplyAlpha?:PremultiplyAlpha;resizeHeight?:number;resizeQuality?:ResizeQuality;resizeWidth?:number;}interface ImageBitmapRenderingContextSettings{alpha?:boolean;}interface ImageEncodeOptions{quality?:number;type?:string;}interface JsonWebKey{alg?:string;crv?:string;d?:string;dp?:string;dq?:string;e?:string;ext?:boolean;k?:string;key_ops?:string[];kty?:string;n?:string;oth?:RsaOtherPrimesInfo[];p?:string;q?:string;qi?:string;use?:string;x?:string;y?:string;}interface KeyAlgorithm{name:string;}interface MessageEventInit extends EventInit{data?:any;lastEventId?:string;origin?:string;ports?:MessagePort[];source?:MessageEventSource|null;}interface MidiPermissionDescriptor extends PermissionDescriptor{name:"midi";sysex?:boolean;}interface MultiCacheQueryOptions extends CacheQueryOptions{cacheName?:string;}interface NavigationPreloadState{enabled?:boolean;headerValue?:string;}interface NotificationAction{action:string;icon?:string;title:string;}interface NotificationEventInit extends ExtendableEventInit{action?:string;notification:Notification;}interface NotificationOptions{actions?:NotificationAction[];badge?:string;body?:string;data?:any;dir?:NotificationDirection;icon?:string;image?:string;lang?:string;renotify?:boolean;requireInteraction?:boolean;silent?:boolean;tag?:string;timestamp?:number;vibrate?:VibratePattern;}interface Pbkdf2Params extends Algorithm{hash:HashAlgorithmIdentifier;iterations:number;salt:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface PerformanceObserverInit{buffered?:boolean;entryTypes?:string[];type?:string;}interface PermissionDescriptor{name:PermissionName;}interface PipeOptions{preventAbort?:boolean;preventCancel?:boolean;preventClose?:boolean;signal?:AbortSignal;}interface PostMessageOptions{transfer?:any[];}interface ProgressEventInit extends EventInit{lengthComputable?:boolean;loaded?:number;total?:number;}interface PromiseRejectionEventInit extends EventInit{promise:Promise<any>;reason?:any;}interface PushEventInit extends ExtendableEventInit{data?:PushMessageDataInit;}interface PushPermissionDescriptor extends PermissionDescriptor{name:"push";userVisibleOnly?:boolean;}interface PushSubscriptionChangeEventInit extends ExtendableEventInit{newSubscription?:PushSubscription;oldSubscription?:PushSubscription;}interface PushSubscriptionJSON{endpoint?:string;expirationTime?:number|null;keys?:Record<string,string>;}interface PushSubscriptionOptionsInit{applicationServerKey?:BufferSource|string|null;userVisibleOnly?:boolean;}interface QueuingStrategy<T=any>{highWaterMark?:number;size?:QueuingStrategySizeCallback<T>;}interface ReadableStreamReadDoneResult<T>{done:true;value?:T;}interface ReadableStreamReadValueResult<T>{done:false;value:T;}interface RegistrationOptions{scope?:string;type?:WorkerType;updateViaCache?:ServiceWorkerUpdateViaCache;}interface RequestInit{body?:BodyInit|null;cache?:RequestCache;credentials?:RequestCredentials;headers?:HeadersInit;integrity?:string;keepalive?:boolean;method?:string;mode?:RequestMode;redirect?:RequestRedirect;referrer?:string;referrerPolicy?:ReferrerPolicy;signal?:AbortSignal|null;window?:any;}interface ResponseInit{headers?:HeadersInit;status?:number;statusText?:string;}interface RsaHashedImportParams extends Algorithm{hash:HashAlgorithmIdentifier;}interface RsaHashedKeyGenParams extends RsaKeyGenParams{hash:HashAlgorithmIdentifier;}interface RsaKeyGenParams extends Algorithm{modulusLength:number;publicExponent:BigInteger;}interface RsaOaepParams extends Algorithm{label?:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface RsaOtherPrimesInfo{d?:string;r?:string;t?:string;}interface RsaPssParams extends Algorithm{saltLength:number;}interface StorageEstimate{quota?:number;usage?:number;}interface SyncEventInit extends ExtendableEventInit{lastChance?:boolean;tag:string;}interface TextDecodeOptions{stream?:boolean;}interface TextDecoderOptions{fatal?:boolean;ignoreBOM?:boolean;}interface TextEncoderEncodeIntoResult{read?:number;written?:number;}interface Transformer<I=any,O=any>{flush?:TransformStreamDefaultControllerCallback<O>;readableType?:undefined;start?:TransformStreamDefaultControllerCallback<O>;transform?:TransformStreamDefaultControllerTransformCallback<I,O>;writableType?:undefined;}interface UnderlyingByteSource{autoAllocateChunkSize?:number;cancel?:ReadableStreamErrorCallback;pull?:ReadableByteStreamControllerCallback;start?:ReadableByteStreamControllerCallback;type:"bytes";}interface UnderlyingSink<W=any>{abort?:WritableStreamErrorCallback;close?:WritableStreamDefaultControllerCloseCallback;start?:WritableStreamDefaultControllerStartCallback;type?:undefined;write?:WritableStreamDefaultControllerWriteCallback<W>;}interface UnderlyingSource<R=any>{cancel?:ReadableStreamErrorCallback;pull?:ReadableStreamDefaultControllerCallback<R>;start?:ReadableStreamDefaultControllerCallback<R>;type?:undefined;}interface WebGLContextAttributes{alpha?:boolean;antialias?:boolean;depth?:boolean;desynchronized?:boolean;failIfMajorPerformanceCaveat?:boolean;powerPreference?:WebGLPowerPreference;premultipliedAlpha?:boolean;preserveDrawingBuffer?:boolean;stencil?:boolean;}interface WebGLContextEventInit extends EventInit{statusMessage?:string;}interface WorkerOptions{credentials?:RequestCredentials;name?:string;type?:WorkerType;}interface EventListener{(evt:Event):void;}interface ANGLE_instanced_arrays{drawArraysInstancedANGLE(mode:GLenum,first:GLint,count:GLsizei,primcount:GLsizei):void;drawElementsInstancedANGLE(mode:GLenum,count:GLsizei,type:GLenum,offset:GLintptr,primcount:GLsizei):void;vertexAttribDivisorANGLE(index:GLuint,divisor:GLuint):void;readonly VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE:GLenum;}interface AbortController{readonly signal:AbortSignal;abort():void;}declare var AbortController:{prototype:AbortController;new():AbortController;};interface AbortSignalEventMap{"abort":Event;}interface AbortSignal extends EventTarget{readonly aborted:boolean;onabort:((this:AbortSignal,ev:Event)=>any)|null;addEventListener<K extends keyof AbortSignalEventMap>(type:K,listener:(this:AbortSignal,ev:AbortSignalEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AbortSignalEventMap>(type:K,listener:(this:AbortSignal,ev:AbortSignalEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var AbortSignal:{prototype:AbortSignal;new():AbortSignal;};interface AbstractWorkerEventMap{"error":ErrorEvent;}interface AbstractWorker{onerror:((this:AbstractWorker,ev:ErrorEvent)=>any)|null;addEventListener<K extends keyof AbstractWorkerEventMap>(type:K,listener:(this:AbstractWorker,ev:AbstractWorkerEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AbstractWorkerEventMap>(type:K,listener:(this:AbstractWorker,ev:AbstractWorkerEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}interface AesCfbParams extends Algorithm{iv:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface AesCmacParams extends Algorithm{length:number;}interface AnimationFrameProvider{cancelAnimationFrame(handle:number):void;requestAnimationFrame(callback:FrameRequestCallback):number;}interface Blob{readonly size:number;readonly type:string;arrayBuffer():Promise<ArrayBuffer>;slice(start?:number,end?:number,contentType?:string):Blob;stream():ReadableStream;text():Promise<string>;}declare var Blob:{prototype:Blob;new(blobParts?:BlobPart[],options?:BlobPropertyBag):Blob;};interface Body{readonly body:ReadableStream<Uint8Array>|null;readonly bodyUsed:boolean;arrayBuffer():Promise<ArrayBuffer>;blob():Promise<Blob>;formData():Promise<FormData>;json():Promise<any>;text():Promise<string>;}interface BroadcastChannelEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface BroadcastChannel extends EventTarget{readonly name:string;onmessage:((this:BroadcastChannel,ev:MessageEvent)=>any)|null;onmessageerror:((this:BroadcastChannel,ev:MessageEvent)=>any)|null;close():void;postMessage(message:any):void;addEventListener<K extends keyof BroadcastChannelEventMap>(type:K,listener:(this:BroadcastChannel,ev:BroadcastChannelEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof BroadcastChannelEventMap>(type:K,listener:(this:BroadcastChannel,ev:BroadcastChannelEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var BroadcastChannel:{prototype:BroadcastChannel;new(name:string):BroadcastChannel;};interface ByteLengthQueuingStrategy extends QueuingStrategy<ArrayBufferView>{highWaterMark:number;size(chunk:ArrayBufferView):number;}declare var ByteLengthQueuingStrategy:{prototype:ByteLengthQueuingStrategy;new(options:{highWaterMark:number}):ByteLengthQueuingStrategy;};interface Cache{add(request:RequestInfo):Promise<void>;addAll(requests:RequestInfo[]):Promise<void>;delete(request:RequestInfo,options?:CacheQueryOptions):Promise<boolean>;keys(request?:RequestInfo,options?:CacheQueryOptions):Promise<ReadonlyArray<Request>>;match(request:RequestInfo,options?:CacheQueryOptions):Promise<Response|undefined>;matchAll(request?:RequestInfo,options?:CacheQueryOptions):Promise<ReadonlyArray<Response>>;put(request:RequestInfo,response:Response):Promise<void>;}declare var Cache:{prototype:Cache;new():Cache;};interface CacheStorage{delete(cacheName:string):Promise<boolean>;has(cacheName:string):Promise<boolean>;keys():Promise<string[]>;match(request:RequestInfo,options?:MultiCacheQueryOptions):Promise<Response|undefined>;open(cacheName:string):Promise<Cache>;}declare var CacheStorage:{prototype:CacheStorage;new():CacheStorage;};interface CanvasCompositing{globalAlpha:number;globalCompositeOperation:string;}interface CanvasDrawImage{drawImage(image:CanvasImageSource,dx:number,dy:number):void;drawImage(image:CanvasImageSource,dx:number,dy:number,dw:number,dh:number):void;drawImage(image:CanvasImageSource,sx:number,sy:number,sw:number,sh:number,dx:number,dy:number,dw:number,dh:number):void;}interface CanvasDrawPath{beginPath():void;clip(fillRule?:CanvasFillRule):void;clip(path:Path2D,fillRule?:CanvasFillRule):void;fill(fillRule?:CanvasFillRule):void;fill(path:Path2D,fillRule?:CanvasFillRule):void;isPointInPath(x:number,y:number,fillRule?:CanvasFillRule):boolean;isPointInPath(path:Path2D,x:number,y:number,fillRule?:CanvasFillRule):boolean;isPointInStroke(x:number,y:number):boolean;isPointInStroke(path:Path2D,x:number,y:number):boolean;stroke():void;stroke(path:Path2D):void;}interface CanvasFillStrokeStyles{fillStyle:string|CanvasGradient|CanvasPattern;strokeStyle:string|CanvasGradient|CanvasPattern;createLinearGradient(x0:number,y0:number,x1:number,y1:number):CanvasGradient;createPattern(image:CanvasImageSource,repetition:string|null):CanvasPattern|null;createRadialGradient(x0:number,y0:number,r0:number,x1:number,y1:number,r1:number):CanvasGradient;}interface CanvasFilters{filter:string;}interface CanvasGradient{addColorStop(offset:number,color:string):void;}declare var CanvasGradient:{prototype:CanvasGradient;new():CanvasGradient;};interface CanvasImageData{createImageData(sw:number,sh:number):ImageData;createImageData(imagedata:ImageData):ImageData;getImageData(sx:number,sy:number,sw:number,sh:number):ImageData;putImageData(imagedata:ImageData,dx:number,dy:number):void;putImageData(imagedata:ImageData,dx:number,dy:number,dirtyX:number,dirtyY:number,dirtyWidth:number,dirtyHeight:number):void;}interface CanvasImageSmoothing{imageSmoothingEnabled:boolean;imageSmoothingQuality:ImageSmoothingQuality;}interface CanvasPath{arc(x:number,y:number,radius:number,startAngle:number,endAngle:number,anticlockwise?:boolean):void;arcTo(x1:number,y1:number,x2:number,y2:number,radius:number):void;bezierCurveTo(cp1x:number,cp1y:number,cp2x:number,cp2y:number,x:number,y:number):void;closePath():void;ellipse(x:number,y:number,radiusX:number,radiusY:number,rotation:number,startAngle:number,endAngle:number,anticlockwise?:boolean):void;lineTo(x:number,y:number):void;moveTo(x:number,y:number):void;quadraticCurveTo(cpx:number,cpy:number,x:number,y:number):void;rect(x:number,y:number,w:number,h:number):void;}interface CanvasPathDrawingStyles{lineCap:CanvasLineCap;lineDashOffset:number;lineJoin:CanvasLineJoin;lineWidth:number;miterLimit:number;getLineDash():number[];setLineDash(segments:number[]):void;}interface CanvasPattern{setTransform(transform?:DOMMatrix2DInit):void;}declare var CanvasPattern:{prototype:CanvasPattern;new():CanvasPattern;};interface CanvasRect{clearRect(x:number,y:number,w:number,h:number):void;fillRect(x:number,y:number,w:number,h:number):void;strokeRect(x:number,y:number,w:number,h:number):void;}interface CanvasShadowStyles{shadowBlur:number;shadowColor:string;shadowOffsetX:number;shadowOffsetY:number;}interface CanvasState{restore():void;save():void;}interface CanvasText{fillText(text:string,x:number,y:number,maxWidth?:number):void;measureText(text:string):TextMetrics;strokeText(text:string,x:number,y:number,maxWidth?:number):void;}interface CanvasTextDrawingStyles{direction:CanvasDirection;font:string;textAlign:CanvasTextAlign;textBaseline:CanvasTextBaseline;}interface CanvasTransform{getTransform():DOMMatrix;resetTransform():void;rotate(angle:number):void;scale(x:number,y:number):void;setTransform(a:number,b:number,c:number,d:number,e:number,f:number):void;setTransform(transform?:DOMMatrix2DInit):void;transform(a:number,b:number,c:number,d:number,e:number,f:number):void;translate(x:number,y:number):void;}interface Client{readonly frameType:FrameType;readonly id:string;readonly type:ClientTypes;readonly url:string;postMessage(message:any,transfer?:Transferable[]):void;}declare var Client:{prototype:Client;new():Client;};interface Clients{claim():Promise<void>;get(id:string):Promise<any>;matchAll(options?:ClientQueryOptions):Promise<ReadonlyArray<Client>>;openWindow(url:string):Promise<WindowClient|null>;}declare var Clients:{prototype:Clients;new():Clients;};interface CloseEvent extends Event{readonly code:number;readonly reason:string;readonly wasClean:boolean;}declare var CloseEvent:{prototype:CloseEvent;new(type:string,eventInitDict?:CloseEventInit):CloseEvent;};interface ConcatParams extends Algorithm{algorithmId:Uint8Array;hash?:string|Algorithm;partyUInfo:Uint8Array;partyVInfo:Uint8Array;privateInfo?:Uint8Array;publicInfo?:Uint8Array;}interface CountQueuingStrategy extends QueuingStrategy{highWaterMark:number;size(chunk:any):1;}declare var CountQueuingStrategy:{prototype:CountQueuingStrategy;new(options:{highWaterMark:number}):CountQueuingStrategy;};interface Crypto{readonly subtle:SubtleCrypto;getRandomValues<T extends Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|null>(array:T):T;}declare var Crypto:{prototype:Crypto;new():Crypto;};interface CryptoKey{readonly algorithm:KeyAlgorithm;readonly extractable:boolean;readonly type:KeyType;readonly usages:KeyUsage[];}declare var CryptoKey:{prototype:CryptoKey;new():CryptoKey;};interface CustomEvent<T=any>extends Event{readonly detail:T;initCustomEvent(typeArg:string,canBubbleArg:boolean,cancelableArg:boolean,detailArg:T):void;}declare var CustomEvent:{prototype:CustomEvent;new<T>(typeArg:string,eventInitDict?:CustomEventInit<T>):CustomEvent<T>;};interface DOMException{readonly code:number;readonly message:string;readonly name:string;readonly ABORT_ERR:number;readonly DATA_CLONE_ERR:number;readonly DOMSTRING_SIZE_ERR:number;readonly HIERARCHY_REQUEST_ERR:number;readonly INDEX_SIZE_ERR:number;readonly INUSE_ATTRIBUTE_ERR:number;readonly INVALID_ACCESS_ERR:number;readonly INVALID_CHARACTER_ERR:number;readonly INVALID_MODIFICATION_ERR:number;readonly INVALID_NODE_TYPE_ERR:number;readonly INVALID_STATE_ERR:number;readonly NAMESPACE_ERR:number;readonly NETWORK_ERR:number;readonly NOT_FOUND_ERR:number;readonly NOT_SUPPORTED_ERR:number;readonly NO_DATA_ALLOWED_ERR:number;readonly NO_MODIFICATION_ALLOWED_ERR:number;readonly QUOTA_EXCEEDED_ERR:number;readonly SECURITY_ERR:number;readonly SYNTAX_ERR:number;readonly TIMEOUT_ERR:number;readonly TYPE_MISMATCH_ERR:number;readonly URL_MISMATCH_ERR:number;readonly VALIDATION_ERR:number;readonly WRONG_DOCUMENT_ERR:number;}declare var DOMException:{prototype:DOMException;new(message?:string,name?:string):DOMException;readonly ABORT_ERR:number;readonly DATA_CLONE_ERR:number;readonly DOMSTRING_SIZE_ERR:number;readonly HIERARCHY_REQUEST_ERR:number;readonly INDEX_SIZE_ERR:number;readonly INUSE_ATTRIBUTE_ERR:number;readonly INVALID_ACCESS_ERR:number;readonly INVALID_CHARACTER_ERR:number;readonly INVALID_MODIFICATION_ERR:number;readonly INVALID_NODE_TYPE_ERR:number;readonly INVALID_STATE_ERR:number;readonly NAMESPACE_ERR:number;readonly NETWORK_ERR:number;readonly NOT_FOUND_ERR:number;readonly NOT_SUPPORTED_ERR:number;readonly NO_DATA_ALLOWED_ERR:number;readonly NO_MODIFICATION_ALLOWED_ERR:number;readonly QUOTA_EXCEEDED_ERR:number;readonly SECURITY_ERR:number;readonly SYNTAX_ERR:number;readonly TIMEOUT_ERR:number;readonly TYPE_MISMATCH_ERR:number;readonly URL_MISMATCH_ERR:number;readonly VALIDATION_ERR:number;readonly WRONG_DOCUMENT_ERR:number;};interface DOMMatrix extends DOMMatrixReadOnly{a:number;b:number;c:number;d:number;e:number;f:number;m11:number;m12:number;m13:number;m14:number;m21:number;m22:number;m23:number;m24:number;m31:number;m32:number;m33:number;m34:number;m41:number;m42:number;m43:number;m44:number;invertSelf():DOMMatrix;multiplySelf(other?:DOMMatrixInit):DOMMatrix;preMultiplySelf(other?:DOMMatrixInit):DOMMatrix;rotateAxisAngleSelf(x?:number,y?:number,z?:number,angle?:number):DOMMatrix;rotateFromVectorSelf(x?:number,y?:number):DOMMatrix;rotateSelf(rotX?:number,rotY?:number,rotZ?:number):DOMMatrix;scale3dSelf(scale?:number,originX?:number,originY?:number,originZ?:number):DOMMatrix;scaleSelf(scaleX?:number,scaleY?:number,scaleZ?:number,originX?:number,originY?:number,originZ?:number):DOMMatrix;skewXSelf(sx?:number):DOMMatrix;skewYSelf(sy?:number):DOMMatrix;translateSelf(tx?:number,ty?:number,tz?:number):DOMMatrix;}declare var DOMMatrix:{prototype:DOMMatrix;new(init?:string|number[]):DOMMatrix;fromFloat32Array(array32:Float32Array):DOMMatrix;fromFloat64Array(array64:Float64Array):DOMMatrix;fromMatrix(other?:DOMMatrixInit):DOMMatrix;};interface DOMMatrixReadOnly{readonly a:number;readonly b:number;readonly c:number;readonly d:number;readonly e:number;readonly f:number;readonly is2D:boolean;readonly isIdentity:boolean;readonly m11:number;readonly m12:number;readonly m13:number;readonly m14:number;readonly m21:number;readonly m22:number;readonly m23:number;readonly m24:number;readonly m31:number;readonly m32:number;readonly m33:number;readonly m34:number;readonly m41:number;readonly m42:number;readonly m43:number;readonly m44:number;flipX():DOMMatrix;flipY():DOMMatrix;inverse():DOMMatrix;multiply(other?:DOMMatrixInit):DOMMatrix;rotate(rotX?:number,rotY?:number,rotZ?:number):DOMMatrix;rotateAxisAngle(x?:number,y?:number,z?:number,angle?:number):DOMMatrix;rotateFromVector(x?:number,y?:number):DOMMatrix;scale(scaleX?:number,scaleY?:number,scaleZ?:number,originX?:number,originY?:number,originZ?:number):DOMMatrix;scale3d(scale?:number,originX?:number,originY?:number,originZ?:number):DOMMatrix;scaleNonUniform(scaleX?:number,scaleY?:number):DOMMatrix;skewX(sx?:number):DOMMatrix;skewY(sy?:number):DOMMatrix;toFloat32Array():Float32Array;toFloat64Array():Float64Array;toJSON():any;transformPoint(point?:DOMPointInit):DOMPoint;translate(tx?:number,ty?:number,tz?:number):DOMMatrix;}declare var DOMMatrixReadOnly:{prototype:DOMMatrixReadOnly;new(init?:string|number[]):DOMMatrixReadOnly;fromFloat32Array(array32:Float32Array):DOMMatrixReadOnly;fromFloat64Array(array64:Float64Array):DOMMatrixReadOnly;fromMatrix(other?:DOMMatrixInit):DOMMatrixReadOnly;};interface DOMPoint extends DOMPointReadOnly{w:number;x:number;y:number;z:number;}declare var DOMPoint:{prototype:DOMPoint;new(x?:number,y?:number,z?:number,w?:number):DOMPoint;fromPoint(other?:DOMPointInit):DOMPoint;};interface DOMPointReadOnly{readonly w:number;readonly x:number;readonly y:number;readonly z:number;matrixTransform(matrix?:DOMMatrixInit):DOMPoint;toJSON():any;}declare var DOMPointReadOnly:{prototype:DOMPointReadOnly;new(x?:number,y?:number,z?:number,w?:number):DOMPointReadOnly;fromPoint(other?:DOMPointInit):DOMPointReadOnly;};interface DOMQuad{readonly p1:DOMPoint;readonly p2:DOMPoint;readonly p3:DOMPoint;readonly p4:DOMPoint;getBounds():DOMRect;toJSON():any;}declare var DOMQuad:{prototype:DOMQuad;new(p1?:DOMPointInit,p2?:DOMPointInit,p3?:DOMPointInit,p4?:DOMPointInit):DOMQuad;fromQuad(other?:DOMQuadInit):DOMQuad;fromRect(other?:DOMRectInit):DOMQuad;};interface DOMRect extends DOMRectReadOnly{height:number;width:number;x:number;y:number;}declare var DOMRect:{prototype:DOMRect;new(x?:number,y?:number,width?:number,height?:number):DOMRect;fromRect(other?:DOMRectInit):DOMRect;};interface DOMRectReadOnly{readonly bottom:number;readonly height:number;readonly left:number;readonly right:number;readonly top:number;readonly width:number;readonly x:number;readonly y:number;toJSON():any;}declare var DOMRectReadOnly:{prototype:DOMRectReadOnly;new(x?:number,y?:number,width?:number,height?:number):DOMRectReadOnly;fromRect(other?:DOMRectInit):DOMRectReadOnly;};interface DOMStringList{readonly length:number;contains(string:string):boolean;item(index:number):string|null;[index:number]:string;}declare var DOMStringList:{prototype:DOMStringList;new():DOMStringList;};interface DedicatedWorkerGlobalScopeEventMap extends WorkerGlobalScopeEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface DedicatedWorkerGlobalScope extends WorkerGlobalScope,AnimationFrameProvider{readonly name:string;onmessage:((this:DedicatedWorkerGlobalScope,ev:MessageEvent)=>any)|null;onmessageerror:((this:DedicatedWorkerGlobalScope,ev:MessageEvent)=>any)|null;close():void;postMessage(message:any,transfer:Transferable[]):void;postMessage(message:any,options?:PostMessageOptions):void;addEventListener<K extends keyof DedicatedWorkerGlobalScopeEventMap>(type:K,listener:(this:DedicatedWorkerGlobalScope,ev:DedicatedWorkerGlobalScopeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof DedicatedWorkerGlobalScopeEventMap>(type:K,listener:(this:DedicatedWorkerGlobalScope,ev:DedicatedWorkerGlobalScopeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var DedicatedWorkerGlobalScope:{prototype:DedicatedWorkerGlobalScope;new():DedicatedWorkerGlobalScope;};interface DhImportKeyParams extends Algorithm{generator:Uint8Array;prime:Uint8Array;}interface DhKeyAlgorithm extends KeyAlgorithm{generator:Uint8Array;prime:Uint8Array;}interface DhKeyDeriveParams extends Algorithm{public:CryptoKey;}interface DhKeyGenParams extends Algorithm{generator:Uint8Array;prime:Uint8Array;}interface EXT_blend_minmax{readonly MAX_EXT:GLenum;readonly MIN_EXT:GLenum;}interface EXT_frag_depth{}interface EXT_sRGB{readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT:GLenum;readonly SRGB8_ALPHA8_EXT:GLenum;readonly SRGB_ALPHA_EXT:GLenum;readonly SRGB_EXT:GLenum;}interface EXT_shader_texture_lod{}interface EXT_texture_filter_anisotropic{readonly MAX_TEXTURE_MAX_ANISOTROPY_EXT:GLenum;readonly TEXTURE_MAX_ANISOTROPY_EXT:GLenum;}interface ErrorEvent extends Event{readonly colno:number;readonly error:any;readonly filename:string;readonly lineno:number;readonly message:string;}declare var ErrorEvent:{prototype:ErrorEvent;new(type:string,eventInitDict?:ErrorEventInit):ErrorEvent;};interface Event{readonly bubbles:boolean;cancelBubble:boolean;readonly cancelable:boolean;readonly composed:boolean;readonly currentTarget:EventTarget|null;readonly defaultPrevented:boolean;readonly eventPhase:number;readonly isTrusted:boolean;returnValue:boolean;readonly srcElement:EventTarget|null;readonly target:EventTarget|null;readonly timeStamp:number;readonly type:string;composedPath():EventTarget[];initEvent(type:string,bubbles?:boolean,cancelable?:boolean):void;preventDefault():void;stopImmediatePropagation():void;stopPropagation():void;readonly AT_TARGET:number;readonly BUBBLING_PHASE:number;readonly CAPTURING_PHASE:number;readonly NONE:number;}declare var Event:{prototype:Event;new(type:string,eventInitDict?:EventInit):Event;readonly AT_TARGET:number;readonly BUBBLING_PHASE:number;readonly CAPTURING_PHASE:number;readonly NONE:number;};interface EventListenerObject{handleEvent(evt:Event):void;}interface EventSourceEventMap{"error":Event;"message":MessageEvent;"open":Event;}interface EventSource extends EventTarget{onerror:((this:EventSource,ev:Event)=>any)|null;onmessage:((this:EventSource,ev:MessageEvent)=>any)|null;onopen:((this:EventSource,ev:Event)=>any)|null;readonly readyState:number;readonly url:string;readonly withCredentials:boolean;close():void;readonly CLOSED:number;readonly CONNECTING:number;readonly OPEN:number;addEventListener<K extends keyof EventSourceEventMap>(type:K,listener:(this:EventSource,ev:EventSourceEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof EventSourceEventMap>(type:K,listener:(this:EventSource,ev:EventSourceEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var EventSource:{prototype:EventSource;new(url:string,eventSourceInitDict?:EventSourceInit):EventSource;readonly CLOSED:number;readonly CONNECTING:number;readonly OPEN:number;};interface EventTarget{addEventListener(type:string,listener:EventListenerOrEventListenerObject|null,options?:boolean|AddEventListenerOptions):void;dispatchEvent(event:Event):boolean;removeEventListener(type:string,callback:EventListenerOrEventListenerObject|null,options?:EventListenerOptions|boolean):void;}declare var EventTarget:{prototype:EventTarget;new():EventTarget;};interface ExtendableEvent extends Event{waitUntil(f:any):void;}declare var ExtendableEvent:{prototype:ExtendableEvent;new(type:string,eventInitDict?:ExtendableEventInit):ExtendableEvent;};interface ExtendableMessageEvent extends ExtendableEvent{readonly data:any;readonly lastEventId:string;readonly origin:string;readonly ports:ReadonlyArray<MessagePort>;readonly source:Client|ServiceWorker|MessagePort|null;}declare var ExtendableMessageEvent:{prototype:ExtendableMessageEvent;new(type:string,eventInitDict?:ExtendableMessageEventInit):ExtendableMessageEvent;};interface FetchEvent extends ExtendableEvent{readonly clientId:string;readonly preloadResponse:Promise<any>;readonly replacesClientId:string;readonly request:Request;readonly resultingClientId:string;respondWith(r:Response|Promise<Response>):void;}declare var FetchEvent:{prototype:FetchEvent;new(type:string,eventInitDict:FetchEventInit):FetchEvent;};interface File extends Blob{readonly lastModified:number;readonly name:string;}declare var File:{prototype:File;new(fileBits:BlobPart[],fileName:string,options?:FilePropertyBag):File;};interface FileList{readonly length:number;item(index:number):File|null;[index:number]:File;}declare var FileList:{prototype:FileList;new():FileList;};interface FileReaderEventMap{"abort":ProgressEvent<FileReader>;"error":ProgressEvent<FileReader>;"load":ProgressEvent<FileReader>;"loadend":ProgressEvent<FileReader>;"loadstart":ProgressEvent<FileReader>;"progress":ProgressEvent<FileReader>;}interface FileReader extends EventTarget{readonly error:DOMException|null;onabort:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onerror:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onload:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onloadend:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onloadstart:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;onprogress:((this:FileReader,ev:ProgressEvent<FileReader>)=>any)|null;readonly readyState:number;readonly result:string|ArrayBuffer|null;abort():void;readAsArrayBuffer(blob:Blob):void;readAsBinaryString(blob:Blob):void;readAsDataURL(blob:Blob):void;readAsText(blob:Blob,encoding?:string):void;readonly DONE:number;readonly EMPTY:number;readonly LOADING:number;addEventListener<K extends keyof FileReaderEventMap>(type:K,listener:(this:FileReader,ev:FileReaderEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof FileReaderEventMap>(type:K,listener:(this:FileReader,ev:FileReaderEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var FileReader:{prototype:FileReader;new():FileReader;readonly DONE:number;readonly EMPTY:number;readonly LOADING:number;};interface FileReaderSync{readAsArrayBuffer(blob:Blob):ArrayBuffer;readAsBinaryString(blob:Blob):string;readAsDataURL(blob:Blob):string;readAsText(blob:Blob,encoding?:string):string;}declare var FileReaderSync:{prototype:FileReaderSync;new():FileReaderSync;};interface FormData{append(name:string,value:string|Blob,fileName?:string):void;delete(name:string):void;get(name:string):FormDataEntryValue|null;getAll(name:string):FormDataEntryValue[];has(name:string):boolean;set(name:string,value:string|Blob,fileName?:string):void;forEach(callbackfn:(value:FormDataEntryValue,key:string,parent:FormData)=>void,thisArg?:any):void;}declare var FormData:{prototype:FormData;new():FormData;};interface GenericTransformStream{readonly readable:ReadableStream;readonly writable:WritableStream;}interface Headers{append(name:string,value:string):void;delete(name:string):void;get(name:string):string|null;has(name:string):boolean;set(name:string,value:string):void;forEach(callbackfn:(value:string,key:string,parent:Headers)=>void,thisArg?:any):void;}declare var Headers:{prototype:Headers;new(init?:HeadersInit):Headers;};interface HkdfCtrParams extends Algorithm{context:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;hash:string|Algorithm;label:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer;}interface IDBArrayKey extends Array<IDBValidKey>{}interface IDBCursor{readonly direction:IDBCursorDirection;readonly key:IDBValidKey;readonly primaryKey:IDBValidKey;readonly source:IDBObjectStore|IDBIndex;advance(count:number):void;continue(key?:IDBValidKey):void;continuePrimaryKey(key:IDBValidKey,primaryKey:IDBValidKey):void;delete():IDBRequest<undefined>;update(value:any):IDBRequest<IDBValidKey>;}declare var IDBCursor:{prototype:IDBCursor;new():IDBCursor;};interface IDBCursorWithValue extends IDBCursor{readonly value:any;}declare var IDBCursorWithValue:{prototype:IDBCursorWithValue;new():IDBCursorWithValue;};interface IDBDatabaseEventMap{"abort":Event;"close":Event;"error":Event;"versionchange":IDBVersionChangeEvent;}interface IDBDatabase extends EventTarget{readonly name:string;readonly objectStoreNames:DOMStringList;onabort:((this:IDBDatabase,ev:Event)=>any)|null;onclose:((this:IDBDatabase,ev:Event)=>any)|null;onerror:((this:IDBDatabase,ev:Event)=>any)|null;onversionchange:((this:IDBDatabase,ev:IDBVersionChangeEvent)=>any)|null;readonly version:number;close():void;createObjectStore(name:string,optionalParameters?:IDBObjectStoreParameters):IDBObjectStore;deleteObjectStore(name:string):void;transaction(storeNames:string|string[],mode?:IDBTransactionMode):IDBTransaction;addEventListener<K extends keyof IDBDatabaseEventMap>(type:K,listener:(this:IDBDatabase,ev:IDBDatabaseEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof IDBDatabaseEventMap>(type:K,listener:(this:IDBDatabase,ev:IDBDatabaseEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var IDBDatabase:{prototype:IDBDatabase;new():IDBDatabase;};interface IDBFactory{cmp(first:any,second:any):number;deleteDatabase(name:string):IDBOpenDBRequest;open(name:string,version?:number):IDBOpenDBRequest;}declare var IDBFactory:{prototype:IDBFactory;new():IDBFactory;};interface IDBIndex{readonly keyPath:string|string[];readonly multiEntry:boolean;name:string;readonly objectStore:IDBObjectStore;readonly unique:boolean;count(key?:IDBValidKey|IDBKeyRange):IDBRequest<number>;get(key:IDBValidKey|IDBKeyRange):IDBRequest<any|undefined>;getAll(query?:IDBValidKey|IDBKeyRange|null,count?:number):IDBRequest<any[]>;getAllKeys(query?:IDBValidKey|IDBKeyRange|null,count?:number):IDBRequest<IDBValidKey[]>;getKey(key:IDBValidKey|IDBKeyRange):IDBRequest<IDBValidKey|undefined>;openCursor(query?:IDBValidKey|IDBKeyRange|null,direction?:IDBCursorDirection):IDBRequest<IDBCursorWithValue|null>;openKeyCursor(query?:IDBValidKey|IDBKeyRange|null,direction?:IDBCursorDirection):IDBRequest<IDBCursor|null>;}declare var IDBIndex:{prototype:IDBIndex;new():IDBIndex;};interface IDBKeyRange{readonly lower:any;readonly lowerOpen:boolean;readonly upper:any;readonly upperOpen:boolean;includes(key:any):boolean;}declare var IDBKeyRange:{prototype:IDBKeyRange;new():IDBKeyRange;bound(lower:any,upper:any,lowerOpen?:boolean,upperOpen?:boolean):IDBKeyRange;lowerBound(lower:any,open?:boolean):IDBKeyRange;only(value:any):IDBKeyRange;upperBound(upper:any,open?:boolean):IDBKeyRange;};interface IDBObjectStore{readonly autoIncrement:boolean;readonly indexNames:DOMStringList;readonly keyPath:string|string[];name:string;readonly transaction:IDBTransaction;add(value:any,key?:IDBValidKey):IDBRequest<IDBValidKey>;clear():IDBRequest<undefined>;count(key?:IDBValidKey|IDBKeyRange):IDBRequest<number>;createIndex(name:string,keyPath:string|string[],options?:IDBIndexParameters):IDBIndex;delete(key:IDBValidKey|IDBKeyRange):IDBRequest<undefined>;deleteIndex(name:string):void;get(query:IDBValidKey|IDBKeyRange):IDBRequest<any|undefined>;getAll(query?:IDBValidKey|IDBKeyRange|null,count?:number):IDBRequest<any[]>;getAllKeys(query?:IDBValidKey|IDBKeyRange|null,count?:number):IDBRequest<IDBValidKey[]>;getKey(query:IDBValidKey|IDBKeyRange):IDBRequest<IDBValidKey|undefined>;index(name:string):IDBIndex;openCursor(query?:IDBValidKey|IDBKeyRange|null,direction?:IDBCursorDirection):IDBRequest<IDBCursorWithValue|null>;openKeyCursor(query?:IDBValidKey|IDBKeyRange|null,direction?:IDBCursorDirection):IDBRequest<IDBCursor|null>;put(value:any,key?:IDBValidKey):IDBRequest<IDBValidKey>;}declare var IDBObjectStore:{prototype:IDBObjectStore;new():IDBObjectStore;};interface IDBOpenDBRequestEventMap extends IDBRequestEventMap{"blocked":Event;"upgradeneeded":IDBVersionChangeEvent;}interface IDBOpenDBRequest extends IDBRequest<IDBDatabase>{onblocked:((this:IDBOpenDBRequest,ev:Event)=>any)|null;onupgradeneeded:((this:IDBOpenDBRequest,ev:IDBVersionChangeEvent)=>any)|null;addEventListener<K extends keyof IDBOpenDBRequestEventMap>(type:K,listener:(this:IDBOpenDBRequest,ev:IDBOpenDBRequestEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof IDBOpenDBRequestEventMap>(type:K,listener:(this:IDBOpenDBRequest,ev:IDBOpenDBRequestEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var IDBOpenDBRequest:{prototype:IDBOpenDBRequest;new():IDBOpenDBRequest;};interface IDBRequestEventMap{"error":Event;"success":Event;}interface IDBRequest<T=any>extends EventTarget{readonly error:DOMException|null;onerror:((this:IDBRequest<T>,ev:Event)=>any)|null;onsuccess:((this:IDBRequest<T>,ev:Event)=>any)|null;readonly readyState:IDBRequestReadyState;readonly result:T;readonly source:IDBObjectStore|IDBIndex|IDBCursor;readonly transaction:IDBTransaction|null;addEventListener<K extends keyof IDBRequestEventMap>(type:K,listener:(this:IDBRequest<T>,ev:IDBRequestEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof IDBRequestEventMap>(type:K,listener:(this:IDBRequest<T>,ev:IDBRequestEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var IDBRequest:{prototype:IDBRequest;new():IDBRequest;};interface IDBTransactionEventMap{"abort":Event;"complete":Event;"error":Event;}interface IDBTransaction extends EventTarget{readonly db:IDBDatabase;readonly error:DOMException;readonly mode:IDBTransactionMode;readonly objectStoreNames:DOMStringList;onabort:((this:IDBTransaction,ev:Event)=>any)|null;oncomplete:((this:IDBTransaction,ev:Event)=>any)|null;onerror:((this:IDBTransaction,ev:Event)=>any)|null;abort():void;objectStore(name:string):IDBObjectStore;addEventListener<K extends keyof IDBTransactionEventMap>(type:K,listener:(this:IDBTransaction,ev:IDBTransactionEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof IDBTransactionEventMap>(type:K,listener:(this:IDBTransaction,ev:IDBTransactionEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var IDBTransaction:{prototype:IDBTransaction;new():IDBTransaction;};interface IDBVersionChangeEvent extends Event{readonly newVersion:number|null;readonly oldVersion:number;}declare var IDBVersionChangeEvent:{prototype:IDBVersionChangeEvent;new(type:string,eventInitDict?:IDBVersionChangeEventInit):IDBVersionChangeEvent;};interface ImageBitmap{readonly height:number;readonly width:number;close():void;}declare var ImageBitmap:{prototype:ImageBitmap;new():ImageBitmap;};interface ImageBitmapRenderingContext{readonly canvas:OffscreenCanvas;transferFromImageBitmap(bitmap:ImageBitmap|null):void;}declare var ImageBitmapRenderingContext:{prototype:ImageBitmapRenderingContext;new():ImageBitmapRenderingContext;};interface ImageData{readonly data:Uint8ClampedArray;readonly height:number;readonly width:number;}declare var ImageData:{prototype:ImageData;new(width:number,height:number):ImageData;new(array:Uint8ClampedArray,width:number,height?:number):ImageData;};interface MessageChannel{readonly port1:MessagePort;readonly port2:MessagePort;}declare var MessageChannel:{prototype:MessageChannel;new():MessageChannel;};interface MessageEvent extends Event{readonly data:any;readonly lastEventId:string;readonly origin:string;readonly ports:ReadonlyArray<MessagePort>;readonly source:MessageEventSource|null;}declare var MessageEvent:{prototype:MessageEvent;new(type:string,eventInitDict?:MessageEventInit):MessageEvent;};interface MessagePortEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface MessagePort extends EventTarget{onmessage:((this:MessagePort,ev:MessageEvent)=>any)|null;onmessageerror:((this:MessagePort,ev:MessageEvent)=>any)|null;close():void;postMessage(message:any,transfer:Transferable[]):void;postMessage(message:any,options?:PostMessageOptions):void;start():void;addEventListener<K extends keyof MessagePortEventMap>(type:K,listener:(this:MessagePort,ev:MessagePortEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof MessagePortEventMap>(type:K,listener:(this:MessagePort,ev:MessagePortEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var MessagePort:{prototype:MessagePort;new():MessagePort;};interface NavigationPreloadManager{disable():Promise<void>;enable():Promise<void>;getState():Promise<NavigationPreloadState>;setHeaderValue(value:string):Promise<void>;}declare var NavigationPreloadManager:{prototype:NavigationPreloadManager;new():NavigationPreloadManager;};interface NavigatorConcurrentHardware{readonly hardwareConcurrency:number;}interface NavigatorID{readonly appCodeName:string;readonly appName:string;readonly appVersion:string;readonly platform:string;readonly product:string;readonly userAgent:string;}interface NavigatorLanguage{readonly language:string;readonly languages:ReadonlyArray<string>;}interface NavigatorOnLine{readonly onLine:boolean;}interface NavigatorStorage{readonly storage:StorageManager;}interface NotificationEventMap{"click":Event;"close":Event;"error":Event;"show":Event;}interface Notification extends EventTarget{readonly actions:ReadonlyArray<NotificationAction>;readonly badge:string;readonly body:string;readonly data:any;readonly dir:NotificationDirection;readonly icon:string;readonly image:string;readonly lang:string;onclick:((this:Notification,ev:Event)=>any)|null;onclose:((this:Notification,ev:Event)=>any)|null;onerror:((this:Notification,ev:Event)=>any)|null;onshow:((this:Notification,ev:Event)=>any)|null;readonly renotify:boolean;readonly requireInteraction:boolean;readonly silent:boolean;readonly tag:string;readonly timestamp:number;readonly title:string;readonly vibrate:ReadonlyArray<number>;close():void;addEventListener<K extends keyof NotificationEventMap>(type:K,listener:(this:Notification,ev:NotificationEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof NotificationEventMap>(type:K,listener:(this:Notification,ev:NotificationEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var Notification:{prototype:Notification;new(title:string,options?:NotificationOptions):Notification;readonly maxActions:number;readonly permission:NotificationPermission;};interface NotificationEvent extends ExtendableEvent{readonly action:string;readonly notification:Notification;}declare var NotificationEvent:{prototype:NotificationEvent;new(type:string,eventInitDict:NotificationEventInit):NotificationEvent;};interface OES_element_index_uint{}interface OES_standard_derivatives{readonly FRAGMENT_SHADER_DERIVATIVE_HINT_OES:GLenum;}interface OES_texture_float{}interface OES_texture_float_linear{}interface OES_texture_half_float{readonly HALF_FLOAT_OES:GLenum;}interface OES_texture_half_float_linear{}interface OES_vertex_array_object{bindVertexArrayOES(arrayObject:WebGLVertexArrayObjectOES|null):void;createVertexArrayOES():WebGLVertexArrayObjectOES|null;deleteVertexArrayOES(arrayObject:WebGLVertexArrayObjectOES|null):void;isVertexArrayOES(arrayObject:WebGLVertexArrayObjectOES|null):GLboolean;readonly VERTEX_ARRAY_BINDING_OES:GLenum;}interface OffscreenCanvas extends EventTarget{height:number;width:number;convertToBlob(options?:ImageEncodeOptions):Promise<Blob>;getContext(contextId:"2d",options?:CanvasRenderingContext2DSettings):OffscreenCanvasRenderingContext2D|null;getContext(contextId:"bitmaprenderer",options?:ImageBitmapRenderingContextSettings):ImageBitmapRenderingContext|null;getContext(contextId:"webgl",options?:WebGLContextAttributes):WebGLRenderingContext|null;getContext(contextId:"webgl2",options?:WebGLContextAttributes):WebGL2RenderingContext|null;getContext(contextId:OffscreenRenderingContextId,options?:any):OffscreenRenderingContext|null;transferToImageBitmap():ImageBitmap;}declare var OffscreenCanvas:{prototype:OffscreenCanvas;new(width:number,height:number):OffscreenCanvas;};interface OffscreenCanvasRenderingContext2D extends CanvasCompositing,CanvasDrawImage,CanvasDrawPath,CanvasFillStrokeStyles,CanvasFilters,CanvasImageData,CanvasImageSmoothing,CanvasPath,CanvasPathDrawingStyles,CanvasRect,CanvasShadowStyles,CanvasState,CanvasText,CanvasTextDrawingStyles,CanvasTransform{readonly canvas:OffscreenCanvas;commit():void;}declare var OffscreenCanvasRenderingContext2D:{prototype:OffscreenCanvasRenderingContext2D;new():OffscreenCanvasRenderingContext2D;};interface Path2D extends CanvasPath{addPath(path:Path2D,transform?:DOMMatrix2DInit):void;}declare var Path2D:{prototype:Path2D;new(path?:Path2D|string):Path2D;};interface PerformanceEventMap{"resourcetimingbufferfull":Event;}interface Performance extends EventTarget{onresourcetimingbufferfull:((this:Performance,ev:Event)=>any)|null;readonly timeOrigin:number;clearMarks(markName?:string):void;clearMeasures(measureName?:string):void;clearResourceTimings():void;getEntries():PerformanceEntryList;getEntriesByName(name:string,type?:string):PerformanceEntryList;getEntriesByType(type:string):PerformanceEntryList;mark(markName:string):void;measure(measureName:string,startMark?:string,endMark?:string):void;now():number;setResourceTimingBufferSize(maxSize:number):void;toJSON():any;addEventListener<K extends keyof PerformanceEventMap>(type:K,listener:(this:Performance,ev:PerformanceEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof PerformanceEventMap>(type:K,listener:(this:Performance,ev:PerformanceEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var Performance:{prototype:Performance;new():Performance;};interface PerformanceEntry{readonly duration:number;readonly entryType:string;readonly name:string;readonly startTime:number;toJSON():any;}declare var PerformanceEntry:{prototype:PerformanceEntry;new():PerformanceEntry;};interface PerformanceMark extends PerformanceEntry{}declare var PerformanceMark:{prototype:PerformanceMark;new():PerformanceMark;};interface PerformanceMeasure extends PerformanceEntry{}declare var PerformanceMeasure:{prototype:PerformanceMeasure;new():PerformanceMeasure;};interface PerformanceObserver{disconnect():void;observe(options?:PerformanceObserverInit):void;takeRecords():PerformanceEntryList;}declare var PerformanceObserver:{prototype:PerformanceObserver;new(callback:PerformanceObserverCallback):PerformanceObserver;readonly supportedEntryTypes:ReadonlyArray<string>;};interface PerformanceObserverEntryList{getEntries():PerformanceEntryList;getEntriesByName(name:string,type?:string):PerformanceEntryList;getEntriesByType(type:string):PerformanceEntryList;}declare var PerformanceObserverEntryList:{prototype:PerformanceObserverEntryList;new():PerformanceObserverEntryList;};interface PerformanceResourceTiming extends PerformanceEntry{readonly connectEnd:number;readonly connectStart:number;readonly decodedBodySize:number;readonly domainLookupEnd:number;readonly domainLookupStart:number;readonly encodedBodySize:number;readonly fetchStart:number;readonly initiatorType:string;readonly nextHopProtocol:string;readonly redirectEnd:number;readonly redirectStart:number;readonly requestStart:number;readonly responseEnd:number;readonly responseStart:number;readonly secureConnectionStart:number;readonly transferSize:number;readonly workerStart:number;toJSON():any;}declare var PerformanceResourceTiming:{prototype:PerformanceResourceTiming;new():PerformanceResourceTiming;};interface PermissionStatusEventMap{"change":Event;}interface PermissionStatus extends EventTarget{onchange:((this:PermissionStatus,ev:Event)=>any)|null;readonly state:PermissionState;addEventListener<K extends keyof PermissionStatusEventMap>(type:K,listener:(this:PermissionStatus,ev:PermissionStatusEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof PermissionStatusEventMap>(type:K,listener:(this:PermissionStatus,ev:PermissionStatusEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var PermissionStatus:{prototype:PermissionStatus;new():PermissionStatus;};interface Permissions{query(permissionDesc:PermissionDescriptor|DevicePermissionDescriptor|MidiPermissionDescriptor|PushPermissionDescriptor):Promise<PermissionStatus>;}declare var Permissions:{prototype:Permissions;new():Permissions;};interface ProgressEvent<T extends EventTarget=EventTarget>extends Event{readonly lengthComputable:boolean;readonly loaded:number;readonly target:T|null;readonly total:number;}declare var ProgressEvent:{prototype:ProgressEvent;new(type:string,eventInitDict?:ProgressEventInit):ProgressEvent;};interface PromiseRejectionEvent extends Event{readonly promise:Promise<any>;readonly reason:any;}declare var PromiseRejectionEvent:{prototype:PromiseRejectionEvent;new(type:string,eventInitDict:PromiseRejectionEventInit):PromiseRejectionEvent;};interface PushEvent extends ExtendableEvent{readonly data:PushMessageData|null;}declare var PushEvent:{prototype:PushEvent;new(type:string,eventInitDict?:PushEventInit):PushEvent;};interface PushManager{getSubscription():Promise<PushSubscription|null>;permissionState(options?:PushSubscriptionOptionsInit):Promise<PushPermissionState>;subscribe(options?:PushSubscriptionOptionsInit):Promise<PushSubscription>;}declare var PushManager:{prototype:PushManager;new():PushManager;readonly supportedContentEncodings:ReadonlyArray<string>;};interface PushMessageData{arrayBuffer():ArrayBuffer;blob():Blob;json():any;text():string;}declare var PushMessageData:{prototype:PushMessageData;new():PushMessageData;};interface PushSubscription{readonly endpoint:string;readonly expirationTime:number|null;readonly options:PushSubscriptionOptions;getKey(name:PushEncryptionKeyName):ArrayBuffer|null;toJSON():PushSubscriptionJSON;unsubscribe():Promise<boolean>;}declare var PushSubscription:{prototype:PushSubscription;new():PushSubscription;};interface PushSubscriptionChangeEvent extends ExtendableEvent{readonly newSubscription:PushSubscription|null;readonly oldSubscription:PushSubscription|null;}declare var PushSubscriptionChangeEvent:{prototype:PushSubscriptionChangeEvent;new(type:string,eventInitDict?:PushSubscriptionChangeEventInit):PushSubscriptionChangeEvent;};interface PushSubscriptionOptions{readonly applicationServerKey:ArrayBuffer|null;readonly userVisibleOnly:boolean;}declare var PushSubscriptionOptions:{prototype:PushSubscriptionOptions;new():PushSubscriptionOptions;};interface ReadableByteStreamController{readonly byobRequest:ReadableStreamBYOBRequest|undefined;readonly desiredSize:number|null;close():void;enqueue(chunk:ArrayBufferView):void;error(error?:any):void;}interface ReadableStream<R=any>{readonly locked:boolean;cancel(reason?:any):Promise<void>;getReader(options:{mode:"byob"}):ReadableStreamBYOBReader;getReader():ReadableStreamDefaultReader<R>;pipeThrough<T>({writable,readable}:{writable:WritableStream<R>,readable:ReadableStream<T>},options?:PipeOptions):ReadableStream<T>;pipeTo(dest:WritableStream<R>,options?:PipeOptions):Promise<void>;tee():[ReadableStream<R>,ReadableStream<R>];}declare var ReadableStream:{prototype:ReadableStream;new(underlyingSource:UnderlyingByteSource,strategy?:{highWaterMark?:number,size?:undefined}):ReadableStream<Uint8Array>;new<R=any>(underlyingSource?:UnderlyingSource<R>,strategy?:QueuingStrategy<R>):ReadableStream<R>;};interface ReadableStreamBYOBReader{readonly closed:Promise<void>;cancel(reason?:any):Promise<void>;read<T extends ArrayBufferView>(view:T):Promise<ReadableStreamReadResult<T>>;releaseLock():void;}interface ReadableStreamBYOBRequest{readonly view:ArrayBufferView;respond(bytesWritten:number):void;respondWithNewView(view:ArrayBufferView):void;}interface ReadableStreamDefaultController<R=any>{readonly desiredSize:number|null;close():void;enqueue(chunk:R):void;error(error?:any):void;}interface ReadableStreamDefaultReader<R=any>{readonly closed:Promise<void>;cancel(reason?:any):Promise<void>;read():Promise<ReadableStreamReadResult<R>>;releaseLock():void;}interface ReadableStreamReader<R=any>{cancel():Promise<void>;read():Promise<ReadableStreamReadResult<R>>;releaseLock():void;}declare var ReadableStreamReader:{prototype:ReadableStreamReader;new():ReadableStreamReader;};interface Request extends Body{readonly cache:RequestCache;readonly credentials:RequestCredentials;readonly destination:RequestDestination;readonly headers:Headers;readonly integrity:string;readonly isHistoryNavigation:boolean;readonly isReloadNavigation:boolean;readonly keepalive:boolean;readonly method:string;readonly mode:RequestMode;readonly redirect:RequestRedirect;readonly referrer:string;readonly referrerPolicy:ReferrerPolicy;readonly signal:AbortSignal;readonly url:string;clone():Request;}declare var Request:{prototype:Request;new(input:RequestInfo,init?:RequestInit):Request;};interface Response extends Body{readonly headers:Headers;readonly ok:boolean;readonly redirected:boolean;readonly status:number;readonly statusText:string;readonly trailer:Promise<Headers>;readonly type:ResponseType;readonly url:string;clone():Response;}declare var Response:{prototype:Response;new(body?:BodyInit|null,init?:ResponseInit):Response;error():Response;redirect(url:string,status?:number):Response;};interface ServiceWorkerEventMap extends AbstractWorkerEventMap{"statechange":Event;}interface ServiceWorker extends EventTarget,AbstractWorker{onstatechange:((this:ServiceWorker,ev:Event)=>any)|null;readonly scriptURL:string;readonly state:ServiceWorkerState;postMessage(message:any,transfer:Transferable[]):void;postMessage(message:any,options?:PostMessageOptions):void;addEventListener<K extends keyof ServiceWorkerEventMap>(type:K,listener:(this:ServiceWorker,ev:ServiceWorkerEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ServiceWorkerEventMap>(type:K,listener:(this:ServiceWorker,ev:ServiceWorkerEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ServiceWorker:{prototype:ServiceWorker;new():ServiceWorker;};interface ServiceWorkerContainerEventMap{"controllerchange":Event;"message":MessageEvent;"messageerror":MessageEvent;}interface ServiceWorkerContainer extends EventTarget{readonly controller:ServiceWorker|null;oncontrollerchange:((this:ServiceWorkerContainer,ev:Event)=>any)|null;onmessage:((this:ServiceWorkerContainer,ev:MessageEvent)=>any)|null;onmessageerror:((this:ServiceWorkerContainer,ev:MessageEvent)=>any)|null;readonly ready:Promise<ServiceWorkerRegistration>;getRegistration(clientURL?:string):Promise<ServiceWorkerRegistration|undefined>;getRegistrations():Promise<ReadonlyArray<ServiceWorkerRegistration>>;register(scriptURL:string,options?:RegistrationOptions):Promise<ServiceWorkerRegistration>;startMessages():void;addEventListener<K extends keyof ServiceWorkerContainerEventMap>(type:K,listener:(this:ServiceWorkerContainer,ev:ServiceWorkerContainerEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ServiceWorkerContainerEventMap>(type:K,listener:(this:ServiceWorkerContainer,ev:ServiceWorkerContainerEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ServiceWorkerContainer:{prototype:ServiceWorkerContainer;new():ServiceWorkerContainer;};interface ServiceWorkerGlobalScopeEventMap extends WorkerGlobalScopeEventMap{"activate":ExtendableEvent;"fetch":FetchEvent;"install":ExtendableEvent;"message":ExtendableMessageEvent;"messageerror":MessageEvent;"notificationclick":NotificationEvent;"notificationclose":NotificationEvent;"push":PushEvent;"pushsubscriptionchange":PushSubscriptionChangeEvent;"sync":SyncEvent;}interface ServiceWorkerGlobalScope extends WorkerGlobalScope{readonly clients:Clients;onactivate:((this:ServiceWorkerGlobalScope,ev:ExtendableEvent)=>any)|null;onfetch:((this:ServiceWorkerGlobalScope,ev:FetchEvent)=>any)|null;oninstall:((this:ServiceWorkerGlobalScope,ev:ExtendableEvent)=>any)|null;onmessage:((this:ServiceWorkerGlobalScope,ev:ExtendableMessageEvent)=>any)|null;onmessageerror:((this:ServiceWorkerGlobalScope,ev:MessageEvent)=>any)|null;onnotificationclick:((this:ServiceWorkerGlobalScope,ev:NotificationEvent)=>any)|null;onnotificationclose:((this:ServiceWorkerGlobalScope,ev:NotificationEvent)=>any)|null;onpush:((this:ServiceWorkerGlobalScope,ev:PushEvent)=>any)|null;onpushsubscriptionchange:((this:ServiceWorkerGlobalScope,ev:PushSubscriptionChangeEvent)=>any)|null;onsync:((this:ServiceWorkerGlobalScope,ev:SyncEvent)=>any)|null;readonly registration:ServiceWorkerRegistration;readonly serviceWorker:ServiceWorker;skipWaiting():Promise<void>;addEventListener<K extends keyof ServiceWorkerGlobalScopeEventMap>(type:K,listener:(this:ServiceWorkerGlobalScope,ev:ServiceWorkerGlobalScopeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ServiceWorkerGlobalScopeEventMap>(type:K,listener:(this:ServiceWorkerGlobalScope,ev:ServiceWorkerGlobalScopeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ServiceWorkerGlobalScope:{prototype:ServiceWorkerGlobalScope;new():ServiceWorkerGlobalScope;};interface ServiceWorkerRegistrationEventMap{"updatefound":Event;}interface ServiceWorkerRegistration extends EventTarget{readonly active:ServiceWorker|null;readonly installing:ServiceWorker|null;readonly navigationPreload:NavigationPreloadManager;onupdatefound:((this:ServiceWorkerRegistration,ev:Event)=>any)|null;readonly pushManager:PushManager;readonly scope:string;readonly sync:SyncManager;readonly updateViaCache:ServiceWorkerUpdateViaCache;readonly waiting:ServiceWorker|null;getNotifications(filter?:GetNotificationOptions):Promise<Notification[]>;showNotification(title:string,options?:NotificationOptions):Promise<void>;unregister():Promise<boolean>;update():Promise<void>;addEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type:K,listener:(this:ServiceWorkerRegistration,ev:ServiceWorkerRegistrationEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof ServiceWorkerRegistrationEventMap>(type:K,listener:(this:ServiceWorkerRegistration,ev:ServiceWorkerRegistrationEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var ServiceWorkerRegistration:{prototype:ServiceWorkerRegistration;new():ServiceWorkerRegistration;};interface SharedWorker extends EventTarget,AbstractWorker{readonly port:MessagePort;addEventListener<K extends keyof AbstractWorkerEventMap>(type:K,listener:(this:SharedWorker,ev:AbstractWorkerEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof AbstractWorkerEventMap>(type:K,listener:(this:SharedWorker,ev:AbstractWorkerEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SharedWorker:{prototype:SharedWorker;new(scriptURL:string,options?:string|WorkerOptions):SharedWorker;};interface SharedWorkerGlobalScopeEventMap extends WorkerGlobalScopeEventMap{"connect":MessageEvent;}interface SharedWorkerGlobalScope extends WorkerGlobalScope{readonly name:string;onconnect:((this:SharedWorkerGlobalScope,ev:MessageEvent)=>any)|null;close():void;addEventListener<K extends keyof SharedWorkerGlobalScopeEventMap>(type:K,listener:(this:SharedWorkerGlobalScope,ev:SharedWorkerGlobalScopeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof SharedWorkerGlobalScopeEventMap>(type:K,listener:(this:SharedWorkerGlobalScope,ev:SharedWorkerGlobalScopeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var SharedWorkerGlobalScope:{prototype:SharedWorkerGlobalScope;new():SharedWorkerGlobalScope;};interface StorageManager{estimate():Promise<StorageEstimate>;persisted():Promise<boolean>;}declare var StorageManager:{prototype:StorageManager;new():StorageManager;};interface SubtleCrypto{decrypt(algorithm:AlgorithmIdentifier|RsaOaepParams|AesCtrParams|AesCbcParams|AesCmacParams|AesGcmParams|AesCfbParams,key:CryptoKey,data:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer):PromiseLike<ArrayBuffer>;deriveBits(algorithm:AlgorithmIdentifier|EcdhKeyDeriveParams|DhKeyDeriveParams|ConcatParams|HkdfCtrParams|Pbkdf2Params,baseKey:CryptoKey,length:number):PromiseLike<ArrayBuffer>;deriveKey(algorithm:AlgorithmIdentifier|EcdhKeyDeriveParams|DhKeyDeriveParams|ConcatParams|HkdfCtrParams|Pbkdf2Params,baseKey:CryptoKey,derivedKeyType:string|AesDerivedKeyParams|HmacImportParams|ConcatParams|HkdfCtrParams|Pbkdf2Params,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;digest(algorithm:AlgorithmIdentifier,data:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer):PromiseLike<ArrayBuffer>;encrypt(algorithm:AlgorithmIdentifier|RsaOaepParams|AesCtrParams|AesCbcParams|AesCmacParams|AesGcmParams|AesCfbParams,key:CryptoKey,data:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer):PromiseLike<ArrayBuffer>;exportKey(format:"jwk",key:CryptoKey):PromiseLike<JsonWebKey>;exportKey(format:"raw"|"pkcs8"|"spki",key:CryptoKey):PromiseLike<ArrayBuffer>;exportKey(format:string,key:CryptoKey):PromiseLike<JsonWebKey|ArrayBuffer>;generateKey(algorithm:AlgorithmIdentifier,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKeyPair|CryptoKey>;generateKey(algorithm:RsaHashedKeyGenParams|EcKeyGenParams|DhKeyGenParams,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKeyPair>;generateKey(algorithm:AesKeyGenParams|HmacKeyGenParams|Pbkdf2Params,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;importKey(format:"jwk",keyData:JsonWebKey,algorithm:AlgorithmIdentifier|RsaHashedImportParams|EcKeyImportParams|HmacImportParams|DhImportKeyParams|AesKeyAlgorithm,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;importKey(format:"raw"|"pkcs8"|"spki",keyData:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer,algorithm:AlgorithmIdentifier|RsaHashedImportParams|EcKeyImportParams|HmacImportParams|DhImportKeyParams|AesKeyAlgorithm,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;importKey(format:string,keyData:JsonWebKey|Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer,algorithm:AlgorithmIdentifier|RsaHashedImportParams|EcKeyImportParams|HmacImportParams|DhImportKeyParams|AesKeyAlgorithm,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;sign(algorithm:AlgorithmIdentifier|RsaPssParams|EcdsaParams|AesCmacParams,key:CryptoKey,data:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer):PromiseLike<ArrayBuffer>;unwrapKey(format:"raw"|"pkcs8"|"spki"|"jwk"|string,wrappedKey:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer,unwrappingKey:CryptoKey,unwrapAlgorithm:AlgorithmIdentifier|RsaOaepParams|AesCtrParams|AesCbcParams|AesCmacParams|AesGcmParams|AesCfbParams,unwrappedKeyAlgorithm:AlgorithmIdentifier|RsaHashedImportParams|EcKeyImportParams|HmacImportParams|DhImportKeyParams|AesKeyAlgorithm,extractable:boolean,keyUsages:KeyUsage[]):PromiseLike<CryptoKey>;verify(algorithm:AlgorithmIdentifier|RsaPssParams|EcdsaParams|AesCmacParams,key:CryptoKey,signature:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer,data:Int8Array|Int16Array|Int32Array|Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|Float32Array|Float64Array|DataView|ArrayBuffer):PromiseLike<boolean>;wrapKey(format:"raw"|"pkcs8"|"spki"|"jwk"|string,key:CryptoKey,wrappingKey:CryptoKey,wrapAlgorithm:AlgorithmIdentifier|RsaOaepParams|AesCtrParams|AesCbcParams|AesCmacParams|AesGcmParams|AesCfbParams):PromiseLike<ArrayBuffer>;}declare var SubtleCrypto:{prototype:SubtleCrypto;new():SubtleCrypto;};interface SyncEvent extends ExtendableEvent{readonly lastChance:boolean;readonly tag:string;}declare var SyncEvent:{prototype:SyncEvent;new(type:string,init:SyncEventInit):SyncEvent;};interface SyncManager{getTags():Promise<string[]>;register(tag:string):Promise<void>;}declare var SyncManager:{prototype:SyncManager;new():SyncManager;};interface TextDecoder extends TextDecoderCommon{decode(input?:BufferSource,options?:TextDecodeOptions):string;}declare var TextDecoder:{prototype:TextDecoder;new(label?:string,options?:TextDecoderOptions):TextDecoder;};interface TextDecoderCommon{readonly encoding:string;readonly fatal:boolean;readonly ignoreBOM:boolean;}interface TextDecoderStream extends GenericTransformStream,TextDecoderCommon{readonly readable:ReadableStream<string>;readonly writable:WritableStream<BufferSource>;}declare var TextDecoderStream:{prototype:TextDecoderStream;new(label?:string,options?:TextDecoderOptions):TextDecoderStream;};interface TextEncoder extends TextEncoderCommon{encode(input?:string):Uint8Array;encodeInto(source:string,destination:Uint8Array):TextEncoderEncodeIntoResult;}declare var TextEncoder:{prototype:TextEncoder;new():TextEncoder;};interface TextEncoderCommon{readonly encoding:string;}interface TextEncoderStream extends GenericTransformStream,TextEncoderCommon{readonly readable:ReadableStream<Uint8Array>;readonly writable:WritableStream<string>;}declare var TextEncoderStream:{prototype:TextEncoderStream;new():TextEncoderStream;};interface TextMetrics{readonly actualBoundingBoxAscent:number;readonly actualBoundingBoxDescent:number;readonly actualBoundingBoxLeft:number;readonly actualBoundingBoxRight:number;readonly alphabeticBaseline:number;readonly emHeightAscent:number;readonly emHeightDescent:number;readonly fontBoundingBoxAscent:number;readonly fontBoundingBoxDescent:number;readonly hangingBaseline:number;readonly ideographicBaseline:number;readonly width:number;}declare var TextMetrics:{prototype:TextMetrics;new():TextMetrics;};interface TransformStream<I=any,O=any>{readonly readable:ReadableStream<O>;readonly writable:WritableStream<I>;}declare var TransformStream:{prototype:TransformStream;new<I=any,O=any>(transformer?:Transformer<I,O>,writableStrategy?:QueuingStrategy<I>,readableStrategy?:QueuingStrategy<O>):TransformStream<I,O>;};interface TransformStreamDefaultController<O=any>{readonly desiredSize:number|null;enqueue(chunk:O):void;error(reason?:any):void;terminate():void;}interface URL{hash:string;host:string;hostname:string;href:string;toString():string;readonly origin:string;password:string;pathname:string;port:string;protocol:string;search:string;readonly searchParams:URLSearchParams;username:string;toJSON():string;}declare var URL:{prototype:URL;new(url:string,base?:string|URL):URL;createObjectURL(object:any):string;revokeObjectURL(url:string):void;};interface URLSearchParams{append(name:string,value:string):void;delete(name:string):void;get(name:string):string|null;getAll(name:string):string[];has(name:string):boolean;set(name:string,value:string):void;sort():void;toString():string;forEach(callbackfn:(value:string,key:string,parent:URLSearchParams)=>void,thisArg?:any):void;}declare var URLSearchParams:{prototype:URLSearchParams;new(init?:string[][]|Record<string,string>|string|URLSearchParams):URLSearchParams;toString():string;};interface WEBGL_color_buffer_float{readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT:GLenum;readonly RGBA32F_EXT:GLenum;readonly UNSIGNED_NORMALIZED_EXT:GLenum;}interface WEBGL_compressed_texture_astc{getSupportedProfiles():string[];readonly COMPRESSED_RGBA_ASTC_10x10_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_10x5_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_10x6_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_10x8_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_12x10_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_12x12_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_4x4_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_5x4_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_5x5_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_6x5_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_6x6_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_8x5_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_8x6_KHR:GLenum;readonly COMPRESSED_RGBA_ASTC_8x8_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:GLenum;readonly COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:GLenum;}interface WEBGL_compressed_texture_s3tc{readonly COMPRESSED_RGBA_S3TC_DXT1_EXT:GLenum;readonly COMPRESSED_RGBA_S3TC_DXT3_EXT:GLenum;readonly COMPRESSED_RGBA_S3TC_DXT5_EXT:GLenum;readonly COMPRESSED_RGB_S3TC_DXT1_EXT:GLenum;}interface WEBGL_compressed_texture_s3tc_srgb{readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:GLenum;readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:GLenum;readonly COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:GLenum;readonly COMPRESSED_SRGB_S3TC_DXT1_EXT:GLenum;}interface WEBGL_debug_renderer_info{readonly UNMASKED_RENDERER_WEBGL:GLenum;readonly UNMASKED_VENDOR_WEBGL:GLenum;}interface WEBGL_debug_shaders{getTranslatedShaderSource(shader:WebGLShader):string;}interface WEBGL_depth_texture{readonly UNSIGNED_INT_24_8_WEBGL:GLenum;}interface WEBGL_draw_buffers{drawBuffersWEBGL(buffers:GLenum[]):void;readonly COLOR_ATTACHMENT0_WEBGL:GLenum;readonly COLOR_ATTACHMENT10_WEBGL:GLenum;readonly COLOR_ATTACHMENT11_WEBGL:GLenum;readonly COLOR_ATTACHMENT12_WEBGL:GLenum;readonly COLOR_ATTACHMENT13_WEBGL:GLenum;readonly COLOR_ATTACHMENT14_WEBGL:GLenum;readonly COLOR_ATTACHMENT15_WEBGL:GLenum;readonly COLOR_ATTACHMENT1_WEBGL:GLenum;readonly COLOR_ATTACHMENT2_WEBGL:GLenum;readonly COLOR_ATTACHMENT3_WEBGL:GLenum;readonly COLOR_ATTACHMENT4_WEBGL:GLenum;readonly COLOR_ATTACHMENT5_WEBGL:GLenum;readonly COLOR_ATTACHMENT6_WEBGL:GLenum;readonly COLOR_ATTACHMENT7_WEBGL:GLenum;readonly COLOR_ATTACHMENT8_WEBGL:GLenum;readonly COLOR_ATTACHMENT9_WEBGL:GLenum;readonly DRAW_BUFFER0_WEBGL:GLenum;readonly DRAW_BUFFER10_WEBGL:GLenum;readonly DRAW_BUFFER11_WEBGL:GLenum;readonly DRAW_BUFFER12_WEBGL:GLenum;readonly DRAW_BUFFER13_WEBGL:GLenum;readonly DRAW_BUFFER14_WEBGL:GLenum;readonly DRAW_BUFFER15_WEBGL:GLenum;readonly DRAW_BUFFER1_WEBGL:GLenum;readonly DRAW_BUFFER2_WEBGL:GLenum;readonly DRAW_BUFFER3_WEBGL:GLenum;readonly DRAW_BUFFER4_WEBGL:GLenum;readonly DRAW_BUFFER5_WEBGL:GLenum;readonly DRAW_BUFFER6_WEBGL:GLenum;readonly DRAW_BUFFER7_WEBGL:GLenum;readonly DRAW_BUFFER8_WEBGL:GLenum;readonly DRAW_BUFFER9_WEBGL:GLenum;readonly MAX_COLOR_ATTACHMENTS_WEBGL:GLenum;readonly MAX_DRAW_BUFFERS_WEBGL:GLenum;}interface WEBGL_lose_context{loseContext():void;restoreContext():void;}interface WebGL2RenderingContext extends WebGL2RenderingContextBase,WebGL2RenderingContextOverloads,WebGLRenderingContextBase{}declare var WebGL2RenderingContext:{prototype:WebGL2RenderingContext;new():WebGL2RenderingContext;readonly ACTIVE_ATTRIBUTES:GLenum;readonly ACTIVE_TEXTURE:GLenum;readonly ACTIVE_UNIFORMS:GLenum;readonly ALIASED_LINE_WIDTH_RANGE:GLenum;readonly ALIASED_POINT_SIZE_RANGE:GLenum;readonly ALPHA:GLenum;readonly ALPHA_BITS:GLenum;readonly ALWAYS:GLenum;readonly ARRAY_BUFFER:GLenum;readonly ARRAY_BUFFER_BINDING:GLenum;readonly ATTACHED_SHADERS:GLenum;readonly BACK:GLenum;readonly BLEND:GLenum;readonly BLEND_COLOR:GLenum;readonly BLEND_DST_ALPHA:GLenum;readonly BLEND_DST_RGB:GLenum;readonly BLEND_EQUATION:GLenum;readonly BLEND_EQUATION_ALPHA:GLenum;readonly BLEND_EQUATION_RGB:GLenum;readonly BLEND_SRC_ALPHA:GLenum;readonly BLEND_SRC_RGB:GLenum;readonly BLUE_BITS:GLenum;readonly BOOL:GLenum;readonly BOOL_VEC2:GLenum;readonly BOOL_VEC3:GLenum;readonly BOOL_VEC4:GLenum;readonly BROWSER_DEFAULT_WEBGL:GLenum;readonly BUFFER_SIZE:GLenum;readonly BUFFER_USAGE:GLenum;readonly BYTE:GLenum;readonly CCW:GLenum;readonly CLAMP_TO_EDGE:GLenum;readonly COLOR_ATTACHMENT0:GLenum;readonly COLOR_BUFFER_BIT:GLenum;readonly COLOR_CLEAR_VALUE:GLenum;readonly COLOR_WRITEMASK:GLenum;readonly COMPILE_STATUS:GLenum;readonly COMPRESSED_TEXTURE_FORMATS:GLenum;readonly CONSTANT_ALPHA:GLenum;readonly CONSTANT_COLOR:GLenum;readonly CONTEXT_LOST_WEBGL:GLenum;readonly CULL_FACE:GLenum;readonly CULL_FACE_MODE:GLenum;readonly CURRENT_PROGRAM:GLenum;readonly CURRENT_VERTEX_ATTRIB:GLenum;readonly CW:GLenum;readonly DECR:GLenum;readonly DECR_WRAP:GLenum;readonly DELETE_STATUS:GLenum;readonly DEPTH_ATTACHMENT:GLenum;readonly DEPTH_BITS:GLenum;readonly DEPTH_BUFFER_BIT:GLenum;readonly DEPTH_CLEAR_VALUE:GLenum;readonly DEPTH_COMPONENT:GLenum;readonly DEPTH_COMPONENT16:GLenum;readonly DEPTH_FUNC:GLenum;readonly DEPTH_RANGE:GLenum;readonly DEPTH_STENCIL:GLenum;readonly DEPTH_STENCIL_ATTACHMENT:GLenum;readonly DEPTH_TEST:GLenum;readonly DEPTH_WRITEMASK:GLenum;readonly DITHER:GLenum;readonly DONT_CARE:GLenum;readonly DST_ALPHA:GLenum;readonly DST_COLOR:GLenum;readonly DYNAMIC_DRAW:GLenum;readonly ELEMENT_ARRAY_BUFFER:GLenum;readonly ELEMENT_ARRAY_BUFFER_BINDING:GLenum;readonly EQUAL:GLenum;readonly FASTEST:GLenum;readonly FLOAT:GLenum;readonly FLOAT_MAT2:GLenum;readonly FLOAT_MAT3:GLenum;readonly FLOAT_MAT4:GLenum;readonly FLOAT_VEC2:GLenum;readonly FLOAT_VEC3:GLenum;readonly FLOAT_VEC4:GLenum;readonly FRAGMENT_SHADER:GLenum;readonly FRAMEBUFFER:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:GLenum;readonly FRAMEBUFFER_BINDING:GLenum;readonly FRAMEBUFFER_COMPLETE:GLenum;readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT:GLenum;readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS:GLenum;readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:GLenum;readonly FRAMEBUFFER_UNSUPPORTED:GLenum;readonly FRONT:GLenum;readonly FRONT_AND_BACK:GLenum;readonly FRONT_FACE:GLenum;readonly FUNC_ADD:GLenum;readonly FUNC_REVERSE_SUBTRACT:GLenum;readonly FUNC_SUBTRACT:GLenum;readonly GENERATE_MIPMAP_HINT:GLenum;readonly GEQUAL:GLenum;readonly GREATER:GLenum;readonly GREEN_BITS:GLenum;readonly HIGH_FLOAT:GLenum;readonly HIGH_INT:GLenum;readonly IMPLEMENTATION_COLOR_READ_FORMAT:GLenum;readonly IMPLEMENTATION_COLOR_READ_TYPE:GLenum;readonly INCR:GLenum;readonly INCR_WRAP:GLenum;readonly INT:GLenum;readonly INT_VEC2:GLenum;readonly INT_VEC3:GLenum;readonly INT_VEC4:GLenum;readonly INVALID_ENUM:GLenum;readonly INVALID_FRAMEBUFFER_OPERATION:GLenum;readonly INVALID_OPERATION:GLenum;readonly INVALID_VALUE:GLenum;readonly INVERT:GLenum;readonly KEEP:GLenum;readonly LEQUAL:GLenum;readonly LESS:GLenum;readonly LINEAR:GLenum;readonly LINEAR_MIPMAP_LINEAR:GLenum;readonly LINEAR_MIPMAP_NEAREST:GLenum;readonly LINES:GLenum;readonly LINE_LOOP:GLenum;readonly LINE_STRIP:GLenum;readonly LINE_WIDTH:GLenum;readonly LINK_STATUS:GLenum;readonly LOW_FLOAT:GLenum;readonly LOW_INT:GLenum;readonly LUMINANCE:GLenum;readonly LUMINANCE_ALPHA:GLenum;readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_CUBE_MAP_TEXTURE_SIZE:GLenum;readonly MAX_FRAGMENT_UNIFORM_VECTORS:GLenum;readonly MAX_RENDERBUFFER_SIZE:GLenum;readonly MAX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_TEXTURE_SIZE:GLenum;readonly MAX_VARYING_VECTORS:GLenum;readonly MAX_VERTEX_ATTRIBS:GLenum;readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_VERTEX_UNIFORM_VECTORS:GLenum;readonly MAX_VIEWPORT_DIMS:GLenum;readonly MEDIUM_FLOAT:GLenum;readonly MEDIUM_INT:GLenum;readonly MIRRORED_REPEAT:GLenum;readonly NEAREST:GLenum;readonly NEAREST_MIPMAP_LINEAR:GLenum;readonly NEAREST_MIPMAP_NEAREST:GLenum;readonly NEVER:GLenum;readonly NICEST:GLenum;readonly NONE:GLenum;readonly NOTEQUAL:GLenum;readonly NO_ERROR:GLenum;readonly ONE:GLenum;readonly ONE_MINUS_CONSTANT_ALPHA:GLenum;readonly ONE_MINUS_CONSTANT_COLOR:GLenum;readonly ONE_MINUS_DST_ALPHA:GLenum;readonly ONE_MINUS_DST_COLOR:GLenum;readonly ONE_MINUS_SRC_ALPHA:GLenum;readonly ONE_MINUS_SRC_COLOR:GLenum;readonly OUT_OF_MEMORY:GLenum;readonly PACK_ALIGNMENT:GLenum;readonly POINTS:GLenum;readonly POLYGON_OFFSET_FACTOR:GLenum;readonly POLYGON_OFFSET_FILL:GLenum;readonly POLYGON_OFFSET_UNITS:GLenum;readonly RED_BITS:GLenum;readonly RENDERBUFFER:GLenum;readonly RENDERBUFFER_ALPHA_SIZE:GLenum;readonly RENDERBUFFER_BINDING:GLenum;readonly RENDERBUFFER_BLUE_SIZE:GLenum;readonly RENDERBUFFER_DEPTH_SIZE:GLenum;readonly RENDERBUFFER_GREEN_SIZE:GLenum;readonly RENDERBUFFER_HEIGHT:GLenum;readonly RENDERBUFFER_INTERNAL_FORMAT:GLenum;readonly RENDERBUFFER_RED_SIZE:GLenum;readonly RENDERBUFFER_STENCIL_SIZE:GLenum;readonly RENDERBUFFER_WIDTH:GLenum;readonly RENDERER:GLenum;readonly REPEAT:GLenum;readonly REPLACE:GLenum;readonly RGB:GLenum;readonly RGB565:GLenum;readonly RGB5_A1:GLenum;readonly RGBA:GLenum;readonly RGBA4:GLenum;readonly SAMPLER_2D:GLenum;readonly SAMPLER_CUBE:GLenum;readonly SAMPLES:GLenum;readonly SAMPLE_ALPHA_TO_COVERAGE:GLenum;readonly SAMPLE_BUFFERS:GLenum;readonly SAMPLE_COVERAGE:GLenum;readonly SAMPLE_COVERAGE_INVERT:GLenum;readonly SAMPLE_COVERAGE_VALUE:GLenum;readonly SCISSOR_BOX:GLenum;readonly SCISSOR_TEST:GLenum;readonly SHADER_TYPE:GLenum;readonly SHADING_LANGUAGE_VERSION:GLenum;readonly SHORT:GLenum;readonly SRC_ALPHA:GLenum;readonly SRC_ALPHA_SATURATE:GLenum;readonly SRC_COLOR:GLenum;readonly STATIC_DRAW:GLenum;readonly STENCIL_ATTACHMENT:GLenum;readonly STENCIL_BACK_FAIL:GLenum;readonly STENCIL_BACK_FUNC:GLenum;readonly STENCIL_BACK_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_BACK_PASS_DEPTH_PASS:GLenum;readonly STENCIL_BACK_REF:GLenum;readonly STENCIL_BACK_VALUE_MASK:GLenum;readonly STENCIL_BACK_WRITEMASK:GLenum;readonly STENCIL_BITS:GLenum;readonly STENCIL_BUFFER_BIT:GLenum;readonly STENCIL_CLEAR_VALUE:GLenum;readonly STENCIL_FAIL:GLenum;readonly STENCIL_FUNC:GLenum;readonly STENCIL_INDEX8:GLenum;readonly STENCIL_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_PASS_DEPTH_PASS:GLenum;readonly STENCIL_REF:GLenum;readonly STENCIL_TEST:GLenum;readonly STENCIL_VALUE_MASK:GLenum;readonly STENCIL_WRITEMASK:GLenum;readonly STREAM_DRAW:GLenum;readonly SUBPIXEL_BITS:GLenum;readonly TEXTURE:GLenum;readonly TEXTURE0:GLenum;readonly TEXTURE1:GLenum;readonly TEXTURE10:GLenum;readonly TEXTURE11:GLenum;readonly TEXTURE12:GLenum;readonly TEXTURE13:GLenum;readonly TEXTURE14:GLenum;readonly TEXTURE15:GLenum;readonly TEXTURE16:GLenum;readonly TEXTURE17:GLenum;readonly TEXTURE18:GLenum;readonly TEXTURE19:GLenum;readonly TEXTURE2:GLenum;readonly TEXTURE20:GLenum;readonly TEXTURE21:GLenum;readonly TEXTURE22:GLenum;readonly TEXTURE23:GLenum;readonly TEXTURE24:GLenum;readonly TEXTURE25:GLenum;readonly TEXTURE26:GLenum;readonly TEXTURE27:GLenum;readonly TEXTURE28:GLenum;readonly TEXTURE29:GLenum;readonly TEXTURE3:GLenum;readonly TEXTURE30:GLenum;readonly TEXTURE31:GLenum;readonly TEXTURE4:GLenum;readonly TEXTURE5:GLenum;readonly TEXTURE6:GLenum;readonly TEXTURE7:GLenum;readonly TEXTURE8:GLenum;readonly TEXTURE9:GLenum;readonly TEXTURE_2D:GLenum;readonly TEXTURE_BINDING_2D:GLenum;readonly TEXTURE_BINDING_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Z:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Z:GLenum;readonly TEXTURE_MAG_FILTER:GLenum;readonly TEXTURE_MIN_FILTER:GLenum;readonly TEXTURE_WRAP_S:GLenum;readonly TEXTURE_WRAP_T:GLenum;readonly TRIANGLES:GLenum;readonly TRIANGLE_FAN:GLenum;readonly TRIANGLE_STRIP:GLenum;readonly UNPACK_ALIGNMENT:GLenum;readonly UNPACK_COLORSPACE_CONVERSION_WEBGL:GLenum;readonly UNPACK_FLIP_Y_WEBGL:GLenum;readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL:GLenum;readonly UNSIGNED_BYTE:GLenum;readonly UNSIGNED_INT:GLenum;readonly UNSIGNED_SHORT:GLenum;readonly UNSIGNED_SHORT_4_4_4_4:GLenum;readonly UNSIGNED_SHORT_5_5_5_1:GLenum;readonly UNSIGNED_SHORT_5_6_5:GLenum;readonly VALIDATE_STATUS:GLenum;readonly VENDOR:GLenum;readonly VERSION:GLenum;readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:GLenum;readonly VERTEX_ATTRIB_ARRAY_ENABLED:GLenum;readonly VERTEX_ATTRIB_ARRAY_NORMALIZED:GLenum;readonly VERTEX_ATTRIB_ARRAY_POINTER:GLenum;readonly VERTEX_ATTRIB_ARRAY_SIZE:GLenum;readonly VERTEX_ATTRIB_ARRAY_STRIDE:GLenum;readonly VERTEX_ATTRIB_ARRAY_TYPE:GLenum;readonly VERTEX_SHADER:GLenum;readonly VIEWPORT:GLenum;readonly ZERO:GLenum;readonly ACTIVE_UNIFORM_BLOCKS:GLenum;readonly ALREADY_SIGNALED:GLenum;readonly ANY_SAMPLES_PASSED:GLenum;readonly ANY_SAMPLES_PASSED_CONSERVATIVE:GLenum;readonly COLOR:GLenum;readonly COLOR_ATTACHMENT1:GLenum;readonly COLOR_ATTACHMENT10:GLenum;readonly COLOR_ATTACHMENT11:GLenum;readonly COLOR_ATTACHMENT12:GLenum;readonly COLOR_ATTACHMENT13:GLenum;readonly COLOR_ATTACHMENT14:GLenum;readonly COLOR_ATTACHMENT15:GLenum;readonly COLOR_ATTACHMENT2:GLenum;readonly COLOR_ATTACHMENT3:GLenum;readonly COLOR_ATTACHMENT4:GLenum;readonly COLOR_ATTACHMENT5:GLenum;readonly COLOR_ATTACHMENT6:GLenum;readonly COLOR_ATTACHMENT7:GLenum;readonly COLOR_ATTACHMENT8:GLenum;readonly COLOR_ATTACHMENT9:GLenum;readonly COMPARE_REF_TO_TEXTURE:GLenum;readonly CONDITION_SATISFIED:GLenum;readonly COPY_READ_BUFFER:GLenum;readonly COPY_READ_BUFFER_BINDING:GLenum;readonly COPY_WRITE_BUFFER:GLenum;readonly COPY_WRITE_BUFFER_BINDING:GLenum;readonly CURRENT_QUERY:GLenum;readonly DEPTH:GLenum;readonly DEPTH24_STENCIL8:GLenum;readonly DEPTH32F_STENCIL8:GLenum;readonly DEPTH_COMPONENT24:GLenum;readonly DEPTH_COMPONENT32F:GLenum;readonly DRAW_BUFFER0:GLenum;readonly DRAW_BUFFER1:GLenum;readonly DRAW_BUFFER10:GLenum;readonly DRAW_BUFFER11:GLenum;readonly DRAW_BUFFER12:GLenum;readonly DRAW_BUFFER13:GLenum;readonly DRAW_BUFFER14:GLenum;readonly DRAW_BUFFER15:GLenum;readonly DRAW_BUFFER2:GLenum;readonly DRAW_BUFFER3:GLenum;readonly DRAW_BUFFER4:GLenum;readonly DRAW_BUFFER5:GLenum;readonly DRAW_BUFFER6:GLenum;readonly DRAW_BUFFER7:GLenum;readonly DRAW_BUFFER8:GLenum;readonly DRAW_BUFFER9:GLenum;readonly DRAW_FRAMEBUFFER:GLenum;readonly DRAW_FRAMEBUFFER_BINDING:GLenum;readonly DYNAMIC_COPY:GLenum;readonly DYNAMIC_READ:GLenum;readonly FLOAT_32_UNSIGNED_INT_24_8_REV:GLenum;readonly FLOAT_MAT2x3:GLenum;readonly FLOAT_MAT2x4:GLenum;readonly FLOAT_MAT3x2:GLenum;readonly FLOAT_MAT3x4:GLenum;readonly FLOAT_MAT4x2:GLenum;readonly FLOAT_MAT4x3:GLenum;readonly FRAGMENT_SHADER_DERIVATIVE_HINT:GLenum;readonly FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:GLenum;readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_RED_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:GLenum;readonly FRAMEBUFFER_DEFAULT:GLenum;readonly FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:GLenum;readonly HALF_FLOAT:GLenum;readonly INTERLEAVED_ATTRIBS:GLenum;readonly INT_2_10_10_10_REV:GLenum;readonly INT_SAMPLER_2D:GLenum;readonly INT_SAMPLER_2D_ARRAY:GLenum;readonly INT_SAMPLER_3D:GLenum;readonly INT_SAMPLER_CUBE:GLenum;readonly INVALID_INDEX:GLenum;readonly MAX:GLenum;readonly MAX_3D_TEXTURE_SIZE:GLenum;readonly MAX_ARRAY_TEXTURE_LAYERS:GLenum;readonly MAX_CLIENT_WAIT_TIMEOUT_WEBGL:GLenum;readonly MAX_COLOR_ATTACHMENTS:GLenum;readonly MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:GLenum;readonly MAX_COMBINED_UNIFORM_BLOCKS:GLenum;readonly MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:GLenum;readonly MAX_DRAW_BUFFERS:GLenum;readonly MAX_ELEMENTS_INDICES:GLenum;readonly MAX_ELEMENTS_VERTICES:GLenum;readonly MAX_ELEMENT_INDEX:GLenum;readonly MAX_FRAGMENT_INPUT_COMPONENTS:GLenum;readonly MAX_FRAGMENT_UNIFORM_BLOCKS:GLenum;readonly MAX_FRAGMENT_UNIFORM_COMPONENTS:GLenum;readonly MAX_PROGRAM_TEXEL_OFFSET:GLenum;readonly MAX_SAMPLES:GLenum;readonly MAX_SERVER_WAIT_TIMEOUT:GLenum;readonly MAX_TEXTURE_LOD_BIAS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:GLenum;readonly MAX_UNIFORM_BLOCK_SIZE:GLenum;readonly MAX_UNIFORM_BUFFER_BINDINGS:GLenum;readonly MAX_VARYING_COMPONENTS:GLenum;readonly MAX_VERTEX_OUTPUT_COMPONENTS:GLenum;readonly MAX_VERTEX_UNIFORM_BLOCKS:GLenum;readonly MAX_VERTEX_UNIFORM_COMPONENTS:GLenum;readonly MIN:GLenum;readonly MIN_PROGRAM_TEXEL_OFFSET:GLenum;readonly OBJECT_TYPE:GLenum;readonly PACK_ROW_LENGTH:GLenum;readonly PACK_SKIP_PIXELS:GLenum;readonly PACK_SKIP_ROWS:GLenum;readonly PIXEL_PACK_BUFFER:GLenum;readonly PIXEL_PACK_BUFFER_BINDING:GLenum;readonly PIXEL_UNPACK_BUFFER:GLenum;readonly PIXEL_UNPACK_BUFFER_BINDING:GLenum;readonly QUERY_RESULT:GLenum;readonly QUERY_RESULT_AVAILABLE:GLenum;readonly R11F_G11F_B10F:GLenum;readonly R16F:GLenum;readonly R16I:GLenum;readonly R16UI:GLenum;readonly R32F:GLenum;readonly R32I:GLenum;readonly R32UI:GLenum;readonly R8:GLenum;readonly R8I:GLenum;readonly R8UI:GLenum;readonly R8_SNORM:GLenum;readonly RASTERIZER_DISCARD:GLenum;readonly READ_BUFFER:GLenum;readonly READ_FRAMEBUFFER:GLenum;readonly READ_FRAMEBUFFER_BINDING:GLenum;readonly RED:GLenum;readonly RED_INTEGER:GLenum;readonly RENDERBUFFER_SAMPLES:GLenum;readonly RG:GLenum;readonly RG16F:GLenum;readonly RG16I:GLenum;readonly RG16UI:GLenum;readonly RG32F:GLenum;readonly RG32I:GLenum;readonly RG32UI:GLenum;readonly RG8:GLenum;readonly RG8I:GLenum;readonly RG8UI:GLenum;readonly RG8_SNORM:GLenum;readonly RGB10_A2:GLenum;readonly RGB10_A2UI:GLenum;readonly RGB16F:GLenum;readonly RGB16I:GLenum;readonly RGB16UI:GLenum;readonly RGB32F:GLenum;readonly RGB32I:GLenum;readonly RGB32UI:GLenum;readonly RGB8:GLenum;readonly RGB8I:GLenum;readonly RGB8UI:GLenum;readonly RGB8_SNORM:GLenum;readonly RGB9_E5:GLenum;readonly RGBA16F:GLenum;readonly RGBA16I:GLenum;readonly RGBA16UI:GLenum;readonly RGBA32F:GLenum;readonly RGBA32I:GLenum;readonly RGBA32UI:GLenum;readonly RGBA8:GLenum;readonly RGBA8I:GLenum;readonly RGBA8UI:GLenum;readonly RGBA8_SNORM:GLenum;readonly RGBA_INTEGER:GLenum;readonly RGB_INTEGER:GLenum;readonly RG_INTEGER:GLenum;readonly SAMPLER_2D_ARRAY:GLenum;readonly SAMPLER_2D_ARRAY_SHADOW:GLenum;readonly SAMPLER_2D_SHADOW:GLenum;readonly SAMPLER_3D:GLenum;readonly SAMPLER_BINDING:GLenum;readonly SAMPLER_CUBE_SHADOW:GLenum;readonly SEPARATE_ATTRIBS:GLenum;readonly SIGNALED:GLenum;readonly SIGNED_NORMALIZED:GLenum;readonly SRGB:GLenum;readonly SRGB8:GLenum;readonly SRGB8_ALPHA8:GLenum;readonly STATIC_COPY:GLenum;readonly STATIC_READ:GLenum;readonly STENCIL:GLenum;readonly STREAM_COPY:GLenum;readonly STREAM_READ:GLenum;readonly SYNC_CONDITION:GLenum;readonly SYNC_FENCE:GLenum;readonly SYNC_FLAGS:GLenum;readonly SYNC_FLUSH_COMMANDS_BIT:GLenum;readonly SYNC_GPU_COMMANDS_COMPLETE:GLenum;readonly SYNC_STATUS:GLenum;readonly TEXTURE_2D_ARRAY:GLenum;readonly TEXTURE_3D:GLenum;readonly TEXTURE_BASE_LEVEL:GLenum;readonly TEXTURE_BINDING_2D_ARRAY:GLenum;readonly TEXTURE_BINDING_3D:GLenum;readonly TEXTURE_COMPARE_FUNC:GLenum;readonly TEXTURE_COMPARE_MODE:GLenum;readonly TEXTURE_IMMUTABLE_FORMAT:GLenum;readonly TEXTURE_IMMUTABLE_LEVELS:GLenum;readonly TEXTURE_MAX_LEVEL:GLenum;readonly TEXTURE_MAX_LOD:GLenum;readonly TEXTURE_MIN_LOD:GLenum;readonly TEXTURE_WRAP_R:GLenum;readonly TIMEOUT_EXPIRED:GLenum;readonly TIMEOUT_IGNORED:GLint64;readonly TRANSFORM_FEEDBACK:GLenum;readonly TRANSFORM_FEEDBACK_ACTIVE:GLenum;readonly TRANSFORM_FEEDBACK_BINDING:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_BINDING:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_MODE:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_SIZE:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_START:GLenum;readonly TRANSFORM_FEEDBACK_PAUSED:GLenum;readonly TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:GLenum;readonly TRANSFORM_FEEDBACK_VARYINGS:GLenum;readonly UNIFORM_ARRAY_STRIDE:GLenum;readonly UNIFORM_BLOCK_ACTIVE_UNIFORMS:GLenum;readonly UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:GLenum;readonly UNIFORM_BLOCK_BINDING:GLenum;readonly UNIFORM_BLOCK_DATA_SIZE:GLenum;readonly UNIFORM_BLOCK_INDEX:GLenum;readonly UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:GLenum;readonly UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:GLenum;readonly UNIFORM_BUFFER:GLenum;readonly UNIFORM_BUFFER_BINDING:GLenum;readonly UNIFORM_BUFFER_OFFSET_ALIGNMENT:GLenum;readonly UNIFORM_BUFFER_SIZE:GLenum;readonly UNIFORM_BUFFER_START:GLenum;readonly UNIFORM_IS_ROW_MAJOR:GLenum;readonly UNIFORM_MATRIX_STRIDE:GLenum;readonly UNIFORM_OFFSET:GLenum;readonly UNIFORM_SIZE:GLenum;readonly UNIFORM_TYPE:GLenum;readonly UNPACK_IMAGE_HEIGHT:GLenum;readonly UNPACK_ROW_LENGTH:GLenum;readonly UNPACK_SKIP_IMAGES:GLenum;readonly UNPACK_SKIP_PIXELS:GLenum;readonly UNPACK_SKIP_ROWS:GLenum;readonly UNSIGNALED:GLenum;readonly UNSIGNED_INT_10F_11F_11F_REV:GLenum;readonly UNSIGNED_INT_24_8:GLenum;readonly UNSIGNED_INT_2_10_10_10_REV:GLenum;readonly UNSIGNED_INT_5_9_9_9_REV:GLenum;readonly UNSIGNED_INT_SAMPLER_2D:GLenum;readonly UNSIGNED_INT_SAMPLER_2D_ARRAY:GLenum;readonly UNSIGNED_INT_SAMPLER_3D:GLenum;readonly UNSIGNED_INT_SAMPLER_CUBE:GLenum;readonly UNSIGNED_INT_VEC2:GLenum;readonly UNSIGNED_INT_VEC3:GLenum;readonly UNSIGNED_INT_VEC4:GLenum;readonly UNSIGNED_NORMALIZED:GLenum;readonly VERTEX_ARRAY_BINDING:GLenum;readonly VERTEX_ATTRIB_ARRAY_DIVISOR:GLenum;readonly VERTEX_ATTRIB_ARRAY_INTEGER:GLenum;readonly WAIT_FAILED:GLenum;};interface WebGL2RenderingContextBase{beginQuery(target:GLenum,query:WebGLQuery):void;beginTransformFeedback(primitiveMode:GLenum):void;bindBufferBase(target:GLenum,index:GLuint,buffer:WebGLBuffer|null):void;bindBufferRange(target:GLenum,index:GLuint,buffer:WebGLBuffer|null,offset:GLintptr,size:GLsizeiptr):void;bindSampler(unit:GLuint,sampler:WebGLSampler|null):void;bindTransformFeedback(target:GLenum,tf:WebGLTransformFeedback|null):void;bindVertexArray(array:WebGLVertexArrayObject|null):void;blitFramebuffer(srcX0:GLint,srcY0:GLint,srcX1:GLint,srcY1:GLint,dstX0:GLint,dstY0:GLint,dstX1:GLint,dstY1:GLint,mask:GLbitfield,filter:GLenum):void;clearBufferfi(buffer:GLenum,drawbuffer:GLint,depth:GLfloat,stencil:GLint):void;clearBufferfv(buffer:GLenum,drawbuffer:GLint,values:Float32List,srcOffset?:GLuint):void;clearBufferiv(buffer:GLenum,drawbuffer:GLint,values:Int32List,srcOffset?:GLuint):void;clearBufferuiv(buffer:GLenum,drawbuffer:GLint,values:Uint32List,srcOffset?:GLuint):void;clientWaitSync(sync:WebGLSync,flags:GLbitfield,timeout:GLuint64):GLenum;compressedTexImage3D(target:GLenum,level:GLint,internalformat:GLenum,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,imageSize:GLsizei,offset:GLintptr):void;compressedTexImage3D(target:GLenum,level:GLint,internalformat:GLenum,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,srcData:ArrayBufferView,srcOffset?:GLuint,srcLengthOverride?:GLuint):void;compressedTexSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,format:GLenum,imageSize:GLsizei,offset:GLintptr):void;compressedTexSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,format:GLenum,srcData:ArrayBufferView,srcOffset?:GLuint,srcLengthOverride?:GLuint):void;copyBufferSubData(readTarget:GLenum,writeTarget:GLenum,readOffset:GLintptr,writeOffset:GLintptr,size:GLsizeiptr):void;copyTexSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;createQuery():WebGLQuery|null;createSampler():WebGLSampler|null;createTransformFeedback():WebGLTransformFeedback|null;createVertexArray():WebGLVertexArrayObject|null;deleteQuery(query:WebGLQuery|null):void;deleteSampler(sampler:WebGLSampler|null):void;deleteSync(sync:WebGLSync|null):void;deleteTransformFeedback(tf:WebGLTransformFeedback|null):void;deleteVertexArray(vertexArray:WebGLVertexArrayObject|null):void;drawArraysInstanced(mode:GLenum,first:GLint,count:GLsizei,instanceCount:GLsizei):void;drawBuffers(buffers:GLenum[]):void;drawElementsInstanced(mode:GLenum,count:GLsizei,type:GLenum,offset:GLintptr,instanceCount:GLsizei):void;drawRangeElements(mode:GLenum,start:GLuint,end:GLuint,count:GLsizei,type:GLenum,offset:GLintptr):void;endQuery(target:GLenum):void;endTransformFeedback():void;fenceSync(condition:GLenum,flags:GLbitfield):WebGLSync|null;framebufferTextureLayer(target:GLenum,attachment:GLenum,texture:WebGLTexture|null,level:GLint,layer:GLint):void;getActiveUniformBlockName(program:WebGLProgram,uniformBlockIndex:GLuint):string|null;getActiveUniformBlockParameter(program:WebGLProgram,uniformBlockIndex:GLuint,pname:GLenum):any;getActiveUniforms(program:WebGLProgram,uniformIndices:GLuint[],pname:GLenum):any;getBufferSubData(target:GLenum,srcByteOffset:GLintptr,dstBuffer:ArrayBufferView,dstOffset?:GLuint,length?:GLuint):void;getFragDataLocation(program:WebGLProgram,name:string):GLint;getIndexedParameter(target:GLenum,index:GLuint):any;getInternalformatParameter(target:GLenum,internalformat:GLenum,pname:GLenum):any;getQuery(target:GLenum,pname:GLenum):WebGLQuery|null;getQueryParameter(query:WebGLQuery,pname:GLenum):any;getSamplerParameter(sampler:WebGLSampler,pname:GLenum):any;getSyncParameter(sync:WebGLSync,pname:GLenum):any;getTransformFeedbackVarying(program:WebGLProgram,index:GLuint):WebGLActiveInfo|null;getUniformBlockIndex(program:WebGLProgram,uniformBlockName:string):GLuint;getUniformIndices(program:WebGLProgram,uniformNames:string[]):GLuint[]|null;invalidateFramebuffer(target:GLenum,attachments:GLenum[]):void;invalidateSubFramebuffer(target:GLenum,attachments:GLenum[],x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;isQuery(query:WebGLQuery|null):GLboolean;isSampler(sampler:WebGLSampler|null):GLboolean;isSync(sync:WebGLSync|null):GLboolean;isTransformFeedback(tf:WebGLTransformFeedback|null):GLboolean;isVertexArray(vertexArray:WebGLVertexArrayObject|null):GLboolean;pauseTransformFeedback():void;readBuffer(src:GLenum):void;renderbufferStorageMultisample(target:GLenum,samples:GLsizei,internalformat:GLenum,width:GLsizei,height:GLsizei):void;resumeTransformFeedback():void;samplerParameterf(sampler:WebGLSampler,pname:GLenum,param:GLfloat):void;samplerParameteri(sampler:WebGLSampler,pname:GLenum,param:GLint):void;texImage3D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,format:GLenum,type:GLenum,pboOffset:GLintptr):void;texImage3D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;texImage3D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,format:GLenum,type:GLenum,srcData:ArrayBufferView|null):void;texImage3D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,border:GLint,format:GLenum,type:GLenum,srcData:ArrayBufferView,srcOffset:GLuint):void;texStorage2D(target:GLenum,levels:GLsizei,internalformat:GLenum,width:GLsizei,height:GLsizei):void;texStorage3D(target:GLenum,levels:GLsizei,internalformat:GLenum,width:GLsizei,height:GLsizei,depth:GLsizei):void;texSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,format:GLenum,type:GLenum,pboOffset:GLintptr):void;texSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,format:GLenum,type:GLenum,source:TexImageSource):void;texSubImage3D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,zoffset:GLint,width:GLsizei,height:GLsizei,depth:GLsizei,format:GLenum,type:GLenum,srcData:ArrayBufferView|null,srcOffset?:GLuint):void;transformFeedbackVaryings(program:WebGLProgram,varyings:string[],bufferMode:GLenum):void;uniform1ui(location:WebGLUniformLocation|null,v0:GLuint):void;uniform1uiv(location:WebGLUniformLocation|null,data:Uint32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform2ui(location:WebGLUniformLocation|null,v0:GLuint,v1:GLuint):void;uniform2uiv(location:WebGLUniformLocation|null,data:Uint32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform3ui(location:WebGLUniformLocation|null,v0:GLuint,v1:GLuint,v2:GLuint):void;uniform3uiv(location:WebGLUniformLocation|null,data:Uint32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform4ui(location:WebGLUniformLocation|null,v0:GLuint,v1:GLuint,v2:GLuint,v3:GLuint):void;uniform4uiv(location:WebGLUniformLocation|null,data:Uint32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformBlockBinding(program:WebGLProgram,uniformBlockIndex:GLuint,uniformBlockBinding:GLuint):void;uniformMatrix2x3fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix2x4fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix3x2fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix3x4fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix4x2fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix4x3fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;vertexAttribDivisor(index:GLuint,divisor:GLuint):void;vertexAttribI4i(index:GLuint,x:GLint,y:GLint,z:GLint,w:GLint):void;vertexAttribI4iv(index:GLuint,values:Int32List):void;vertexAttribI4ui(index:GLuint,x:GLuint,y:GLuint,z:GLuint,w:GLuint):void;vertexAttribI4uiv(index:GLuint,values:Uint32List):void;vertexAttribIPointer(index:GLuint,size:GLint,type:GLenum,stride:GLsizei,offset:GLintptr):void;waitSync(sync:WebGLSync,flags:GLbitfield,timeout:GLint64):void;readonly ACTIVE_UNIFORM_BLOCKS:GLenum;readonly ALREADY_SIGNALED:GLenum;readonly ANY_SAMPLES_PASSED:GLenum;readonly ANY_SAMPLES_PASSED_CONSERVATIVE:GLenum;readonly COLOR:GLenum;readonly COLOR_ATTACHMENT1:GLenum;readonly COLOR_ATTACHMENT10:GLenum;readonly COLOR_ATTACHMENT11:GLenum;readonly COLOR_ATTACHMENT12:GLenum;readonly COLOR_ATTACHMENT13:GLenum;readonly COLOR_ATTACHMENT14:GLenum;readonly COLOR_ATTACHMENT15:GLenum;readonly COLOR_ATTACHMENT2:GLenum;readonly COLOR_ATTACHMENT3:GLenum;readonly COLOR_ATTACHMENT4:GLenum;readonly COLOR_ATTACHMENT5:GLenum;readonly COLOR_ATTACHMENT6:GLenum;readonly COLOR_ATTACHMENT7:GLenum;readonly COLOR_ATTACHMENT8:GLenum;readonly COLOR_ATTACHMENT9:GLenum;readonly COMPARE_REF_TO_TEXTURE:GLenum;readonly CONDITION_SATISFIED:GLenum;readonly COPY_READ_BUFFER:GLenum;readonly COPY_READ_BUFFER_BINDING:GLenum;readonly COPY_WRITE_BUFFER:GLenum;readonly COPY_WRITE_BUFFER_BINDING:GLenum;readonly CURRENT_QUERY:GLenum;readonly DEPTH:GLenum;readonly DEPTH24_STENCIL8:GLenum;readonly DEPTH32F_STENCIL8:GLenum;readonly DEPTH_COMPONENT24:GLenum;readonly DEPTH_COMPONENT32F:GLenum;readonly DRAW_BUFFER0:GLenum;readonly DRAW_BUFFER1:GLenum;readonly DRAW_BUFFER10:GLenum;readonly DRAW_BUFFER11:GLenum;readonly DRAW_BUFFER12:GLenum;readonly DRAW_BUFFER13:GLenum;readonly DRAW_BUFFER14:GLenum;readonly DRAW_BUFFER15:GLenum;readonly DRAW_BUFFER2:GLenum;readonly DRAW_BUFFER3:GLenum;readonly DRAW_BUFFER4:GLenum;readonly DRAW_BUFFER5:GLenum;readonly DRAW_BUFFER6:GLenum;readonly DRAW_BUFFER7:GLenum;readonly DRAW_BUFFER8:GLenum;readonly DRAW_BUFFER9:GLenum;readonly DRAW_FRAMEBUFFER:GLenum;readonly DRAW_FRAMEBUFFER_BINDING:GLenum;readonly DYNAMIC_COPY:GLenum;readonly DYNAMIC_READ:GLenum;readonly FLOAT_32_UNSIGNED_INT_24_8_REV:GLenum;readonly FLOAT_MAT2x3:GLenum;readonly FLOAT_MAT2x4:GLenum;readonly FLOAT_MAT3x2:GLenum;readonly FLOAT_MAT3x4:GLenum;readonly FLOAT_MAT4x2:GLenum;readonly FLOAT_MAT4x3:GLenum;readonly FRAGMENT_SHADER_DERIVATIVE_HINT:GLenum;readonly FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:GLenum;readonly FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_RED_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:GLenum;readonly FRAMEBUFFER_DEFAULT:GLenum;readonly FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:GLenum;readonly HALF_FLOAT:GLenum;readonly INTERLEAVED_ATTRIBS:GLenum;readonly INT_2_10_10_10_REV:GLenum;readonly INT_SAMPLER_2D:GLenum;readonly INT_SAMPLER_2D_ARRAY:GLenum;readonly INT_SAMPLER_3D:GLenum;readonly INT_SAMPLER_CUBE:GLenum;readonly INVALID_INDEX:GLenum;readonly MAX:GLenum;readonly MAX_3D_TEXTURE_SIZE:GLenum;readonly MAX_ARRAY_TEXTURE_LAYERS:GLenum;readonly MAX_CLIENT_WAIT_TIMEOUT_WEBGL:GLenum;readonly MAX_COLOR_ATTACHMENTS:GLenum;readonly MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:GLenum;readonly MAX_COMBINED_UNIFORM_BLOCKS:GLenum;readonly MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:GLenum;readonly MAX_DRAW_BUFFERS:GLenum;readonly MAX_ELEMENTS_INDICES:GLenum;readonly MAX_ELEMENTS_VERTICES:GLenum;readonly MAX_ELEMENT_INDEX:GLenum;readonly MAX_FRAGMENT_INPUT_COMPONENTS:GLenum;readonly MAX_FRAGMENT_UNIFORM_BLOCKS:GLenum;readonly MAX_FRAGMENT_UNIFORM_COMPONENTS:GLenum;readonly MAX_PROGRAM_TEXEL_OFFSET:GLenum;readonly MAX_SAMPLES:GLenum;readonly MAX_SERVER_WAIT_TIMEOUT:GLenum;readonly MAX_TEXTURE_LOD_BIAS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:GLenum;readonly MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:GLenum;readonly MAX_UNIFORM_BLOCK_SIZE:GLenum;readonly MAX_UNIFORM_BUFFER_BINDINGS:GLenum;readonly MAX_VARYING_COMPONENTS:GLenum;readonly MAX_VERTEX_OUTPUT_COMPONENTS:GLenum;readonly MAX_VERTEX_UNIFORM_BLOCKS:GLenum;readonly MAX_VERTEX_UNIFORM_COMPONENTS:GLenum;readonly MIN:GLenum;readonly MIN_PROGRAM_TEXEL_OFFSET:GLenum;readonly OBJECT_TYPE:GLenum;readonly PACK_ROW_LENGTH:GLenum;readonly PACK_SKIP_PIXELS:GLenum;readonly PACK_SKIP_ROWS:GLenum;readonly PIXEL_PACK_BUFFER:GLenum;readonly PIXEL_PACK_BUFFER_BINDING:GLenum;readonly PIXEL_UNPACK_BUFFER:GLenum;readonly PIXEL_UNPACK_BUFFER_BINDING:GLenum;readonly QUERY_RESULT:GLenum;readonly QUERY_RESULT_AVAILABLE:GLenum;readonly R11F_G11F_B10F:GLenum;readonly R16F:GLenum;readonly R16I:GLenum;readonly R16UI:GLenum;readonly R32F:GLenum;readonly R32I:GLenum;readonly R32UI:GLenum;readonly R8:GLenum;readonly R8I:GLenum;readonly R8UI:GLenum;readonly R8_SNORM:GLenum;readonly RASTERIZER_DISCARD:GLenum;readonly READ_BUFFER:GLenum;readonly READ_FRAMEBUFFER:GLenum;readonly READ_FRAMEBUFFER_BINDING:GLenum;readonly RED:GLenum;readonly RED_INTEGER:GLenum;readonly RENDERBUFFER_SAMPLES:GLenum;readonly RG:GLenum;readonly RG16F:GLenum;readonly RG16I:GLenum;readonly RG16UI:GLenum;readonly RG32F:GLenum;readonly RG32I:GLenum;readonly RG32UI:GLenum;readonly RG8:GLenum;readonly RG8I:GLenum;readonly RG8UI:GLenum;readonly RG8_SNORM:GLenum;readonly RGB10_A2:GLenum;readonly RGB10_A2UI:GLenum;readonly RGB16F:GLenum;readonly RGB16I:GLenum;readonly RGB16UI:GLenum;readonly RGB32F:GLenum;readonly RGB32I:GLenum;readonly RGB32UI:GLenum;readonly RGB8:GLenum;readonly RGB8I:GLenum;readonly RGB8UI:GLenum;readonly RGB8_SNORM:GLenum;readonly RGB9_E5:GLenum;readonly RGBA16F:GLenum;readonly RGBA16I:GLenum;readonly RGBA16UI:GLenum;readonly RGBA32F:GLenum;readonly RGBA32I:GLenum;readonly RGBA32UI:GLenum;readonly RGBA8:GLenum;readonly RGBA8I:GLenum;readonly RGBA8UI:GLenum;readonly RGBA8_SNORM:GLenum;readonly RGBA_INTEGER:GLenum;readonly RGB_INTEGER:GLenum;readonly RG_INTEGER:GLenum;readonly SAMPLER_2D_ARRAY:GLenum;readonly SAMPLER_2D_ARRAY_SHADOW:GLenum;readonly SAMPLER_2D_SHADOW:GLenum;readonly SAMPLER_3D:GLenum;readonly SAMPLER_BINDING:GLenum;readonly SAMPLER_CUBE_SHADOW:GLenum;readonly SEPARATE_ATTRIBS:GLenum;readonly SIGNALED:GLenum;readonly SIGNED_NORMALIZED:GLenum;readonly SRGB:GLenum;readonly SRGB8:GLenum;readonly SRGB8_ALPHA8:GLenum;readonly STATIC_COPY:GLenum;readonly STATIC_READ:GLenum;readonly STENCIL:GLenum;readonly STREAM_COPY:GLenum;readonly STREAM_READ:GLenum;readonly SYNC_CONDITION:GLenum;readonly SYNC_FENCE:GLenum;readonly SYNC_FLAGS:GLenum;readonly SYNC_FLUSH_COMMANDS_BIT:GLenum;readonly SYNC_GPU_COMMANDS_COMPLETE:GLenum;readonly SYNC_STATUS:GLenum;readonly TEXTURE_2D_ARRAY:GLenum;readonly TEXTURE_3D:GLenum;readonly TEXTURE_BASE_LEVEL:GLenum;readonly TEXTURE_BINDING_2D_ARRAY:GLenum;readonly TEXTURE_BINDING_3D:GLenum;readonly TEXTURE_COMPARE_FUNC:GLenum;readonly TEXTURE_COMPARE_MODE:GLenum;readonly TEXTURE_IMMUTABLE_FORMAT:GLenum;readonly TEXTURE_IMMUTABLE_LEVELS:GLenum;readonly TEXTURE_MAX_LEVEL:GLenum;readonly TEXTURE_MAX_LOD:GLenum;readonly TEXTURE_MIN_LOD:GLenum;readonly TEXTURE_WRAP_R:GLenum;readonly TIMEOUT_EXPIRED:GLenum;readonly TIMEOUT_IGNORED:GLint64;readonly TRANSFORM_FEEDBACK:GLenum;readonly TRANSFORM_FEEDBACK_ACTIVE:GLenum;readonly TRANSFORM_FEEDBACK_BINDING:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_BINDING:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_MODE:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_SIZE:GLenum;readonly TRANSFORM_FEEDBACK_BUFFER_START:GLenum;readonly TRANSFORM_FEEDBACK_PAUSED:GLenum;readonly TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:GLenum;readonly TRANSFORM_FEEDBACK_VARYINGS:GLenum;readonly UNIFORM_ARRAY_STRIDE:GLenum;readonly UNIFORM_BLOCK_ACTIVE_UNIFORMS:GLenum;readonly UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:GLenum;readonly UNIFORM_BLOCK_BINDING:GLenum;readonly UNIFORM_BLOCK_DATA_SIZE:GLenum;readonly UNIFORM_BLOCK_INDEX:GLenum;readonly UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:GLenum;readonly UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:GLenum;readonly UNIFORM_BUFFER:GLenum;readonly UNIFORM_BUFFER_BINDING:GLenum;readonly UNIFORM_BUFFER_OFFSET_ALIGNMENT:GLenum;readonly UNIFORM_BUFFER_SIZE:GLenum;readonly UNIFORM_BUFFER_START:GLenum;readonly UNIFORM_IS_ROW_MAJOR:GLenum;readonly UNIFORM_MATRIX_STRIDE:GLenum;readonly UNIFORM_OFFSET:GLenum;readonly UNIFORM_SIZE:GLenum;readonly UNIFORM_TYPE:GLenum;readonly UNPACK_IMAGE_HEIGHT:GLenum;readonly UNPACK_ROW_LENGTH:GLenum;readonly UNPACK_SKIP_IMAGES:GLenum;readonly UNPACK_SKIP_PIXELS:GLenum;readonly UNPACK_SKIP_ROWS:GLenum;readonly UNSIGNALED:GLenum;readonly UNSIGNED_INT_10F_11F_11F_REV:GLenum;readonly UNSIGNED_INT_24_8:GLenum;readonly UNSIGNED_INT_2_10_10_10_REV:GLenum;readonly UNSIGNED_INT_5_9_9_9_REV:GLenum;readonly UNSIGNED_INT_SAMPLER_2D:GLenum;readonly UNSIGNED_INT_SAMPLER_2D_ARRAY:GLenum;readonly UNSIGNED_INT_SAMPLER_3D:GLenum;readonly UNSIGNED_INT_SAMPLER_CUBE:GLenum;readonly UNSIGNED_INT_VEC2:GLenum;readonly UNSIGNED_INT_VEC3:GLenum;readonly UNSIGNED_INT_VEC4:GLenum;readonly UNSIGNED_NORMALIZED:GLenum;readonly VERTEX_ARRAY_BINDING:GLenum;readonly VERTEX_ATTRIB_ARRAY_DIVISOR:GLenum;readonly VERTEX_ATTRIB_ARRAY_INTEGER:GLenum;readonly WAIT_FAILED:GLenum;}interface WebGL2RenderingContextOverloads{bufferData(target:GLenum,size:GLsizeiptr,usage:GLenum):void;bufferData(target:GLenum,srcData:BufferSource|null,usage:GLenum):void;bufferData(target:GLenum,srcData:ArrayBufferView,usage:GLenum,srcOffset:GLuint,length?:GLuint):void;bufferSubData(target:GLenum,dstByteOffset:GLintptr,srcData:BufferSource):void;bufferSubData(target:GLenum,dstByteOffset:GLintptr,srcData:ArrayBufferView,srcOffset:GLuint,length?:GLuint):void;compressedTexImage2D(target:GLenum,level:GLint,internalformat:GLenum,width:GLsizei,height:GLsizei,border:GLint,imageSize:GLsizei,offset:GLintptr):void;compressedTexImage2D(target:GLenum,level:GLint,internalformat:GLenum,width:GLsizei,height:GLsizei,border:GLint,srcData:ArrayBufferView,srcOffset?:GLuint,srcLengthOverride?:GLuint):void;compressedTexSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,imageSize:GLsizei,offset:GLintptr):void;compressedTexSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,srcData:ArrayBufferView,srcOffset?:GLuint,srcLengthOverride?:GLuint):void;readPixels(x:GLint,y:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,dstData:ArrayBufferView|null):void;readPixels(x:GLint,y:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,offset:GLintptr):void;readPixels(x:GLint,y:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,dstData:ArrayBufferView,dstOffset:GLuint):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,border:GLint,format:GLenum,type:GLenum,pixels:ArrayBufferView|null):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,border:GLint,format:GLenum,type:GLenum,pboOffset:GLintptr):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,border:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,border:GLint,format:GLenum,type:GLenum,srcData:ArrayBufferView,srcOffset:GLuint):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,pixels:ArrayBufferView|null):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,pboOffset:GLintptr):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,source:TexImageSource):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,srcData:ArrayBufferView,srcOffset:GLuint):void;uniform1fv(location:WebGLUniformLocation|null,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform1iv(location:WebGLUniformLocation|null,data:Int32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform2fv(location:WebGLUniformLocation|null,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform2iv(location:WebGLUniformLocation|null,data:Int32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform3fv(location:WebGLUniformLocation|null,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform3iv(location:WebGLUniformLocation|null,data:Int32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform4fv(location:WebGLUniformLocation|null,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniform4iv(location:WebGLUniformLocation|null,data:Int32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix2fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix3fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;uniformMatrix4fv(location:WebGLUniformLocation|null,transpose:GLboolean,data:Float32List,srcOffset?:GLuint,srcLength?:GLuint):void;}interface WebGLActiveInfo{readonly name:string;readonly size:GLint;readonly type:GLenum;}declare var WebGLActiveInfo:{prototype:WebGLActiveInfo;new():WebGLActiveInfo;};interface WebGLBuffer extends WebGLObject{}declare var WebGLBuffer:{prototype:WebGLBuffer;new():WebGLBuffer;};interface WebGLContextEvent extends Event{readonly statusMessage:string;}declare var WebGLContextEvent:{prototype:WebGLContextEvent;new(type:string,eventInit?:WebGLContextEventInit):WebGLContextEvent;};interface WebGLFramebuffer extends WebGLObject{}declare var WebGLFramebuffer:{prototype:WebGLFramebuffer;new():WebGLFramebuffer;};interface WebGLObject{}declare var WebGLObject:{prototype:WebGLObject;new():WebGLObject;};interface WebGLProgram extends WebGLObject{}declare var WebGLProgram:{prototype:WebGLProgram;new():WebGLProgram;};interface WebGLQuery extends WebGLObject{}declare var WebGLQuery:{prototype:WebGLQuery;new():WebGLQuery;};interface WebGLRenderbuffer extends WebGLObject{}declare var WebGLRenderbuffer:{prototype:WebGLRenderbuffer;new():WebGLRenderbuffer;};interface WebGLRenderingContext extends WebGLRenderingContextBase,WebGLRenderingContextOverloads{}declare var WebGLRenderingContext:{prototype:WebGLRenderingContext;new():WebGLRenderingContext;readonly ACTIVE_ATTRIBUTES:GLenum;readonly ACTIVE_TEXTURE:GLenum;readonly ACTIVE_UNIFORMS:GLenum;readonly ALIASED_LINE_WIDTH_RANGE:GLenum;readonly ALIASED_POINT_SIZE_RANGE:GLenum;readonly ALPHA:GLenum;readonly ALPHA_BITS:GLenum;readonly ALWAYS:GLenum;readonly ARRAY_BUFFER:GLenum;readonly ARRAY_BUFFER_BINDING:GLenum;readonly ATTACHED_SHADERS:GLenum;readonly BACK:GLenum;readonly BLEND:GLenum;readonly BLEND_COLOR:GLenum;readonly BLEND_DST_ALPHA:GLenum;readonly BLEND_DST_RGB:GLenum;readonly BLEND_EQUATION:GLenum;readonly BLEND_EQUATION_ALPHA:GLenum;readonly BLEND_EQUATION_RGB:GLenum;readonly BLEND_SRC_ALPHA:GLenum;readonly BLEND_SRC_RGB:GLenum;readonly BLUE_BITS:GLenum;readonly BOOL:GLenum;readonly BOOL_VEC2:GLenum;readonly BOOL_VEC3:GLenum;readonly BOOL_VEC4:GLenum;readonly BROWSER_DEFAULT_WEBGL:GLenum;readonly BUFFER_SIZE:GLenum;readonly BUFFER_USAGE:GLenum;readonly BYTE:GLenum;readonly CCW:GLenum;readonly CLAMP_TO_EDGE:GLenum;readonly COLOR_ATTACHMENT0:GLenum;readonly COLOR_BUFFER_BIT:GLenum;readonly COLOR_CLEAR_VALUE:GLenum;readonly COLOR_WRITEMASK:GLenum;readonly COMPILE_STATUS:GLenum;readonly COMPRESSED_TEXTURE_FORMATS:GLenum;readonly CONSTANT_ALPHA:GLenum;readonly CONSTANT_COLOR:GLenum;readonly CONTEXT_LOST_WEBGL:GLenum;readonly CULL_FACE:GLenum;readonly CULL_FACE_MODE:GLenum;readonly CURRENT_PROGRAM:GLenum;readonly CURRENT_VERTEX_ATTRIB:GLenum;readonly CW:GLenum;readonly DECR:GLenum;readonly DECR_WRAP:GLenum;readonly DELETE_STATUS:GLenum;readonly DEPTH_ATTACHMENT:GLenum;readonly DEPTH_BITS:GLenum;readonly DEPTH_BUFFER_BIT:GLenum;readonly DEPTH_CLEAR_VALUE:GLenum;readonly DEPTH_COMPONENT:GLenum;readonly DEPTH_COMPONENT16:GLenum;readonly DEPTH_FUNC:GLenum;readonly DEPTH_RANGE:GLenum;readonly DEPTH_STENCIL:GLenum;readonly DEPTH_STENCIL_ATTACHMENT:GLenum;readonly DEPTH_TEST:GLenum;readonly DEPTH_WRITEMASK:GLenum;readonly DITHER:GLenum;readonly DONT_CARE:GLenum;readonly DST_ALPHA:GLenum;readonly DST_COLOR:GLenum;readonly DYNAMIC_DRAW:GLenum;readonly ELEMENT_ARRAY_BUFFER:GLenum;readonly ELEMENT_ARRAY_BUFFER_BINDING:GLenum;readonly EQUAL:GLenum;readonly FASTEST:GLenum;readonly FLOAT:GLenum;readonly FLOAT_MAT2:GLenum;readonly FLOAT_MAT3:GLenum;readonly FLOAT_MAT4:GLenum;readonly FLOAT_VEC2:GLenum;readonly FLOAT_VEC3:GLenum;readonly FLOAT_VEC4:GLenum;readonly FRAGMENT_SHADER:GLenum;readonly FRAMEBUFFER:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:GLenum;readonly FRAMEBUFFER_BINDING:GLenum;readonly FRAMEBUFFER_COMPLETE:GLenum;readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT:GLenum;readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS:GLenum;readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:GLenum;readonly FRAMEBUFFER_UNSUPPORTED:GLenum;readonly FRONT:GLenum;readonly FRONT_AND_BACK:GLenum;readonly FRONT_FACE:GLenum;readonly FUNC_ADD:GLenum;readonly FUNC_REVERSE_SUBTRACT:GLenum;readonly FUNC_SUBTRACT:GLenum;readonly GENERATE_MIPMAP_HINT:GLenum;readonly GEQUAL:GLenum;readonly GREATER:GLenum;readonly GREEN_BITS:GLenum;readonly HIGH_FLOAT:GLenum;readonly HIGH_INT:GLenum;readonly IMPLEMENTATION_COLOR_READ_FORMAT:GLenum;readonly IMPLEMENTATION_COLOR_READ_TYPE:GLenum;readonly INCR:GLenum;readonly INCR_WRAP:GLenum;readonly INT:GLenum;readonly INT_VEC2:GLenum;readonly INT_VEC3:GLenum;readonly INT_VEC4:GLenum;readonly INVALID_ENUM:GLenum;readonly INVALID_FRAMEBUFFER_OPERATION:GLenum;readonly INVALID_OPERATION:GLenum;readonly INVALID_VALUE:GLenum;readonly INVERT:GLenum;readonly KEEP:GLenum;readonly LEQUAL:GLenum;readonly LESS:GLenum;readonly LINEAR:GLenum;readonly LINEAR_MIPMAP_LINEAR:GLenum;readonly LINEAR_MIPMAP_NEAREST:GLenum;readonly LINES:GLenum;readonly LINE_LOOP:GLenum;readonly LINE_STRIP:GLenum;readonly LINE_WIDTH:GLenum;readonly LINK_STATUS:GLenum;readonly LOW_FLOAT:GLenum;readonly LOW_INT:GLenum;readonly LUMINANCE:GLenum;readonly LUMINANCE_ALPHA:GLenum;readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_CUBE_MAP_TEXTURE_SIZE:GLenum;readonly MAX_FRAGMENT_UNIFORM_VECTORS:GLenum;readonly MAX_RENDERBUFFER_SIZE:GLenum;readonly MAX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_TEXTURE_SIZE:GLenum;readonly MAX_VARYING_VECTORS:GLenum;readonly MAX_VERTEX_ATTRIBS:GLenum;readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_VERTEX_UNIFORM_VECTORS:GLenum;readonly MAX_VIEWPORT_DIMS:GLenum;readonly MEDIUM_FLOAT:GLenum;readonly MEDIUM_INT:GLenum;readonly MIRRORED_REPEAT:GLenum;readonly NEAREST:GLenum;readonly NEAREST_MIPMAP_LINEAR:GLenum;readonly NEAREST_MIPMAP_NEAREST:GLenum;readonly NEVER:GLenum;readonly NICEST:GLenum;readonly NONE:GLenum;readonly NOTEQUAL:GLenum;readonly NO_ERROR:GLenum;readonly ONE:GLenum;readonly ONE_MINUS_CONSTANT_ALPHA:GLenum;readonly ONE_MINUS_CONSTANT_COLOR:GLenum;readonly ONE_MINUS_DST_ALPHA:GLenum;readonly ONE_MINUS_DST_COLOR:GLenum;readonly ONE_MINUS_SRC_ALPHA:GLenum;readonly ONE_MINUS_SRC_COLOR:GLenum;readonly OUT_OF_MEMORY:GLenum;readonly PACK_ALIGNMENT:GLenum;readonly POINTS:GLenum;readonly POLYGON_OFFSET_FACTOR:GLenum;readonly POLYGON_OFFSET_FILL:GLenum;readonly POLYGON_OFFSET_UNITS:GLenum;readonly RED_BITS:GLenum;readonly RENDERBUFFER:GLenum;readonly RENDERBUFFER_ALPHA_SIZE:GLenum;readonly RENDERBUFFER_BINDING:GLenum;readonly RENDERBUFFER_BLUE_SIZE:GLenum;readonly RENDERBUFFER_DEPTH_SIZE:GLenum;readonly RENDERBUFFER_GREEN_SIZE:GLenum;readonly RENDERBUFFER_HEIGHT:GLenum;readonly RENDERBUFFER_INTERNAL_FORMAT:GLenum;readonly RENDERBUFFER_RED_SIZE:GLenum;readonly RENDERBUFFER_STENCIL_SIZE:GLenum;readonly RENDERBUFFER_WIDTH:GLenum;readonly RENDERER:GLenum;readonly REPEAT:GLenum;readonly REPLACE:GLenum;readonly RGB:GLenum;readonly RGB565:GLenum;readonly RGB5_A1:GLenum;readonly RGBA:GLenum;readonly RGBA4:GLenum;readonly SAMPLER_2D:GLenum;readonly SAMPLER_CUBE:GLenum;readonly SAMPLES:GLenum;readonly SAMPLE_ALPHA_TO_COVERAGE:GLenum;readonly SAMPLE_BUFFERS:GLenum;readonly SAMPLE_COVERAGE:GLenum;readonly SAMPLE_COVERAGE_INVERT:GLenum;readonly SAMPLE_COVERAGE_VALUE:GLenum;readonly SCISSOR_BOX:GLenum;readonly SCISSOR_TEST:GLenum;readonly SHADER_TYPE:GLenum;readonly SHADING_LANGUAGE_VERSION:GLenum;readonly SHORT:GLenum;readonly SRC_ALPHA:GLenum;readonly SRC_ALPHA_SATURATE:GLenum;readonly SRC_COLOR:GLenum;readonly STATIC_DRAW:GLenum;readonly STENCIL_ATTACHMENT:GLenum;readonly STENCIL_BACK_FAIL:GLenum;readonly STENCIL_BACK_FUNC:GLenum;readonly STENCIL_BACK_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_BACK_PASS_DEPTH_PASS:GLenum;readonly STENCIL_BACK_REF:GLenum;readonly STENCIL_BACK_VALUE_MASK:GLenum;readonly STENCIL_BACK_WRITEMASK:GLenum;readonly STENCIL_BITS:GLenum;readonly STENCIL_BUFFER_BIT:GLenum;readonly STENCIL_CLEAR_VALUE:GLenum;readonly STENCIL_FAIL:GLenum;readonly STENCIL_FUNC:GLenum;readonly STENCIL_INDEX8:GLenum;readonly STENCIL_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_PASS_DEPTH_PASS:GLenum;readonly STENCIL_REF:GLenum;readonly STENCIL_TEST:GLenum;readonly STENCIL_VALUE_MASK:GLenum;readonly STENCIL_WRITEMASK:GLenum;readonly STREAM_DRAW:GLenum;readonly SUBPIXEL_BITS:GLenum;readonly TEXTURE:GLenum;readonly TEXTURE0:GLenum;readonly TEXTURE1:GLenum;readonly TEXTURE10:GLenum;readonly TEXTURE11:GLenum;readonly TEXTURE12:GLenum;readonly TEXTURE13:GLenum;readonly TEXTURE14:GLenum;readonly TEXTURE15:GLenum;readonly TEXTURE16:GLenum;readonly TEXTURE17:GLenum;readonly TEXTURE18:GLenum;readonly TEXTURE19:GLenum;readonly TEXTURE2:GLenum;readonly TEXTURE20:GLenum;readonly TEXTURE21:GLenum;readonly TEXTURE22:GLenum;readonly TEXTURE23:GLenum;readonly TEXTURE24:GLenum;readonly TEXTURE25:GLenum;readonly TEXTURE26:GLenum;readonly TEXTURE27:GLenum;readonly TEXTURE28:GLenum;readonly TEXTURE29:GLenum;readonly TEXTURE3:GLenum;readonly TEXTURE30:GLenum;readonly TEXTURE31:GLenum;readonly TEXTURE4:GLenum;readonly TEXTURE5:GLenum;readonly TEXTURE6:GLenum;readonly TEXTURE7:GLenum;readonly TEXTURE8:GLenum;readonly TEXTURE9:GLenum;readonly TEXTURE_2D:GLenum;readonly TEXTURE_BINDING_2D:GLenum;readonly TEXTURE_BINDING_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Z:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Z:GLenum;readonly TEXTURE_MAG_FILTER:GLenum;readonly TEXTURE_MIN_FILTER:GLenum;readonly TEXTURE_WRAP_S:GLenum;readonly TEXTURE_WRAP_T:GLenum;readonly TRIANGLES:GLenum;readonly TRIANGLE_FAN:GLenum;readonly TRIANGLE_STRIP:GLenum;readonly UNPACK_ALIGNMENT:GLenum;readonly UNPACK_COLORSPACE_CONVERSION_WEBGL:GLenum;readonly UNPACK_FLIP_Y_WEBGL:GLenum;readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL:GLenum;readonly UNSIGNED_BYTE:GLenum;readonly UNSIGNED_INT:GLenum;readonly UNSIGNED_SHORT:GLenum;readonly UNSIGNED_SHORT_4_4_4_4:GLenum;readonly UNSIGNED_SHORT_5_5_5_1:GLenum;readonly UNSIGNED_SHORT_5_6_5:GLenum;readonly VALIDATE_STATUS:GLenum;readonly VENDOR:GLenum;readonly VERSION:GLenum;readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:GLenum;readonly VERTEX_ATTRIB_ARRAY_ENABLED:GLenum;readonly VERTEX_ATTRIB_ARRAY_NORMALIZED:GLenum;readonly VERTEX_ATTRIB_ARRAY_POINTER:GLenum;readonly VERTEX_ATTRIB_ARRAY_SIZE:GLenum;readonly VERTEX_ATTRIB_ARRAY_STRIDE:GLenum;readonly VERTEX_ATTRIB_ARRAY_TYPE:GLenum;readonly VERTEX_SHADER:GLenum;readonly VIEWPORT:GLenum;readonly ZERO:GLenum;};interface WebGLRenderingContextBase{readonly canvas:OffscreenCanvas;readonly drawingBufferHeight:GLsizei;readonly drawingBufferWidth:GLsizei;activeTexture(texture:GLenum):void;attachShader(program:WebGLProgram,shader:WebGLShader):void;bindAttribLocation(program:WebGLProgram,index:GLuint,name:string):void;bindBuffer(target:GLenum,buffer:WebGLBuffer|null):void;bindFramebuffer(target:GLenum,framebuffer:WebGLFramebuffer|null):void;bindRenderbuffer(target:GLenum,renderbuffer:WebGLRenderbuffer|null):void;bindTexture(target:GLenum,texture:WebGLTexture|null):void;blendColor(red:GLclampf,green:GLclampf,blue:GLclampf,alpha:GLclampf):void;blendEquation(mode:GLenum):void;blendEquationSeparate(modeRGB:GLenum,modeAlpha:GLenum):void;blendFunc(sfactor:GLenum,dfactor:GLenum):void;blendFuncSeparate(srcRGB:GLenum,dstRGB:GLenum,srcAlpha:GLenum,dstAlpha:GLenum):void;checkFramebufferStatus(target:GLenum):GLenum;clear(mask:GLbitfield):void;clearColor(red:GLclampf,green:GLclampf,blue:GLclampf,alpha:GLclampf):void;clearDepth(depth:GLclampf):void;clearStencil(s:GLint):void;colorMask(red:GLboolean,green:GLboolean,blue:GLboolean,alpha:GLboolean):void;compileShader(shader:WebGLShader):void;copyTexImage2D(target:GLenum,level:GLint,internalformat:GLenum,x:GLint,y:GLint,width:GLsizei,height:GLsizei,border:GLint):void;copyTexSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;createBuffer():WebGLBuffer|null;createFramebuffer():WebGLFramebuffer|null;createProgram():WebGLProgram|null;createRenderbuffer():WebGLRenderbuffer|null;createShader(type:GLenum):WebGLShader|null;createTexture():WebGLTexture|null;cullFace(mode:GLenum):void;deleteBuffer(buffer:WebGLBuffer|null):void;deleteFramebuffer(framebuffer:WebGLFramebuffer|null):void;deleteProgram(program:WebGLProgram|null):void;deleteRenderbuffer(renderbuffer:WebGLRenderbuffer|null):void;deleteShader(shader:WebGLShader|null):void;deleteTexture(texture:WebGLTexture|null):void;depthFunc(func:GLenum):void;depthMask(flag:GLboolean):void;depthRange(zNear:GLclampf,zFar:GLclampf):void;detachShader(program:WebGLProgram,shader:WebGLShader):void;disable(cap:GLenum):void;disableVertexAttribArray(index:GLuint):void;drawArrays(mode:GLenum,first:GLint,count:GLsizei):void;drawElements(mode:GLenum,count:GLsizei,type:GLenum,offset:GLintptr):void;enable(cap:GLenum):void;enableVertexAttribArray(index:GLuint):void;finish():void;flush():void;framebufferRenderbuffer(target:GLenum,attachment:GLenum,renderbuffertarget:GLenum,renderbuffer:WebGLRenderbuffer|null):void;framebufferTexture2D(target:GLenum,attachment:GLenum,textarget:GLenum,texture:WebGLTexture|null,level:GLint):void;frontFace(mode:GLenum):void;generateMipmap(target:GLenum):void;getActiveAttrib(program:WebGLProgram,index:GLuint):WebGLActiveInfo|null;getActiveUniform(program:WebGLProgram,index:GLuint):WebGLActiveInfo|null;getAttachedShaders(program:WebGLProgram):WebGLShader[]|null;getAttribLocation(program:WebGLProgram,name:string):GLint;getBufferParameter(target:GLenum,pname:GLenum):any;getContextAttributes():WebGLContextAttributes|null;getError():GLenum;getExtension(extensionName:"EXT_blend_minmax"):EXT_blend_minmax|null;getExtension(extensionName:"EXT_texture_filter_anisotropic"):EXT_texture_filter_anisotropic|null;getExtension(extensionName:"EXT_frag_depth"):EXT_frag_depth|null;getExtension(extensionName:"EXT_shader_texture_lod"):EXT_shader_texture_lod|null;getExtension(extensionName:"EXT_sRGB"):EXT_sRGB|null;getExtension(extensionName:"OES_vertex_array_object"):OES_vertex_array_object|null;getExtension(extensionName:"WEBGL_color_buffer_float"):WEBGL_color_buffer_float|null;getExtension(extensionName:"WEBGL_compressed_texture_astc"):WEBGL_compressed_texture_astc|null;getExtension(extensionName:"WEBGL_compressed_texture_s3tc_srgb"):WEBGL_compressed_texture_s3tc_srgb|null;getExtension(extensionName:"WEBGL_debug_shaders"):WEBGL_debug_shaders|null;getExtension(extensionName:"WEBGL_draw_buffers"):WEBGL_draw_buffers|null;getExtension(extensionName:"WEBGL_lose_context"):WEBGL_lose_context|null;getExtension(extensionName:"WEBGL_depth_texture"):WEBGL_depth_texture|null;getExtension(extensionName:"WEBGL_debug_renderer_info"):WEBGL_debug_renderer_info|null;getExtension(extensionName:"WEBGL_compressed_texture_s3tc"):WEBGL_compressed_texture_s3tc|null;getExtension(extensionName:"OES_texture_half_float_linear"):OES_texture_half_float_linear|null;getExtension(extensionName:"OES_texture_half_float"):OES_texture_half_float|null;getExtension(extensionName:"OES_texture_float_linear"):OES_texture_float_linear|null;getExtension(extensionName:"OES_texture_float"):OES_texture_float|null;getExtension(extensionName:"OES_standard_derivatives"):OES_standard_derivatives|null;getExtension(extensionName:"OES_element_index_uint"):OES_element_index_uint|null;getExtension(extensionName:"ANGLE_instanced_arrays"):ANGLE_instanced_arrays|null;getExtension(extensionName:string):any;getFramebufferAttachmentParameter(target:GLenum,attachment:GLenum,pname:GLenum):any;getParameter(pname:GLenum):any;getProgramInfoLog(program:WebGLProgram):string|null;getProgramParameter(program:WebGLProgram,pname:GLenum):any;getRenderbufferParameter(target:GLenum,pname:GLenum):any;getShaderInfoLog(shader:WebGLShader):string|null;getShaderParameter(shader:WebGLShader,pname:GLenum):any;getShaderPrecisionFormat(shadertype:GLenum,precisiontype:GLenum):WebGLShaderPrecisionFormat|null;getShaderSource(shader:WebGLShader):string|null;getSupportedExtensions():string[]|null;getTexParameter(target:GLenum,pname:GLenum):any;getUniform(program:WebGLProgram,location:WebGLUniformLocation):any;getUniformLocation(program:WebGLProgram,name:string):WebGLUniformLocation|null;getVertexAttrib(index:GLuint,pname:GLenum):any;getVertexAttribOffset(index:GLuint,pname:GLenum):GLintptr;hint(target:GLenum,mode:GLenum):void;isBuffer(buffer:WebGLBuffer|null):GLboolean;isContextLost():boolean;isEnabled(cap:GLenum):GLboolean;isFramebuffer(framebuffer:WebGLFramebuffer|null):GLboolean;isProgram(program:WebGLProgram|null):GLboolean;isRenderbuffer(renderbuffer:WebGLRenderbuffer|null):GLboolean;isShader(shader:WebGLShader|null):GLboolean;isTexture(texture:WebGLTexture|null):GLboolean;lineWidth(width:GLfloat):void;linkProgram(program:WebGLProgram):void;pixelStorei(pname:GLenum,param:GLint|GLboolean):void;polygonOffset(factor:GLfloat,units:GLfloat):void;renderbufferStorage(target:GLenum,internalformat:GLenum,width:GLsizei,height:GLsizei):void;sampleCoverage(value:GLclampf,invert:GLboolean):void;scissor(x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;shaderSource(shader:WebGLShader,source:string):void;stencilFunc(func:GLenum,ref:GLint,mask:GLuint):void;stencilFuncSeparate(face:GLenum,func:GLenum,ref:GLint,mask:GLuint):void;stencilMask(mask:GLuint):void;stencilMaskSeparate(face:GLenum,mask:GLuint):void;stencilOp(fail:GLenum,zfail:GLenum,zpass:GLenum):void;stencilOpSeparate(face:GLenum,fail:GLenum,zfail:GLenum,zpass:GLenum):void;texParameterf(target:GLenum,pname:GLenum,param:GLfloat):void;texParameteri(target:GLenum,pname:GLenum,param:GLint):void;uniform1f(location:WebGLUniformLocation|null,x:GLfloat):void;uniform1i(location:WebGLUniformLocation|null,x:GLint):void;uniform2f(location:WebGLUniformLocation|null,x:GLfloat,y:GLfloat):void;uniform2i(location:WebGLUniformLocation|null,x:GLint,y:GLint):void;uniform3f(location:WebGLUniformLocation|null,x:GLfloat,y:GLfloat,z:GLfloat):void;uniform3i(location:WebGLUniformLocation|null,x:GLint,y:GLint,z:GLint):void;uniform4f(location:WebGLUniformLocation|null,x:GLfloat,y:GLfloat,z:GLfloat,w:GLfloat):void;uniform4i(location:WebGLUniformLocation|null,x:GLint,y:GLint,z:GLint,w:GLint):void;useProgram(program:WebGLProgram|null):void;validateProgram(program:WebGLProgram):void;vertexAttrib1f(index:GLuint,x:GLfloat):void;vertexAttrib1fv(index:GLuint,values:Float32List):void;vertexAttrib2f(index:GLuint,x:GLfloat,y:GLfloat):void;vertexAttrib2fv(index:GLuint,values:Float32List):void;vertexAttrib3f(index:GLuint,x:GLfloat,y:GLfloat,z:GLfloat):void;vertexAttrib3fv(index:GLuint,values:Float32List):void;vertexAttrib4f(index:GLuint,x:GLfloat,y:GLfloat,z:GLfloat,w:GLfloat):void;vertexAttrib4fv(index:GLuint,values:Float32List):void;vertexAttribPointer(index:GLuint,size:GLint,type:GLenum,normalized:GLboolean,stride:GLsizei,offset:GLintptr):void;viewport(x:GLint,y:GLint,width:GLsizei,height:GLsizei):void;readonly ACTIVE_ATTRIBUTES:GLenum;readonly ACTIVE_TEXTURE:GLenum;readonly ACTIVE_UNIFORMS:GLenum;readonly ALIASED_LINE_WIDTH_RANGE:GLenum;readonly ALIASED_POINT_SIZE_RANGE:GLenum;readonly ALPHA:GLenum;readonly ALPHA_BITS:GLenum;readonly ALWAYS:GLenum;readonly ARRAY_BUFFER:GLenum;readonly ARRAY_BUFFER_BINDING:GLenum;readonly ATTACHED_SHADERS:GLenum;readonly BACK:GLenum;readonly BLEND:GLenum;readonly BLEND_COLOR:GLenum;readonly BLEND_DST_ALPHA:GLenum;readonly BLEND_DST_RGB:GLenum;readonly BLEND_EQUATION:GLenum;readonly BLEND_EQUATION_ALPHA:GLenum;readonly BLEND_EQUATION_RGB:GLenum;readonly BLEND_SRC_ALPHA:GLenum;readonly BLEND_SRC_RGB:GLenum;readonly BLUE_BITS:GLenum;readonly BOOL:GLenum;readonly BOOL_VEC2:GLenum;readonly BOOL_VEC3:GLenum;readonly BOOL_VEC4:GLenum;readonly BROWSER_DEFAULT_WEBGL:GLenum;readonly BUFFER_SIZE:GLenum;readonly BUFFER_USAGE:GLenum;readonly BYTE:GLenum;readonly CCW:GLenum;readonly CLAMP_TO_EDGE:GLenum;readonly COLOR_ATTACHMENT0:GLenum;readonly COLOR_BUFFER_BIT:GLenum;readonly COLOR_CLEAR_VALUE:GLenum;readonly COLOR_WRITEMASK:GLenum;readonly COMPILE_STATUS:GLenum;readonly COMPRESSED_TEXTURE_FORMATS:GLenum;readonly CONSTANT_ALPHA:GLenum;readonly CONSTANT_COLOR:GLenum;readonly CONTEXT_LOST_WEBGL:GLenum;readonly CULL_FACE:GLenum;readonly CULL_FACE_MODE:GLenum;readonly CURRENT_PROGRAM:GLenum;readonly CURRENT_VERTEX_ATTRIB:GLenum;readonly CW:GLenum;readonly DECR:GLenum;readonly DECR_WRAP:GLenum;readonly DELETE_STATUS:GLenum;readonly DEPTH_ATTACHMENT:GLenum;readonly DEPTH_BITS:GLenum;readonly DEPTH_BUFFER_BIT:GLenum;readonly DEPTH_CLEAR_VALUE:GLenum;readonly DEPTH_COMPONENT:GLenum;readonly DEPTH_COMPONENT16:GLenum;readonly DEPTH_FUNC:GLenum;readonly DEPTH_RANGE:GLenum;readonly DEPTH_STENCIL:GLenum;readonly DEPTH_STENCIL_ATTACHMENT:GLenum;readonly DEPTH_TEST:GLenum;readonly DEPTH_WRITEMASK:GLenum;readonly DITHER:GLenum;readonly DONT_CARE:GLenum;readonly DST_ALPHA:GLenum;readonly DST_COLOR:GLenum;readonly DYNAMIC_DRAW:GLenum;readonly ELEMENT_ARRAY_BUFFER:GLenum;readonly ELEMENT_ARRAY_BUFFER_BINDING:GLenum;readonly EQUAL:GLenum;readonly FASTEST:GLenum;readonly FLOAT:GLenum;readonly FLOAT_MAT2:GLenum;readonly FLOAT_MAT3:GLenum;readonly FLOAT_MAT4:GLenum;readonly FLOAT_VEC2:GLenum;readonly FLOAT_VEC3:GLenum;readonly FLOAT_VEC4:GLenum;readonly FRAGMENT_SHADER:GLenum;readonly FRAMEBUFFER:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:GLenum;readonly FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:GLenum;readonly FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:GLenum;readonly FRAMEBUFFER_BINDING:GLenum;readonly FRAMEBUFFER_COMPLETE:GLenum;readonly FRAMEBUFFER_INCOMPLETE_ATTACHMENT:GLenum;readonly FRAMEBUFFER_INCOMPLETE_DIMENSIONS:GLenum;readonly FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:GLenum;readonly FRAMEBUFFER_UNSUPPORTED:GLenum;readonly FRONT:GLenum;readonly FRONT_AND_BACK:GLenum;readonly FRONT_FACE:GLenum;readonly FUNC_ADD:GLenum;readonly FUNC_REVERSE_SUBTRACT:GLenum;readonly FUNC_SUBTRACT:GLenum;readonly GENERATE_MIPMAP_HINT:GLenum;readonly GEQUAL:GLenum;readonly GREATER:GLenum;readonly GREEN_BITS:GLenum;readonly HIGH_FLOAT:GLenum;readonly HIGH_INT:GLenum;readonly IMPLEMENTATION_COLOR_READ_FORMAT:GLenum;readonly IMPLEMENTATION_COLOR_READ_TYPE:GLenum;readonly INCR:GLenum;readonly INCR_WRAP:GLenum;readonly INT:GLenum;readonly INT_VEC2:GLenum;readonly INT_VEC3:GLenum;readonly INT_VEC4:GLenum;readonly INVALID_ENUM:GLenum;readonly INVALID_FRAMEBUFFER_OPERATION:GLenum;readonly INVALID_OPERATION:GLenum;readonly INVALID_VALUE:GLenum;readonly INVERT:GLenum;readonly KEEP:GLenum;readonly LEQUAL:GLenum;readonly LESS:GLenum;readonly LINEAR:GLenum;readonly LINEAR_MIPMAP_LINEAR:GLenum;readonly LINEAR_MIPMAP_NEAREST:GLenum;readonly LINES:GLenum;readonly LINE_LOOP:GLenum;readonly LINE_STRIP:GLenum;readonly LINE_WIDTH:GLenum;readonly LINK_STATUS:GLenum;readonly LOW_FLOAT:GLenum;readonly LOW_INT:GLenum;readonly LUMINANCE:GLenum;readonly LUMINANCE_ALPHA:GLenum;readonly MAX_COMBINED_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_CUBE_MAP_TEXTURE_SIZE:GLenum;readonly MAX_FRAGMENT_UNIFORM_VECTORS:GLenum;readonly MAX_RENDERBUFFER_SIZE:GLenum;readonly MAX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_TEXTURE_SIZE:GLenum;readonly MAX_VARYING_VECTORS:GLenum;readonly MAX_VERTEX_ATTRIBS:GLenum;readonly MAX_VERTEX_TEXTURE_IMAGE_UNITS:GLenum;readonly MAX_VERTEX_UNIFORM_VECTORS:GLenum;readonly MAX_VIEWPORT_DIMS:GLenum;readonly MEDIUM_FLOAT:GLenum;readonly MEDIUM_INT:GLenum;readonly MIRRORED_REPEAT:GLenum;readonly NEAREST:GLenum;readonly NEAREST_MIPMAP_LINEAR:GLenum;readonly NEAREST_MIPMAP_NEAREST:GLenum;readonly NEVER:GLenum;readonly NICEST:GLenum;readonly NONE:GLenum;readonly NOTEQUAL:GLenum;readonly NO_ERROR:GLenum;readonly ONE:GLenum;readonly ONE_MINUS_CONSTANT_ALPHA:GLenum;readonly ONE_MINUS_CONSTANT_COLOR:GLenum;readonly ONE_MINUS_DST_ALPHA:GLenum;readonly ONE_MINUS_DST_COLOR:GLenum;readonly ONE_MINUS_SRC_ALPHA:GLenum;readonly ONE_MINUS_SRC_COLOR:GLenum;readonly OUT_OF_MEMORY:GLenum;readonly PACK_ALIGNMENT:GLenum;readonly POINTS:GLenum;readonly POLYGON_OFFSET_FACTOR:GLenum;readonly POLYGON_OFFSET_FILL:GLenum;readonly POLYGON_OFFSET_UNITS:GLenum;readonly RED_BITS:GLenum;readonly RENDERBUFFER:GLenum;readonly RENDERBUFFER_ALPHA_SIZE:GLenum;readonly RENDERBUFFER_BINDING:GLenum;readonly RENDERBUFFER_BLUE_SIZE:GLenum;readonly RENDERBUFFER_DEPTH_SIZE:GLenum;readonly RENDERBUFFER_GREEN_SIZE:GLenum;readonly RENDERBUFFER_HEIGHT:GLenum;readonly RENDERBUFFER_INTERNAL_FORMAT:GLenum;readonly RENDERBUFFER_RED_SIZE:GLenum;readonly RENDERBUFFER_STENCIL_SIZE:GLenum;readonly RENDERBUFFER_WIDTH:GLenum;readonly RENDERER:GLenum;readonly REPEAT:GLenum;readonly REPLACE:GLenum;readonly RGB:GLenum;readonly RGB565:GLenum;readonly RGB5_A1:GLenum;readonly RGBA:GLenum;readonly RGBA4:GLenum;readonly SAMPLER_2D:GLenum;readonly SAMPLER_CUBE:GLenum;readonly SAMPLES:GLenum;readonly SAMPLE_ALPHA_TO_COVERAGE:GLenum;readonly SAMPLE_BUFFERS:GLenum;readonly SAMPLE_COVERAGE:GLenum;readonly SAMPLE_COVERAGE_INVERT:GLenum;readonly SAMPLE_COVERAGE_VALUE:GLenum;readonly SCISSOR_BOX:GLenum;readonly SCISSOR_TEST:GLenum;readonly SHADER_TYPE:GLenum;readonly SHADING_LANGUAGE_VERSION:GLenum;readonly SHORT:GLenum;readonly SRC_ALPHA:GLenum;readonly SRC_ALPHA_SATURATE:GLenum;readonly SRC_COLOR:GLenum;readonly STATIC_DRAW:GLenum;readonly STENCIL_ATTACHMENT:GLenum;readonly STENCIL_BACK_FAIL:GLenum;readonly STENCIL_BACK_FUNC:GLenum;readonly STENCIL_BACK_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_BACK_PASS_DEPTH_PASS:GLenum;readonly STENCIL_BACK_REF:GLenum;readonly STENCIL_BACK_VALUE_MASK:GLenum;readonly STENCIL_BACK_WRITEMASK:GLenum;readonly STENCIL_BITS:GLenum;readonly STENCIL_BUFFER_BIT:GLenum;readonly STENCIL_CLEAR_VALUE:GLenum;readonly STENCIL_FAIL:GLenum;readonly STENCIL_FUNC:GLenum;readonly STENCIL_INDEX8:GLenum;readonly STENCIL_PASS_DEPTH_FAIL:GLenum;readonly STENCIL_PASS_DEPTH_PASS:GLenum;readonly STENCIL_REF:GLenum;readonly STENCIL_TEST:GLenum;readonly STENCIL_VALUE_MASK:GLenum;readonly STENCIL_WRITEMASK:GLenum;readonly STREAM_DRAW:GLenum;readonly SUBPIXEL_BITS:GLenum;readonly TEXTURE:GLenum;readonly TEXTURE0:GLenum;readonly TEXTURE1:GLenum;readonly TEXTURE10:GLenum;readonly TEXTURE11:GLenum;readonly TEXTURE12:GLenum;readonly TEXTURE13:GLenum;readonly TEXTURE14:GLenum;readonly TEXTURE15:GLenum;readonly TEXTURE16:GLenum;readonly TEXTURE17:GLenum;readonly TEXTURE18:GLenum;readonly TEXTURE19:GLenum;readonly TEXTURE2:GLenum;readonly TEXTURE20:GLenum;readonly TEXTURE21:GLenum;readonly TEXTURE22:GLenum;readonly TEXTURE23:GLenum;readonly TEXTURE24:GLenum;readonly TEXTURE25:GLenum;readonly TEXTURE26:GLenum;readonly TEXTURE27:GLenum;readonly TEXTURE28:GLenum;readonly TEXTURE29:GLenum;readonly TEXTURE3:GLenum;readonly TEXTURE30:GLenum;readonly TEXTURE31:GLenum;readonly TEXTURE4:GLenum;readonly TEXTURE5:GLenum;readonly TEXTURE6:GLenum;readonly TEXTURE7:GLenum;readonly TEXTURE8:GLenum;readonly TEXTURE9:GLenum;readonly TEXTURE_2D:GLenum;readonly TEXTURE_BINDING_2D:GLenum;readonly TEXTURE_BINDING_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_NEGATIVE_Z:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_X:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Y:GLenum;readonly TEXTURE_CUBE_MAP_POSITIVE_Z:GLenum;readonly TEXTURE_MAG_FILTER:GLenum;readonly TEXTURE_MIN_FILTER:GLenum;readonly TEXTURE_WRAP_S:GLenum;readonly TEXTURE_WRAP_T:GLenum;readonly TRIANGLES:GLenum;readonly TRIANGLE_FAN:GLenum;readonly TRIANGLE_STRIP:GLenum;readonly UNPACK_ALIGNMENT:GLenum;readonly UNPACK_COLORSPACE_CONVERSION_WEBGL:GLenum;readonly UNPACK_FLIP_Y_WEBGL:GLenum;readonly UNPACK_PREMULTIPLY_ALPHA_WEBGL:GLenum;readonly UNSIGNED_BYTE:GLenum;readonly UNSIGNED_INT:GLenum;readonly UNSIGNED_SHORT:GLenum;readonly UNSIGNED_SHORT_4_4_4_4:GLenum;readonly UNSIGNED_SHORT_5_5_5_1:GLenum;readonly UNSIGNED_SHORT_5_6_5:GLenum;readonly VALIDATE_STATUS:GLenum;readonly VENDOR:GLenum;readonly VERSION:GLenum;readonly VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:GLenum;readonly VERTEX_ATTRIB_ARRAY_ENABLED:GLenum;readonly VERTEX_ATTRIB_ARRAY_NORMALIZED:GLenum;readonly VERTEX_ATTRIB_ARRAY_POINTER:GLenum;readonly VERTEX_ATTRIB_ARRAY_SIZE:GLenum;readonly VERTEX_ATTRIB_ARRAY_STRIDE:GLenum;readonly VERTEX_ATTRIB_ARRAY_TYPE:GLenum;readonly VERTEX_SHADER:GLenum;readonly VIEWPORT:GLenum;readonly ZERO:GLenum;}interface WebGLRenderingContextOverloads{bufferData(target:GLenum,size:GLsizeiptr,usage:GLenum):void;bufferData(target:GLenum,data:BufferSource|null,usage:GLenum):void;bufferSubData(target:GLenum,offset:GLintptr,data:BufferSource):void;compressedTexImage2D(target:GLenum,level:GLint,internalformat:GLenum,width:GLsizei,height:GLsizei,border:GLint,data:ArrayBufferView):void;compressedTexSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,data:ArrayBufferView):void;readPixels(x:GLint,y:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,pixels:ArrayBufferView|null):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,width:GLsizei,height:GLsizei,border:GLint,format:GLenum,type:GLenum,pixels:ArrayBufferView|null):void;texImage2D(target:GLenum,level:GLint,internalformat:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,width:GLsizei,height:GLsizei,format:GLenum,type:GLenum,pixels:ArrayBufferView|null):void;texSubImage2D(target:GLenum,level:GLint,xoffset:GLint,yoffset:GLint,format:GLenum,type:GLenum,source:TexImageSource):void;uniform1fv(location:WebGLUniformLocation|null,v:Float32List):void;uniform1iv(location:WebGLUniformLocation|null,v:Int32List):void;uniform2fv(location:WebGLUniformLocation|null,v:Float32List):void;uniform2iv(location:WebGLUniformLocation|null,v:Int32List):void;uniform3fv(location:WebGLUniformLocation|null,v:Float32List):void;uniform3iv(location:WebGLUniformLocation|null,v:Int32List):void;uniform4fv(location:WebGLUniformLocation|null,v:Float32List):void;uniform4iv(location:WebGLUniformLocation|null,v:Int32List):void;uniformMatrix2fv(location:WebGLUniformLocation|null,transpose:GLboolean,value:Float32List):void;uniformMatrix3fv(location:WebGLUniformLocation|null,transpose:GLboolean,value:Float32List):void;uniformMatrix4fv(location:WebGLUniformLocation|null,transpose:GLboolean,value:Float32List):void;}interface WebGLSampler extends WebGLObject{}declare var WebGLSampler:{prototype:WebGLSampler;new():WebGLSampler;};interface WebGLShader extends WebGLObject{}declare var WebGLShader:{prototype:WebGLShader;new():WebGLShader;};interface WebGLShaderPrecisionFormat{readonly precision:GLint;readonly rangeMax:GLint;readonly rangeMin:GLint;}declare var WebGLShaderPrecisionFormat:{prototype:WebGLShaderPrecisionFormat;new():WebGLShaderPrecisionFormat;};interface WebGLSync extends WebGLObject{}declare var WebGLSync:{prototype:WebGLSync;new():WebGLSync;};interface WebGLTexture extends WebGLObject{}declare var WebGLTexture:{prototype:WebGLTexture;new():WebGLTexture;};interface WebGLTransformFeedback extends WebGLObject{}declare var WebGLTransformFeedback:{prototype:WebGLTransformFeedback;new():WebGLTransformFeedback;};interface WebGLUniformLocation{}declare var WebGLUniformLocation:{prototype:WebGLUniformLocation;new():WebGLUniformLocation;};interface WebGLVertexArrayObject extends WebGLObject{}declare var WebGLVertexArrayObject:{prototype:WebGLVertexArrayObject;new():WebGLVertexArrayObject;};interface WebGLVertexArrayObjectOES extends WebGLObject{}interface WebSocketEventMap{"close":CloseEvent;"error":Event;"message":MessageEvent;"open":Event;}interface WebSocket extends EventTarget{binaryType:BinaryType;readonly bufferedAmount:number;readonly extensions:string;onclose:((this:WebSocket,ev:CloseEvent)=>any)|null;onerror:((this:WebSocket,ev:Event)=>any)|null;onmessage:((this:WebSocket,ev:MessageEvent)=>any)|null;onopen:((this:WebSocket,ev:Event)=>any)|null;readonly protocol:string;readonly readyState:number;readonly url:string;close(code?:number,reason?:string):void;send(data:string|ArrayBufferLike|Blob|ArrayBufferView):void;readonly CLOSED:number;readonly CLOSING:number;readonly CONNECTING:number;readonly OPEN:number;addEventListener<K extends keyof WebSocketEventMap>(type:K,listener:(this:WebSocket,ev:WebSocketEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof WebSocketEventMap>(type:K,listener:(this:WebSocket,ev:WebSocketEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var WebSocket:{prototype:WebSocket;new(url:string,protocols?:string|string[]):WebSocket;readonly CLOSED:number;readonly CLOSING:number;readonly CONNECTING:number;readonly OPEN:number;};interface WindowClient extends Client{readonly ancestorOrigins:ReadonlyArray<string>;readonly focused:boolean;readonly visibilityState:VisibilityState;focus():Promise<WindowClient>;navigate(url:string):Promise<WindowClient|null>;}declare var WindowClient:{prototype:WindowClient;new():WindowClient;};interface WindowOrWorkerGlobalScope{readonly caches:CacheStorage;readonly crypto:Crypto;readonly indexedDB:IDBFactory;readonly isSecureContext:boolean;readonly origin:string;readonly performance:Performance;atob(data:string):string;btoa(data:string):string;clearInterval(handle?:number):void;clearTimeout(handle?:number):void;createImageBitmap(image:ImageBitmapSource,options?:ImageBitmapOptions):Promise<ImageBitmap>;createImageBitmap(image:ImageBitmapSource,sx:number,sy:number,sw:number,sh:number,options?:ImageBitmapOptions):Promise<ImageBitmap>;fetch(input:RequestInfo,init?:RequestInit):Promise<Response>;queueMicrotask(callback:VoidFunction):void;setInterval(handler:TimerHandler,timeout?:number,...arguments:any[]):number;setTimeout(handler:TimerHandler,timeout?:number,...arguments:any[]):number;}interface WorkerEventMap extends AbstractWorkerEventMap{"message":MessageEvent;"messageerror":MessageEvent;}interface Worker extends EventTarget,AbstractWorker{onmessage:((this:Worker,ev:MessageEvent)=>any)|null;onmessageerror:((this:Worker,ev:MessageEvent)=>any)|null;postMessage(message:any,transfer:Transferable[]):void;postMessage(message:any,options?:PostMessageOptions):void;terminate():void;addEventListener<K extends keyof WorkerEventMap>(type:K,listener:(this:Worker,ev:WorkerEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof WorkerEventMap>(type:K,listener:(this:Worker,ev:WorkerEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var Worker:{prototype:Worker;new(stringUrl:string|URL,options?:WorkerOptions):Worker;};interface WorkerGlobalScopeEventMap{"error":ErrorEvent;"languagechange":Event;"offline":Event;"online":Event;"rejectionhandled":PromiseRejectionEvent;"unhandledrejection":PromiseRejectionEvent;}interface WorkerGlobalScope extends EventTarget,WindowOrWorkerGlobalScope{readonly location:WorkerLocation;readonly navigator:WorkerNavigator;onerror:((this:WorkerGlobalScope,ev:ErrorEvent)=>any)|null;onlanguagechange:((this:WorkerGlobalScope,ev:Event)=>any)|null;onoffline:((this:WorkerGlobalScope,ev:Event)=>any)|null;ononline:((this:WorkerGlobalScope,ev:Event)=>any)|null;onrejectionhandled:((this:WorkerGlobalScope,ev:PromiseRejectionEvent)=>any)|null;onunhandledrejection:((this:WorkerGlobalScope,ev:PromiseRejectionEvent)=>any)|null;readonly self:WorkerGlobalScope&typeof globalThis;importScripts(...urls:string[]):void;addEventListener<K extends keyof WorkerGlobalScopeEventMap>(type:K,listener:(this:WorkerGlobalScope,ev:WorkerGlobalScopeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof WorkerGlobalScopeEventMap>(type:K,listener:(this:WorkerGlobalScope,ev:WorkerGlobalScopeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var WorkerGlobalScope:{prototype:WorkerGlobalScope;new():WorkerGlobalScope;};interface WorkerLocation{readonly hash:string;readonly host:string;readonly hostname:string;readonly href:string;toString():string;readonly origin:string;readonly pathname:string;readonly port:string;readonly protocol:string;readonly search:string;}declare var WorkerLocation:{prototype:WorkerLocation;new():WorkerLocation;};interface WorkerNavigator extends NavigatorConcurrentHardware,NavigatorID,NavigatorLanguage,NavigatorOnLine,NavigatorStorage{readonly permissions:Permissions;readonly serviceWorker:ServiceWorkerContainer;}declare var WorkerNavigator:{prototype:WorkerNavigator;new():WorkerNavigator;};interface WritableStream<W=any>{readonly locked:boolean;abort(reason?:any):Promise<void>;getWriter():WritableStreamDefaultWriter<W>;}declare var WritableStream:{prototype:WritableStream;new<W=any>(underlyingSink?:UnderlyingSink<W>,strategy?:QueuingStrategy<W>):WritableStream<W>;};interface WritableStreamDefaultController{error(error?:any):void;}interface WritableStreamDefaultWriter<W=any>{readonly closed:Promise<void>;readonly desiredSize:number|null;readonly ready:Promise<void>;abort(reason?:any):Promise<void>;close():Promise<void>;releaseLock():void;write(chunk:W):Promise<void>;}interface XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap{"readystatechange":Event;}interface XMLHttpRequest extends XMLHttpRequestEventTarget{onreadystatechange:((this:XMLHttpRequest,ev:Event)=>any)|null;readonly readyState:number;readonly response:any;readonly responseText:string;responseType:XMLHttpRequestResponseType;readonly responseURL:string;readonly status:number;readonly statusText:string;timeout:number;readonly upload:XMLHttpRequestUpload;withCredentials:boolean;abort():void;getAllResponseHeaders():string;getResponseHeader(name:string):string|null;open(method:string,url:string):void;open(method:string,url:string,async:boolean,username?:string|null,password?:string|null):void;overrideMimeType(mime:string):void;send(body?:BodyInit|null):void;setRequestHeader(name:string,value:string):void;readonly DONE:number;readonly HEADERS_RECEIVED:number;readonly LOADING:number;readonly OPENED:number;readonly UNSENT:number;addEventListener<K extends keyof XMLHttpRequestEventMap>(type:K,listener:(this:XMLHttpRequest,ev:XMLHttpRequestEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof XMLHttpRequestEventMap>(type:K,listener:(this:XMLHttpRequest,ev:XMLHttpRequestEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var XMLHttpRequest:{prototype:XMLHttpRequest;new():XMLHttpRequest;readonly DONE:number;readonly HEADERS_RECEIVED:number;readonly LOADING:number;readonly OPENED:number;readonly UNSENT:number;};interface XMLHttpRequestEventTargetEventMap{"abort":ProgressEvent<XMLHttpRequestEventTarget>;"error":ProgressEvent<XMLHttpRequestEventTarget>;"load":ProgressEvent<XMLHttpRequestEventTarget>;"loadend":ProgressEvent<XMLHttpRequestEventTarget>;"loadstart":ProgressEvent<XMLHttpRequestEventTarget>;"progress":ProgressEvent<XMLHttpRequestEventTarget>;"timeout":ProgressEvent<XMLHttpRequestEventTarget>;}interface XMLHttpRequestEventTarget extends EventTarget{onabort:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;onerror:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;onload:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;onloadend:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;onloadstart:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;onprogress:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;ontimeout:((this:XMLHttpRequest,ev:ProgressEvent)=>any)|null;addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type:K,listener:(this:XMLHttpRequestEventTarget,ev:XMLHttpRequestEventTargetEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type:K,listener:(this:XMLHttpRequestEventTarget,ev:XMLHttpRequestEventTargetEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var XMLHttpRequestEventTarget:{prototype:XMLHttpRequestEventTarget;new():XMLHttpRequestEventTarget;};interface XMLHttpRequestUpload extends XMLHttpRequestEventTarget{addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type:K,listener:(this:XMLHttpRequestUpload,ev:XMLHttpRequestEventTargetEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type:K,listener:(this:XMLHttpRequestUpload,ev:XMLHttpRequestEventTargetEventMap[K])=>any,options?:boolean|EventListenerOptions):void;removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;}declare var XMLHttpRequestUpload:{prototype:XMLHttpRequestUpload;new():XMLHttpRequestUpload;};declare type EventListenerOrEventListenerObject=EventListener|EventListenerObject;interface Console{memory:any;assert(condition?:boolean,...data:any[]):void;clear():void;count(label?:string):void;countReset(label?:string):void;debug(...data:any[]):void;dir(item?:any,options?:any):void;dirxml(...data:any[]):void;error(...data:any[]):void;exception(message?:string,...optionalParams:any[]):void;group(...data:any[]):void;groupCollapsed(...data:any[]):void;groupEnd():void;info(...data:any[]):void;log(...data:any[]):void;table(tabularData?:any,properties?:string[]):void;time(label?:string):void;timeEnd(label?:string):void;timeLog(label?:string,...data:any[]):void;timeStamp(label?:string):void;trace(...data:any[]):void;warn(...data:any[]):void;}declare var console:Console;declare namespace WebAssembly{interface Global{value:any;valueOf():any;}var Global:{prototype:Global;new(descriptor:GlobalDescriptor,v?:any):Global;};interface Instance{readonly exports:Exports;}var Instance:{prototype:Instance;new(module:Module,importObject?:Imports):Instance;};interface Memory{readonly buffer:ArrayBuffer;grow(delta:number):number;}var Memory:{prototype:Memory;new(descriptor:MemoryDescriptor):Memory;};interface Module{}var Module:{prototype:Module;new(bytes:BufferSource):Module;customSections(moduleObject:Module,sectionName:string):ArrayBuffer[];exports(moduleObject:Module):ModuleExportDescriptor[];imports(moduleObject:Module):ModuleImportDescriptor[];};interface Table{readonly length:number;get(index:number):Function|null;grow(delta:number):number;set(index:number,value:Function|null):void;}var Table:{prototype:Table;new(descriptor:TableDescriptor):Table;};interface GlobalDescriptor{mutable?:boolean;value:ValueType;}interface MemoryDescriptor{initial:number;maximum?:number;}interface ModuleExportDescriptor{kind:ImportExportKind;name:string;}interface ModuleImportDescriptor{kind:ImportExportKind;module:string;name:string;}interface TableDescriptor{element:TableKind;initial:number;maximum?:number;}interface WebAssemblyInstantiatedSource{instance:Instance;module:Module;}type ImportExportKind="function"|"global"|"memory"|"table";type TableKind="anyfunc";type ValueType="f32"|"f64"|"i32"|"i64";type ExportValue=Function|Global|Memory|Table;type Exports=Record<string,ExportValue>;type ImportValue=ExportValue|number;type ModuleImports=Record<string,ImportValue>;type Imports=Record<string,ModuleImports>;function compile(bytes:BufferSource):Promise<Module>;function compileStreaming(source:Response|Promise<Response>):Promise<Module>;function instantiate(bytes:BufferSource,importObject?:Imports):Promise<WebAssemblyInstantiatedSource>;function instantiate(moduleObject:Module,importObject?:Imports):Promise<Instance>;function instantiateStreaming(response:Response|PromiseLike<Response>,importObject?:Imports):Promise<WebAssemblyInstantiatedSource>;function validate(bytes:BufferSource):boolean;}interface FrameRequestCallback{(time:number):void;}interface OnErrorEventHandlerNonNull{(event:Event|string,source?:string,lineno?:number,colno?:number,error?:Error):any;}interface PerformanceObserverCallback{(entries:PerformanceObserverEntryList,observer:PerformanceObserver):void;}interface QueuingStrategySizeCallback<T=any>{(chunk:T):number;}interface ReadableByteStreamControllerCallback{(controller:ReadableByteStreamController):void|PromiseLike<void>;}interface ReadableStreamDefaultControllerCallback<R>{(controller:ReadableStreamDefaultController<R>):void|PromiseLike<void>;}interface ReadableStreamErrorCallback{(reason:any):void|PromiseLike<void>;}interface TransformStreamDefaultControllerCallback<O>{(controller:TransformStreamDefaultController<O>):void|PromiseLike<void>;}interface TransformStreamDefaultControllerTransformCallback<I,O>{(chunk:I,controller:TransformStreamDefaultController<O>):void|PromiseLike<void>;}interface VoidFunction{():void;}interface WritableStreamDefaultControllerCloseCallback{():void|PromiseLike<void>;}interface WritableStreamDefaultControllerStartCallback{(controller:WritableStreamDefaultController):void|PromiseLike<void>;}interface WritableStreamDefaultControllerWriteCallback<W>{(chunk:W,controller:WritableStreamDefaultController):void|PromiseLike<void>;}interface WritableStreamErrorCallback{(reason:any):void|PromiseLike<void>;}declare var name:string;declare var onmessage:((this:DedicatedWorkerGlobalScope,ev:MessageEvent)=>any)|null;declare var onmessageerror:((this:DedicatedWorkerGlobalScope,ev:MessageEvent)=>any)|null;declare function close():void;declare function postMessage(message:any,transfer:Transferable[]):void;declare function postMessage(message:any,options?:PostMessageOptions):void;declare function dispatchEvent(event:Event):boolean;declare var location:WorkerLocation;declare var navigator:WorkerNavigator;declare var onerror:((this:DedicatedWorkerGlobalScope,ev:ErrorEvent)=>any)|null;declare var onlanguagechange:((this:DedicatedWorkerGlobalScope,ev:Event)=>any)|null;declare var onoffline:((this:DedicatedWorkerGlobalScope,ev:Event)=>any)|null;declare var ononline:((this:DedicatedWorkerGlobalScope,ev:Event)=>any)|null;declare var onrejectionhandled:((this:DedicatedWorkerGlobalScope,ev:PromiseRejectionEvent)=>any)|null;declare var onunhandledrejection:((this:DedicatedWorkerGlobalScope,ev:PromiseRejectionEvent)=>any)|null;declare var self:WorkerGlobalScope&typeof globalThis;declare function importScripts(...urls:string[]):void;declare function dispatchEvent(event:Event):boolean;declare var caches:CacheStorage;declare var crypto:Crypto;declare var indexedDB:IDBFactory;declare var isSecureContext:boolean;declare var origin:string;declare var performance:Performance;declare function atob(data:string):string;declare function btoa(data:string):string;declare function clearInterval(handle?:number):void;declare function clearTimeout(handle?:number):void;declare function createImageBitmap(image:ImageBitmapSource,options?:ImageBitmapOptions):Promise<ImageBitmap>;declare function createImageBitmap(image:ImageBitmapSource,sx:number,sy:number,sw:number,sh:number,options?:ImageBitmapOptions):Promise<ImageBitmap>;declare function fetch(input:RequestInfo,init?:RequestInit):Promise<Response>;declare function queueMicrotask(callback:VoidFunction):void;declare function setInterval(handler:TimerHandler,timeout?:number,...arguments:any[]):number;declare function setTimeout(handler:TimerHandler,timeout?:number,...arguments:any[]):number;declare function cancelAnimationFrame(handle:number):void;declare function requestAnimationFrame(callback:FrameRequestCallback):number;declare function addEventListener<K extends keyof DedicatedWorkerGlobalScopeEventMap>(type:K,listener:(this:DedicatedWorkerGlobalScope,ev:DedicatedWorkerGlobalScopeEventMap[K])=>any,options?:boolean|AddEventListenerOptions):void;declare function addEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|AddEventListenerOptions):void;declare function removeEventListener<K extends keyof DedicatedWorkerGlobalScopeEventMap>(type:K,listener:(this:DedicatedWorkerGlobalScope,ev:DedicatedWorkerGlobalScopeEventMap[K])=>any,options?:boolean|EventListenerOptions):void;declare function removeEventListener(type:string,listener:EventListenerOrEventListenerObject,options?:boolean|EventListenerOptions):void;type HeadersInit=Headers|string[][]|Record<string,string>;type BodyInit=Blob|BufferSource|FormData|URLSearchParams|ReadableStream<Uint8Array>|string;type RequestInfo=Request|string;type BlobPart=BufferSource|Blob|string;type DOMHighResTimeStamp=number;type CanvasImageSource=ImageBitmap|OffscreenCanvas;type OffscreenRenderingContext=OffscreenCanvasRenderingContext2D|ImageBitmapRenderingContext|WebGLRenderingContext|WebGL2RenderingContext;type MessageEventSource=MessagePort|ServiceWorker;type ImageBitmapSource=CanvasImageSource|Blob|ImageData;type OnErrorEventHandler=OnErrorEventHandlerNonNull|null;type TimerHandler=string|Function;type PerformanceEntryList=PerformanceEntry[];type PushMessageDataInit=BufferSource|string;type ReadableStreamReadResult<T>=ReadableStreamReadValueResult<T>|ReadableStreamReadDoneResult<T>;type VibratePattern=number|number[];type AlgorithmIdentifier=string|Algorithm;type HashAlgorithmIdentifier=AlgorithmIdentifier;type BigInteger=Uint8Array;type NamedCurve=string;type GLenum=number;type GLboolean=boolean;type GLbitfield=number;type GLint=number;type GLsizei=number;type GLintptr=number;type GLsizeiptr=number;type GLuint=number;type GLfloat=number;type GLclampf=number;type TexImageSource=ImageBitmap|ImageData|OffscreenCanvas;type Float32List=Float32Array|GLfloat[];type Int32List=Int32Array|GLint[];type GLint64=number;type GLuint64=number;type Uint32List=Uint32Array|GLuint[];type BufferSource=ArrayBufferView|ArrayBuffer;type DOMTimeStamp=number;type FormDataEntryValue=File|string;type IDBValidKey=number|string|Date|BufferSource|IDBArrayKey;type Transferable=ArrayBuffer|MessagePort|ImageBitmap|OffscreenCanvas;type BinaryType="arraybuffer"|"blob";type CanvasDirection="inherit"|"ltr"|"rtl";type CanvasFillRule="evenodd"|"nonzero";type CanvasLineCap="butt"|"round"|"square";type CanvasLineJoin="bevel"|"miter"|"round";type CanvasTextAlign="center"|"end"|"left"|"right"|"start";type CanvasTextBaseline="alphabetic"|"bottom"|"hanging"|"ideographic"|"middle"|"top";type ClientTypes="all"|"sharedworker"|"window"|"worker";type ColorSpaceConversion="default"|"none";type EndingType="native"|"transparent";type FrameType="auxiliary"|"nested"|"none"|"top-level";type IDBCursorDirection="next"|"nextunique"|"prev"|"prevunique";type IDBRequestReadyState="done"|"pending";type IDBTransactionMode="readonly"|"readwrite"|"versionchange";type ImageOrientation="flipY"|"none";type ImageSmoothingQuality="high"|"low"|"medium";type KeyFormat="jwk"|"pkcs8"|"raw"|"spki";type KeyType="private"|"public"|"secret";type KeyUsage="decrypt"|"deriveBits"|"deriveKey"|"encrypt"|"sign"|"unwrapKey"|"verify"|"wrapKey";type NotificationDirection="auto"|"ltr"|"rtl";type NotificationPermission="default"|"denied"|"granted";type OffscreenRenderingContextId="2d"|"bitmaprenderer"|"webgl"|"webgl2";type PermissionName="accelerometer"|"ambient-light-sensor"|"background-sync"|"bluetooth"|"camera"|"clipboard"|"device-info"|"geolocation"|"gyroscope"|"magnetometer"|"microphone"|"midi"|"notifications"|"persistent-storage"|"push"|"speaker";type PermissionState="denied"|"granted"|"prompt";type PremultiplyAlpha="default"|"none"|"premultiply";type PushEncryptionKeyName="auth"|"p256dh";type PushPermissionState="denied"|"granted"|"prompt";type ReferrerPolicy=""|"no-referrer"|"no-referrer-when-downgrade"|"origin"|"origin-when-cross-origin"|"same-origin"|"strict-origin"|"strict-origin-when-cross-origin"|"unsafe-url";type RequestCache="default"|"force-cache"|"no-cache"|"no-store"|"only-if-cached"|"reload";type RequestCredentials="include"|"omit"|"same-origin";type RequestDestination=""|"audio"|"audioworklet"|"document"|"embed"|"font"|"image"|"manifest"|"object"|"paintworklet"|"report"|"script"|"sharedworker"|"style"|"track"|"video"|"worker"|"xslt";type RequestMode="cors"|"navigate"|"no-cors"|"same-origin";type RequestRedirect="error"|"follow"|"manual";type ResizeQuality="high"|"low"|"medium"|"pixelated";type ResponseType="basic"|"cors"|"default"|"error"|"opaque"|"opaqueredirect";type ServiceWorkerState="activated"|"activating"|"installed"|"installing"|"parsed"|"redundant";type ServiceWorkerUpdateViaCache="all"|"imports"|"none";type VisibilityState="hidden"|"visible";type WebGLPowerPreference="default"|"high-performance"|"low-power";type WorkerType="classic"|"module";type XMLHttpRequestResponseType=""|"arraybuffer"|"blob"|"document"|"json"|"text";`
    }, {
        fileName: "lib.webworker.importscripts.d.ts",
        text: `/// <reference no-default-lib="true"/>\ndeclare function importScripts(...urls:string[]):void;`
    }];
    return libFiles;
}

class InMemoryFileSystemHost {
    constructor(options) {
        this.directories = new Map();
        this.getOrCreateDir("/");
        if (!(options === null || options === void 0 ? void 0 : options.skipLoadingLibFiles)) {
            const libFiles = getLibFiles();
            for (const libFile of libFiles)
                this._writeFileSync(`/node_modules/typescript/lib/${libFile.fileName}`, libFile.text);
        }
    }
    isCaseSensitive() {
        return true;
    }
    delete(path) {
        try {
            this.deleteSync(path);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    deleteSync(path) {
        const standardizedPath = FileUtils.getStandardizedAbsolutePath(this, path);
        if (this.directories.has(standardizedPath)) {
            for (const descendantDirPath of getDescendantDirectories(this.directories.keys(), standardizedPath))
                this.directories.delete(descendantDirPath);
            this.directories.delete(standardizedPath);
            return;
        }
        const parentDir = this.directories.get(FileUtils.getDirPath(standardizedPath));
        if (parentDir == null || !parentDir.files.has(standardizedPath))
            throw new errors.FileNotFoundError(standardizedPath);
        parentDir.files.delete(standardizedPath);
    }
    readDirSync(dirPath) {
        const standardizedDirPath = FileUtils.getStandardizedAbsolutePath(this, dirPath);
        const dir = this.directories.get(standardizedDirPath);
        if (dir == null)
            throw new errors.DirectoryNotFoundError(standardizedDirPath);
        return [...getDirectories(this.directories.keys()), ...dir.files.keys()];
        function* getDirectories(dirPaths) {
            for (const path of dirPaths) {
                const parentDir = FileUtils.getDirPath(path);
                if (parentDir === standardizedDirPath && parentDir !== path)
                    yield path;
            }
        }
    }
    readFile(filePath, encoding = "utf-8") {
        try {
            return Promise.resolve(this.readFileSync(filePath, encoding));
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    readFileSync(filePath, encoding = "utf-8") {
        const standardizedFilePath = FileUtils.getStandardizedAbsolutePath(this, filePath);
        const parentDir = this.directories.get(FileUtils.getDirPath(standardizedFilePath));
        if (parentDir == null)
            throw new errors.FileNotFoundError(standardizedFilePath);
        const fileText = parentDir.files.get(standardizedFilePath);
        if (fileText === undefined)
            throw new errors.FileNotFoundError(standardizedFilePath);
        return fileText;
    }
    writeFile(filePath, fileText) {
        this.writeFileSync(filePath, fileText);
        return Promise.resolve();
    }
    writeFileSync(filePath, fileText) {
        this._writeFileSync(filePath, fileText);
    }
    _writeFileSync(filePath, fileText) {
        const standardizedFilePath = FileUtils.getStandardizedAbsolutePath(this, filePath);
        const dirPath = FileUtils.getDirPath(standardizedFilePath);
        this.getOrCreateDir(dirPath).files.set(standardizedFilePath, fileText);
    }
    mkdir(dirPath) {
        this.mkdirSync(dirPath);
        return Promise.resolve();
    }
    mkdirSync(dirPath) {
        this.getOrCreateDir(FileUtils.getStandardizedAbsolutePath(this, dirPath));
    }
    move(srcPath, destPath) {
        this.moveSync(srcPath, destPath);
        return Promise.resolve();
    }
    moveSync(srcPath, destPath) {
        const standardizedSrcPath = FileUtils.getStandardizedAbsolutePath(this, srcPath);
        const standardizedDestPath = FileUtils.getStandardizedAbsolutePath(this, destPath);
        if (this.fileExistsSync(standardizedSrcPath)) {
            const fileText = this.readFileSync(standardizedSrcPath);
            this.deleteSync(standardizedSrcPath);
            this.writeFileSync(standardizedDestPath, fileText);
        }
        else if (this.directories.has(standardizedSrcPath)) {
            const moveDirectory = (from, to) => {
                this._copyDirInternal(from, to);
                this.directories.delete(from);
            };
            moveDirectory(standardizedSrcPath, standardizedDestPath);
            for (const descendantDirPath of getDescendantDirectories(this.directories.keys(), standardizedSrcPath)) {
                const relativePath = FileUtils.getRelativePathTo(standardizedSrcPath, descendantDirPath);
                moveDirectory(descendantDirPath, FileUtils.pathJoin(standardizedDestPath, relativePath));
            }
        }
        else {
            throw new errors.PathNotFoundError(standardizedSrcPath);
        }
    }
    copy(srcPath, destPath) {
        this.copySync(srcPath, destPath);
        return Promise.resolve();
    }
    copySync(srcPath, destPath) {
        const standardizedSrcPath = FileUtils.getStandardizedAbsolutePath(this, srcPath);
        const standardizedDestPath = FileUtils.getStandardizedAbsolutePath(this, destPath);
        if (this.fileExistsSync(standardizedSrcPath))
            this.writeFileSync(standardizedDestPath, this.readFileSync(standardizedSrcPath));
        else if (this.directories.has(standardizedSrcPath)) {
            this._copyDirInternal(standardizedSrcPath, standardizedDestPath);
            for (const descendantDirPath of getDescendantDirectories(this.directories.keys(), standardizedSrcPath)) {
                const relativePath = FileUtils.getRelativePathTo(standardizedSrcPath, descendantDirPath);
                this._copyDirInternal(descendantDirPath, FileUtils.pathJoin(standardizedDestPath, relativePath));
            }
        }
        else {
            throw new errors.PathNotFoundError(standardizedSrcPath);
        }
    }
    _copyDirInternal(from, to) {
        const dir = this.directories.get(from);
        const newDir = this.getOrCreateDir(to);
        for (const [filePath, text] of dir.files.entries()) {
            const toDir = FileUtils.pathJoin(to, FileUtils.getBaseName(filePath));
            newDir.files.set(toDir, text);
        }
    }
    fileExists(filePath) {
        return Promise.resolve(this.fileExistsSync(filePath));
    }
    fileExistsSync(filePath) {
        const standardizedFilePath = FileUtils.getStandardizedAbsolutePath(this, filePath);
        const dirPath = FileUtils.getDirPath(standardizedFilePath);
        const dir = this.directories.get(dirPath);
        if (dir == null)
            return false;
        return dir.files.has(standardizedFilePath);
    }
    directoryExists(dirPath) {
        return Promise.resolve(this.directoryExistsSync(dirPath));
    }
    directoryExistsSync(dirPath) {
        return this.directories.has(FileUtils.getStandardizedAbsolutePath(this, dirPath));
    }
    realpathSync(path) {
        return path;
    }
    getCurrentDirectory() {
        return "/";
    }
    glob(patterns) {
        try {
            return Promise.resolve(this.globSync(patterns));
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    globSync(patterns) {
        const allFilePaths = Array.from(getAllFilePaths(this.directories.values()));
        return matchGlobs(allFilePaths, patterns, this.getCurrentDirectory());
        function* getAllFilePaths(directories) {
            for (const dir of directories)
                yield* dir.files.keys();
        }
    }
    getOrCreateDir(dirPath) {
        let dir = this.directories.get(dirPath);
        if (dir == null) {
            dir = { path: dirPath, files: new Map() };
            this.directories.set(dirPath, dir);
            const parentDirPath = FileUtils.getDirPath(dirPath);
            if (parentDirPath !== dirPath)
                this.getOrCreateDir(parentDirPath);
        }
        return dir;
    }
}
function* getDescendantDirectories(directoryPaths, dirPath) {
    for (const path of directoryPaths) {
        if (FileUtils.pathStartsWith(path, dirPath))
            yield path;
    }
}

function createHosts(options) {
    const { transactionalFileSystem, sourceFileContainer, compilerOptions, getNewLine, resolutionHost } = options;
    let version = 0;
    const fileExistsSync = (path) => sourceFileContainer.containsSourceFileAtPath(path)
        || transactionalFileSystem.fileExistsSync(path);
    const languageServiceHost = {
        getCompilationSettings: () => compilerOptions.get(),
        getNewLine,
        getScriptFileNames: () => Array.from(sourceFileContainer.getSourceFilePaths()),
        getScriptVersion: fileName => {
            const filePath = transactionalFileSystem.getStandardizedAbsolutePath(fileName);
            const sourceFile = sourceFileContainer.getSourceFileFromCacheFromFilePath(filePath);
            if (sourceFile == null)
                return (version++).toString();
            return sourceFileContainer.getSourceFileVersion(sourceFile);
        },
        getScriptSnapshot: fileName => {
            const filePath = transactionalFileSystem.getStandardizedAbsolutePath(fileName);
            if (!fileExistsSync(filePath))
                return undefined;
            return ts.ScriptSnapshot.fromString(sourceFileContainer.addOrGetSourceFileFromFilePathSync(filePath, {
                markInProject: false,
                scriptKind: undefined,
            }).getFullText());
        },
        getCurrentDirectory: () => transactionalFileSystem.getCurrentDirectory(),
        getDefaultLibFileName: options => {
            if (transactionalFileSystem.getFileSystem() instanceof RealFileSystemHost)
                return ts.getDefaultLibFilePath(options);
            else {
                return FileUtils.pathJoin(transactionalFileSystem.getCurrentDirectory(), "node_modules/typescript/lib/" + ts.getDefaultLibFileName(options));
            }
        },
        useCaseSensitiveFileNames: () => true,
        readFile: (path, encoding) => {
            const standardizedPath = transactionalFileSystem.getStandardizedAbsolutePath(path);
            if (sourceFileContainer.containsSourceFileAtPath(standardizedPath))
                return sourceFileContainer.getSourceFileFromCacheFromFilePath(standardizedPath).getFullText();
            return transactionalFileSystem.readFileSync(standardizedPath, encoding);
        },
        fileExists: fileExistsSync,
        directoryExists: dirName => {
            const dirPath = transactionalFileSystem.getStandardizedAbsolutePath(dirName);
            return sourceFileContainer.containsDirectoryAtPath(dirPath)
                || transactionalFileSystem.directoryExistsSync(dirPath);
        },
        resolveModuleNames: resolutionHost.resolveModuleNames,
        resolveTypeReferenceDirectives: resolutionHost.resolveTypeReferenceDirectives,
        getResolvedModuleWithFailedLookupLocationsFromCache: resolutionHost.getResolvedModuleWithFailedLookupLocationsFromCache,
    };
    const compilerHost = {
        getSourceFile: (fileName, languageVersion, onError) => {
            const filePath = transactionalFileSystem.getStandardizedAbsolutePath(fileName);
            return sourceFileContainer.addOrGetSourceFileFromFilePathSync(filePath, {
                markInProject: false,
                scriptKind: undefined,
            });
        },
        getDefaultLibFileName: (options) => languageServiceHost.getDefaultLibFileName(options),
        writeFile: (fileName, data, writeByteOrderMark, onError, sourceFiles) => {
            const filePath = transactionalFileSystem.getStandardizedAbsolutePath(fileName);
            transactionalFileSystem.writeFileSync(filePath, writeByteOrderMark ? "\uFEFF" + data : data);
        },
        getCurrentDirectory: () => languageServiceHost.getCurrentDirectory(),
        getDirectories: (path) => transactionalFileSystem.getDirectories(transactionalFileSystem.getStandardizedAbsolutePath(path)),
        fileExists: (fileName) => languageServiceHost.fileExists(fileName),
        readFile: (fileName) => languageServiceHost.readFile(fileName),
        getCanonicalFileName: (fileName) => transactionalFileSystem.getStandardizedAbsolutePath(fileName),
        useCaseSensitiveFileNames: () => languageServiceHost.useCaseSensitiveFileNames(),
        getNewLine: () => languageServiceHost.getNewLine(),
        getEnvironmentVariable: (name) => process.env[name],
        directoryExists: dirName => languageServiceHost.directoryExists(dirName),
        resolveModuleNames: resolutionHost.resolveModuleNames,
        resolveTypeReferenceDirectives: resolutionHost.resolveTypeReferenceDirectives,
    };
    return { languageServiceHost, compilerHost };
}

function createCompilerSourceFile(filePath, scriptSnapshot, scriptTarget, version, setParentNodes, scriptKind) {
    return ts.createLanguageServiceSourceFile(filePath, scriptSnapshot, scriptTarget !== null && scriptTarget !== void 0 ? scriptTarget : ts.ScriptTarget.Latest, version, setParentNodes, scriptKind);
}

class DocumentRegistry {
    constructor(transactionalFileSystem) {
        this.transactionalFileSystem = transactionalFileSystem;
        this.sourceFileCacheByFilePath = new Map();
    }
    createOrUpdateSourceFile(fileName, compilationSettings, scriptSnapshot, scriptKind) {
        let sourceFile = this.sourceFileCacheByFilePath.get(fileName);
        if (sourceFile == null)
            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, DocumentRegistry.initialVersion, scriptKind);
        else
            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, this.getNextSourceFileVersion(sourceFile), scriptKind);
        return sourceFile;
    }
    removeSourceFile(fileName) {
        this.sourceFileCacheByFilePath.delete(fileName);
    }
    acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
        const standardizedFilePath = this.transactionalFileSystem.getStandardizedAbsolutePath(fileName);
        let sourceFile = this.sourceFileCacheByFilePath.get(standardizedFilePath);
        if (sourceFile == null || this.getSourceFileVersion(sourceFile) !== version)
            sourceFile = this.updateSourceFile(standardizedFilePath, compilationSettings, scriptSnapshot, version, scriptKind);
        return sourceFile;
    }
    acquireDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
        return this.acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);
    }
    updateDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
        return this.acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);
    }
    updateDocumentWithKey(fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
        return this.updateDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);
    }
    getKeyForCompilationSettings(settings) {
        return "defaultKey";
    }
    releaseDocument(fileName, compilationSettings) {
    }
    releaseDocumentWithKey(path, key) {
    }
    reportStats() {
        throw new errors.NotImplementedError();
    }
    getSourceFileVersion(sourceFile) {
        return sourceFile.version || "0";
    }
    getNextSourceFileVersion(sourceFile) {
        const currentVersion = parseInt(this.getSourceFileVersion(sourceFile), 10) || 0;
        return (currentVersion + 1).toString();
    }
    updateSourceFile(fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
        const newSourceFile = createCompilerSourceFile(fileName, scriptSnapshot, compilationSettings.target, version, true, scriptKind);
        this.sourceFileCacheByFilePath.set(fileName, newSourceFile);
        return newSourceFile;
    }
}
DocumentRegistry.initialVersion = "0";

function Memoize(target, propertyName, descriptor) {
    if (descriptor.value != null)
        descriptor.value = getNewFunction(descriptor.value);
    else if (descriptor.get != null)
        descriptor.get = getNewFunction(descriptor.get);
    else
        throw new Error("Only put a Memoize decorator on a method or get accessor.");
}
const weakMap = new WeakMap();
let counter = 0;
function getNewFunction(originalFunction) {
    const identifier = counter++;
    function decorator(...args) {
        let propertyValues = weakMap.get(this);
        if (propertyValues == null) {
            propertyValues = new Map();
            weakMap.set(this, propertyValues);
        }
        let propName = `__memoized_value_${identifier}`;
        if (arguments.length > 0)
            propName += "_" + JSON.stringify(args);
        let returnedValue;
        if (propertyValues.has(propName))
            returnedValue = propertyValues.get(propName);
        else {
            returnedValue = originalFunction.apply(this, args);
            propertyValues.set(propName, returnedValue);
        }
        return returnedValue;
    }
    return decorator;
}

class SettingsContainer {
    constructor(defaultSettings) {
        this._defaultSettings = ObjectUtils.assign({}, defaultSettings);
        this._settings = defaultSettings;
    }
    reset() {
        this._settings = ObjectUtils.assign({}, this._defaultSettings);
        this._fireModified();
    }
    get() {
        return ObjectUtils.assign({}, this._settings);
    }
    set(settings) {
        ObjectUtils.assign(this._settings, settings);
        this._fireModified();
    }
    onModified(action) {
        if (this._modifiedEventContainer == null)
            this._modifiedEventContainer = new EventContainer();
        this._modifiedEventContainer.subscribe(action);
    }
    _fireModified() {
        if (this._modifiedEventContainer != null)
            this._modifiedEventContainer.fire(undefined);
    }
}

class CompilerOptionsContainer extends SettingsContainer {
    constructor() {
        super({});
    }
    set(settings) {
        super.set(settings);
    }
    getEncoding() {
        return this._settings.charset || "utf-8";
    }
}

function readDirectory(fileSystemWrapper, useCaseSensitiveFileNames, rootDir, extensions, excludes, includes, depth) {
    const currentDir = fileSystemWrapper.getCurrentDirectory();
    const directories = [];
    const regexFlag = useCaseSensitiveFileNames ? "" : "i";
    const patterns = getFileMatcherPatterns(rootDir, excludes || [], includes, useCaseSensitiveFileNames, currentDir);
    const includeDirectoryRegex = patterns.includeDirectoryPattern && new RegExp(patterns.includeDirectoryPattern, regexFlag);
    const excludeRegex = patterns.excludePattern && new RegExp(patterns.excludePattern, regexFlag);
    return {
        files: matchFiles(rootDir, extensions, excludes || [], includes, useCaseSensitiveFileNames, currentDir, undefined, path => {
            const includeDir = dirPathMatches(path);
            const standardizedPath = fileSystemWrapper.getStandardizedAbsolutePath(path);
            if (includeDir)
                directories.push(standardizedPath);
            return getFileSystemEntries(standardizedPath, fileSystemWrapper);
        }, path => fileSystemWrapper.realpathSync(fileSystemWrapper.getStandardizedAbsolutePath(path))),
        directories,
    };
    function dirPathMatches(absoluteName) {
        if (absoluteName[absoluteName.length - 1] !== "/")
            absoluteName += "/";
        return (!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName))
            && (!excludeRegex || !excludeRegex.test(absoluteName));
    }
}
function getFileSystemEntries(path, fileSystemWrapper) {
    const files = [];
    const directories = [];
    try {
        const entries = fileSystemWrapper.readDirSync(path);
        for (const entry of entries) {
            if (fileSystemWrapper.fileExistsSync(entry))
                files.push(entry);
            else
                directories.push(entry);
        }
    }
    catch (err) {
        if (!FileUtils.isNotExistsError(err))
            throw err;
    }
    return { files, directories };
}

function getTsParseConfigHost(fileSystemWrapper, options) {
    const directories = [];
    const useCaseSensitiveFileNames = false;
    const host = {
        useCaseSensitiveFileNames,
        readDirectory: (rootDir, extensions, excludes, includes, depth) => {
            const result = readDirectory(fileSystemWrapper, useCaseSensitiveFileNames, rootDir, extensions, excludes, includes);
            directories.push(...result.directories);
            return result.files;
        },
        fileExists: path => fileSystemWrapper.fileExistsSync(fileSystemWrapper.getStandardizedAbsolutePath(path)),
        readFile: path => fileSystemWrapper.readFileSync(fileSystemWrapper.getStandardizedAbsolutePath(path), options.encoding),
        getDirectories: () => [...directories],
        clearDirectories: () => directories.length = 0,
    };
    return host;
}

class TsConfigResolver {
    constructor(fileSystem, tsConfigFilePath, encoding) {
        this.fileSystem = fileSystem;
        this.encoding = encoding;
        this.host = getTsParseConfigHost(fileSystem, { encoding });
        this.tsConfigFilePath = fileSystem.getStandardizedAbsolutePath(tsConfigFilePath);
        this.tsConfigDirPath = FileUtils.getDirPath(this.tsConfigFilePath);
    }
    getCompilerOptions() {
        return this.parseJsonConfigFileContent().options;
    }
    getErrors() {
        return this.parseJsonConfigFileContent().errors || [];
    }
    getPaths(compilerOptions) {
        const files = new Set();
        const { tsConfigDirPath, fileSystem } = this;
        const directories = new Set();
        compilerOptions = compilerOptions || this.getCompilerOptions();
        const rootDirs = getRootDirs(compilerOptions);
        const configFileContent = this.parseJsonConfigFileContent();
        for (let dirName of configFileContent.directories) {
            const dirPath = fileSystem.getStandardizedAbsolutePath(dirName);
            if (dirInProject(dirPath) && fileSystem.directoryExistsSync(dirPath))
                directories.add(dirPath);
        }
        for (let fileName of configFileContent.fileNames) {
            const filePath = fileSystem.getStandardizedAbsolutePath(fileName);
            const parentDirPath = FileUtils.getDirPath(filePath);
            if (dirInProject(parentDirPath) && fileSystem.fileExistsSync(filePath)) {
                files.add(filePath);
                directories.add(parentDirPath);
            }
        }
        for (const rootDir of rootDirs)
            directories.add(rootDir);
        return {
            filePaths: Array.from(files.values()),
            directoryPaths: Array.from(directories.values()),
        };
        function dirInProject(dirPath) {
            if (directories.has(dirPath))
                return true;
            if (rootDirs.length > 0)
                return rootDirs.some(rootDir => FileUtils.pathStartsWith(dirPath, rootDir));
            return FileUtils.pathStartsWith(dirPath, tsConfigDirPath);
        }
        function getRootDirs(options) {
            const result = [];
            if (typeof options.rootDir === "string")
                result.push(options.rootDir);
            if (options.rootDirs != null)
                result.push(...options.rootDirs);
            return result.map(rootDir => fileSystem.getStandardizedAbsolutePath(rootDir, tsConfigDirPath));
        }
    }
    parseJsonConfigFileContent() {
        this.host.clearDirectories();
        const result = ts.parseJsonConfigFileContent(this.getTsConfigFileJson(), this.host, this.tsConfigDirPath, undefined, this.tsConfigFilePath);
        return Object.assign(Object.assign({}, result), { directories: this.host.getDirectories() });
    }
    getTsConfigFileJson() {
        const text = this.fileSystem.readFileSync(this.tsConfigFilePath, this.encoding);
        const parseResult = ts.parseConfigFileTextToJson(this.tsConfigFilePath, text);
        if (parseResult.error != null)
            throw new Error(parseResult.error.messageText.toString());
        return parseResult.config;
    }
}
__decorate([
    Memoize
], TsConfigResolver.prototype, "getCompilerOptions", null);
__decorate([
    Memoize
], TsConfigResolver.prototype, "getErrors", null);
__decorate([
    Memoize
], TsConfigResolver.prototype, "getPaths", null);
__decorate([
    Memoize
], TsConfigResolver.prototype, "parseJsonConfigFileContent", null);
__decorate([
    Memoize
], TsConfigResolver.prototype, "getTsConfigFileJson", null);

const CommentChar = {};
CommentChar[CommentChar["Line"] = 0] = "Line";
CommentChar[CommentChar["Star"] = 1] = "Star";

const isCharToHandle = new Set(["/", "\\", "\n", "\r", "*", "\"", "'", "`", "{", "}"].map(c => c.charCodeAt(0)));
const CHARS = {
    BACK_SLASH: "\\".charCodeAt(0),
    FORWARD_SLASH: "/".charCodeAt(0),
    NEW_LINE: "\n".charCodeAt(0),
    CARRIAGE_RETURN: "\r".charCodeAt(0),
    ASTERISK: "*".charCodeAt(0),
    DOUBLE_QUOTE: "\"".charCodeAt(0),
    SINGLE_QUOTE: "'".charCodeAt(0),
    BACK_TICK: "`".charCodeAt(0),
    OPEN_BRACE: "{".charCodeAt(0),
    CLOSE_BRACE: "}".charCodeAt(0),
    DOLLAR_SIGN: "$".charCodeAt(0)
};
/**
 * Code writer that assists with formatting and visualizing blocks of JavaScript or TypeScript code.
 */
class CodeBlockWriter {
    /**
     * Constructor.
     * @param opts - Options for the writer.
     */
    constructor(opts = {}) {
        /** @internal */
        this._currentIndentation = 0;
        /** @internal */
        this._length = 0;
        /** @internal */
        this._newLineOnNextWrite = false;
        /** @internal */
        this._currentCommentChar = undefined;
        /** @internal */
        this._stringCharStack = [];
        /** @internal */
        this._isInRegEx = false;
        /** @internal */
        this._isOnFirstLineOfBlock = true;
        // An array of strings is used rather than a single string because it was
        // found to be ~11x faster when printing a 10K line file (~11s to ~1s).
        /** @internal */
        this._texts = [];
        this._newLine = opts.newLine || "\n";
        this._useTabs = opts.useTabs || false;
        this._indentNumberOfSpaces = opts.indentNumberOfSpaces || 4;
        this._indentationText = getIndentationText(this._useTabs, this._indentNumberOfSpaces);
        this._quoteChar = opts.useSingleQuote ? "'" : `"`;
    }
    /**
     * Gets the options.
     */
    getOptions() {
        return {
            indentNumberOfSpaces: this._indentNumberOfSpaces,
            newLine: this._newLine,
            useTabs: this._useTabs,
            useSingleQuote: this._quoteChar === "'"
        };
    }
    queueIndentationLevel(countOrText) {
        this._queuedIndentation = this._getIndentationLevelFromArg(countOrText);
        this._queuedOnlyIfNotBlock = undefined;
        return this;
    }
    /**
     * Writes the text within the provided action with hanging indentation.
     * @param action - Action to perform with hanging indentation.
     */
    hangingIndent(action) {
        return this._withResetIndentation(() => this.queueIndentationLevel(this.getIndentationLevel() + 1), action);
    }
    /**
     * Writes the text within the provided action with hanging indentation unless writing a block.
     * @param action - Action to perform with hanging indentation unless a block is written.
     */
    hangingIndentUnlessBlock(action) {
        return this._withResetIndentation(() => {
            this.queueIndentationLevel(this.getIndentationLevel() + 1);
            this._queuedOnlyIfNotBlock = true;
        }, action);
    }
    setIndentationLevel(countOrText) {
        this._currentIndentation = this._getIndentationLevelFromArg(countOrText);
        return this;
    }
    withIndentationLevel(countOrText, action) {
        return this._withResetIndentation(() => this.setIndentationLevel(countOrText), action);
    }
    /** @internal */
    _withResetIndentation(setStateAction, writeAction) {
        const previousState = this._getIndentationState();
        setStateAction();
        try {
            writeAction();
        }
        finally {
            this._setIndentationState(previousState);
        }
        return this;
    }
    /**
     * Gets the current indentation level.
     */
    getIndentationLevel() {
        return this._currentIndentation;
    }
    /**
     * Writes a block using braces.
     * @param block - Write using the writer within this block.
     */
    block(block) {
        this._newLineIfNewLineOnNextWrite();
        if (this.getLength() > 0 && !this.isLastNewLine())
            this.spaceIfLastNot();
        this.inlineBlock(block);
        this._newLineOnNextWrite = true;
        return this;
    }
    /**
     * Writes an inline block with braces.
     * @param block - Write using the writer within this block.
     */
    inlineBlock(block) {
        this._newLineIfNewLineOnNextWrite();
        this.write("{");
        this._indentBlockInternal(block);
        this.newLineIfLastNot().write("}");
        return this;
    }
    indent(timesOrBlock = 1) {
        if (typeof timesOrBlock === "number") {
            this._newLineIfNewLineOnNextWrite();
            return this.write(this._indentationText.repeat(timesOrBlock));
        }
        else {
            this._indentBlockInternal(timesOrBlock);
            if (!this.isLastNewLine())
                this._newLineOnNextWrite = true;
            return this;
        }
    }
    /** @internal */
    _indentBlockInternal(block) {
        if (this.getLastChar() != null)
            this.newLineIfLastNot();
        this._currentIndentation++;
        this._isOnFirstLineOfBlock = true;
        if (block != null)
            block();
        this._isOnFirstLineOfBlock = false;
        this._currentIndentation = Math.max(0, this._currentIndentation - 1);
    }
    conditionalWriteLine(condition, strOrFunc) {
        if (condition)
            this.writeLine(stringUtils_1.getStringFromStrOrFunc(strOrFunc));
        return this;
    }
    /**
     * Writes a line of text.
     * @param text - String to write.
     */
    writeLine(text) {
        this._newLineIfNewLineOnNextWrite();
        if (this.getLastChar() != null)
            this.newLineIfLastNot();
        this._writeIndentingNewLines(text);
        this.newLine();
        return this;
    }
    /**
     * Writes a newline if the last line was not a newline.
     */
    newLineIfLastNot() {
        this._newLineIfNewLineOnNextWrite();
        if (!this.isLastNewLine())
            this.newLine();
        return this;
    }
    /**
     * Writes a blank line if the last written text was not a blank line.
     */
    blankLineIfLastNot() {
        if (!this.isLastBlankLine())
            this.blankLine();
        return this;
    }
    /**
     * Writes a blank line if the condition is true.
     * @param condition - Condition to evaluate.
     */
    conditionalBlankLine(condition) {
        if (condition)
            this.blankLine();
        return this;
    }
    /**
     * Writes a blank line.
     */
    blankLine() {
        return this.newLineIfLastNot().newLine();
    }
    /**
     * Writes a newline if the condition is true.
     * @param condition - Condition to evaluate.
     */
    conditionalNewLine(condition) {
        if (condition)
            this.newLine();
        return this;
    }
    /**
     * Writes a newline.
     */
    newLine() {
        this._newLineOnNextWrite = false;
        this._baseWriteNewline();
        return this;
    }
    quote(text) {
        this._newLineIfNewLineOnNextWrite();
        this._writeIndentingNewLines(text == null ? this._quoteChar : this._quoteChar + stringUtils_1.escapeForWithinString(text, this._quoteChar) + this._quoteChar);
        return this;
    }
    /**
     * Writes a space if the last character was not a space.
     */
    spaceIfLastNot() {
        this._newLineIfNewLineOnNextWrite();
        if (!this.isLastSpace())
            this._writeIndentingNewLines(" ");
        return this;
    }
    /**
     * Writes a space.
     * @param times - Number of times to write a space.
     */
    space(times = 1) {
        this._newLineIfNewLineOnNextWrite();
        this._writeIndentingNewLines(" ".repeat(times));
        return this;
    }
    /**
     * Writes a tab if the last character was not a tab.
     */
    tabIfLastNot() {
        this._newLineIfNewLineOnNextWrite();
        if (!this.isLastTab())
            this._writeIndentingNewLines("\t");
        return this;
    }
    /**
     * Writes a tab.
     * @param times - Number of times to write a tab.
     */
    tab(times = 1) {
        this._newLineIfNewLineOnNextWrite();
        this._writeIndentingNewLines("\t".repeat(times));
        return this;
    }
    conditionalWrite(condition, textOrFunc) {
        if (condition)
            this.write(stringUtils_1.getStringFromStrOrFunc(textOrFunc));
        return this;
    }
    /**
     * Writes the provided text.
     * @param text - Text to write.
     */
    write(text) {
        this._newLineIfNewLineOnNextWrite();
        this._writeIndentingNewLines(text);
        return this;
    }
    /**
     * Writes text to exit a comment if in a comment.
     */
    closeComment() {
        const commentChar = this._currentCommentChar;
        switch (commentChar) {
            case CommentChar.Line:
                this.newLine();
                break;
            case CommentChar.Star:
                if (!this.isLastNewLine())
                    this.spaceIfLastNot();
                this.write("*/");
                break;
        }
        return this;
    }
    /**
     * Inserts text at the provided position.
     *
     * This method is "unsafe" because it won't update the state of the writer unless
     * inserting at the end position. It is biased towards being fast at inserting closer
     * to the start or end, but slower to insert in the middle. Only use this if
     * absolutely necessary.
     * @param pos - Position to insert at.
     * @param text - Text to insert.
     */
    unsafeInsert(pos, text) {
        const textLength = this._length;
        const texts = this._texts;
        verifyInput();
        if (pos === textLength)
            return this.write(text);
        updateInternalArray();
        this._length += text.length;
        return this;
        function verifyInput() {
            if (pos < 0)
                throw new Error(`Provided position of '${pos}' was less than zero.`);
            if (pos > textLength)
                throw new Error(`Provided position of '${pos}' was greater than the text length of '${textLength}'.`);
        }
        function updateInternalArray() {
            const { index, localIndex } = getArrayIndexAndLocalIndex();
            if (localIndex === 0)
                texts.splice(index, 0, text);
            else if (localIndex === texts[index].length)
                texts.splice(index + 1, 0, text);
            else {
                const textItem = texts[index];
                const startText = textItem.substring(0, localIndex);
                const endText = textItem.substring(localIndex);
                texts.splice(index, 1, startText, text, endText);
            }
        }
        function getArrayIndexAndLocalIndex() {
            if (pos < textLength / 2) {
                // start searching from the front
                let endPos = 0;
                for (let i = 0; i < texts.length; i++) {
                    const textItem = texts[i];
                    const startPos = endPos;
                    endPos += textItem.length;
                    if (endPos >= pos)
                        return { index: i, localIndex: pos - startPos };
                }
            }
            else {
                // start searching from the back
                let startPos = textLength;
                for (let i = texts.length - 1; i >= 0; i--) {
                    const textItem = texts[i];
                    startPos -= textItem.length;
                    if (startPos <= pos)
                        return { index: i, localIndex: pos - startPos };
                }
            }
            throw new Error("Unhandled situation inserting. This should never happen.");
        }
    }
    /**
     * Gets the length of the string in the writer.
     */
    getLength() {
        return this._length;
    }
    /**
     * Gets if the writer is currently in a comment.
     */
    isInComment() {
        return this._currentCommentChar !== undefined;
    }
    /**
     * Gets if the writer is currently at the start of the first line of the text, block, or indentation block.
     */
    isAtStartOfFirstLineOfBlock() {
        return this.isOnFirstLineOfBlock() && (this.isLastNewLine() || this.getLastChar() == null);
    }
    /**
     * Gets if the writer is currently on the first line of the text, block, or indentation block.
     */
    isOnFirstLineOfBlock() {
        return this._isOnFirstLineOfBlock;
    }
    /**
     * Gets if the writer is currently in a string.
     */
    isInString() {
        return this._stringCharStack.length > 0 && this._stringCharStack[this._stringCharStack.length - 1] !== CHARS.OPEN_BRACE;
    }
    /**
     * Gets if the last chars written were for a newline.
     */
    isLastNewLine() {
        const lastChar = this.getLastChar();
        return lastChar === "\n" || lastChar === "\r";
    }
    /**
     * Gets if the last chars written were for a blank line.
     */
    isLastBlankLine() {
        let foundCount = 0;
        // todo: consider extracting out iterating over past characters, but don't use
        // an iterator because it will be slow.
        for (let i = this._texts.length - 1; i >= 0; i--) {
            const currentText = this._texts[i];
            for (let j = currentText.length - 1; j >= 0; j--) {
                const currentChar = currentText.charCodeAt(j);
                if (currentChar === CHARS.NEW_LINE) {
                    foundCount++;
                    if (foundCount === 2)
                        return true;
                }
                else if (currentChar !== CHARS.CARRIAGE_RETURN) {
                    return false;
                }
            }
        }
        return false;
    }
    /**
     * Gets if the last char written was a space.
     */
    isLastSpace() {
        return this.getLastChar() === " ";
    }
    /**
     * Gets if the last char written was a tab.
     */
    isLastTab() {
        return this.getLastChar() === "\t";
    }
    /**
     * Gets the last char written.
     */
    getLastChar() {
        const charCode = this._getLastCharCodeWithOffset(0);
        return charCode == null ? undefined : String.fromCharCode(charCode);
    }
    /**
     * Gets if the writer ends with the provided text.
     * @param text - Text to check if the writer ends with the provided text.
     */
    endsWith(text) {
        const length = this._length;
        return this.iterateLastCharCodes((charCode, index) => {
            const offset = length - index;
            const textIndex = text.length - offset;
            if (text.charCodeAt(textIndex) !== charCode)
                return false;
            return textIndex === 0 ? true : undefined;
        }) || false;
    }
    /**
     * Iterates over the writer characters in reverse order. The iteration stops when a non-null or
     * undefined value is returned from the action. The returned value is then returned by the method.
     *
     * @remarks It is much more efficient to use this method rather than `#toString()` since `#toString()`
     * will combine the internal array into a string.
     */
    iterateLastChars(action) {
        return this.iterateLastCharCodes((charCode, index) => action(String.fromCharCode(charCode), index));
    }
    /**
     * Iterates over the writer character char codes in reverse order. The iteration stops when a non-null or
     * undefined value is returned from the action. The returned value is then returned by the method.
     *
     * @remarks It is much more efficient to use this method rather than `#toString()` since `#toString()`
     * will combine the internal array into a string. Additionally, this is slightly more efficient that
     * `iterateLastChars` as this won't allocate a string per character.
     */
    iterateLastCharCodes(action) {
        let index = this._length;
        for (let i = this._texts.length - 1; i >= 0; i--) {
            const currentText = this._texts[i];
            for (let j = currentText.length - 1; j >= 0; j--) {
                index--;
                const result = action(currentText.charCodeAt(j), index);
                if (result != null)
                    return result;
            }
        }
        return undefined;
    }
    /**
     * Gets the writer's text.
     */
    toString() {
        if (this._texts.length > 1) {
            const text = this._texts.join("");
            this._texts.length = 0;
            this._texts.push(text);
        }
        return this._texts[0] || "";
    }
    /** @internal */
    _writeIndentingNewLines(text) {
        text = text || "";
        if (text.length === 0) {
            writeIndividual(this, "");
            return;
        }
        const items = text.split(CodeBlockWriter._newLineRegEx);
        items.forEach((s, i) => {
            if (i > 0)
                this._baseWriteNewline();
            if (s.length === 0)
                return;
            writeIndividual(this, s);
        });
        function writeIndividual(writer, s) {
            if (!writer.isInString()) {
                const isAtStartOfLine = writer.isLastNewLine() || writer.getLastChar() == null;
                if (isAtStartOfLine)
                    writer._writeIndentation();
            }
            writer._updateInternalState(s);
            writer._internalWrite(s);
        }
    }
    /** @internal */
    _baseWriteNewline() {
        if (this._currentCommentChar === CommentChar.Line)
            this._currentCommentChar = undefined;
        const lastStringCharOnStack = this._stringCharStack[this._stringCharStack.length - 1];
        if ((lastStringCharOnStack === CHARS.DOUBLE_QUOTE || lastStringCharOnStack === CHARS.SINGLE_QUOTE) && this._getLastCharCodeWithOffset(0) !== CHARS.BACK_SLASH)
            this._stringCharStack.pop();
        this._internalWrite(this._newLine);
        this._isOnFirstLineOfBlock = false;
        this._dequeueQueuedIndentation();
    }
    /** @internal */
    _dequeueQueuedIndentation() {
        if (this._queuedIndentation == null)
            return;
        if (this._queuedOnlyIfNotBlock && wasLastBlock(this)) {
            this._queuedIndentation = undefined;
            this._queuedOnlyIfNotBlock = undefined;
        }
        else {
            this._currentIndentation = this._queuedIndentation;
            this._queuedIndentation = undefined;
        }
        function wasLastBlock(writer) {
            let foundNewLine = false;
            return writer.iterateLastCharCodes(charCode => {
                switch (charCode) {
                    case CHARS.NEW_LINE:
                        if (foundNewLine)
                            return false;
                        else
                            foundNewLine = true;
                        break;
                    case CHARS.CARRIAGE_RETURN:
                        return undefined;
                    case CHARS.OPEN_BRACE:
                        return true;
                    default:
                        return false;
                }
            });
        }
    }
    /** @internal */
    _updateInternalState(str) {
        for (let i = 0; i < str.length; i++) {
            const currentChar = str.charCodeAt(i);
            // This is a performance optimization to short circuit all the checks below. If the current char
            // is not in this set then it won't change any internal state so no need to continue and do
            // so many other checks (this made it 3x faster in one scenario I tested).
            if (!isCharToHandle.has(currentChar))
                continue;
            const pastChar = i === 0 ? this._getLastCharCodeWithOffset(0) : str.charCodeAt(i - 1);
            const pastPastChar = i === 0 ? this._getLastCharCodeWithOffset(1) : i === 1 ? this._getLastCharCodeWithOffset(0) : str.charCodeAt(i - 2);
            // handle regex
            if (this._isInRegEx) {
                if (pastChar === CHARS.FORWARD_SLASH && pastPastChar !== CHARS.BACK_SLASH || pastChar === CHARS.NEW_LINE)
                    this._isInRegEx = false;
                else
                    continue;
            }
            else if (!this.isInString() && !this.isInComment() && isRegExStart(currentChar, pastChar, pastPastChar)) {
                this._isInRegEx = true;
                continue;
            }
            // handle comments
            if (this._currentCommentChar == null && pastChar === CHARS.FORWARD_SLASH && currentChar === CHARS.FORWARD_SLASH)
                this._currentCommentChar = CommentChar.Line;
            else if (this._currentCommentChar == null && pastChar === CHARS.FORWARD_SLASH && currentChar === CHARS.ASTERISK)
                this._currentCommentChar = CommentChar.Star;
            else if (this._currentCommentChar === CommentChar.Star && pastChar === CHARS.ASTERISK && currentChar === CHARS.FORWARD_SLASH)
                this._currentCommentChar = undefined;
            if (this.isInComment())
                continue;
            // handle strings
            const lastStringCharOnStack = this._stringCharStack.length === 0 ? undefined : this._stringCharStack[this._stringCharStack.length - 1];
            if (pastChar !== CHARS.BACK_SLASH && (currentChar === CHARS.DOUBLE_QUOTE || currentChar === CHARS.SINGLE_QUOTE || currentChar === CHARS.BACK_TICK)) {
                if (lastStringCharOnStack === currentChar)
                    this._stringCharStack.pop();
                else if (lastStringCharOnStack === CHARS.OPEN_BRACE || lastStringCharOnStack === undefined)
                    this._stringCharStack.push(currentChar);
            }
            else if (pastPastChar !== CHARS.BACK_SLASH && pastChar === CHARS.DOLLAR_SIGN && currentChar === CHARS.OPEN_BRACE && lastStringCharOnStack === CHARS.BACK_TICK)
                this._stringCharStack.push(currentChar);
            else if (currentChar === CHARS.CLOSE_BRACE && lastStringCharOnStack === CHARS.OPEN_BRACE)
                this._stringCharStack.pop();
        }
    }
    /** @internal - This is private, but exposed for testing. */
    _getLastCharCodeWithOffset(offset) {
        if (offset >= this._length || offset < 0)
            return undefined;
        for (let i = this._texts.length - 1; i >= 0; i--) {
            const currentText = this._texts[i];
            if (offset >= currentText.length)
                offset -= currentText.length;
            else
                return currentText.charCodeAt(currentText.length - 1 - offset);
        }
        return undefined;
    }
    /** @internal */
    _writeIndentation() {
        const flooredIndentation = Math.floor(this._currentIndentation);
        this._internalWrite(this._indentationText.repeat(flooredIndentation));
        const overflow = this._currentIndentation - flooredIndentation;
        if (this._useTabs) {
            if (overflow > 0.5)
                this._internalWrite(this._indentationText);
        }
        else {
            const portion = Math.round(this._indentationText.length * overflow);
            // build up the string first, then append it for performance reasons
            let text = "";
            for (let i = 0; i < portion; i++)
                text += this._indentationText[i];
            this._internalWrite(text);
        }
    }
    /** @internal */
    _newLineIfNewLineOnNextWrite() {
        if (!this._newLineOnNextWrite)
            return;
        this._newLineOnNextWrite = false;
        this.newLine();
    }
    /** @internal */
    _internalWrite(text) {
        if (text.length === 0)
            return;
        this._texts.push(text);
        this._length += text.length;
    }
    /** @internal */
    _getIndentationLevelFromArg(countOrText) {
        if (typeof countOrText === "number") {
            if (countOrText < 0)
                throw new Error("Passed in indentation level should be greater than or equal to 0.");
            return countOrText;
        }
        else if (typeof countOrText === "string") {
            if (!CodeBlockWriter._spacesOrTabsRegEx.test(countOrText))
                throw new Error("Provided string must be empty or only contain spaces or tabs.");
            const { spacesCount, tabsCount } = getSpacesAndTabsCount(countOrText);
            return tabsCount + spacesCount / this._indentNumberOfSpaces;
        }
        else {
            throw new Error("Argument provided must be a string or number.");
        }
    }
    /** @internal */
    _setIndentationState(state) {
        this._currentIndentation = state.current;
        this._queuedIndentation = state.queued;
        this._queuedOnlyIfNotBlock = state.queuedOnlyIfNotBlock;
    }
    /** @internal */
    _getIndentationState() {
        return {
            current: this._currentIndentation,
            queued: this._queuedIndentation,
            queuedOnlyIfNotBlock: this._queuedOnlyIfNotBlock
        };
    }
}
/** @internal */
CodeBlockWriter._newLineRegEx = /\r?\n/;
/** @internal */
CodeBlockWriter._spacesOrTabsRegEx = /^[ \t]*$/;
function isRegExStart(currentChar, pastChar, pastPastChar) {
    return pastChar === CHARS.FORWARD_SLASH
        && currentChar !== CHARS.FORWARD_SLASH
        && currentChar !== CHARS.ASTERISK
        && pastPastChar !== CHARS.ASTERISK
        && pastPastChar !== CHARS.FORWARD_SLASH;
}
function getIndentationText(useTabs, numberSpaces) {
    if (useTabs)
        return "\t";
    return Array(numberSpaces + 1).join(" ");
}
function getSpacesAndTabsCount(str) {
    let spacesCount = 0;
    let tabsCount = 0;
    for (const char of str) {
        if (char === " ")
            spacesCount++;
        else if (char === "\t")
            tabsCount++;
    }
    return { spacesCount, tabsCount };
}

const { ts: ts$1 } = globalThis;

const exports = {};

class AdvancedIterator {
    constructor(iterator) {
        this.iterator = iterator;
        this.buffer = [undefined, undefined, undefined];
        this.bufferIndex = 0;
        this.isDone = false;
        this.nextCount = 0;
        this.advance();
    }
    get done() {
        return this.isDone;
    }
    get current() {
        if (this.nextCount === 0)
            throw new errors.InvalidOperationError("Cannot get the current when the iterator has not been advanced.");
        return this.buffer[this.bufferIndex];
    }
    get previous() {
        if (this.nextCount <= 1)
            throw new errors.InvalidOperationError("Cannot get the previous when the iterator has not advanced enough.");
        return this.buffer[(this.bufferIndex + this.buffer.length - 1) % this.buffer.length];
    }
    get peek() {
        if (this.isDone)
            throw new errors.InvalidOperationError("Cannot peek at the end of the iterator.");
        return this.buffer[(this.bufferIndex + 1) % this.buffer.length];
    }
    next() {
        if (this.done)
            throw new errors.InvalidOperationError("Cannot get the next when at the end of the iterator.");
        const next = this.buffer[this.getNextBufferIndex()];
        this.advance();
        this.nextCount++;
        return next;
    }
    *rest() {
        while (!this.done)
            yield this.next();
    }
    advance() {
        const next = this.iterator.next();
        this.bufferIndex = this.getNextBufferIndex();
        if (next.done) {
            this.isDone = true;
            return;
        }
        this.buffer[this.getNextBufferIndex()] = next.value;
    }
    getNextBufferIndex() {
        return (this.bufferIndex + 1) % this.buffer.length;
    }
}

const CharCodes$1 = {
    ASTERISK: "*".charCodeAt(0),
    NEWLINE: "\n".charCodeAt(0),
    CARRIAGE_RETURN: "\r".charCodeAt(0),
    SPACE: " ".charCodeAt(0),
    TAB: "\t".charCodeAt(0),
    CLOSE_BRACE: "}".charCodeAt(0),
};

function getNodeByNameOrFindFunction(items, nameOrFindFunc) {
    let findFunc;
    if (typeof nameOrFindFunc === "string")
        findFunc = dec => nodeHasName(dec, nameOrFindFunc);
    else
        findFunc = nameOrFindFunc;
    return items.find(findFunc);
}
function nodeHasName(node, name) {
    if (node.getNameNode == null)
        return false;
    const nameNode = node.getNameNode();
    if (nameNode == null)
        return false;
    if (Node.isArrayBindingPattern(nameNode) || Node.isObjectBindingPattern(nameNode))
        return nameNode.getElements().some(element => nodeHasName(element, name));
    const nodeName = node.getName != null ? node.getName() : nameNode.getText();
    return nodeName === name;
}
function getNotFoundErrorMessageForNameOrFindFunction(findName, nameOrFindFunction) {
    if (typeof nameOrFindFunction === "string")
        return `Expected to find ${findName} named '${nameOrFindFunction}'.`;
    return `Expected to find ${findName} that matched the provided condition.`;
}

function getParentSyntaxList(node, sourceFile) {
    if (node.kind === ts$1.SyntaxKind.EndOfFileToken)
        return undefined;
    const parent = node.parent;
    if (parent == null)
        return undefined;
    const { pos, end } = node;
    for (const child of parent.getChildren(sourceFile)) {
        if (child.pos > end || child === node)
            return undefined;
        if (child.kind === ts$1.SyntaxKind.SyntaxList && child.pos <= pos && child.end >= end)
            return child;
    }
    return undefined;
}

function getSymbolByNameOrFindFunction(items, nameOrFindFunc) {
    let findFunc;
    if (typeof nameOrFindFunc === "string")
        findFunc = dec => dec.getName() === nameOrFindFunc;
    else
        findFunc = nameOrFindFunc;
    return items.find(findFunc);
}

function isNodeAmbientOrInAmbientContext(node) {
    if (checkNodeIsAmbient(node) || node._sourceFile.isDeclarationFile())
        return true;
    for (const ancestor of node._getAncestorsIterator(false)) {
        if (checkNodeIsAmbient(ancestor))
            return true;
    }
    return false;
}
function checkNodeIsAmbient(node) {
    const isThisAmbient = (node.getCombinedModifierFlags() & ts$1.ModifierFlags.Ambient) === ts$1.ModifierFlags.Ambient;
    return isThisAmbient || Node.isInterfaceDeclaration(node) || Node.isTypeAliasDeclaration(node);
}

function isStringKind(kind) {
    switch (kind) {
        case ts$1.SyntaxKind.StringLiteral:
        case ts$1.SyntaxKind.NoSubstitutionTemplateLiteral:
        case ts$1.SyntaxKind.TemplateHead:
        case ts$1.SyntaxKind.TemplateMiddle:
        case ts$1.SyntaxKind.TemplateTail:
            return true;
        default:
            return false;
    }
}

class ModuleUtils {
    constructor() {
    }
    static isModuleSpecifierRelative(text) {
        return text.startsWith("./")
            || text.startsWith("../");
    }
    static getReferencedSourceFileFromSymbol(symbol) {
        const declarations = symbol.getDeclarations();
        if (declarations.length === 0 || declarations[0].getKind() !== ts$1.SyntaxKind.SourceFile)
            return undefined;
        return declarations[0];
    }
}

function printNode(node, sourceFileOrOptions, secondOverloadOptions) {
    var _a, _b;
    const isFirstOverload = sourceFileOrOptions == null || sourceFileOrOptions.kind !== ts$1.SyntaxKind.SourceFile;
    const options = getOptions();
    const sourceFile = getSourceFile();
    const printer = ts$1.createPrinter({
        newLine: (_a = options.newLineKind) !== null && _a !== void 0 ? _a : ts$1.NewLineKind.LineFeed,
        removeComments: options.removeComments || false,
    });
    if (sourceFile == null)
        return printer.printFile(node);
    else
        return printer.printNode((_b = options.emitHint) !== null && _b !== void 0 ? _b : common.EmitHint.Unspecified, node, sourceFile);
    function getSourceFile() {
        if (isFirstOverload) {
            if (node.kind === ts$1.SyntaxKind.SourceFile)
                return undefined;
            const topParent = getNodeSourceFile();
            if (topParent == null) {
                const scriptKind = getScriptKind();
                return ts$1.createSourceFile(`print.${getFileExt(scriptKind)}`, "", common.ScriptTarget.Latest, false, scriptKind);
            }
            return topParent;
        }
        return sourceFileOrOptions;
        function getScriptKind() {
            var _a;
            return (_a = options.scriptKind) !== null && _a !== void 0 ? _a : common.ScriptKind.TSX;
        }
        function getFileExt(scriptKind) {
            if (scriptKind === common.ScriptKind.JSX || scriptKind === common.ScriptKind.TSX)
                return "tsx";
            return "ts";
        }
    }
    function getNodeSourceFile() {
        let topNode = node.parent;
        while (topNode != null && topNode.parent != null)
            topNode = topNode.parent;
        return topNode;
    }
    function getOptions() {
        return (isFirstOverload ? sourceFileOrOptions : secondOverloadOptions) || {};
    }
}

(function(IndentationText) {
    IndentationText["TwoSpaces"] = "  ";
    IndentationText["FourSpaces"] = "    ";
    IndentationText["EightSpaces"] = "        ";
    IndentationText["Tab"] = "\t";
})(exports.IndentationText || (exports.IndentationText = {}));
class SettingsContainer$1 {
    constructor(defaultSettings) {
        this._defaultSettings = ObjectUtils.assign({}, defaultSettings);
        this._settings = defaultSettings;
    }
    reset() {
        this._settings = ObjectUtils.assign({}, this._defaultSettings);
        this._fireModified();
    }
    get() {
        return ObjectUtils.assign({}, this._settings);
    }
    set(settings) {
        ObjectUtils.assign(this._settings, settings);
        this._fireModified();
    }
    onModified(action) {
        if (this._modifiedEventContainer == null)
            this._modifiedEventContainer = new EventContainer();
        this._modifiedEventContainer.subscribe(action);
    }
    _fireModified() {
        if (this._modifiedEventContainer != null)
            this._modifiedEventContainer.fire(undefined);
    }
}
class ManipulationSettingsContainer extends SettingsContainer$1 {
    constructor() {
        super({
            indentationText: exports.IndentationText.FourSpaces,
            newLineKind: ts$1.NewLineKind.LineFeed,
            quoteKind: exports.QuoteKind.Double,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
            usePrefixAndSuffixTextForRename: false,
            useTrailingCommas: false,
        });
    }
    getEditorSettings() {
        if (this._editorSettings == null) {
            this._editorSettings = {};
            fillDefaultEditorSettings(this._editorSettings, this);
        }
        return Object.assign({}, this._editorSettings);
    }
    getFormatCodeSettings() {
        if (this._formatCodeSettings == null) {
            this._formatCodeSettings = Object.assign(Object.assign({}, this.getEditorSettings()), { insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: this._settings.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces });
        }
        return Object.assign({}, this._formatCodeSettings);
    }
    getUserPreferences() {
        if (this._userPreferences == null) {
            this._userPreferences = {
                quotePreference: this.getQuoteKind() === exports.QuoteKind.Double ? "double" : "single",
                providePrefixAndSuffixTextForRename: this.getUsePrefixAndSuffixTextForRename(),
            };
        }
        return Object.assign({}, this._userPreferences);
    }
    getQuoteKind() {
        return this._settings.quoteKind;
    }
    getNewLineKind() {
        return this._settings.newLineKind;
    }
    getNewLineKindAsString() {
        return newLineKindToString(this.getNewLineKind());
    }
    getIndentationText() {
        return this._settings.indentationText;
    }
    getUsePrefixAndSuffixTextForRename() {
        return this._settings.usePrefixAndSuffixTextForRename;
    }
    getUseTrailingCommas() {
        return this._settings.useTrailingCommas;
    }
    set(settings) {
        super.set(settings);
        this._editorSettings = undefined;
        this._formatCodeSettings = undefined;
        this._userPreferences = undefined;
    }
    _getIndentSizeInSpaces() {
        const indentationText = this.getIndentationText();
        switch (indentationText) {
            case exports.IndentationText.EightSpaces:
                return 8;
            case exports.IndentationText.FourSpaces:
                return 4;
            case exports.IndentationText.TwoSpaces:
                return 2;
            case exports.IndentationText.Tab:
                return 4;
            default:
                return errors.throwNotImplementedForNeverValueError(indentationText);
        }
    }
}

function setValueIfUndefined(obj, propertyName, defaultValue) {
    if (typeof obj[propertyName] === "undefined")
        obj[propertyName] = defaultValue;
}

function fillDefaultEditorSettings(settings, manipulationSettings) {
    setValueIfUndefined(settings, "convertTabsToSpaces", manipulationSettings.getIndentationText() !== exports.IndentationText.Tab);
    setValueIfUndefined(settings, "newLineCharacter", manipulationSettings.getNewLineKindAsString());
    setValueIfUndefined(settings, "indentStyle", ts$1.IndentStyle.Smart);
    setValueIfUndefined(settings, "indentSize", manipulationSettings.getIndentationText().length);
    setValueIfUndefined(settings, "tabSize", manipulationSettings.getIndentationText().length);
}

function fillDefaultFormatCodeSettings(settings, manipulationSettings) {
    fillDefaultEditorSettings(settings, manipulationSettings);
    setValueIfUndefined(settings, "insertSpaceAfterCommaDelimiter", true);
    setValueIfUndefined(settings, "insertSpaceAfterConstructor", false);
    setValueIfUndefined(settings, "insertSpaceAfterSemicolonInForStatements", true);
    setValueIfUndefined(settings, "insertSpaceAfterKeywordsInControlFlowStatements", true);
    setValueIfUndefined(settings, "insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces", true);
    setValueIfUndefined(settings, "insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets", false);
    setValueIfUndefined(settings, "insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces", false);
    setValueIfUndefined(settings, "insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces", false);
    setValueIfUndefined(settings, "insertSpaceBeforeFunctionParenthesis", false);
    setValueIfUndefined(settings, "insertSpaceBeforeAndAfterBinaryOperators", true);
    setValueIfUndefined(settings, "placeOpenBraceOnNewLineForFunctions", false);
    setValueIfUndefined(settings, "placeOpenBraceOnNewLineForControlBlocks", false);
    setValueIfUndefined(settings, "ensureNewLineAtEndOfFile", true);
}

function getTextFromStringOrWriter(writer, textOrWriterFunction) {
    printTextFromStringOrWriter(writer, textOrWriterFunction);
    return writer.toString();
}
function printTextFromStringOrWriter(writer, textOrWriterFunction) {
    if (typeof textOrWriterFunction === "string")
        writer.write(textOrWriterFunction);
    else if (textOrWriterFunction instanceof Function)
        textOrWriterFunction(writer);
    else {
        for (let i = 0; i < textOrWriterFunction.length; i++) {
            if (i > 0)
                writer.newLineIfLastNot();
            printTextFromStringOrWriter(writer, textOrWriterFunction[i]);
        }
    }
}

class EnableableLogger {
    constructor() {
        this.enabled = false;
    }
    setEnabled(enabled) {
        this.enabled = enabled;
    }
    log(text) {
        if (this.enabled)
            this.logInternal(text);
    }
    warn(text) {
        if (this.enabled)
            this.warnInternal(text);
    }
}

class ConsoleLogger extends EnableableLogger {
    logInternal(text) {
        console.log(text);
    }
    warnInternal(text) {
        console.warn(text);
    }
}

const reg = /^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/;
function isValidVariableName(variableName) {
    return reg.test(variableName);
}

function newLineKindToString(kind) {
    switch (kind) {
        case ts$1.NewLineKind.CarriageReturnLineFeed:
            return "\r\n";
        case ts$1.NewLineKind.LineFeed:
            return "\n";
        default:
            throw new errors.NotImplementedError(`Not implemented newline kind: ${kind}`);
    }
}

class LazyReferenceCoordinator {
    constructor(factory) {
        this.dirtySourceFiles = new Set();
        const onSourceFileModified = (sourceFile) => {
            if (!sourceFile.wasForgotten())
                this.dirtySourceFiles.add(sourceFile);
        };
        factory.onSourceFileAdded(sourceFile => {
            this.dirtySourceFiles.add(sourceFile);
            sourceFile.onModified(onSourceFileModified);
        });
        factory.onSourceFileRemoved(sourceFile => {
            sourceFile._referenceContainer.clear();
            this.dirtySourceFiles.delete(sourceFile);
            sourceFile.onModified(onSourceFileModified, false);
        });
    }
    refreshDirtySourceFiles() {
        for (const sourceFile of this.dirtySourceFiles.values())
            sourceFile._referenceContainer.refresh();
        this.clearDirtySourceFiles();
    }
    refreshSourceFileIfDirty(sourceFile) {
        if (!this.dirtySourceFiles.has(sourceFile))
            return;
        sourceFile._referenceContainer.refresh();
        this.clearDityForSourceFile(sourceFile);
    }
    addDirtySourceFile(sourceFile) {
        this.dirtySourceFiles.add(sourceFile);
    }
    clearDirtySourceFiles() {
        this.dirtySourceFiles.clear();
    }
    clearDityForSourceFile(sourceFile) {
        this.dirtySourceFiles.delete(sourceFile);
    }
}

class SourceFileReferenceContainer {
    constructor(sourceFile) {
        this.sourceFile = sourceFile;
        this.nodesInThis = new KeyValueCache();
        this.nodesInOther = new KeyValueCache();
        this.unresolvedLiterals = [];
        this.resolveUnresolved = () => {
            for (let i = this.unresolvedLiterals.length - 1; i >= 0; i--) {
                const literal = this.unresolvedLiterals[i];
                const sourceFile = this.getSourceFileForLiteral(literal);
                if (sourceFile != null) {
                    this.unresolvedLiterals.splice(i, 1);
                    this.addNodeInThis(literal, sourceFile);
                }
            }
            if (this.unresolvedLiterals.length === 0)
                this.sourceFile._context.compilerFactory.onSourceFileAdded(this.resolveUnresolved, false);
        };
    }
    getDependentSourceFiles() {
        this.sourceFile._context.lazyReferenceCoordinator.refreshDirtySourceFiles();
        const hashSet = new Set();
        for (const nodeInOther of this.nodesInOther.getKeys())
            hashSet.add(nodeInOther._sourceFile);
        return hashSet.values();
    }
    getLiteralsReferencingOtherSourceFilesEntries() {
        this.sourceFile._context.lazyReferenceCoordinator.refreshSourceFileIfDirty(this.sourceFile);
        return this.nodesInThis.getEntries();
    }
    getReferencingLiteralsInOtherSourceFiles() {
        this.sourceFile._context.lazyReferenceCoordinator.refreshDirtySourceFiles();
        return this.nodesInOther.getKeys();
    }
    refresh() {
        if (this.unresolvedLiterals.length > 0)
            this.sourceFile._context.compilerFactory.onSourceFileAdded(this.resolveUnresolved, false);
        this.clear();
        this.populateReferences();
        if (this.unresolvedLiterals.length > 0)
            this.sourceFile._context.compilerFactory.onSourceFileAdded(this.resolveUnresolved);
    }
    clear() {
        this.unresolvedLiterals.length = 0;
        for (const [node, sourceFile] of this.nodesInThis.getEntries()) {
            this.nodesInThis.removeByKey(node);
            sourceFile._referenceContainer.nodesInOther.removeByKey(node);
        }
    }
    populateReferences() {
        this.sourceFile._context.compilerFactory.forgetNodesCreatedInBlock(remember => {
            for (const literal of this.sourceFile.getImportStringLiterals()) {
                const sourceFile = this.getSourceFileForLiteral(literal);
                remember(literal);
                if (sourceFile == null)
                    this.unresolvedLiterals.push(literal);
                else
                    this.addNodeInThis(literal, sourceFile);
            }
        });
    }
    getSourceFileForLiteral(literal) {
        const parent = literal.getParentOrThrow();
        const grandParent = parent.getParent();
        if (Node.isImportDeclaration(parent) || Node.isExportDeclaration(parent))
            return parent.getModuleSpecifierSourceFile();
        else if (grandParent != null && Node.isImportEqualsDeclaration(grandParent))
            return grandParent.getExternalModuleReferenceSourceFile();
        else if (Node.isCallExpression(parent)) {
            const literalSymbol = literal.getSymbol();
            if (literalSymbol != null)
                return ModuleUtils.getReferencedSourceFileFromSymbol(literalSymbol);
        }
        else {
            this.sourceFile._context.logger.warn(`Unknown import string literal parent: ${parent.getKindName()}`);
        }
        return undefined;
    }
    addNodeInThis(literal, sourceFile) {
        this.nodesInThis.set(literal, sourceFile);
        sourceFile._referenceContainer.nodesInOther.set(literal, sourceFile);
    }
}

class WriterUtils {
    constructor() {
    }
    static getLastCharactersToPos(writer, pos) {
        const writerLength = writer.getLength();
        const charCount = writerLength - pos;
        const chars = new Array(charCount);
        writer.iterateLastChars((char, i) => {
            const insertPos = i - pos;
            if (insertPos < 0)
                return true;
            chars[insertPos] = char;
            return undefined;
        });
        return chars.join("");
    }
}

function callBaseSet(basePrototype, node, structure) {
    if (basePrototype.set != null)
        basePrototype.set.call(node, structure);
}

function callBaseGetStructure(basePrototype, node, structure) {
    let newStructure;
    if (basePrototype.getStructure != null)
        newStructure = basePrototype.getStructure.call(node);
    else
        newStructure = {};
    if (structure != null)
        common.ObjectUtils.assign(newStructure, structure);
    return newStructure;
}

function AmbientableNode(Base) {
    return class extends Base {
        hasDeclareKeyword() {
            return this.getDeclareKeyword() != null;
        }
        getDeclareKeywordOrThrow() {
            return errors.throwIfNullOrUndefined(this.getDeclareKeyword(), "Expected to find a declare keyword.");
        }
        getDeclareKeyword() {
            return this.getFirstModifierByKind(ts$1.SyntaxKind.DeclareKeyword);
        }
        isAmbient() {
            return isNodeAmbientOrInAmbientContext(this);
        }
        setHasDeclareKeyword(value) {
            this.toggleModifier("declare", value);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.hasDeclareKeyword != null)
                this.setHasDeclareKeyword(structure.hasDeclareKeyword);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                hasDeclareKeyword: this.hasDeclareKeyword(),
            });
        }
    };
}

var FormattingKind;
(function(FormattingKind) {
    FormattingKind[FormattingKind["Newline"] = 0] = "Newline";
    FormattingKind[FormattingKind["Blankline"] = 1] = "Blankline";
    FormattingKind[FormattingKind["Space"] = 2] = "Space";
    FormattingKind[FormattingKind["None"] = 3] = "None";
})(FormattingKind || (FormattingKind = {}));

function getClassMemberFormatting(parent, member) {
    if (Node.isAmbientableNode(parent) && parent.isAmbient())
        return FormattingKind.Newline;
    if (hasBody(member))
        return FormattingKind.Blankline;
    return FormattingKind.Newline;
}
function hasBody(node) {
    if (Node.isBodyableNode(node) && node.getBody() != null)
        return true;
    if (Node.isBodiedNode(node))
        return true;
    return false;
}

function getFormattingKindText(formattingKind, opts) {
    switch (formattingKind) {
        case FormattingKind.Space:
            return " ";
        case FormattingKind.Newline:
            return opts.newLineKind;
        case FormattingKind.Blankline:
            return opts.newLineKind + opts.newLineKind;
        case FormattingKind.None:
            return "";
        default:
            throw new errors.NotImplementedError(`Not implemented formatting kind: ${formattingKind}`);
    }
}

function getInterfaceMemberFormatting(parent, member) {
    return FormattingKind.Newline;
}

function hasBody$1(node) {
    if (Node.isBodyableNode(node) && node.hasBody())
        return true;
    if (Node.isBodiedNode(node))
        return true;
    return Node.isInterfaceDeclaration(node) || Node.isClassDeclaration(node) || Node.isEnumDeclaration(node);
}

function getStatementedNodeChildFormatting(parent, member) {
    if (hasBody$1(member))
        return FormattingKind.Blankline;
    return FormattingKind.Newline;
}
function getClausedNodeChildFormatting(parent, member) {
    return FormattingKind.Newline;
}

function getGeneralFormatting(parent, child) {
    if (Node.isClassDeclaration(parent))
        return getClassMemberFormatting(parent, child);
    if (Node.isInterfaceDeclaration(parent))
        return getInterfaceMemberFormatting();
    return getStatementedNodeChildFormatting(parent, child);
}

function getTextFromTextChanges(sourceFile, textChanges) {
    const text = sourceFile.getFullText();
    const editResult = [];
    let start = 0;
    for (const { edit } of getSortedTextChanges()) {
        const span = edit.getSpan();
        const beforeEdit = text.slice(start, span.getStart());
        start = span.getEnd();
        editResult.push(beforeEdit);
        editResult.push(edit.getNewText());
    }
    editResult.push(text.slice(start));
    return editResult.join("");
    function getSortedTextChanges() {
        return textChanges.map((edit, index) => ({ edit: toWrappedTextChange(edit), index })).sort((a, b) => {
            const aStart = a.edit.getSpan().getStart();
            const bStart = b.edit.getSpan().getStart();
            const difference = aStart - bStart;
            if (difference === 0)
                return a.index < b.index ? -1 : 1;
            return difference < 0 ? -1 : 1;
        });
    }
    function toWrappedTextChange(change) {
        if (change instanceof TextChange)
            return change;
        else
            return new TextChange(change);
    }
}

function getNewInsertCode(opts) {
    var _a;
    const { structures, newCodes, parent, getSeparator, previousFormattingKind, nextFormattingKind } = opts;
    const indentationText = (_a = opts.indentationText) !== null && _a !== void 0 ? _a : parent.getChildIndentationText();
    const newLineKind = parent._context.manipulationSettings.getNewLineKindAsString();
    return getFormattingKindTextWithIndent(previousFormattingKind) + getChildCode() + getFormattingKindTextWithIndent(nextFormattingKind);
    function getChildCode() {
        let code = newCodes[0];
        for (let i = 1; i < newCodes.length; i++) {
            const formattingKind = getSeparator(structures[i - 1], structures[i]);
            code += getFormattingKindTextWithIndent(formattingKind);
            code += newCodes[i];
        }
        return code;
    }
    function getFormattingKindTextWithIndent(formattingKind) {
        let code = getFormattingKindText(formattingKind, { newLineKind });
        if (formattingKind === FormattingKind.Newline || formattingKind === FormattingKind.Blankline)
            code += indentationText;
        return code;
    }
}

const scanner = ts$1.createScanner(ts$1.ScriptTarget.Latest, true);
function appendCommaToText(text) {
    const pos = getAppendCommaPos(text);
    if (pos === -1)
        return text;
    return text.substring(0, pos) + "," + text.substring(pos);
}
function getAppendCommaPos(text) {
    scanner.setText(text);
    try {
        if (scanner.scan() === ts$1.SyntaxKind.EndOfFileToken)
            return -1;
        while (scanner.scan() !== ts$1.SyntaxKind.EndOfFileToken) {
        }
        const pos = scanner.getStartPos();
        return text[pos - 1] === "," ? -1 : pos;
    }
    finally {
        scanner.setText(undefined);
    }
}

function getEndIndexFromArray(array) {
    var _a;
    return (_a = array === null || array === void 0 ? void 0 : array.length) !== null && _a !== void 0 ? _a : 0;
}

function getNextMatchingPos(text, pos, condition) {
    while (pos < text.length) {
        const charCode = text.charCodeAt(pos);
        if (!condition(charCode))
            pos++;
        else
            break;
    }
    return pos;
}

function getPreviousMatchingPos(text, pos, condition) {
    while (pos > 0) {
        const charCode = text.charCodeAt(pos - 1);
        if (!condition(charCode))
            pos--;
        else
            break;
    }
    return pos;
}

function getNextNonWhitespacePos(text, pos) {
    return getNextMatchingPos(text, pos, isNotWhitespace);
}
function getPreviousNonWhitespacePos(text, pos) {
    return getPreviousMatchingPos(text, pos, isNotWhitespace);
}
function isNotWhitespace(charCode) {
    return !StringUtils.isWhitespaceCharCode(charCode);
}

function getPosAtEndOfPreviousLine(fullText, pos) {
    while (pos > 0) {
        pos--;
        if (fullText[pos] === "\n") {
            if (fullText[pos - 1] === "\r")
                return pos - 1;
            return pos;
        }
    }
    return pos;
}

function getPosAtNextNonBlankLine(text, pos) {
    let newPos = pos;
    for (let i = pos; i < text.length; i++) {
        if (text[i] === " " || text[i] === "\t")
            continue;
        if (text[i] === "\r" && text[i + 1] === "\n" || text[i] === "\n") {
            newPos = i + 1;
            if (text[i] === "\r") {
                i++;
                newPos++;
            }
            continue;
        }
        return newPos;
    }
    return newPos;
}

function getPosAtStartOfLineOrNonWhitespace(fullText, pos) {
    while (pos > 0) {
        pos--;
        const currentChar = fullText[pos];
        if (currentChar === "\n")
            return pos + 1;
        else if (currentChar !== " " && currentChar !== "\t")
            return pos + 1;
    }
    return pos;
}

function getInsertPosFromIndex(index, syntaxList, children) {
    if (index === 0) {
        const parent = syntaxList.getParentOrThrow();
        if (Node.isSourceFile(parent))
            return 0;
        else if (Node.isCaseClause(parent) || Node.isDefaultClause(parent)) {
            const colonToken = parent.getFirstChildByKindOrThrow(ts$1.SyntaxKind.ColonToken);
            return colonToken.getEnd();
        }
        const isInline = syntaxList !== parent.getChildSyntaxList();
        if (isInline)
            return syntaxList.getStart();
        const parentContainer = getParentContainer(parent);
        const openBraceToken = parentContainer.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenBraceToken);
        return openBraceToken.getEnd();
    }
    else {
        return children[index - 1].getEnd();
    }
}
function getEndPosFromIndex(index, parent, children, fullText) {
    let endPos;
    if (index === children.length) {
        if (Node.isSourceFile(parent))
            endPos = parent.getEnd();
        else if (Node.isCaseClause(parent) || Node.isDefaultClause(parent))
            endPos = parent.getEnd();
        else {
            const parentContainer = getParentContainer(parent);
            const closeBraceToken = parentContainer.getLastChildByKind(ts$1.SyntaxKind.CloseBraceToken);
            if (closeBraceToken == null)
                endPos = parent.getEnd();
            else
                endPos = closeBraceToken.getStart();
        }
    }
    else {
        endPos = children[index].getNonWhitespaceStart();
    }
    return getPosAtStartOfLineOrNonWhitespace(fullText, endPos);
}
function getParentContainer(parent) {
    if (Node.isBodiedNode(parent))
        return Node.isNamespaceDeclaration(parent) ? parent._getInnerBody() : parent.getBody();
    if (Node.isBodyableNode(parent))
        return parent.getBodyOrThrow();
    else
        return parent;
}

function fromAbstractableNode(node) {
    return {
        isAbstract: node.isAbstract(),
    };
}
function fromAmbientableNode(node) {
    return {
        hasDeclareKeyword: node.hasDeclareKeyword(),
    };
}
function fromExportableNode(node) {
    return {
        isDefaultExport: node.hasDefaultKeyword(),
        isExported: node.hasExportKeyword(),
    };
}
function fromStaticableNode(node) {
    return {
        isStatic: node.isStatic(),
    };
}
function fromScopedNode(node) {
    return {
        scope: node.hasScopeKeyword() ? node.getScope() : undefined,
    };
}
function fromQuestionTokenableNode(node) {
    return {
        hasQuestionToken: node.hasQuestionToken(),
    };
}

function getNodesToReturn(oldChildren, newChildren, index, allowCommentNodes) {
    const oldChildCount = typeof oldChildren === "number" ? oldChildren : oldChildren.length;
    const newLength = newChildren.length - oldChildCount;
    const result = [];
    for (let i = 0; i < newLength; i++) {
        const currentChild = newChildren[index + i];
        if (allowCommentNodes || !Node.isCommentNode(currentChild))
            result.push(currentChild);
    }
    return result;
}

function getRangeWithoutCommentsFromArray(array, index, length, expectedKind) {
    const children = [];
    while (index < array.length && children.length < length) {
        const child = array[index];
        const childKind = child.getKind();
        if (childKind !== ts$1.SyntaxKind.SingleLineCommentTrivia && childKind !== ts$1.SyntaxKind.MultiLineCommentTrivia) {
            if (childKind !== expectedKind) {
                throw new errors.NotImplementedError(`Unexpected! Inserting syntax kind of ${common.getSyntaxKindName(expectedKind)}`
                    + `, but ${child.getKindName()} was inserted.`);
            }
            children.push(child);
        }
        index++;
    }
    if (children.length !== length)
        throw new errors.NotImplementedError(`Unexpected! Inserted ${length} child/children, but ${children.length} were inserted.`);
    return children;
}

function fromConstructorDeclarationOverload(node) {
    const structure = {};
    common.ObjectUtils.assign(structure, fromScopedNode(node));
    return structure;
}
function fromMethodDeclarationOverload(node) {
    const structure = {};
    common.ObjectUtils.assign(structure, fromStaticableNode(node));
    common.ObjectUtils.assign(structure, fromAbstractableNode(node));
    common.ObjectUtils.assign(structure, fromScopedNode(node));
    common.ObjectUtils.assign(structure, fromQuestionTokenableNode(node));
    return structure;
}
function fromFunctionDeclarationOverload(node) {
    const structure = {};
    common.ObjectUtils.assign(structure, fromAmbientableNode(node));
    common.ObjectUtils.assign(structure, fromExportableNode(node));
    return structure;
}

function verifyAndGetIndex(index, length) {
    const newIndex = index < 0 ? length + index : index;
    if (newIndex < 0)
        throw new errors.InvalidOperationError(`Invalid index: The max negative index is ${length * -1}, but ${index} was specified.`);
    if (index > length)
        throw new errors.InvalidOperationError(`Invalid index: The max index is ${length}, but ${index} was specified.`);
    return newIndex;
}

(function(CommentNodeKind) {
    CommentNodeKind[CommentNodeKind["Statement"] = 0] = "Statement";
    CommentNodeKind[CommentNodeKind["ClassElement"] = 1] = "ClassElement";
    CommentNodeKind[CommentNodeKind["TypeElement"] = 2] = "TypeElement";
    CommentNodeKind[CommentNodeKind["ObjectLiteralElement"] = 3] = "ObjectLiteralElement";
    CommentNodeKind[CommentNodeKind["EnumMember"] = 4] = "EnumMember";
})(exports.CommentNodeKind || (exports.CommentNodeKind = {}));
class CompilerCommentNode {
    constructor(fullStart, pos, end, kind, sourceFile, parent) {
        this._fullStart = fullStart;
        this._start = pos;
        this._sourceFile = sourceFile;
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.flags = ts$1.NodeFlags.None;
        this.parent = parent;
    }
    getSourceFile() {
        return this._sourceFile;
    }
    getChildCount(sourceFile) {
        return 0;
    }
    getChildAt(index, sourceFile) {
        return undefined;
    }
    getChildren(sourceFile) {
        return [];
    }
    getStart(sourceFile, includeJsDocComment) {
        return this._start;
    }
    getFullStart() {
        return this._fullStart;
    }
    getEnd() {
        return this.end;
    }
    getWidth(sourceFile) {
        return this.end - this._start;
    }
    getFullWidth() {
        return this.end - this._fullStart;
    }
    getLeadingTriviaWidth(sourceFile) {
        return this._start - this._fullStart;
    }
    getFullText(sourceFile) {
        return this._sourceFile.text.substring(this._fullStart, this.end);
    }
    getText(sourceFile) {
        return this._sourceFile.text.substring(this._start, this.end);
    }
    getFirstToken(sourceFile) {
        return undefined;
    }
    getLastToken(sourceFile) {
        return undefined;
    }
    forEachChild(cbNode, cbNodeArray) {
        return undefined;
    }
}
class CompilerCommentStatement extends CompilerCommentNode {
    constructor() {
        super(...arguments);
        this._commentKind = exports.CommentNodeKind.Statement;
    }
}
class CompilerCommentClassElement extends CompilerCommentNode {
    constructor() {
        super(...arguments);
        this._commentKind = exports.CommentNodeKind.ClassElement;
    }
}
class CompilerCommentTypeElement extends CompilerCommentNode {
    constructor() {
        super(...arguments);
        this._commentKind = exports.CommentNodeKind.TypeElement;
    }
}
class CompilerCommentObjectLiteralElement extends CompilerCommentNode {
    constructor() {
        super(...arguments);
        this._commentKind = exports.CommentNodeKind.ObjectLiteralElement;
    }
}
class CompilerCommentEnumMember extends CompilerCommentNode {
    constructor() {
        super(...arguments);
        this._commentKind = exports.CommentNodeKind.EnumMember;
    }
}

var CommentKind;
(function(CommentKind) {
    CommentKind[CommentKind["SingleLine"] = 0] = "SingleLine";
    CommentKind[CommentKind["MultiLine"] = 1] = "MultiLine";
    CommentKind[CommentKind["JsDoc"] = 2] = "JsDoc";
})(CommentKind || (CommentKind = {}));
const childrenSaver = new WeakMap();
const commentNodeParserKinds = new Set([
    ts$1.SyntaxKind.SourceFile,
    ts$1.SyntaxKind.Block,
    ts$1.SyntaxKind.ModuleBlock,
    ts$1.SyntaxKind.CaseClause,
    ts$1.SyntaxKind.DefaultClause,
    ts$1.SyntaxKind.ClassDeclaration,
    ts$1.SyntaxKind.InterfaceDeclaration,
    ts$1.SyntaxKind.EnumDeclaration,
    ts$1.SyntaxKind.ClassExpression,
    ts$1.SyntaxKind.TypeLiteral,
    ts$1.SyntaxKind.ObjectLiteralExpression,
]);
class CommentNodeParser {
    constructor() {
    }
    static getOrParseChildren(container, sourceFile) {
        if (isSyntaxList(container))
            container = container.parent;
        let children = childrenSaver.get(container);
        if (children == null) {
            children = Array.from(getNodes(container, sourceFile));
            childrenSaver.set(container, children);
        }
        return children;
    }
    static shouldParseChildren(container) {
        return commentNodeParserKinds.has(container.kind)
            && container.pos !== container.end;
    }
    static hasParsedChildren(container) {
        if (isSyntaxList(container))
            container = container.parent;
        return childrenSaver.has(container);
    }
    static isCommentStatement(node) {
        return node._commentKind === exports.CommentNodeKind.Statement;
    }
    static isCommentClassElement(node) {
        return node._commentKind === exports.CommentNodeKind.ClassElement;
    }
    static isCommentTypeElement(node) {
        return node._commentKind === exports.CommentNodeKind.TypeElement;
    }
    static isCommentObjectLiteralElement(node) {
        return node._commentKind === exports.CommentNodeKind.ObjectLiteralElement;
    }
    static isCommentEnumMember(node) {
        return node._commentKind === exports.CommentNodeKind.EnumMember;
    }
    static getContainerBodyPos(container, sourceFile) {
        if (ts$1.isSourceFile(container))
            return 0;
        if (ts$1.isClassDeclaration(container)
            || ts$1.isEnumDeclaration(container)
            || ts$1.isInterfaceDeclaration(container)
            || ts$1.isTypeLiteralNode(container)
            || ts$1.isClassExpression(container)
            || ts$1.isBlock(container)
            || ts$1.isModuleBlock(container)
            || ts$1.isObjectLiteralExpression(container)) {
            return getTokenEnd(container, ts$1.SyntaxKind.OpenBraceToken);
        }
        if (ts$1.isCaseClause(container) || ts$1.isDefaultClause(container))
            return getTokenEnd(container, ts$1.SyntaxKind.ColonToken);
        return errors.throwNotImplementedForNeverValueError(container);
        function getTokenEnd(node, kind) {
            var _a;
            return (_a = node.getChildren(sourceFile).find(c => c.kind === kind)) === null || _a === void 0 ? void 0 : _a.end;
        }
    }
}
function* getNodes(container, sourceFile) {
    const sourceFileText = sourceFile.text;
    const childNodes = getContainerChildren();
    const createComment = getCreationFunction();
    if (childNodes.length === 0) {
        const bodyStartPos = CommentNodeParser.getContainerBodyPos(container, sourceFile);
        if (bodyStartPos != null)
            yield* getCommentNodes(bodyStartPos, false);
    }
    else {
        for (const childNode of childNodes) {
            yield* getCommentNodes(childNode.pos, true);
            yield childNode;
        }
        const lastChild = childNodes[childNodes.length - 1];
        yield* getCommentNodes(lastChild.end, false);
    }
    function* getCommentNodes(pos, stopAtJsDoc) {
        const fullStart = pos;
        skipTrailingLine();
        const leadingComments = Array.from(getLeadingComments());
        const maxEnd = sourceFileText.length === pos || sourceFileText[pos] === "}" ? pos : StringUtils.getLineStartFromPos(sourceFileText, pos);
        for (const leadingComment of leadingComments) {
            if (leadingComment.end <= maxEnd)
                yield leadingComment;
        }
        function skipTrailingLine() {
            if (pos === 0)
                return;
            let lineEnd = StringUtils.getLineEndFromPos(sourceFileText, pos);
            while (pos < lineEnd) {
                const commentKind = getCommentKind();
                if (commentKind != null) {
                    const comment = parseForComment(commentKind);
                    if (comment.kind === ts$1.SyntaxKind.SingleLineCommentTrivia)
                        return;
                    else
                        lineEnd = StringUtils.getLineEndFromPos(sourceFileText, pos);
                }
                else if (!StringUtils.isWhitespace(sourceFileText[pos]) && sourceFileText[pos] !== ",")
                    return;
                else
                    pos++;
            }
            while (StringUtils.startsWithNewLine(sourceFileText[pos]))
                pos++;
        }
        function* getLeadingComments() {
            while (pos < sourceFileText.length) {
                const commentKind = getCommentKind();
                if (commentKind != null) {
                    const isJsDoc = commentKind === CommentKind.JsDoc;
                    if (isJsDoc && stopAtJsDoc)
                        return;
                    else
                        yield parseForComment(commentKind);
                    skipTrailingLine();
                }
                else if (!StringUtils.isWhitespace(sourceFileText[pos]))
                    return;
                else
                    pos++;
            }
        }
        function parseForComment(commentKind) {
            if (commentKind === CommentKind.SingleLine)
                return parseSingleLineComment();
            const isJsDoc = commentKind === CommentKind.JsDoc;
            return parseMultiLineComment(isJsDoc);
        }
        function getCommentKind() {
            const currentChar = sourceFileText[pos];
            if (currentChar !== "/")
                return undefined;
            const nextChar = sourceFileText[pos + 1];
            if (nextChar === "/")
                return CommentKind.SingleLine;
            if (nextChar !== "*")
                return undefined;
            const nextNextChar = sourceFileText[pos + 2];
            return nextNextChar === "*" ? CommentKind.JsDoc : CommentKind.MultiLine;
        }
        function parseSingleLineComment() {
            const start = pos;
            skipSingleLineComment();
            const end = pos;
            return createComment(fullStart, start, end, ts$1.SyntaxKind.SingleLineCommentTrivia);
        }
        function skipSingleLineComment() {
            pos += 2;
            while (pos < sourceFileText.length && sourceFileText[pos] !== "\n" && sourceFileText[pos] !== "\r")
                pos++;
        }
        function parseMultiLineComment(isJsDoc) {
            const start = pos;
            skipSlashStarComment(isJsDoc);
            const end = pos;
            return createComment(fullStart, start, end, ts$1.SyntaxKind.MultiLineCommentTrivia);
        }
        function skipSlashStarComment(isJsDoc) {
            pos += isJsDoc ? 3 : 2;
            while (pos < sourceFileText.length) {
                if (sourceFileText[pos] === "*" && sourceFileText[pos + 1] === "/") {
                    pos += 2;
                    break;
                }
                pos++;
            }
        }
    }
    function getContainerChildren() {
        if (ts$1.isSourceFile(container) || ts$1.isBlock(container) || ts$1.isModuleBlock(container) || ts$1.isCaseClause(container) || ts$1.isDefaultClause(container))
            return container.statements;
        if (ts$1.isClassDeclaration(container)
            || ts$1.isClassExpression(container)
            || ts$1.isEnumDeclaration(container)
            || ts$1.isInterfaceDeclaration(container)
            || ts$1.isTypeLiteralNode(container)
            || ts$1.isClassExpression(container)) {
            return container.members;
        }
        if (ts$1.isObjectLiteralExpression(container))
            return container.properties;
        return errors.throwNotImplementedForNeverValueError(container);
    }
    function getCreationFunction() {
        const ctor = getCtor();
        return (fullStart, pos, end, kind) => new ctor(fullStart, pos, end, kind, sourceFile, container);
        function getCtor() {
            if (isStatementContainerNode(container))
                return CompilerCommentStatement;
            if (ts$1.isClassLike(container))
                return CompilerCommentClassElement;
            if (ts$1.isInterfaceDeclaration(container) || ts$1.isTypeLiteralNode(container))
                return CompilerCommentTypeElement;
            if (ts$1.isObjectLiteralExpression(container))
                return CompilerCommentObjectLiteralElement;
            if (ts$1.isEnumDeclaration(container))
                return CompilerCommentEnumMember;
            throw new errors.NotImplementedError(`Not implemented comment node container type: ${common.getSyntaxKindName(container.kind)}`);
        }
    }
}
function isSyntaxList(node) {
    return node.kind === ts$1.SyntaxKind.SyntaxList;
}
function isStatementContainerNode(node) {
    return getStatementContainerNode() != null;
    function getStatementContainerNode() {
        const container = node;
        if (ts$1.isSourceFile(container)
            || ts$1.isBlock(container)
            || ts$1.isModuleBlock(container)
            || ts$1.isCaseClause(container)
            || ts$1.isDefaultClause(container)) {
            return container;
        }
        return undefined;
    }
}

function hasParsedTokens(node) {
    return node._children != null;
}

const forEachChildSaver = new WeakMap();
const getChildrenSaver = new WeakMap();
class ExtendedParser {
    static getContainerArray(container, sourceFile) {
        return CommentNodeParser.getOrParseChildren(container, sourceFile);
    }
    static getCompilerChildrenFast(node, sourceFile) {
        if (hasParsedTokens(node))
            return ExtendedParser.getCompilerChildren(node, sourceFile);
        return ExtendedParser.getCompilerForEachChildren(node, sourceFile);
    }
    static getCompilerForEachChildren(node, sourceFile) {
        if (CommentNodeParser.shouldParseChildren(node)) {
            let result = forEachChildSaver.get(node);
            if (result == null) {
                result = getForEachChildren();
                mergeInComments(result, CommentNodeParser.getOrParseChildren(node, sourceFile));
                forEachChildSaver.set(node, result);
            }
            return result;
        }
        return getForEachChildren();
        function getForEachChildren() {
            const children = [];
            node.forEachChild(child => {
                children.push(child);
            });
            return children;
        }
    }
    static getCompilerChildren(node, sourceFile) {
        if (isStatementMemberOrPropertyHoldingSyntaxList()) {
            let result = getChildrenSaver.get(node);
            if (result == null) {
                result = [...node.getChildren(sourceFile)];
                mergeInComments(result, CommentNodeParser.getOrParseChildren(node, sourceFile));
                getChildrenSaver.set(node, result);
            }
            return result;
        }
        return node.getChildren(sourceFile);
        function isStatementMemberOrPropertyHoldingSyntaxList() {
            if (node.kind !== ts$1.SyntaxKind.SyntaxList)
                return false;
            const parent = node.parent;
            if (!CommentNodeParser.shouldParseChildren(parent))
                return false;
            return CommentNodeParser.getContainerBodyPos(parent, sourceFile) === node.pos;
        }
    }
}
function mergeInComments(nodes, otherNodes) {
    let currentIndex = 0;
    for (const child of otherNodes) {
        if (child.kind !== ts$1.SyntaxKind.SingleLineCommentTrivia && child.kind !== ts$1.SyntaxKind.MultiLineCommentTrivia)
            continue;
        while (currentIndex < nodes.length && nodes[currentIndex].end < child.end)
            currentIndex++;
        nodes.splice(currentIndex, 0, child);
        currentIndex++;
    }
}

function isComment(node) {
    return node.kind === ts$1.SyntaxKind.SingleLineCommentTrivia
        || node.kind === ts$1.SyntaxKind.MultiLineCommentTrivia;
}

class NodeHandlerHelper {
    constructor(compilerFactory) {
        this.compilerFactory = compilerFactory;
    }
    handleForValues(handler, currentNode, newNode, newSourceFile) {
        if (this.compilerFactory.hasCompilerNode(currentNode))
            handler.handleNode(this.compilerFactory.getExistingNodeFromCompilerNode(currentNode), newNode, newSourceFile);
        else if (currentNode.kind === ts$1.SyntaxKind.SyntaxList) {
            const sourceFile = this.compilerFactory.getExistingNodeFromCompilerNode(currentNode.getSourceFile());
            handler.handleNode(this.compilerFactory.getNodeFromCompilerNode(currentNode, sourceFile), newNode, newSourceFile);
        }
    }
    forgetNodeIfNecessary(currentNode) {
        if (this.compilerFactory.hasCompilerNode(currentNode))
            this.compilerFactory.getExistingNodeFromCompilerNode(currentNode).forget();
    }
    getCompilerChildrenAsIterators(currentNode, newNode, newSourceFile) {
        const children = this.getCompilerChildren(currentNode, newNode, newSourceFile);
        return [
            new AdvancedIterator(ArrayUtils.toIterator(children[0])),
            new AdvancedIterator(ArrayUtils.toIterator(children[1])),
        ];
    }
    getCompilerChildren(currentNode, newNode, newSourceFile) {
        const currentCompilerNode = currentNode.compilerNode;
        const currentSourceFile = currentNode._sourceFile.compilerNode;
        return [
            ExtendedParser.getCompilerChildren(currentCompilerNode, currentSourceFile),
            ExtendedParser.getCompilerChildren(newNode, newSourceFile),
        ];
    }
    getChildrenFast(currentNode, newNode, newSourceFile) {
        const currentCompilerNode = currentNode.compilerNode;
        const currentSourceFile = currentNode._sourceFile.compilerNode;
        if (hasParsedTokens(currentCompilerNode)) {
            return [
                ExtendedParser.getCompilerChildren(currentCompilerNode, currentSourceFile),
                ExtendedParser.getCompilerChildren(newNode, newSourceFile),
            ];
        }
        return [
            ExtendedParser.getCompilerForEachChildren(currentCompilerNode, currentSourceFile),
            ExtendedParser.getCompilerForEachChildren(newNode, newSourceFile),
        ];
    }
}

class StraightReplacementNodeHandler {
    constructor(compilerFactory) {
        this.compilerFactory = compilerFactory;
        this.helper = new NodeHandlerHelper(compilerFactory);
    }
    handleNode(currentNode, newNode, newSourceFile) {
        if (currentNode.getKind() !== newNode.kind) {
            throw new errors.InvalidOperationError(`Error replacing tree! Perhaps a syntax error was inserted `
                + `(Current: ${currentNode.getKindName()} -- New: ${common.getSyntaxKindName(newNode.kind)}).`);
        }
        if (currentNode._hasWrappedChildren())
            this.handleChildren(currentNode, newNode, newSourceFile);
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    handleChildren(currentNode, newNode, newSourceFile) {
        const [currentChildren, newChildren] = this.helper.getChildrenFast(currentNode, newNode, newSourceFile);
        if (currentChildren.length !== newChildren.length) {
            throw new Error(`Error replacing tree: The children of the old and new trees were expected to have the `
                + `same count (${currentChildren.length}:${newChildren.length}).`);
        }
        for (let i = 0; i < currentChildren.length; i++)
            this.helper.handleForValues(this, currentChildren[i], newChildren[i], newSourceFile);
    }
}

class ChangeChildOrderParentHandler {
    constructor(compilerFactory, opts) {
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper(compilerFactory);
        this.oldIndex = opts.oldIndex;
        this.newIndex = opts.newIndex;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const [currentChildren, newChildren] = this.helper.getCompilerChildren(currentNode, newNode, newSourceFile);
        const currentChildrenInNewOrder = this.getChildrenInNewOrder(currentChildren);
        errors.throwIfNotEqual(newChildren.length, currentChildrenInNewOrder.length, "New children length should match the old children length.");
        for (let i = 0; i < newChildren.length; i++)
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentChildrenInNewOrder[i], newChildren[i], newSourceFile);
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    getChildrenInNewOrder(children) {
        const result = [...children];
        const movingNode = result.splice(this.oldIndex, 1)[0];
        result.splice(this.newIndex, 0, movingNode);
        return result;
    }
}

class DefaultParentHandler {
    constructor(compilerFactory, opts) {
        var _a;
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper(compilerFactory);
        this.childCount = opts.childCount;
        this.isFirstChild = opts.isFirstChild;
        this.replacingNodes = (_a = opts.replacingNodes) === null || _a === void 0 ? void 0 : _a.map(n => n.compilerNode);
        this.customMappings = opts.customMappings;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const [currentChildren, newChildren] = this.helper.getCompilerChildrenAsIterators(currentNode, newNode, newSourceFile);
        let count = this.childCount;
        this.handleCustomMappings(newNode);
        while (!currentChildren.done && !newChildren.done && !this.isFirstChild(currentChildren.peek, newChildren.peek))
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentChildren.next(), newChildren.next(), newSourceFile);
        while (!currentChildren.done && this.tryReplaceNode(currentChildren.peek))
            currentChildren.next();
        if (count > 0) {
            while (count > 0) {
                newChildren.next();
                count--;
            }
        }
        else if (count < 0) {
            while (count < 0) {
                this.helper.forgetNodeIfNecessary(currentChildren.next());
                count++;
            }
        }
        while (!currentChildren.done)
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentChildren.next(), newChildren.next(), newSourceFile);
        if (!newChildren.done)
            throw new Error("Error replacing tree: Should not have children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    handleCustomMappings(newParentNode) {
        if (this.customMappings == null)
            return;
        const customMappings = this.customMappings(newParentNode);
        for (const mapping of customMappings)
            this.compilerFactory.replaceCompilerNode(mapping.currentNode, mapping.newNode);
    }
    tryReplaceNode(currentCompilerNode) {
        if (this.replacingNodes == null || this.replacingNodes.length === 0)
            return false;
        const index = this.replacingNodes.indexOf(currentCompilerNode);
        if (index === -1)
            return false;
        this.replacingNodes.splice(index, 1);
        this.helper.forgetNodeIfNecessary(currentCompilerNode);
        return true;
    }
}

class ForgetChangedNodeHandler {
    constructor(compilerFactory) {
        this.compilerFactory = compilerFactory;
        this.helper = new NodeHandlerHelper(compilerFactory);
    }
    handleNode(currentNode, newNode, newSourceFile) {
        if (currentNode.getKind() !== newNode.kind) {
            currentNode.forget();
            return;
        }
        if (currentNode._hasWrappedChildren())
            this.handleChildren(currentNode, newNode, newSourceFile);
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    handleChildren(currentNode, newNode, newSourceFile) {
        const [currentNodeChildren, newNodeChildrenArray] = this.helper.getChildrenFast(currentNode, newNode, newSourceFile);
        const newNodeChildren = ArrayUtils.toIterator(newNodeChildrenArray);
        for (const currentNodeChild of currentNodeChildren) {
            const nextNodeChildResult = newNodeChildren.next();
            if (nextNodeChildResult.done) {
                const existingNode = this.compilerFactory.getExistingNodeFromCompilerNode(currentNodeChild);
                if (existingNode != null)
                    existingNode.forget();
            }
            else {
                this.helper.handleForValues(this, currentNodeChild, nextNodeChildResult.value, newSourceFile);
            }
        }
    }
}

class ParentFinderReplacementNodeHandler extends StraightReplacementNodeHandler {
    constructor(compilerFactory, parentNodeHandler, changingParent) {
        super(compilerFactory);
        this.parentNodeHandler = parentNodeHandler;
        this.changingParent = changingParent;
        this.foundParent = false;
        this.changingParentParent = this.changingParent.getParentSyntaxList() || this.changingParent.getParent();
        this.parentsAtSamePos = this.changingParentParent != null && this.changingParentParent.getPos() === this.changingParent.getPos();
    }
    handleNode(currentNode, newNode, newSourceFile) {
        if (!this.foundParent && this.isParentNode(newNode, newSourceFile)) {
            this.foundParent = true;
            this.parentNodeHandler.handleNode(currentNode, newNode, newSourceFile);
        }
        else {
            super.handleNode(currentNode, newNode, newSourceFile);
        }
    }
    isParentNode(newNode, newSourceFile) {
        const positionsAndKindsEqual = areNodesEqual(newNode, this.changingParent)
            && areNodesEqual(getParentSyntaxList(newNode, newSourceFile) || newNode.parent, this.changingParentParent);
        if (!positionsAndKindsEqual)
            return false;
        if (!this.parentsAtSamePos)
            return true;
        return getAncestorLength(this.changingParent.compilerNode) === getAncestorLength(newNode);
        function getAncestorLength(nodeToCheck) {
            let node = nodeToCheck;
            let count = 0;
            while (node.parent != null) {
                count++;
                node = node.parent;
            }
            return count;
        }
    }
}
function areNodesEqual(a, b) {
    if (a == null && b == null)
        return true;
    if (a == null || b == null)
        return false;
    if (a.pos === b.getPos() && a.kind === b.getKind())
        return true;
    return false;
}

class RangeHandler {
    constructor(compilerFactory, opts) {
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper(compilerFactory);
        this.start = opts.start;
        this.end = opts.end;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const currentSourceFile = currentNode._sourceFile.compilerNode;
        const children = this.helper.getChildrenFast(currentNode, newNode, newSourceFile);
        const currentNodeChildren = new AdvancedIterator(ArrayUtils.toIterator(children[0]));
        const newNodeChildren = new AdvancedIterator(ArrayUtils.toIterator(children[1]));
        while (!currentNodeChildren.done && !newNodeChildren.done && newNodeChildren.peek.getEnd() <= this.start)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        while (!currentNodeChildren.done && !newNodeChildren.done
            && (currentNodeChildren.peek.getStart(currentSourceFile) < this.start
                || currentNodeChildren.peek.getStart(currentSourceFile) === this.start && newNodeChildren.peek.end > this.end)) {
            this.rangeHandlerReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        }
        while (!newNodeChildren.done && newNodeChildren.peek.getEnd() <= this.end)
            newNodeChildren.next();
        while (!currentNodeChildren.done)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        if (!newNodeChildren.done)
            throw new Error("Error replacing tree: Should not have children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    straightReplace(currentNode, nextNode, newSourceFile) {
        this.helper.handleForValues(this.straightReplacementNodeHandler, currentNode, nextNode, newSourceFile);
    }
    rangeHandlerReplace(currentNode, nextNode, newSourceFile) {
        this.helper.handleForValues(this, currentNode, nextNode, newSourceFile);
    }
}

class RenameNodeHandler extends StraightReplacementNodeHandler {
    handleNode(currentNode, newNode, newSourceFile) {
        const currentNodeKind = currentNode.getKind();
        const newNodeKind = newNode.kind;
        if (currentNodeKind === ts$1.SyntaxKind.ShorthandPropertyAssignment && newNodeKind === ts$1.SyntaxKind.PropertyAssignment) {
            const currentSourceFile = currentNode.getSourceFile();
            const currentIdentifier = currentNode.getNameNode();
            const newIdentifier = newNode.initializer;
            this.compilerFactory.replaceCompilerNode(currentIdentifier, newIdentifier);
            currentNode.forget();
            this.compilerFactory.getNodeFromCompilerNode(newNode, currentSourceFile);
            return;
        }
        else if (currentNodeKind === ts$1.SyntaxKind.ExportSpecifier && newNodeKind === ts$1.SyntaxKind.ExportSpecifier
            && currentNode.compilerNode.propertyName == null && newNode.propertyName != null) {
            handleImportOrExportSpecifier(this.compilerFactory);
            return;
        }
        else if (currentNodeKind === ts$1.SyntaxKind.ImportSpecifier && newNodeKind === ts$1.SyntaxKind.ImportSpecifier
            && currentNode.compilerNode.propertyName == null && newNode.propertyName != null) {
            handleImportOrExportSpecifier(this.compilerFactory);
            return;
        }
        super.handleNode(currentNode, newNode, newSourceFile);
        return;
        function handleImportOrExportSpecifier(compilerFactory) {
            const currentIdentifier = currentNode.getNameNode();
            const newSpecifier = newNode;
            const newPropertyName = newSpecifier.propertyName;
            const newName = newSpecifier.name;
            const newIdentifier = newPropertyName.escapedText === currentIdentifier.compilerNode.escapedText ? newName : newPropertyName;
            compilerFactory.replaceCompilerNode(currentIdentifier, newIdentifier);
            compilerFactory.replaceCompilerNode(currentNode, newNode);
        }
    }
}

class RangeParentHandler {
    constructor(compilerFactory, opts) {
        var _a;
        this.compilerFactory = compilerFactory;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper(compilerFactory);
        this.start = opts.start;
        this.end = opts.end;
        this.replacingLength = opts.replacingLength;
        this.replacingNodes = (_a = opts.replacingNodes) === null || _a === void 0 ? void 0 : _a.map(n => n.compilerNode);
        this.customMappings = opts.customMappings;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const currentSourceFile = currentNode._sourceFile.compilerNode;
        const [currentNodeChildren, newNodeChildren] = this.helper.getCompilerChildrenAsIterators(currentNode, newNode, newSourceFile);
        this.handleCustomMappings(newNode, newSourceFile);
        while (!currentNodeChildren.done && !newNodeChildren.done && newNodeChildren.peek.getStart(newSourceFile) < this.start)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        const newNodes = [];
        while (!newNodeChildren.done && newNodeChildren.peek.getStart(newSourceFile) >= this.start
            && getRealEnd(newNodeChildren.peek, newSourceFile) <= this.end) {
            newNodes.push(newNodeChildren.next());
        }
        if (this.replacingLength != null) {
            const replacingEnd = this.start + this.replacingLength;
            const oldNodes = [];
            while (!currentNodeChildren.done
                && (getRealEnd(currentNodeChildren.peek, currentSourceFile) <= replacingEnd
                    || currentNodeChildren.peek.getStart(currentSourceFile) < replacingEnd)) {
                oldNodes.push(currentNodeChildren.next());
            }
            if (oldNodes.length === newNodes.length && oldNodes.every((node, i) => node.kind === newNodes[i].kind)) {
                for (let i = 0; i < oldNodes.length; i++) {
                    const node = this.compilerFactory.getExistingNodeFromCompilerNode(oldNodes[i]);
                    if (node != null) {
                        node.forgetDescendants();
                        this.compilerFactory.replaceCompilerNode(oldNodes[i], newNodes[i]);
                    }
                }
            }
            else {
                oldNodes.forEach(node => this.helper.forgetNodeIfNecessary(node));
            }
        }
        while (!currentNodeChildren.done)
            this.straightReplace(currentNodeChildren.next(), newNodeChildren.next(), newSourceFile);
        if (!newNodeChildren.done)
            throw new Error("Error replacing tree: Should not have children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
    handleCustomMappings(newParentNode, newSourceFile) {
        if (this.customMappings == null)
            return;
        const customMappings = this.customMappings(newParentNode, newSourceFile);
        for (const mapping of customMappings)
            mapping.currentNode._context.compilerFactory.replaceCompilerNode(mapping.currentNode, mapping.newNode);
    }
    straightReplace(currentNode, nextNode, newSourceFile) {
        if (!this.tryReplaceNode(currentNode))
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentNode, nextNode, newSourceFile);
    }
    tryReplaceNode(currentCompilerNode) {
        if (this.replacingNodes == null || this.replacingNodes.length === 0)
            return false;
        const index = this.replacingNodes.indexOf(currentCompilerNode);
        if (index === -1)
            return false;
        this.replacingNodes.splice(index, 1);
        this.helper.forgetNodeIfNecessary(currentCompilerNode);
        return true;
    }
}
function getRealEnd(node, sourceFile) {
    if (node.kind >= ts$1.SyntaxKind.FirstJSDocNode && node.kind <= ts$1.SyntaxKind.LastJSDocNode) {
        return getPreviousMatchingPos(sourceFile.text, node.end, charCode => charCode !== CharCodes$1.ASTERISK && !StringUtils.isWhitespaceCharCode(charCode));
    }
    return node.end;
}

class TryOrForgetNodeHandler {
    constructor(handler) {
        this.handler = handler;
    }
    handleNode(currentNode, newNode, newSourceFile) {
        if (!Node.isSourceFile(currentNode))
            throw new errors.InvalidOperationError(`Can only use a ${"TryOrForgetNodeHandler"} with a source file.`);
        try {
            this.handler.handleNode(currentNode, newNode, newSourceFile);
        }
        catch (ex) {
            currentNode._context.logger.warn("Could not replace tree, so forgetting all nodes instead. Message: " + ex);
            currentNode.getChildSyntaxListOrThrow().forget();
            currentNode._context.compilerFactory.replaceCompilerNode(currentNode, newNode);
        }
    }
}

class UnwrapParentHandler {
    constructor(compilerFactory, childIndex) {
        this.compilerFactory = compilerFactory;
        this.childIndex = childIndex;
        this.straightReplacementNodeHandler = new StraightReplacementNodeHandler(compilerFactory);
        this.helper = new NodeHandlerHelper(compilerFactory);
    }
    handleNode(currentNode, newNode, newSourceFile) {
        const [currentChildren, newChildren] = this.helper.getCompilerChildrenAsIterators(currentNode, newNode, newSourceFile);
        let index = 0;
        while (!currentChildren.done && !newChildren.done && index++ < this.childIndex)
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentChildren.next(), newChildren.next(), newSourceFile);
        const currentChild = this.compilerFactory.getExistingNodeFromCompilerNode(currentChildren.next());
        const childSyntaxList = currentChild.getChildSyntaxListOrThrow();
        for (const child of ExtendedParser.getCompilerChildren(childSyntaxList.compilerNode, childSyntaxList._sourceFile.compilerNode))
            this.helper.handleForValues(this.straightReplacementNodeHandler, child, newChildren.next(), newSourceFile);
        forgetNodes(currentChild);
        function forgetNodes(node) {
            if (node === childSyntaxList) {
                node._forgetOnlyThis();
                return;
            }
            for (const child of node._getChildrenInCacheIterator())
                forgetNodes(child);
            node._forgetOnlyThis();
        }
        while (!currentChildren.done)
            this.helper.handleForValues(this.straightReplacementNodeHandler, currentChildren.next(), newChildren.next(), newSourceFile);
        if (!newChildren.done)
            throw new Error("Error replacing tree: Should not have children left over.");
        this.compilerFactory.replaceCompilerNode(currentNode, newNode);
    }
}

class NodeHandlerFactory {
    getDefault(opts) {
        const { parent: changingParent, isFirstChild, childCount, customMappings } = opts;
        const sourceFile = changingParent.getSourceFile();
        const compilerFactory = sourceFile._context.compilerFactory;
        const replacingNodes = opts.replacingNodes == null ? undefined : [...opts.replacingNodes];
        const parentHandler = new DefaultParentHandler(compilerFactory, { childCount, isFirstChild, replacingNodes, customMappings });
        if (changingParent === sourceFile)
            return parentHandler;
        else
            return new ParentFinderReplacementNodeHandler(compilerFactory, parentHandler, changingParent);
    }
    getForParentRange(opts) {
        const { parent: changingParent, start, end, replacingLength, replacingNodes, customMappings } = opts;
        const sourceFile = changingParent.getSourceFile();
        const compilerFactory = sourceFile._context.compilerFactory;
        const parentHandler = new RangeParentHandler(compilerFactory, { start, end, replacingLength, replacingNodes, customMappings });
        if (changingParent === sourceFile)
            return parentHandler;
        else
            return new ParentFinderReplacementNodeHandler(compilerFactory, parentHandler, changingParent);
    }
    getForRange(opts) {
        const { sourceFile, start, end } = opts;
        const compilerFactory = sourceFile._context.compilerFactory;
        return new RangeHandler(compilerFactory, { start, end });
    }
    getForChildIndex(opts) {
        const { parent, childIndex, childCount, replacingNodes, customMappings } = opts;
        const parentChildren = parent.getChildren();
        errors.throwIfOutOfRange(childIndex, [0, parentChildren.length], "opts.childIndex");
        if (childCount < 0)
            errors.throwIfOutOfRange(childCount, [childIndex - parentChildren.length, 0], "opts.childCount");
        let i = 0;
        const isFirstChild = () => i++ === childIndex;
        return this.getDefault({
            parent,
            isFirstChild,
            childCount,
            replacingNodes,
            customMappings,
        });
    }
    getForStraightReplacement(compilerFactory) {
        return new StraightReplacementNodeHandler(compilerFactory);
    }
    getForForgetChanged(compilerFactory) {
        return new ForgetChangedNodeHandler(compilerFactory);
    }
    getForRename(compilerFactory) {
        return new RenameNodeHandler(compilerFactory);
    }
    getForTryOrForget(handler) {
        return new TryOrForgetNodeHandler(handler);
    }
    getForChangingChildOrder(opts) {
        const { parent: changingParent, oldIndex, newIndex } = opts;
        const sourceFile = changingParent.getSourceFile();
        const compilerFactory = sourceFile._context.compilerFactory;
        const changeChildOrderParentHandler = new ChangeChildOrderParentHandler(compilerFactory, { oldIndex, newIndex });
        if (changingParent === sourceFile)
            return changeChildOrderParentHandler;
        else
            return new ParentFinderReplacementNodeHandler(compilerFactory, changeChildOrderParentHandler, changingParent);
    }
    getForUnwrappingNode(unwrappingNode) {
        const changingParent = unwrappingNode.getParentSyntaxList() || unwrappingNode.getParentOrThrow();
        const childIndex = unwrappingNode.getChildIndex();
        const sourceFile = changingParent.getSourceFile();
        const compilerFactory = sourceFile._context.compilerFactory;
        const unwrapParentHandler = new UnwrapParentHandler(compilerFactory, childIndex);
        if (changingParent === sourceFile)
            return unwrapParentHandler;
        else
            return new ParentFinderReplacementNodeHandler(compilerFactory, unwrapParentHandler, changingParent);
    }
}

function getSpacingBetweenNodes(opts) {
    const { parent, previousSibling, nextSibling, newLineKind, getSiblingFormatting } = opts;
    if (previousSibling == null || nextSibling == null)
        return "";
    const previousSiblingFormatting = getSiblingFormatting(parent, previousSibling);
    const nextSiblingFormatting = getSiblingFormatting(parent, nextSibling);
    if (previousSiblingFormatting === FormattingKind.Blankline || nextSiblingFormatting === FormattingKind.Blankline)
        return newLineKind + newLineKind;
    else if (previousSiblingFormatting === FormattingKind.Newline || nextSiblingFormatting === FormattingKind.Newline)
        return newLineKind;
    else if (previousSiblingFormatting === FormattingKind.Space || nextSiblingFormatting === FormattingKind.Space)
        return " ";
    else
        return "";
}

class ChangingChildOrderTextManipulator {
    constructor(opts) {
        this.opts = opts;
    }
    getNewText(inputText) {
        const { parent, oldIndex, newIndex, getSiblingFormatting } = this.opts;
        const children = parent.getChildren();
        const newLineKind = parent._context.manipulationSettings.getNewLineKindAsString();
        const movingNode = children[oldIndex];
        const fullText = parent._sourceFile.getFullText();
        const movingNodeStart = getPosAtNextNonBlankLine(fullText, movingNode.getPos());
        const movingNodeText = fullText.substring(movingNodeStart, movingNode.getEnd());
        const lowerIndex = Math.min(newIndex, oldIndex);
        const upperIndex = Math.max(newIndex, oldIndex);
        const childrenInNewOrder = getChildrenInNewOrder();
        const isParentSourceFile = Node.isSourceFile(parent.getParentOrThrow());
        let finalText = "";
        fillPrefixText();
        fillTextForIndex(lowerIndex);
        fillMiddleText();
        fillTextForIndex(upperIndex);
        fillSuffixText();
        return finalText;
        function getChildrenInNewOrder() {
            const result = [...children];
            result.splice(oldIndex, 1);
            result.splice(newIndex, 0, movingNode);
            return result;
        }
        function fillPrefixText() {
            finalText += fullText.substring(0, children[lowerIndex].getPos());
            if (lowerIndex === 0 && !isParentSourceFile)
                finalText += newLineKind;
        }
        function fillMiddleText() {
            let startPos;
            let endPos;
            if (lowerIndex === oldIndex) {
                startPos = getPosAtNextNonBlankLine(fullText, children[lowerIndex].getEnd());
                endPos = children[upperIndex].getEnd();
            }
            else {
                startPos = getPosAtNextNonBlankLine(fullText, children[lowerIndex].getPos());
                endPos = children[upperIndex].getPos();
            }
            finalText += fullText.substring(startPos, endPos);
        }
        function fillSuffixText() {
            if (children.length - 1 === upperIndex && !isParentSourceFile)
                finalText += newLineKind;
            finalText += fullText.substring(getPosAtNextNonBlankLine(fullText, children[upperIndex].getEnd()));
        }
        function fillTextForIndex(index) {
            if (index === oldIndex)
                fillSpacingForRemoval();
            else {
                fillSpacingBeforeInsertion();
                finalText += movingNodeText;
                fillSpacingAfterInsertion();
            }
        }
        function fillSpacingForRemoval() {
            if (oldIndex === 0 || oldIndex === children.length - 1)
                return;
            fillSpacingCommon({
                previousSibling: childrenInNewOrder[oldIndex - 1],
                nextSibling: childrenInNewOrder[oldIndex],
            });
        }
        function fillSpacingBeforeInsertion() {
            if (newIndex === 0)
                return;
            fillSpacingCommon({
                previousSibling: childrenInNewOrder[newIndex - 1],
                nextSibling: childrenInNewOrder[newIndex],
            });
        }
        function fillSpacingAfterInsertion() {
            fillSpacingCommon({
                previousSibling: childrenInNewOrder[newIndex],
                nextSibling: childrenInNewOrder[newIndex + 1],
            });
        }
        function fillSpacingCommon(spacingOpts) {
            const spacing = getSpacingBetweenNodes({
                parent,
                getSiblingFormatting,
                newLineKind,
                previousSibling: spacingOpts.previousSibling,
                nextSibling: spacingOpts.nextSibling,
            });
            const twoNewLines = newLineKind + newLineKind;
            if (spacing === twoNewLines) {
                if (finalText.endsWith(twoNewLines))
                    return;
                else if (finalText.endsWith(newLineKind))
                    finalText += newLineKind;
                else
                    finalText += twoNewLines;
            }
            else if (spacing === newLineKind) {
                if (finalText.endsWith(newLineKind))
                    return;
                else
                    finalText += newLineKind;
            }
            else if (spacing === " ") {
                if (finalText.endsWith(" "))
                    return;
                else
                    finalText += " ";
            }
            else {
                finalText += spacing;
            }
        }
    }
    getTextForError(newText) {
        return newText;
    }
}

class FullReplacementTextManipulator {
    constructor(newText) {
        this.newText = newText;
    }
    getNewText(inputText) {
        return this.newText;
    }
    getTextForError(newText) {
        return newText;
    }
}

function getTextForError(newText, pos, length = 0) {
    const startPos = Math.max(0, newText.lastIndexOf("\n", pos) - 100);
    let endPos = Math.min(newText.length, newText.indexOf("\n", pos + length));
    endPos = endPos === -1 ? newText.length : Math.min(newText.length, endPos + 100);
    let text = "";
    text += newText.substring(startPos, endPos);
    if (startPos !== 0)
        text = "..." + text;
    if (endPos !== newText.length)
        text += "...";
    return text;
}

class InsertionTextManipulator {
    constructor(opts) {
        this.opts = opts;
    }
    getNewText(inputText) {
        const { insertPos, newText, replacingLength = 0 } = this.opts;
        return inputText.substring(0, insertPos) + newText + inputText.substring(insertPos + replacingLength);
    }
    getTextForError(newText) {
        return getTextForError(newText, this.opts.insertPos, this.opts.newText.length);
    }
}

class RemoveChildrenTextManipulator {
    constructor(opts) {
        this.opts = opts;
    }
    getNewText(inputText) {
        const opts = this.opts;
        const { children, removePrecedingSpaces = false, removeFollowingSpaces = false, removePrecedingNewLines = false, removeFollowingNewLines = false, replaceTrivia = "", } = opts;
        const sourceFile = children[0].getSourceFile();
        const fullText = sourceFile.getFullText();
        const removalPos = getRemovalPos();
        this.removalPos = removalPos;
        return getPrefix() + replaceTrivia + getSuffix();
        function getPrefix() {
            return fullText.substring(0, removalPos);
        }
        function getSuffix() {
            return fullText.substring(getRemovalEnd());
        }
        function getRemovalPos() {
            if (opts.customRemovalPos != null)
                return opts.customRemovalPos;
            const pos = children[0].getNonWhitespaceStart();
            if (removePrecedingSpaces || removePrecedingNewLines)
                return getPreviousMatchingPos(fullText, pos, getCharRemovalFunction(removePrecedingSpaces, removePrecedingNewLines));
            return pos;
        }
        function getRemovalEnd() {
            if (opts.customRemovalEnd != null)
                return opts.customRemovalEnd;
            const end = children[children.length - 1].getEnd();
            if (removeFollowingSpaces || removeFollowingNewLines)
                return getNextMatchingPos(fullText, end, getCharRemovalFunction(removeFollowingSpaces, removeFollowingNewLines));
            return end;
        }
        function getCharRemovalFunction(removeSpaces, removeNewLines) {
            return (char) => {
                if (removeNewLines && (char === CharCodes$1.CARRIAGE_RETURN || char === CharCodes$1.NEWLINE))
                    return false;
                if (removeSpaces && !charNotSpaceOrTab(char))
                    return false;
                return true;
            };
        }
        function charNotSpaceOrTab(charCode) {
            return charCode !== CharCodes$1.SPACE && charCode !== CharCodes$1.TAB;
        }
    }
    getTextForError(newText) {
        return getTextForError(newText, this.removalPos);
    }
}

function isNewLineAtPos(fullText, pos) {
    return fullText[pos] === "\n" || (fullText[pos] === "\r" && fullText[pos + 1] === "\n");
}
function hasNewLineInRange(fullText, range) {
    for (let i = range[0]; i < range[1]; i++) {
        if (fullText[i] === "\n")
            return true;
    }
    return false;
}

class RemoveChildrenWithFormattingTextManipulator {
    constructor(opts) {
        this.opts = opts;
    }
    getNewText(inputText) {
        const { children, getSiblingFormatting } = this.opts;
        const firstChild = children[0];
        const lastChild = children[children.length - 1];
        const parent = firstChild.getParentOrThrow();
        const sourceFile = parent.getSourceFile();
        const fullText = sourceFile.getFullText();
        const newLineKind = sourceFile._context.manipulationSettings.getNewLineKindAsString();
        const previousSibling = firstChild.getPreviousSibling();
        const nextSibling = lastChild.getNextSibling();
        const removalPos = getRemovalPos();
        this.removalPos = removalPos;
        return getPrefix() + getSpacing() + getSuffix();
        function getPrefix() {
            return fullText.substring(0, removalPos);
        }
        function getSpacing() {
            return getSpacingBetweenNodes({
                parent,
                previousSibling,
                nextSibling,
                newLineKind,
                getSiblingFormatting,
            });
        }
        function getSuffix() {
            return fullText.substring(getRemovalEnd());
        }
        function getRemovalPos() {
            if (previousSibling != null) {
                const trailingEnd = previousSibling.getTrailingTriviaEnd();
                return isNewLineAtPos(fullText, trailingEnd) ? trailingEnd : previousSibling.getEnd();
            }
            const firstPos = getPreviousNonWhitespacePos(fullText, firstChild.getPos());
            if (parent.getPos() === firstPos)
                return firstChild.getNonWhitespaceStart();
            return firstChild.isFirstNodeOnLine() ? firstPos : firstChild.getNonWhitespaceStart();
        }
        function getRemovalEnd() {
            const triviaEnd = lastChild.getTrailingTriviaEnd();
            if (previousSibling != null && nextSibling != null) {
                const nextSiblingFormatting = getSiblingFormatting(parent, nextSibling);
                if (nextSiblingFormatting === FormattingKind.Blankline || nextSiblingFormatting === FormattingKind.Newline)
                    return getPosAtStartOfLineOrNonWhitespace(fullText, nextSibling.getNonWhitespaceStart());
                return nextSibling.getNonWhitespaceStart();
            }
            if (parent.getEnd() === lastChild.getEnd())
                return lastChild.getEnd();
            if (isNewLineAtPos(fullText, triviaEnd)) {
                if (previousSibling == null && firstChild.getPos() === 0)
                    return getPosAtNextNonBlankLine(fullText, triviaEnd);
                return getPosAtEndOfPreviousLine(fullText, getPosAtNextNonBlankLine(fullText, triviaEnd));
            }
            if (previousSibling == null)
                return triviaEnd;
            else
                return lastChild.getEnd();
        }
    }
    getTextForError(newText) {
        return getTextForError(newText, this.removalPos);
    }
}

class RenameLocationTextManipulator {
    constructor(renameLocations, newName) {
        this.renameLocations = renameLocations;
        this.newName = newName;
    }
    getNewText(inputText) {
        const renameLocations = [...this.renameLocations].sort((a, b) => b.getTextSpan().getStart() - a.getTextSpan().getStart());
        let currentPos = inputText.length;
        let result = "";
        for (let i = 0; i < renameLocations.length; i++) {
            const renameLocation = renameLocations[i];
            const textSpan = renameLocation.getTextSpan();
            result = (renameLocation.getPrefixText() || "")
                + this.newName
                + (renameLocation.getSuffixText() || "")
                + inputText.substring(textSpan.getEnd(), currentPos)
                + result;
            currentPos = textSpan.getStart();
        }
        return inputText.substring(0, currentPos) + result;
    }
    getTextForError(newText) {
        if (this.renameLocations.length === 0)
            return newText;
        return "..." + newText.substring(this.renameLocations[0].getTextSpan().getStart());
    }
}

class UnchangedTextManipulator {
    getNewText(inputText) {
        return inputText;
    }
    getTextForError(newText) {
        return newText;
    }
}

class UnwrapTextManipulator extends InsertionTextManipulator {
    constructor(node) {
        super({
            insertPos: node.getStart(true),
            newText: getReplacementText(node),
            replacingLength: node.getWidth(true),
        });
    }
}
function getReplacementText(node) {
    const sourceFile = node._sourceFile;
    const range = getInnerBraceRange();
    const startPos = range[0];
    const text = sourceFile.getFullText().substring(range[0], range[1]);
    return StringUtils.indent(text, -1, {
        indentText: sourceFile._context.manipulationSettings.getIndentationText(),
        indentSizeInSpaces: sourceFile._context.manipulationSettings._getIndentSizeInSpaces(),
        isInStringAtPos: pos => sourceFile.isInStringAtPos(startPos + pos),
    }).trim();
    function getInnerBraceRange() {
        const bodyNode = getBodyNode();
        return [bodyNode.getStart() + 1, bodyNode.getEnd() - 1];
        function getBodyNode() {
            if (Node.isNamespaceDeclaration(node))
                return node._getInnerBody();
            else if (Node.isBodiedNode(node))
                return node.getBody();
            else if (Node.isBodyableNode(node))
                return node.getBodyOrThrow();
            else
                throw new errors.NotImplementedError(`Not implemented unwrap scenario for ${node.getKindName()}.`);
        }
    }
}

class ManipulationError extends errors.InvalidOperationError {
    constructor(filePath, oldText, newText, errorMessage) {
        super(errorMessage);
        this.filePath = filePath;
        this.oldText = oldText;
        this.newText = newText;
    }
}

function doManipulation(sourceFile, textManipulator, nodeHandler, newFilePath) {
    sourceFile._firePreModified();
    const oldFileText = sourceFile.getFullText();
    const newFileText = textManipulator.getNewText(oldFileText);
    try {
        const replacementSourceFile = sourceFile._context.compilerFactory.createCompilerSourceFileFromText(newFilePath || sourceFile.getFilePath(), newFileText, sourceFile.getScriptKind());
        nodeHandler.handleNode(sourceFile, replacementSourceFile, replacementSourceFile);
    }
    catch (err) {
        const diagnostics = getSyntacticDiagnostics(sourceFile, newFileText);
        const errorDetails = err.message + "\n\n"
            + `-- Details --\n`
            + "Path: " + sourceFile.getFilePath() + "\n"
            + "Text: " + JSON.stringify(textManipulator.getTextForError(newFileText)) + "\n"
            + "Stack: " + err.stack;
        if (diagnostics.length > 0) {
            throwError("Manipulation error: " + "A syntax error was inserted." + "\n\n"
                + sourceFile._context.project.formatDiagnosticsWithColorAndContext(diagnostics, { newLineChar: "\n" })
                + "\n" + errorDetails);
        }
        throwError("Manipulation error: " + errorDetails);
        function throwError(message) {
            throw new ManipulationError(sourceFile.getFilePath(), oldFileText, newFileText, message);
        }
    }
}
function getSyntacticDiagnostics(sourceFile, newText) {
    try {
        const projectOptions = { useInMemoryFileSystem: true };
        const project = new sourceFile._context.project.constructor(projectOptions);
        const newFile = project.createSourceFile(sourceFile.getFilePath(), newText);
        return project.getProgram().getSyntacticDiagnostics(newFile);
    }
    catch (err) {
        return [];
    }
}

function insertIntoParentTextRange(opts) {
    var _a, _b, _c;
    const { insertPos, newText, parent } = opts;
    doManipulation(parent._sourceFile, new InsertionTextManipulator({
        insertPos,
        newText,
        replacingLength: (_a = opts.replacing) === null || _a === void 0 ? void 0 : _a.textLength,
    }), new NodeHandlerFactory().getForParentRange({
        parent,
        start: insertPos,
        end: insertPos + newText.length,
        replacingLength: (_b = opts.replacing) === null || _b === void 0 ? void 0 : _b.textLength,
        replacingNodes: (_c = opts.replacing) === null || _c === void 0 ? void 0 : _c.nodes,
        customMappings: opts.customMappings,
    }));
}
function insertIntoTextRange(opts) {
    const { insertPos, newText, sourceFile } = opts;
    doManipulation(sourceFile, new InsertionTextManipulator({
        insertPos,
        newText,
    }), new NodeHandlerFactory().getForRange({
        sourceFile,
        start: insertPos,
        end: insertPos + newText.length,
    }));
}
function insertIntoCommaSeparatedNodes(opts) {
    const { currentNodes, insertIndex, parent } = opts;
    const previousNode = currentNodes[insertIndex - 1];
    const previousNonCommentNode = getPreviousNonCommentNode();
    const nextNode = currentNodes[insertIndex];
    const nextNonCommentNode = getNextNonCommentNode();
    const separator = opts.useNewLines ? parent._context.manipulationSettings.getNewLineKindAsString() : " ";
    const parentNextSibling = parent.getNextSibling();
    const isContained = parentNextSibling != null && (parentNextSibling.getKind() === ts$1.SyntaxKind.CloseBraceToken || parentNextSibling.getKind() === ts$1.SyntaxKind.CloseBracketToken);
    let { newText } = opts;
    if (previousNode != null) {
        prependCommaAndSeparator();
        if (nextNonCommentNode != null || opts.useTrailingCommas)
            appendCommaAndSeparator();
        else if (opts.useNewLines || opts.surroundWithSpaces)
            appendSeparator();
        else
            appendIndentation();
        const nextEndStart = nextNode == null ? (isContained ? parentNextSibling.getStart(true) : parent.getEnd()) : nextNode.getStart(true);
        const insertPos = (previousNonCommentNode || previousNode).getEnd();
        insertIntoParentTextRange({
            insertPos,
            newText,
            parent,
            replacing: { textLength: nextEndStart - insertPos },
        });
    }
    else if (nextNode != null) {
        if (opts.useNewLines || opts.surroundWithSpaces)
            prependSeparator();
        if (nextNonCommentNode != null || opts.useTrailingCommas)
            appendCommaAndSeparator();
        else
            appendSeparator();
        const insertPos = isContained ? parent.getPos() : parent.getStart(true);
        insertIntoParentTextRange({
            insertPos,
            newText,
            parent,
            replacing: { textLength: nextNode.getStart(true) - insertPos },
        });
    }
    else {
        if (opts.useNewLines || opts.surroundWithSpaces) {
            prependSeparator();
            if (opts.useTrailingCommas)
                appendCommaAndSeparator();
            else
                appendSeparator();
        }
        else {
            appendIndentation();
        }
        insertIntoParentTextRange({
            insertPos: parent.getPos(),
            newText,
            parent,
            replacing: { textLength: parent.getNextSiblingOrThrow().getStart() - parent.getPos() },
        });
    }
    function prependCommaAndSeparator() {
        if (previousNonCommentNode == null) {
            prependSeparator();
            return;
        }
        const originalSourceFileText = parent.getSourceFile().getFullText();
        const previousNodeNextSibling = previousNonCommentNode.getNextSibling();
        let text = "";
        if (previousNodeNextSibling != null && previousNodeNextSibling.getKind() === ts$1.SyntaxKind.CommaToken) {
            appendNodeTrailingCommentRanges(previousNonCommentNode);
            text += ",";
            if (previousNonCommentNode === previousNode)
                appendNodeTrailingCommentRanges(previousNodeNextSibling);
            else
                appendCommentNodeTexts();
        }
        else {
            text += ",";
            if (previousNonCommentNode === previousNode)
                appendNodeTrailingCommentRanges(previousNonCommentNode);
            else
                appendCommentNodeTexts();
        }
        prependSeparator();
        newText = text + newText;
        function appendCommentNodeTexts() {
            const lastCommentRangeEnd = getLastCommentRangeEnd(previousNode) || previousNode.getEnd();
            text += originalSourceFileText.substring(previousNonCommentNode.getEnd(), lastCommentRangeEnd);
        }
        function appendNodeTrailingCommentRanges(node) {
            const lastCommentRangeEnd = getLastCommentRangeEnd(node);
            if (lastCommentRangeEnd == null)
                return;
            text += originalSourceFileText.substring(node.getEnd(), lastCommentRangeEnd);
        }
        function getLastCommentRangeEnd(node) {
            const commentRanges = node.getTrailingCommentRanges();
            const lastCommentRange = commentRanges[commentRanges.length - 1];
            return lastCommentRange === null || lastCommentRange === void 0 ? void 0 : lastCommentRange.getEnd();
        }
    }
    function getPreviousNonCommentNode() {
        for (let i = insertIndex - 1; i >= 0; i--) {
            if (!Node.isCommentNode(currentNodes[i]))
                return currentNodes[i];
        }
        return undefined;
    }
    function getNextNonCommentNode() {
        for (let i = insertIndex; i < currentNodes.length; i++) {
            if (!Node.isCommentNode(currentNodes[i]))
                return currentNodes[i];
        }
        return undefined;
    }
    function prependSeparator() {
        if (!StringUtils.startsWithNewLine(newText))
            newText = separator + newText;
    }
    function appendCommaAndSeparator() {
        newText = appendCommaToText(newText);
        appendSeparator();
    }
    function appendSeparator() {
        if (!StringUtils.endsWithNewLine(newText))
            newText += separator;
        appendIndentation();
    }
    function appendIndentation() {
        if (opts.useNewLines || StringUtils.endsWithNewLine(newText)) {
            if (nextNode != null)
                newText += parent.getParentOrThrow().getChildIndentationText();
            else
                newText += parent.getParentOrThrow().getIndentationText();
        }
    }
}
function insertIntoBracesOrSourceFile(opts) {
    const { parent, index, children } = opts;
    const fullText = parent._sourceFile.getFullText();
    const childSyntaxList = parent.getChildSyntaxListOrThrow();
    const insertPos = getInsertPosFromIndex(index, childSyntaxList, children);
    const endPos = getEndPosFromIndex(index, parent, children, fullText);
    const replacingLength = endPos - insertPos;
    const newText = getNewText();
    doManipulation(parent._sourceFile, new InsertionTextManipulator({ insertPos, replacingLength, newText }), new NodeHandlerFactory().getForParentRange({
        parent: childSyntaxList,
        start: insertPos,
        end: insertPos + newText.length,
        replacingLength,
    }));
    function getNewText() {
        const writer = parent._getWriterWithChildIndentation();
        opts.write(writer, {
            previousMember: getChild(children[index - 1]),
            nextMember: getChild(children[index]),
            isStartOfFile: insertPos === 0,
        });
        return writer.toString();
        function getChild(child) {
            if (child == null)
                return child;
            else if (Node.isOverloadableNode(child))
                return child.getImplementation() || child;
            else
                return child;
        }
    }
}
function insertIntoBracesOrSourceFileWithGetChildren(opts) {
    if (opts.structures.length === 0)
        return [];
    const startChildren = opts.getIndexedChildren();
    const parentSyntaxList = opts.parent.getChildSyntaxListOrThrow();
    const index = verifyAndGetIndex(opts.index, startChildren.length);
    const previousJsDocCount = getPreviousJsDocCount();
    insertIntoBracesOrSourceFile({
        parent: opts.parent,
        index: getChildIndex(),
        children: parentSyntaxList.getChildren(),
        write: opts.write,
    });
    return getRangeWithoutCommentsFromArray(opts.getIndexedChildren(), opts.index - previousJsDocCount, opts.structures.length, opts.expectedKind);
    function getChildIndex() {
        if (index === 0)
            return 0;
        return startChildren[index - 1].getChildIndex() + 1;
    }
    function getPreviousJsDocCount() {
        let commentCount = 0;
        let count = 0;
        for (let i = index - 1; i >= 0; i--) {
            const node = startChildren[i];
            if (Node.isCommentNode(node)) {
                commentCount++;
                if (node.getText().startsWith("/**"))
                    count = commentCount;
            }
            else {
                break;
            }
        }
        return count;
    }
}
function insertIntoBracesOrSourceFileWithGetChildrenWithComments(opts) {
    const startChildren = opts.getIndexedChildren();
    const parentSyntaxList = opts.parent.getChildSyntaxListOrThrow();
    const index = verifyAndGetIndex(opts.index, startChildren.length);
    insertIntoBracesOrSourceFile({
        parent: opts.parent,
        index: getChildIndex(),
        children: parentSyntaxList.getChildren(),
        write: opts.write,
    });
    return getNodesToReturn(startChildren, opts.getIndexedChildren(), index, true);
    function getChildIndex() {
        if (index === 0)
            return 0;
        return startChildren[index - 1].getChildIndex() + 1;
    }
}

function changeChildOrder(opts) {
    const { parent } = opts;
    doManipulation(parent._sourceFile, new ChangingChildOrderTextManipulator(opts), new NodeHandlerFactory().getForChangingChildOrder(opts));
}

function removeChildren(opts) {
    const { children } = opts;
    if (children.length === 0)
        return;
    doManipulation(children[0].getSourceFile(), new RemoveChildrenTextManipulator(opts), new NodeHandlerFactory().getForChildIndex({
        parent: children[0].getParentSyntaxList() || children[0].getParentOrThrow(),
        childIndex: children[0].getChildIndex(),
        childCount: -1 * children.length,
    }));
}
function removeChildrenWithFormattingFromCollapsibleSyntaxList(opts) {
    const { children } = opts;
    if (children.length === 0)
        return;
    const syntaxList = children[0].getParentSyntaxListOrThrow();
    if (syntaxList.getChildCount() === children.length) {
        removeChildrenWithFormatting({
            children: [syntaxList],
            getSiblingFormatting: () => FormattingKind.None,
        });
    }
    else {
        removeChildrenWithFormatting(opts);
    }
}
function removeChildrenWithFormatting(opts) {
    const { children, getSiblingFormatting } = opts;
    if (children.length === 0)
        return;
    doManipulation(children[0]._sourceFile, new RemoveChildrenWithFormattingTextManipulator({
        children,
        getSiblingFormatting,
    }), new NodeHandlerFactory().getForChildIndex({
        parent: children[0].getParentSyntaxList() || children[0].getParentOrThrow(),
        childIndex: children[0].getChildIndex(),
        childCount: -1 * children.length,
    }));
}
function removeClassMember(classMember) {
    if (Node.isOverloadableNode(classMember)) {
        if (classMember.isImplementation())
            removeClassMembers([...classMember.getOverloads(), classMember]);
        else {
            const parent = classMember.getParentOrThrow();
            if (Node.isAmbientableNode(parent) && parent.isAmbient())
                removeClassMembers([classMember]);
            else
                removeChildren({ children: [classMember], removeFollowingSpaces: true, removeFollowingNewLines: true });
        }
    }
    else {
        removeClassMembers([classMember]);
    }
}
function removeClassMembers(classMembers) {
    removeChildrenWithFormatting({
        getSiblingFormatting: getClassMemberFormatting,
        children: classMembers,
    });
}
function removeInterfaceMember(interfaceMember) {
    removeInterfaceMembers([interfaceMember]);
}
function removeInterfaceMembers(interfaceMembers) {
    removeChildrenWithFormatting({
        getSiblingFormatting: getInterfaceMemberFormatting,
        children: interfaceMembers,
    });
}
function removeCommaSeparatedChild(child) {
    const childrenToRemove = [child];
    const syntaxList = child.getParentSyntaxListOrThrow();
    const isRemovingFirstChild = childrenToRemove[0] === syntaxList.getFirstChild();
    addNextCommaIfAble();
    addPreviousCommaIfAble();
    removeChildren({
        children: childrenToRemove,
        removePrecedingSpaces: !isRemovingFirstChild || syntaxList.getChildren().length === childrenToRemove.length && childrenToRemove[0].isFirstNodeOnLine(),
        removeFollowingSpaces: isRemovingFirstChild,
        removePrecedingNewLines: !isRemovingFirstChild,
        removeFollowingNewLines: isRemovingFirstChild,
    });
    function addNextCommaIfAble() {
        const commaToken = child.getNextSiblingIfKind(ts$1.SyntaxKind.CommaToken);
        if (commaToken != null)
            childrenToRemove.push(commaToken);
    }
    function addPreviousCommaIfAble() {
        if (syntaxList.getLastChild() !== childrenToRemove[childrenToRemove.length - 1])
            return;
        const precedingComma = child.getPreviousSiblingIfKind(ts$1.SyntaxKind.CommaToken);
        if (precedingComma != null)
            childrenToRemove.unshift(precedingComma);
    }
}
function removeOverloadableStatementedNodeChild(node) {
    if (node.isOverload())
        removeChildren({ children: [node], removeFollowingSpaces: true, removeFollowingNewLines: true });
    else
        removeStatementedNodeChildren([...node.getOverloads(), node]);
}
function removeStatementedNodeChild(node) {
    removeStatementedNodeChildren([node]);
}
function removeStatementedNodeChildren(nodes) {
    removeChildrenWithFormatting({
        getSiblingFormatting: getStatementedNodeChildFormatting,
        children: nodes,
    });
}
function removeClausedNodeChild(node) {
    removeClausedNodeChildren([node]);
}
function removeClausedNodeChildren(nodes) {
    removeChildrenWithFormatting({
        getSiblingFormatting: getClausedNodeChildFormatting,
        children: nodes,
    });
}
function unwrapNode(node) {
    doManipulation(node._sourceFile, new UnwrapTextManipulator(node), new NodeHandlerFactory().getForUnwrappingNode(node));
}

function replaceNodeText(opts) {
    doManipulation(opts.sourceFile, new InsertionTextManipulator({
        insertPos: opts.start,
        newText: opts.newText,
        replacingLength: opts.replacingLength,
    }), new NodeHandlerFactory().getForForgetChanged(opts.sourceFile._context.compilerFactory));
}
function replaceSourceFileTextForFormatting(opts) {
    replaceSourceFileTextStraight(opts);
}
function replaceSourceFileTextStraight(opts) {
    const { sourceFile, newText } = opts;
    doManipulation(sourceFile, new FullReplacementTextManipulator(newText), new NodeHandlerFactory().getForStraightReplacement(sourceFile._context.compilerFactory));
}
function replaceSourceFileTextForRename(opts) {
    const { sourceFile, renameLocations, newName } = opts;
    const nodeHandlerFactory = new NodeHandlerFactory();
    doManipulation(sourceFile, new RenameLocationTextManipulator(renameLocations, newName), nodeHandlerFactory.getForTryOrForget(nodeHandlerFactory.getForRename(sourceFile._context.compilerFactory)));
}
function replaceTextPossiblyCreatingChildNodes(opts) {
    const { replacePos, replacingLength, newText, parent } = opts;
    doManipulation(parent._sourceFile, new InsertionTextManipulator({
        insertPos: replacePos,
        replacingLength,
        newText,
    }), new NodeHandlerFactory().getForParentRange({
        parent,
        start: replacePos,
        end: replacePos + newText.length,
    }));
}
function replaceSourceFileForFilePathMove(opts) {
    const { sourceFile, newFilePath } = opts;
    doManipulation(sourceFile, new UnchangedTextManipulator(), new NodeHandlerFactory().getForStraightReplacement(sourceFile._context.compilerFactory), newFilePath);
}
function replaceSourceFileForCacheUpdate(sourceFile) {
    replaceSourceFileForFilePathMove({ sourceFile, newFilePath: sourceFile.getFilePath() });
}

function ArgumentedNode(Base) {
    return class extends Base {
        getArguments() {
            return this.compilerNode.arguments.map(a => this._getNodeFromCompilerNode(a));
        }
        addArgument(argumentText) {
            return this.addArguments([argumentText])[0];
        }
        addArguments(argumentTexts) {
            return this.insertArguments(this.getArguments().length, argumentTexts);
        }
        insertArgument(index, argumentText) {
            return this.insertArguments(index, [argumentText])[0];
        }
        insertArguments(index, argumentTexts) {
            if (argumentTexts instanceof Function)
                argumentTexts = [argumentTexts];
            if (ArrayUtils.isNullOrEmpty(argumentTexts))
                return [];
            const originalArgs = this.getArguments();
            index = verifyAndGetIndex(index, originalArgs.length);
            const writer = this._getWriterWithQueuedChildIndentation();
            for (let i = 0; i < argumentTexts.length; i++) {
                writer.conditionalWrite(i > 0, ", ");
                printTextFromStringOrWriter(writer, argumentTexts[i]);
            }
            insertIntoCommaSeparatedNodes({
                parent: this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenParenToken).getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.SyntaxList),
                currentNodes: originalArgs,
                insertIndex: index,
                newText: writer.toString(),
                useTrailingCommas: false,
            });
            return getNodesToReturn(originalArgs, this.getArguments(), index, false);
        }
        removeArgument(argOrIndex) {
            const args = this.getArguments();
            if (args.length === 0)
                throw new errors.InvalidOperationError("Cannot remove an argument when none exist.");
            const argToRemove = typeof argOrIndex === "number" ? getArgFromIndex(argOrIndex) : argOrIndex;
            removeCommaSeparatedChild(argToRemove);
            return this;
            function getArgFromIndex(index) {
                return args[verifyAndGetIndex(index, args.length - 1)];
            }
        }
    };
}

function AsyncableNode(Base) {
    return class extends Base {
        isAsync() {
            return this.hasModifier(ts$1.SyntaxKind.AsyncKeyword);
        }
        getAsyncKeyword() {
            return this.getFirstModifierByKind(ts$1.SyntaxKind.AsyncKeyword);
        }
        getAsyncKeywordOrThrow() {
            return errors.throwIfNullOrUndefined(this.getAsyncKeyword(), "Expected to find an async keyword.");
        }
        setIsAsync(value) {
            this.toggleModifier("async", value);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.isAsync != null)
                this.setIsAsync(structure.isAsync);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                isAsync: this.isAsync(),
            });
        }
    };
}

function AwaitableNode(Base) {
    return class extends Base {
        isAwaited() {
            return this.compilerNode.awaitModifier != null;
        }
        getAwaitKeyword() {
            const awaitModifier = this.compilerNode.awaitModifier;
            return this._getNodeFromCompilerNodeIfExists(awaitModifier);
        }
        getAwaitKeywordOrThrow() {
            return errors.throwIfNullOrUndefined(this.getAwaitKeyword(), "Expected to find an await token.");
        }
        setIsAwaited(value) {
            const awaitModifier = this.getAwaitKeyword();
            const isSet = awaitModifier != null;
            if (isSet === value)
                return this;
            if (awaitModifier == null) {
                insertIntoParentTextRange({
                    insertPos: getAwaitInsertPos(this),
                    parent: this,
                    newText: " await",
                });
            }
            else {
                removeChildren({
                    children: [awaitModifier],
                    removePrecedingSpaces: true,
                });
            }
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.isAwaited != null)
                this.setIsAwaited(structure.isAwaited);
            return this;
        }
    };
}
function getAwaitInsertPos(node) {
    if (node.getKind() === ts$1.SyntaxKind.ForOfStatement)
        return node.getFirstChildByKindOrThrow(ts$1.SyntaxKind.ForKeyword).getEnd();
    throw new errors.NotImplementedError("Expected a for of statement node.");
}

function getBodyText(writer, textOrWriterFunction) {
    writer.newLineIfLastNot();
    if (typeof textOrWriterFunction !== "string" || textOrWriterFunction.length > 0) {
        writer.indent(() => {
            printTextFromStringOrWriter(writer, textOrWriterFunction);
        });
    }
    writer.newLineIfLastNot();
    writer.write("");
    return writer.toString();
}

function getBodyTextWithoutLeadingIndentation(body) {
    const sourceFile = body._sourceFile;
    const textArea = body.getChildSyntaxList() || body;
    const startPos = textArea.getNonWhitespaceStart();
    const endPos = Math.max(startPos, textArea._getTrailingTriviaNonWhitespaceEnd());
    const width = endPos - startPos;
    if (width === 0)
        return "";
    const fullText = sourceFile.getFullText().substring(startPos, endPos);
    return StringUtils.removeIndentation(fullText, {
        indentSizeInSpaces: body._context.manipulationSettings._getIndentSizeInSpaces(),
        isInStringAtPos: pos => sourceFile.isInStringAtPos(pos + startPos),
    });
}

class TextRange {
    constructor(compilerObject, sourceFile) {
        this._compilerObject = compilerObject;
        this._sourceFile = sourceFile;
    }
    get compilerObject() {
        this._throwIfForgotten();
        return this._compilerObject;
    }
    getSourceFile() {
        this._throwIfForgotten();
        return this._sourceFile;
    }
    getPos() {
        return this.compilerObject.pos;
    }
    getEnd() {
        return this.compilerObject.end;
    }
    getWidth() {
        return this.getEnd() - this.getPos();
    }
    getText() {
        const fullText = this.getSourceFile().getFullText();
        return fullText.substring(this.compilerObject.pos, this.compilerObject.end);
    }
    _forget() {
        this._compilerObject = undefined;
        this._sourceFile = undefined;
    }
    wasForgotten() {
        return this._compilerObject == null;
    }
    _throwIfForgotten() {
        if (this._compilerObject != null)
            return;
        const message = "Attempted to get a text range that was forgotten. "
            + "Text ranges are forgotten after a manipulation has occurred. "
            + "Please re-request the text range after manipulations.";
        throw new errors.InvalidOperationError(message);
    }
}

class CommentRange extends TextRange {
    constructor(compilerObject, sourceFile) {
        super(compilerObject, sourceFile);
    }
    getKind() {
        return this.compilerObject.kind;
    }
}

class Node {
    constructor(context, node, sourceFile) {
        this._wrappedChildCount = 0;
        if (context == null || context.compilerFactory == null) {
            throw new errors.InvalidOperationError("Constructing a node is not supported. Please create a source file from the default export "
                + "of the package and manipulate the source file from there.");
        }
        this._context = context;
        this._compilerNode = node;
        this.__sourceFile = sourceFile;
    }
    get _sourceFile() {
        if (this.__sourceFile == null)
            throw new errors.InvalidOperationError("Operation cannot be performed on a node that has no source file.");
        return this.__sourceFile;
    }
    get compilerNode() {
        if (this._compilerNode == null) {
            let message = "Attempted to get information from a node that was removed or forgotten.";
            if (this._forgottenText != null)
                message += `\n\nNode text: ${this._forgottenText}`;
            throw new errors.InvalidOperationError(message);
        }
        return this._compilerNode;
    }
    forget() {
        if (this.wasForgotten())
            return;
        this.forgetDescendants();
        this._forgetOnlyThis();
    }
    forgetDescendants() {
        for (const child of this._getChildrenInCacheIterator())
            child.forget();
        return this;
    }
    _forgetOnlyThis() {
        if (this.wasForgotten())
            return;
        const parent = this.getParent();
        if (parent != null)
            parent._wrappedChildCount--;
        const parentSyntaxList = this._getParentSyntaxListIfWrapped();
        if (parentSyntaxList != null)
            parentSyntaxList._wrappedChildCount--;
        this._storeTextForForgetting();
        this._context.compilerFactory.removeNodeFromCache(this);
        this._clearInternals();
    }
    wasForgotten() {
        return this._compilerNode == null;
    }
    _hasWrappedChildren() {
        return this._wrappedChildCount > 0;
    }
    _replaceCompilerNodeFromFactory(compilerNode) {
        if (compilerNode == null)
            this._storeTextForForgetting();
        this._clearInternals();
        this._compilerNode = compilerNode;
    }
    _storeTextForForgetting() {
        const sourceFileCompilerNode = this._sourceFile && this._sourceFile.compilerNode;
        const compilerNode = this._compilerNode;
        if (sourceFileCompilerNode == null || compilerNode == null)
            return;
        this._forgottenText = getText();
        function getText() {
            const start = compilerNode.getStart(sourceFileCompilerNode);
            const length = compilerNode.end - start;
            const trimmedLength = Math.min(length, 100);
            const text = sourceFileCompilerNode.text.substr(start, trimmedLength);
            return trimmedLength !== length ? text + "..." : text;
        }
    }
    _clearInternals() {
        this._compilerNode = undefined;
        this._childStringRanges = undefined;
        clearTextRanges(this._leadingCommentRanges);
        clearTextRanges(this._trailingCommentRanges);
        delete this._leadingCommentRanges;
        delete this._trailingCommentRanges;
        function clearTextRanges(textRanges) {
            if (textRanges == null)
                return;
            textRanges.forEach(r => r._forget());
        }
    }
    getKind() {
        return this.compilerNode.kind;
    }
    getKindName() {
        return common.getSyntaxKindName(this.compilerNode.kind);
    }
    print(options = {}) {
        if (options.newLineKind == null)
            options.newLineKind = this._context.manipulationSettings.getNewLineKind();
        if (this.getKind() === ts$1.SyntaxKind.SourceFile)
            return printNode(this.compilerNode, options);
        else
            return printNode(this.compilerNode, this._sourceFile.compilerNode, options);
    }
    getSymbolOrThrow() {
        return errors.throwIfNullOrUndefined(this.getSymbol(), "Could not find the node's symbol.");
    }
    getSymbol() {
        const boundSymbol = this.compilerNode.symbol;
        if (boundSymbol != null)
            return this._context.compilerFactory.getSymbol(boundSymbol);
        const typeChecker = this._context.typeChecker;
        const typeCheckerSymbol = typeChecker.getSymbolAtLocation(this);
        if (typeCheckerSymbol != null)
            return typeCheckerSymbol;
        const nameNode = this.compilerNode.name;
        if (nameNode != null)
            return this._getNodeFromCompilerNode(nameNode).getSymbol();
        return undefined;
    }
    getSymbolsInScope(meaning) {
        return this._context.typeChecker.getSymbolsInScope(this, meaning);
    }
    getLocalOrThrow(name) {
        return errors.throwIfNullOrUndefined(this.getLocal(name), `Expected to find local symbol with name: ${name}`);
    }
    getLocal(name) {
        const locals = this._getCompilerLocals();
        if (locals == null)
            return undefined;
        const tsSymbol = locals.get(ts$1.escapeLeadingUnderscores(name));
        return tsSymbol == null ? undefined : this._context.compilerFactory.getSymbol(tsSymbol);
    }
    getLocals() {
        const locals = this._getCompilerLocals();
        if (locals == null)
            return [];
        return ArrayUtils.from(locals.values()).map(symbol => this._context.compilerFactory.getSymbol(symbol));
    }
    _getCompilerLocals() {
        this._ensureBound();
        return this.compilerNode.locals;
    }
    getType() {
        return this._context.typeChecker.getTypeAtLocation(this);
    }
    containsRange(pos, end) {
        return this.getPos() <= pos && end <= this.getEnd();
    }
    isInStringAtPos(pos) {
        errors.throwIfOutOfRange(pos, [this.getPos(), this.getEnd()], "pos");
        if (this._childStringRanges == null) {
            this._childStringRanges = [];
            for (const descendant of this._getCompilerDescendantsIterator()) {
                if (isStringKind(descendant.kind))
                    this._childStringRanges.push([descendant.getStart(this._sourceFile.compilerNode), descendant.getEnd()]);
            }
        }
        class InStringRangeComparer {
            compareTo(value) {
                if (pos <= value[0])
                    return -1;
                if (pos >= value[1] - 1)
                    return 1;
                return 0;
            }
        }
        return ArrayUtils.binarySearch(this._childStringRanges, new InStringRangeComparer()) !== -1;
    }
    getFirstChildOrThrow(condition) {
        return errors.throwIfNullOrUndefined(this.getFirstChild(condition), "Could not find a child that matched the specified condition.");
    }
    getFirstChild(condition) {
        const firstChild = this._getCompilerFirstChild(getWrappedCondition(this, condition));
        return this._getNodeFromCompilerNodeIfExists(firstChild);
    }
    getLastChildOrThrow(condition) {
        return errors.throwIfNullOrUndefined(this.getLastChild(condition), "Could not find a child that matched the specified condition.");
    }
    getLastChild(condition) {
        const lastChild = this._getCompilerLastChild(getWrappedCondition(this, condition));
        return this._getNodeFromCompilerNodeIfExists(lastChild);
    }
    getFirstDescendantOrThrow(condition) {
        return errors.throwIfNullOrUndefined(this.getFirstDescendant(condition), "Could not find a descendant that matched the specified condition.");
    }
    getFirstDescendant(condition) {
        for (const descendant of this._getDescendantsIterator()) {
            if (condition == null || condition(descendant))
                return descendant;
        }
        return undefined;
    }
    getPreviousSiblingOrThrow(condition) {
        return errors.throwIfNullOrUndefined(this.getPreviousSibling(condition), "Could not find the previous sibling.");
    }
    getPreviousSibling(condition) {
        const previousSibling = this._getCompilerPreviousSibling(getWrappedCondition(this, condition));
        return this._getNodeFromCompilerNodeIfExists(previousSibling);
    }
    getNextSiblingOrThrow(condition) {
        return errors.throwIfNullOrUndefined(this.getNextSibling(condition), "Could not find the next sibling.");
    }
    getNextSibling(condition) {
        const nextSibling = this._getCompilerNextSibling(getWrappedCondition(this, condition));
        return this._getNodeFromCompilerNodeIfExists(nextSibling);
    }
    getPreviousSiblings() {
        return this._getCompilerPreviousSiblings().map(n => this._getNodeFromCompilerNode(n));
    }
    getNextSiblings() {
        return this._getCompilerNextSiblings().map(n => this._getNodeFromCompilerNode(n));
    }
    getChildren() {
        return this._getCompilerChildren().map(n => this._getNodeFromCompilerNode(n));
    }
    getChildAtIndex(index) {
        return this._getNodeFromCompilerNode(this._getCompilerChildAtIndex(index));
    }
    *_getChildrenIterator() {
        for (const compilerChild of this._getCompilerChildren())
            yield this._getNodeFromCompilerNode(compilerChild);
    }
    *_getChildrenInCacheIterator() {
        const children = this._getCompilerChildrenFast();
        for (const child of children) {
            if (this._context.compilerFactory.hasCompilerNode(child))
                yield this._context.compilerFactory.getExistingNodeFromCompilerNode(child);
            else if (child.kind === ts$1.SyntaxKind.SyntaxList) {
                yield this._getNodeFromCompilerNode(child);
            }
        }
    }
    getChildSyntaxListOrThrow() {
        return errors.throwIfNullOrUndefined(this.getChildSyntaxList(), "A child syntax list was expected.");
    }
    getChildSyntaxList() {
        let node = this;
        if (Node.isBodyableNode(node) || Node.isBodiedNode(node)) {
            do {
                const bodyNode = Node.isBodyableNode(node) ? node.getBody() : node.getBody();
                if (bodyNode == null)
                    return undefined;
                node = bodyNode;
            } while ((Node.isBodyableNode(node) || Node.isBodiedNode(node)) && node.compilerNode.statements == null);
        }
        if (Node.isSourceFile(node)
            || Node.isBodyableNode(this)
            || Node.isBodiedNode(this)
            || Node.isCaseBlock(this)
            || Node.isCaseClause(this)
            || Node.isDefaultClause(this)
            || Node.isJsxElement(this)) {
            return node.getFirstChildByKind(ts$1.SyntaxKind.SyntaxList);
        }
        let passedBrace = false;
        for (const child of node._getCompilerChildren()) {
            if (!passedBrace)
                passedBrace = child.kind === ts$1.SyntaxKind.OpenBraceToken;
            else if (child.kind === ts$1.SyntaxKind.SyntaxList)
                return this._getNodeFromCompilerNode(child);
        }
        return undefined;
    }
    forEachChild(cbNode, cbNodeArray) {
        const snapshots = [];
        this.compilerNode.forEachChild(node => {
            snapshots.push(this._getNodeFromCompilerNode(node));
        }, cbNodeArray == null ? undefined : nodes => {
            snapshots.push(nodes.map(n => this._getNodeFromCompilerNode(n)));
        });
        for (const snapshot of snapshots) {
            if (snapshot instanceof Array) {
                const filteredNodes = snapshot.filter(n => !n.wasForgotten());
                if (filteredNodes.length > 0) {
                    const returnValue = cbNodeArray(filteredNodes);
                    if (returnValue)
                        return returnValue;
                }
            }
            else if (!snapshot.wasForgotten()) {
                const returnValue = cbNode(snapshot);
                if (returnValue)
                    return returnValue;
            }
        }
        return undefined;
    }
    forEachDescendant(cbNode, cbNodeArray) {
        const stopReturnValue = {};
        const upReturnValue = {};
        let stop = false;
        let up = false;
        const traversal = {
            stop: () => stop = true,
            up: () => up = true,
        };
        const nodeCallback = (node) => {
            if (stop)
                return stopReturnValue;
            let skip = false;
            const returnValue = cbNode(node, Object.assign(Object.assign({}, traversal), { skip: () => skip = true }));
            if (returnValue)
                return returnValue;
            if (stop)
                return stopReturnValue;
            if (skip || up)
                return undefined;
            if (!node.wasForgotten())
                return forEachChildForNode(node);
            return undefined;
        };
        const arrayCallback = cbNodeArray == null ? undefined : (nodes) => {
            if (stop)
                return stopReturnValue;
            let skip = false;
            const returnValue = cbNodeArray(nodes, Object.assign(Object.assign({}, traversal), { skip: () => skip = true }));
            if (returnValue)
                return returnValue;
            if (skip)
                return undefined;
            for (const node of nodes) {
                if (stop)
                    return stopReturnValue;
                if (up)
                    return undefined;
                const innerReturnValue = forEachChildForNode(node);
                if (innerReturnValue)
                    return innerReturnValue;
            }
            return undefined;
        };
        const finalResult = forEachChildForNode(this);
        return finalResult === stopReturnValue ? undefined : finalResult;
        function forEachChildForNode(node) {
            const result = node.forEachChild(innerNode => {
                const returnValue = nodeCallback(innerNode);
                if (up) {
                    up = false;
                    return returnValue || upReturnValue;
                }
                return returnValue;
            }, arrayCallback == null ? undefined : nodes => {
                const returnValue = arrayCallback(nodes);
                if (up) {
                    up = false;
                    return returnValue || upReturnValue;
                }
                return returnValue;
            });
            return result === upReturnValue ? undefined : result;
        }
    }
    forEachChildAsArray() {
        const children = [];
        this.compilerNode.forEachChild(child => {
            children.push(this._getNodeFromCompilerNode(child));
        });
        return children;
    }
    forEachDescendantAsArray() {
        const descendants = [];
        this.forEachDescendant(descendant => {
            descendants.push(descendant);
        });
        return descendants;
    }
    getDescendants() {
        return Array.from(this._getDescendantsIterator());
    }
    *_getDescendantsIterator() {
        for (const descendant of this._getCompilerDescendantsIterator())
            yield this._getNodeFromCompilerNode(descendant);
    }
    getDescendantStatements() {
        const statements = [];
        handleNode(this, this.compilerNode);
        return statements;
        function handleNode(thisNode, node) {
            if (handleStatements(thisNode, node))
                return;
            else if (node.kind === ts$1.SyntaxKind.ArrowFunction) {
                const arrowFunction = node;
                if (arrowFunction.body.kind !== ts$1.SyntaxKind.Block)
                    statements.push(thisNode._getNodeFromCompilerNode(arrowFunction.body));
                else
                    handleNode(thisNode, arrowFunction.body);
            }
            else {
                handleChildren(thisNode, node);
            }
        }
        function handleStatements(thisNode, node) {
            if (node.statements == null)
                return false;
            const statementedNode = thisNode._getNodeFromCompilerNode(node);
            for (const statement of statementedNode.getStatements()) {
                statements.push(statement);
                handleChildren(thisNode, statement.compilerNode);
            }
            return true;
        }
        function handleChildren(thisNode, node) {
            ts$1.forEachChild(node, childNode => handleNode(thisNode, childNode));
        }
    }
    getChildCount() {
        return this._getCompilerChildren().length;
    }
    getChildAtPos(pos) {
        if (pos < this.getPos() || pos >= this.getEnd())
            return undefined;
        for (const child of this._getCompilerChildren()) {
            if (pos >= child.pos && pos < child.end)
                return this._getNodeFromCompilerNode(child);
        }
        return undefined;
    }
    getDescendantAtPos(pos) {
        let node;
        while (true) {
            const nextNode = (node || this).getChildAtPos(pos);
            if (nextNode == null)
                return node;
            else
                node = nextNode;
        }
    }
    getDescendantAtStartWithWidth(start, width) {
        let foundNode;
        this._context.compilerFactory.forgetNodesCreatedInBlock(remember => {
            let nextNode = this.getSourceFile();
            do {
                nextNode = nextNode.getChildAtPos(start);
                if (nextNode != null) {
                    if (nextNode.getStart() === start && nextNode.getWidth() === width)
                        foundNode = nextNode;
                    else if (foundNode != null)
                        break;
                }
            } while (nextNode != null);
            if (foundNode != null)
                remember(foundNode);
        });
        return foundNode;
    }
    getPos() {
        return this.compilerNode.pos;
    }
    getEnd() {
        return this.compilerNode.end;
    }
    getStart(includeJsDocComments) {
        return this.compilerNode.getStart(this._sourceFile.compilerNode, includeJsDocComments);
    }
    getFullStart() {
        return this.compilerNode.getFullStart();
    }
    getNonWhitespaceStart() {
        return this._context.compilerFactory.forgetNodesCreatedInBlock(() => {
            const parent = this.getParent();
            const pos = this.getPos();
            const parentTakesPrecedence = parent != null
                && !Node.isSourceFile(parent)
                && parent.getPos() === pos;
            if (parentTakesPrecedence)
                return this.getStart(true);
            let startSearchPos;
            const sourceFileFullText = this._sourceFile.getFullText();
            const previousSibling = this.getPreviousSibling();
            if (previousSibling != null && Node.isCommentNode(previousSibling))
                startSearchPos = previousSibling.getEnd();
            else if (previousSibling != null) {
                if (hasNewLineInRange(sourceFileFullText, [pos, this.getStart(true)]))
                    startSearchPos = previousSibling.getTrailingTriviaEnd();
                else
                    startSearchPos = pos;
            }
            else {
                startSearchPos = this.getPos();
            }
            return getNextNonWhitespacePos(sourceFileFullText, startSearchPos);
        });
    }
    _getTrailingTriviaNonWhitespaceEnd() {
        return getPreviousNonWhitespacePos(this._sourceFile.getFullText(), this.getTrailingTriviaEnd());
    }
    getWidth(includeJsDocComments) {
        return this.getEnd() - this.getStart(includeJsDocComments);
    }
    getFullWidth() {
        return this.compilerNode.getFullWidth();
    }
    getLeadingTriviaWidth() {
        return this.compilerNode.getLeadingTriviaWidth(this._sourceFile.compilerNode);
    }
    getTrailingTriviaWidth() {
        return this.getTrailingTriviaEnd() - this.getEnd();
    }
    getTrailingTriviaEnd() {
        const parent = this.getParent();
        const end = this.getEnd();
        if (parent == null)
            return end;
        const parentEnd = parent.getEnd();
        if (parentEnd === end)
            return end;
        const trailingComments = this.getTrailingCommentRanges();
        const searchStart = getSearchStart();
        return getNextMatchingPos(this._sourceFile.getFullText(), searchStart, char => char !== CharCodes$1.SPACE && char !== CharCodes$1.TAB);
        function getSearchStart() {
            return trailingComments.length > 0 ? trailingComments[trailingComments.length - 1].getEnd() : end;
        }
    }
    getText(includeJsDocCommentOrOptions) {
        const options = typeof includeJsDocCommentOrOptions === "object" ? includeJsDocCommentOrOptions : undefined;
        const includeJsDocComments = includeJsDocCommentOrOptions === true || (options != null && options.includeJsDocComments);
        const trimLeadingIndentation = options != null && options.trimLeadingIndentation;
        const startPos = this.getStart(includeJsDocComments);
        const text = this._sourceFile.getFullText().substring(startPos, this.getEnd());
        if (trimLeadingIndentation) {
            return StringUtils.removeIndentation(text, {
                isInStringAtPos: pos => this._sourceFile.isInStringAtPos(pos + startPos),
                indentSizeInSpaces: this._context.manipulationSettings._getIndentSizeInSpaces(),
            });
        }
        else {
            return text;
        }
    }
    getFullText() {
        return this.compilerNode.getFullText(this._sourceFile.compilerNode);
    }
    getCombinedModifierFlags() {
        return ts$1.getCombinedModifierFlags(this.compilerNode);
    }
    getSourceFile() {
        return this._sourceFile;
    }
    getProject() {
        return this._context.project;
    }
    getNodeProperty(propertyName) {
        const property = this.compilerNode[propertyName];
        if (property == null)
            return undefined;
        else if (property instanceof Array)
            return property.map(p => isNode(p) ? this._getNodeFromCompilerNode(p) : p);
        else if (isNode(property))
            return this._getNodeFromCompilerNode(property);
        else
            return property;
        function isNode(value) {
            return typeof value.kind === "number" && typeof value.pos === "number" && typeof value.end === "number";
        }
    }
    getAncestors(includeSyntaxLists = false) {
        return Array.from(this._getAncestorsIterator(includeSyntaxLists));
    }
    *_getAncestorsIterator(includeSyntaxLists) {
        let parent = getParent(this);
        while (parent != null) {
            yield parent;
            parent = getParent(parent);
        }
        function getParent(node) {
            return includeSyntaxLists ? node.getParentSyntaxList() || node.getParent() : node.getParent();
        }
    }
    getParent() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.parent);
    }
    getParentOrThrow() {
        return errors.throwIfNullOrUndefined(this.getParent(), "Expected to find a parent.");
    }
    getParentWhileOrThrow(condition) {
        return errors.throwIfNullOrUndefined(this.getParentWhile(condition), "The initial parent did not match the provided condition.");
    }
    getParentWhile(condition) {
        let node = undefined;
        let parent = this.getParent();
        while (parent && condition(parent, node || this)) {
            node = parent;
            parent = node.getParent();
        }
        return node;
    }
    getParentWhileKindOrThrow(kind) {
        return errors.throwIfNullOrUndefined(this.getParentWhileKind(kind), `The initial parent was not a syntax kind of ${common.getSyntaxKindName(kind)}.`);
    }
    getParentWhileKind(kind) {
        return this.getParentWhile(n => n.getKind() === kind);
    }
    getLastToken() {
        const lastToken = this.compilerNode.getLastToken(this._sourceFile.compilerNode);
        if (lastToken == null)
            throw new errors.NotImplementedError("Not implemented scenario where the last token does not exist.");
        return this._getNodeFromCompilerNode(lastToken);
    }
    isInSyntaxList() {
        return this.getParentSyntaxList() != null;
    }
    getParentSyntaxListOrThrow() {
        return errors.throwIfNullOrUndefined(this.getParentSyntaxList(), "Expected the parent to be a syntax list.");
    }
    getParentSyntaxList() {
        const kind = this.getKind();
        if (kind === ts$1.SyntaxKind.SingleLineCommentTrivia || kind === ts$1.SyntaxKind.MultiLineCommentTrivia)
            return this.getParentOrThrow().getChildSyntaxList();
        const syntaxList = getParentSyntaxList(this.compilerNode, this._sourceFile.compilerNode);
        return this._getNodeFromCompilerNodeIfExists(syntaxList);
    }
    _getParentSyntaxListIfWrapped() {
        const parent = this.getParent();
        if (parent == null || !hasParsedTokens(parent.compilerNode))
            return undefined;
        return this.getParentSyntaxList();
    }
    getChildIndex() {
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        const index = parent._getCompilerChildren().indexOf(this.compilerNode);
        if (index === -1)
            throw new errors.NotImplementedError("For some reason the child's parent did not contain the child.");
        return index;
    }
    getIndentationLevel() {
        const indentationText = this._context.manipulationSettings.getIndentationText();
        return this._context.languageService.getIdentationAtPosition(this._sourceFile, this.getStart()) / indentationText.length;
    }
    getChildIndentationLevel() {
        if (Node.isSourceFile(this))
            return 0;
        return this.getIndentationLevel() + 1;
    }
    getIndentationText(offset = 0) {
        return this._getIndentationTextForLevel(this.getIndentationLevel() + offset);
    }
    getChildIndentationText(offset = 0) {
        return this._getIndentationTextForLevel(this.getChildIndentationLevel() + offset);
    }
    _getIndentationTextForLevel(level) {
        return this._context.manipulationSettings.getIndentationText().repeat(level);
    }
    getStartLinePos(includeJsDocComments) {
        const sourceFileText = this._sourceFile.getFullText();
        return getPreviousMatchingPos(sourceFileText, this.getStart(includeJsDocComments), char => char === CharCodes$1.NEWLINE || char === CharCodes$1.CARRIAGE_RETURN);
    }
    getStartLineNumber(includeJsDocComments) {
        return StringUtils.getLineNumberAtPos(this._sourceFile.getFullText(), this.getStartLinePos(includeJsDocComments));
    }
    getEndLineNumber() {
        const sourceFileText = this._sourceFile.getFullText();
        const endLinePos = getPreviousMatchingPos(sourceFileText, this.getEnd(), char => char === CharCodes$1.NEWLINE || char === CharCodes$1.CARRIAGE_RETURN);
        return StringUtils.getLineNumberAtPos(this._sourceFile.getFullText(), endLinePos);
    }
    isFirstNodeOnLine() {
        const sourceFileText = this._sourceFile.getFullText();
        const startPos = this.getNonWhitespaceStart();
        for (let i = startPos - 1; i >= 0; i--) {
            const currentChar = sourceFileText[i];
            if (currentChar === " " || currentChar === "\t")
                continue;
            if (currentChar === "\n")
                return true;
            return false;
        }
        return true;
    }
    replaceWithText(textOrWriterFunction, writer) {
        const newText = getTextFromStringOrWriter(writer || this._getWriterWithQueuedIndentation(), textOrWriterFunction);
        if (Node.isSourceFile(this)) {
            this.replaceText([this.getPos(), this.getEnd()], newText);
            return this;
        }
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        const childIndex = this.getChildIndex();
        const start = this.getStart(true);
        insertIntoParentTextRange({
            parent,
            insertPos: start,
            newText,
            replacing: {
                textLength: this.getEnd() - start,
            },
        });
        return parent.getChildren()[childIndex];
    }
    prependWhitespace(textOrWriterFunction) {
        insertWhiteSpaceTextAtPos(this, this.getStart(true), textOrWriterFunction, "prependWhitespace");
    }
    appendWhitespace(textOrWriterFunction) {
        insertWhiteSpaceTextAtPos(this, this.getEnd(), textOrWriterFunction, "appendWhitespace");
    }
    formatText(settings = {}) {
        const formattingEdits = this._context.languageService.getFormattingEditsForRange(this._sourceFile.getFilePath(), [this.getStart(true), this.getEnd()], settings);
        replaceSourceFileTextForFormatting({
            sourceFile: this._sourceFile,
            newText: getTextFromTextChanges(this._sourceFile, formattingEdits),
        });
    }
    transform(visitNode) {
        const compilerFactory = this._context.compilerFactory;
        const printer = ts$1.createPrinter({
            newLine: this._context.manipulationSettings.getNewLineKind(),
            removeComments: false,
        });
        const transformations = [];
        const compilerSourceFile = this._sourceFile.compilerNode;
        const compilerNode = this.compilerNode;
        const transformerFactory = context => {
            return rootNode => innerVisit(rootNode, context);
        };
        ts$1.transform(compilerNode, [transformerFactory], this._context.compilerOptions.get());
        replaceSourceFileTextStraight({
            sourceFile: this._sourceFile,
            newText: getTransformedText(),
        });
        return this;
        function innerVisit(node, context) {
            const traversal = {
                visitChildren() {
                    node = ts$1.visitEachChild(node, child => innerVisit(child, context), context);
                    return node;
                },
                currentNode: node,
            };
            const resultNode = visitNode(traversal);
            handleTransformation(node, resultNode);
            return resultNode;
        }
        function handleTransformation(oldNode, newNode) {
            if (oldNode === newNode)
                return;
            const start = oldNode.getStart(compilerSourceFile, true);
            const end = oldNode.end;
            const lastTransformation = transformations[transformations.length - 1];
            if (lastTransformation != null && lastTransformation.start > start)
                transformations.pop();
            const wrappedNode = compilerFactory.getExistingNodeFromCompilerNode(oldNode);
            transformations.push({
                start,
                end,
                compilerNode: newNode,
            });
            if (wrappedNode != null) {
                if (oldNode.kind !== newNode.kind)
                    wrappedNode.forget();
                else
                    wrappedNode.forgetDescendants();
            }
        }
        function getTransformedText() {
            const fileText = compilerSourceFile.getFullText();
            let finalText = "";
            let lastPos = 0;
            for (const transform of transformations) {
                finalText += fileText.substring(lastPos, transform.start);
                finalText += printer.printNode(ts$1.EmitHint.Unspecified, transform.compilerNode, compilerSourceFile);
                lastPos = transform.end;
            }
            finalText += fileText.substring(lastPos);
            return finalText;
        }
    }
    getLeadingCommentRanges() {
        return this._leadingCommentRanges || (this._leadingCommentRanges = this._getCommentsAtPos(this.getFullStart(), (text, pos) => {
            const comments = ts$1.getLeadingCommentRanges(text, pos) || [];
            if (this.getKind() === ts$1.SyntaxKind.SingleLineCommentTrivia || this.getKind() === ts$1.SyntaxKind.MultiLineCommentTrivia) {
                const thisPos = this.getPos();
                return comments.filter(r => r.pos < thisPos);
            }
            else {
                return comments;
            }
        }));
    }
    getTrailingCommentRanges() {
        return this._trailingCommentRanges || (this._trailingCommentRanges = this._getCommentsAtPos(this.getEnd(), ts$1.getTrailingCommentRanges));
    }
    _getCommentsAtPos(pos, getComments) {
        if (this.getKind() === ts$1.SyntaxKind.SourceFile)
            return [];
        return (getComments(this._sourceFile.getFullText(), pos) || []).map(r => new CommentRange(r, this._sourceFile));
    }
    getChildrenOfKind(kind) {
        return this._getCompilerChildrenOfKind(kind).map(c => this._getNodeFromCompilerNode(c));
    }
    getFirstChildByKindOrThrow(kind) {
        return errors.throwIfNullOrUndefined(this.getFirstChildByKind(kind), `A child of the kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getFirstChildByKind(kind) {
        const child = this._getCompilerChildrenOfKind(kind)[0];
        return child == null ? undefined : this._getNodeFromCompilerNode(child);
    }
    getFirstChildIfKindOrThrow(kind) {
        return errors.throwIfNullOrUndefined(this.getFirstChildIfKind(kind), `A first child of the kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getFirstChildIfKind(kind) {
        const firstChild = this._getCompilerFirstChild();
        return firstChild != null && firstChild.kind === kind ? this._getNodeFromCompilerNode(firstChild) : undefined;
    }
    getLastChildByKindOrThrow(kind) {
        return errors.throwIfNullOrUndefined(this.getLastChildByKind(kind), `A child of the kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getLastChildByKind(kind) {
        const children = this._getCompilerChildrenOfKind(kind);
        const lastChild = children[children.length - 1];
        return this._getNodeFromCompilerNodeIfExists(lastChild);
    }
    getLastChildIfKindOrThrow(kind) {
        return errors.throwIfNullOrUndefined(this.getLastChildIfKind(kind), `A last child of the kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getLastChildIfKind(kind) {
        const lastChild = this._getCompilerLastChild();
        return lastChild != null && lastChild.kind === kind ? this._getNodeFromCompilerNode(lastChild) : undefined;
    }
    getChildAtIndexIfKindOrThrow(index, kind) {
        return errors.throwIfNullOrUndefined(this.getChildAtIndexIfKind(index, kind), `Child at index ${index} was expected to be ${common.getSyntaxKindName(kind)}`);
    }
    getChildAtIndexIfKind(index, kind) {
        const node = this._getCompilerChildAtIndex(index);
        return node.kind === kind ? this._getNodeFromCompilerNode(node) : undefined;
    }
    getPreviousSiblingIfKindOrThrow(kind) {
        return errors.throwIfNullOrUndefined(this.getPreviousSiblingIfKind(kind), `A previous sibling of kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getNextSiblingIfKindOrThrow(kind) {
        return errors.throwIfNullOrUndefined(this.getNextSiblingIfKind(kind), `A next sibling of kind ${common.getSyntaxKindName(kind)} was expected.`);
    }
    getPreviousSiblingIfKind(kind) {
        const previousSibling = this._getCompilerPreviousSibling();
        return previousSibling != null && previousSibling.kind === kind
            ? this._getNodeFromCompilerNode(previousSibling)
            : undefined;
    }
    getNextSiblingIfKind(kind) {
        const nextSibling = this._getCompilerNextSibling();
        return nextSibling != null && nextSibling.kind === kind ? this._getNodeFromCompilerNode(nextSibling) : undefined;
    }
    getParentIfOrThrow(condition) {
        return errors.throwIfNullOrUndefined(this.getParentIf(condition), "The parent did not match the provided condition.");
    }
    getParentIf(condition) {
        return condition(this.getParent(), this) ? this.getParent() : undefined;
    }
    getParentIfKindOrThrow(kind) {
        return errors.throwIfNullOrUndefined(this.getParentIfKind(kind), `The parent was not a syntax kind of ${common.getSyntaxKindName(kind)}.`);
    }
    getParentIfKind(kind) {
        return this.getParentIf(n => n !== undefined && n.getKind() === kind);
    }
    getFirstAncestorByKindOrThrow(kind) {
        return errors.throwIfNullOrUndefined(this.getFirstAncestorByKind(kind), `Expected an ancestor with a syntax kind of ${common.getSyntaxKindName(kind)}.`);
    }
    getFirstAncestorByKind(kind) {
        for (const parent of this._getAncestorsIterator(kind === ts$1.SyntaxKind.SyntaxList)) {
            if (parent.getKind() === kind)
                return parent;
        }
        return undefined;
    }
    getFirstAncestorOrThrow(condition) {
        return errors.throwIfNullOrUndefined(this.getFirstAncestor(condition), `Expected to find an ancestor that matched the provided condition.`);
    }
    getFirstAncestor(condition) {
        for (const ancestor of this._getAncestorsIterator(false)) {
            if (condition == null || condition(ancestor))
                return ancestor;
        }
        return undefined;
    }
    getDescendantsOfKind(kind) {
        const descendants = [];
        for (const descendant of this._getCompilerDescendantsOfKindIterator(kind))
            descendants.push(this._getNodeFromCompilerNode(descendant));
        return descendants;
    }
    getFirstDescendantByKindOrThrow(kind) {
        return errors.throwIfNullOrUndefined(this.getFirstDescendantByKind(kind), `A descendant of kind ${common.getSyntaxKindName(kind)} was expected to be found.`);
    }
    getFirstDescendantByKind(kind) {
        for (const descendant of this._getCompilerDescendantsOfKindIterator(kind))
            return this._getNodeFromCompilerNode(descendant);
        return undefined;
    }
    _getCompilerChildren() {
        return ExtendedParser.getCompilerChildren(this.compilerNode, this._sourceFile.compilerNode);
    }
    _getCompilerForEachChildren() {
        return ExtendedParser.getCompilerForEachChildren(this.compilerNode, this._sourceFile.compilerNode);
    }
    _getCompilerChildrenFast() {
        return hasParsedTokens(this.compilerNode) ? this._getCompilerChildren() : this._getCompilerForEachChildren();
    }
    _getCompilerChildrenOfKind(kind) {
        const children = useParseTreeSearchForKind(this, kind) ? this._getCompilerForEachChildren() : this._getCompilerChildren();
        return children.filter(c => c.kind === kind);
    }
    *_getCompilerDescendantsOfKindIterator(kind) {
        const children = useParseTreeSearchForKind(this, kind) ? this._getCompilerForEachChildren() : this._getCompilerChildren();
        for (const child of children) {
            if (child.kind === kind)
                yield child;
            const descendants = useParseTreeSearchForKind(child.kind, kind)
                ? getCompilerForEachDescendantsIterator(child)
                : getCompilerDescendantsIterator(child, this._sourceFile.compilerNode);
            for (const descendant of descendants) {
                if (descendant.kind === kind)
                    yield descendant;
            }
        }
    }
    _getCompilerDescendantsIterator() {
        return getCompilerDescendantsIterator(this.compilerNode, this._sourceFile.compilerNode);
    }
    _getCompilerForEachDescendantsIterator() {
        return getCompilerForEachDescendantsIterator(this.compilerNode);
    }
    _getCompilerFirstChild(condition) {
        for (const child of this._getCompilerChildren()) {
            if (condition == null || condition(child))
                return child;
        }
        return undefined;
    }
    _getCompilerLastChild(condition) {
        const children = this._getCompilerChildren();
        for (let i = children.length - 1; i >= 0; i--) {
            const child = children[i];
            if (condition == null || condition(child))
                return child;
        }
        return undefined;
    }
    _getCompilerPreviousSiblings() {
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        const previousSiblings = [];
        for (const child of parent._getCompilerChildren()) {
            if (child === this.compilerNode)
                break;
            previousSiblings.unshift(child);
        }
        return previousSiblings;
    }
    _getCompilerNextSiblings() {
        let foundChild = false;
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        const nextSiblings = [];
        for (const child of parent._getCompilerChildren()) {
            if (!foundChild) {
                foundChild = child === this.compilerNode;
                continue;
            }
            nextSiblings.push(child);
        }
        return nextSiblings;
    }
    _getCompilerPreviousSibling(condition) {
        for (const sibling of this._getCompilerPreviousSiblings()) {
            if (condition == null || condition(sibling))
                return sibling;
        }
        return undefined;
    }
    _getCompilerNextSibling(condition) {
        for (const sibling of this._getCompilerNextSiblings()) {
            if (condition == null || condition(sibling))
                return sibling;
        }
        return undefined;
    }
    _getCompilerChildAtIndex(index) {
        const children = this._getCompilerChildren();
        errors.throwIfOutOfRange(index, [0, children.length - 1], "index");
        return children[index];
    }
    _getWriterWithIndentation() {
        const writer = this._getWriter();
        writer.setIndentationLevel(this.getIndentationLevel());
        return writer;
    }
    _getWriterWithQueuedIndentation() {
        const writer = this._getWriter();
        writer.queueIndentationLevel(this.getIndentationLevel());
        return writer;
    }
    _getWriterWithChildIndentation() {
        const writer = this._getWriter();
        writer.setIndentationLevel(this.getChildIndentationLevel());
        return writer;
    }
    _getWriterWithQueuedChildIndentation() {
        const writer = this._getWriter();
        writer.queueIndentationLevel(this.getChildIndentationLevel());
        return writer;
    }
    _getTextWithQueuedChildIndentation(textOrWriterFunc) {
        const writer = this._getWriterWithQueuedChildIndentation();
        if (typeof textOrWriterFunc === "string")
            writer.write(textOrWriterFunc);
        else
            textOrWriterFunc(writer);
        return writer.toString();
    }
    _getWriter() {
        return this._context.createWriter();
    }
    _getNodeFromCompilerNode(compilerNode) {
        return this._context.compilerFactory.getNodeFromCompilerNode(compilerNode, this._sourceFile);
    }
    _getNodeFromCompilerNodeIfExists(compilerNode) {
        return compilerNode == null ? undefined : this._getNodeFromCompilerNode(compilerNode);
    }
    _ensureBound() {
        if (this.compilerNode.symbol != null)
            return;
        this.getSymbol();
    }
    static hasExpression(node) {
        var _a, _b;
        return ((_b = (_a = node).getExpression) === null || _b === void 0 ? void 0 : _b.call(_a)) != null;
    }
    static hasName(node) {
        var _a, _b;
        return typeof ((_b = (_a = node).getName) === null || _b === void 0 ? void 0 : _b.call(_a)) === "string";
    }
    static hasBody(node) {
        var _a, _b;
        return ((_b = (_a = node).getBody) === null || _b === void 0 ? void 0 : _b.call(_a)) != null;
    }
    static is(kind) {
        return (node) => {
            return (node === null || node === void 0 ? void 0 : node.getKind()) == kind;
        };
    }
    static isNode(value) {
        return value != null && value.compilerNode != null;
    }
    static isCommentNode(node) {
        const kind = node === null || node === void 0 ? void 0 : node.getKind();
        return kind === ts$1.SyntaxKind.SingleLineCommentTrivia || kind === ts$1.SyntaxKind.MultiLineCommentTrivia;
    }
    static isCommentStatement(node) {
        return (node === null || node === void 0 ? void 0 : node.compilerNode)._commentKind === exports.CommentNodeKind.Statement;
    }
    static isCommentClassElement(node) {
        return (node === null || node === void 0 ? void 0 : node.compilerNode)._commentKind === exports.CommentNodeKind.ClassElement;
    }
    static isCommentTypeElement(node) {
        return (node === null || node === void 0 ? void 0 : node.compilerNode)._commentKind === exports.CommentNodeKind.TypeElement;
    }
    static isCommentObjectLiteralElement(node) {
        return (node === null || node === void 0 ? void 0 : node.compilerNode)._commentKind === exports.CommentNodeKind.ObjectLiteralElement;
    }
    static isCommentEnumMember(node) {
        return (node === null || node === void 0 ? void 0 : node.compilerNode)._commentKind == exports.CommentNodeKind.EnumMember;
    }
    static isAbstractableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }
    static isAmbientableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.VariableStatement:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isArgumentedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.CallExpression:
            case ts$1.SyntaxKind.NewExpression:
                return true;
            default:
                return false;
        }
    }
    static isArrayTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ArrayType;
    }
    static isAsyncableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }
    static isAwaitableNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ForOfStatement;
    }
    static isBindingNamedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.BindingElement:
            case ts$1.SyntaxKind.Parameter:
            case ts$1.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isBodiedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isBodyableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isBooleanLiteral(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.FalseKeyword:
            case ts$1.SyntaxKind.TrueKeyword:
                return true;
            default:
                return false;
        }
    }
    static isCallSignatureDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.CallSignature;
    }
    static isChildOrderableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.CallSignature:
            case ts$1.SyntaxKind.ConstructSignature:
            case ts$1.SyntaxKind.IndexSignature:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.ExportAssignment:
            case ts$1.SyntaxKind.ExportDeclaration:
            case ts$1.SyntaxKind.ImportDeclaration:
            case ts$1.SyntaxKind.ImportEqualsDeclaration:
            case ts$1.SyntaxKind.ModuleBlock:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.Block:
            case ts$1.SyntaxKind.BreakStatement:
            case ts$1.SyntaxKind.ContinueStatement:
            case ts$1.SyntaxKind.DebuggerStatement:
            case ts$1.SyntaxKind.DoStatement:
            case ts$1.SyntaxKind.EmptyStatement:
            case ts$1.SyntaxKind.ExpressionStatement:
            case ts$1.SyntaxKind.ForInStatement:
            case ts$1.SyntaxKind.ForOfStatement:
            case ts$1.SyntaxKind.ForStatement:
            case ts$1.SyntaxKind.IfStatement:
            case ts$1.SyntaxKind.LabeledStatement:
            case ts$1.SyntaxKind.NotEmittedStatement:
            case ts$1.SyntaxKind.ReturnStatement:
            case ts$1.SyntaxKind.SwitchStatement:
            case ts$1.SyntaxKind.ThrowStatement:
            case ts$1.SyntaxKind.TryStatement:
            case ts$1.SyntaxKind.VariableStatement:
            case ts$1.SyntaxKind.WhileStatement:
            case ts$1.SyntaxKind.WithStatement:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isClassLikeDeclarationBase(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }
    static isConditionalTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ConditionalType;
    }
    static isConstructSignatureDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ConstructSignature;
    }
    static isConstructorDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.Constructor;
    }
    static isConstructorTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ConstructorType;
    }
    static isDecoratableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.Parameter:
                return true;
            default:
                return false;
        }
    }
    static isExclamationTokenableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isExportGetableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.VariableStatement:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
            case ts$1.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isExportableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.VariableStatement:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.AnyKeyword:
            case ts$1.SyntaxKind.BooleanKeyword:
            case ts$1.SyntaxKind.NumberKeyword:
            case ts$1.SyntaxKind.ObjectKeyword:
            case ts$1.SyntaxKind.StringKeyword:
            case ts$1.SyntaxKind.SymbolKeyword:
            case ts$1.SyntaxKind.UndefinedKeyword:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.AsExpression:
            case ts$1.SyntaxKind.AwaitExpression:
            case ts$1.SyntaxKind.BinaryExpression:
            case ts$1.SyntaxKind.CallExpression:
            case ts$1.SyntaxKind.CommaListExpression:
            case ts$1.SyntaxKind.ConditionalExpression:
            case ts$1.SyntaxKind.DeleteExpression:
            case ts$1.SyntaxKind.ElementAccessExpression:
            case ts$1.SyntaxKind.ImportKeyword:
            case ts$1.SyntaxKind.MetaProperty:
            case ts$1.SyntaxKind.NewExpression:
            case ts$1.SyntaxKind.NonNullExpression:
            case ts$1.SyntaxKind.OmittedExpression:
            case ts$1.SyntaxKind.ParenthesizedExpression:
            case ts$1.SyntaxKind.PartiallyEmittedExpression:
            case ts$1.SyntaxKind.PostfixUnaryExpression:
            case ts$1.SyntaxKind.PrefixUnaryExpression:
            case ts$1.SyntaxKind.PropertyAccessExpression:
            case ts$1.SyntaxKind.SpreadElement:
            case ts$1.SyntaxKind.SuperKeyword:
            case ts$1.SyntaxKind.ThisKeyword:
            case ts$1.SyntaxKind.TypeAssertionExpression:
            case ts$1.SyntaxKind.TypeOfExpression:
            case ts$1.SyntaxKind.VoidExpression:
            case ts$1.SyntaxKind.YieldExpression:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.JsxClosingFragment:
            case ts$1.SyntaxKind.JsxElement:
            case ts$1.SyntaxKind.JsxExpression:
            case ts$1.SyntaxKind.JsxFragment:
            case ts$1.SyntaxKind.JsxOpeningElement:
            case ts$1.SyntaxKind.JsxOpeningFragment:
            case ts$1.SyntaxKind.JsxSelfClosingElement:
            case ts$1.SyntaxKind.BigIntLiteral:
            case ts$1.SyntaxKind.FalseKeyword:
            case ts$1.SyntaxKind.TrueKeyword:
            case ts$1.SyntaxKind.NullKeyword:
            case ts$1.SyntaxKind.NumericLiteral:
            case ts$1.SyntaxKind.RegularExpressionLiteral:
            case ts$1.SyntaxKind.StringLiteral:
            case ts$1.SyntaxKind.Identifier:
            case ts$1.SyntaxKind.ArrayLiteralExpression:
            case ts$1.SyntaxKind.ObjectLiteralExpression:
            case ts$1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case ts$1.SyntaxKind.TaggedTemplateExpression:
            case ts$1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static isExpressionedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.AsExpression:
            case ts$1.SyntaxKind.NonNullExpression:
            case ts$1.SyntaxKind.ParenthesizedExpression:
            case ts$1.SyntaxKind.PartiallyEmittedExpression:
            case ts$1.SyntaxKind.SpreadElement:
            case ts$1.SyntaxKind.SpreadAssignment:
            case ts$1.SyntaxKind.TemplateSpan:
                return true;
            default:
                return false;
        }
    }
    static isExtendsClauseableNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.InterfaceDeclaration;
    }
    static isFunctionLikeDeclaration(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isFunctionTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.FunctionType;
    }
    static isGeneratorableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.YieldExpression:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }
    static isGetAccessorDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.GetAccessor;
    }
    static isHeritageClauseableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.InterfaceDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isImplementsClauseableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
                return true;
            default:
                return false;
        }
    }
    static isImportExpression(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ImportKeyword;
    }
    static isImportTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ImportType;
    }
    static isIndexSignatureDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.IndexSignature;
    }
    static isIndexedAccessTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.IndexedAccessType;
    }
    static isInferTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.InferType;
    }
    static isInitializerExpressionGetableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.BindingElement:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.EnumMember:
            case ts$1.SyntaxKind.Parameter:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.VariableDeclaration:
            case ts$1.SyntaxKind.PropertyAssignment:
            case ts$1.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isInitializerExpressionableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.BindingElement:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.EnumMember:
            case ts$1.SyntaxKind.Parameter:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isIntersectionTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.IntersectionType;
    }
    static isIterationStatement(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.DoStatement:
            case ts$1.SyntaxKind.ForInStatement:
            case ts$1.SyntaxKind.ForOfStatement:
            case ts$1.SyntaxKind.ForStatement:
            case ts$1.SyntaxKind.WhileStatement:
                return true;
            default:
                return false;
        }
    }
    static isJSDoc(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.JSDocComment;
    }
    static isJSDocPropertyLikeTag(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.JSDocParameterTag:
            case ts$1.SyntaxKind.JSDocPropertyTag:
                return true;
            default:
                return false;
        }
    }
    static isJSDocTag(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.JSDocAugmentsTag:
            case ts$1.SyntaxKind.JSDocClassTag:
            case ts$1.SyntaxKind.JSDocParameterTag:
            case ts$1.SyntaxKind.JSDocPrivateTag:
            case ts$1.SyntaxKind.JSDocPropertyTag:
            case ts$1.SyntaxKind.JSDocProtectedTag:
            case ts$1.SyntaxKind.JSDocPublicTag:
            case ts$1.SyntaxKind.JSDocReadonlyTag:
            case ts$1.SyntaxKind.JSDocReturnTag:
            case ts$1.SyntaxKind.JSDocTemplateTag:
            case ts$1.SyntaxKind.JSDocThisTag:
            case ts$1.SyntaxKind.JSDocTypedefTag:
            case ts$1.SyntaxKind.JSDocTypeTag:
            case ts$1.SyntaxKind.JSDocTag:
                return true;
            default:
                return false;
        }
    }
    static isJSDocType(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.JSDocFunctionType:
            case ts$1.SyntaxKind.JSDocSignature:
                return true;
            default:
                return false;
        }
    }
    static isJSDocTypeExpressionableTag(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.JSDocReturnTag:
            case ts$1.SyntaxKind.JSDocThisTag:
                return true;
            default:
                return false;
        }
    }
    static isJSDocTypeParameteredTag(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.JSDocTemplateTag;
    }
    static isJSDocUnknownTag(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.JSDocTag;
    }
    static isJSDocableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.EnumMember:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.CallSignature:
            case ts$1.SyntaxKind.ConstructSignature:
            case ts$1.SyntaxKind.IndexSignature:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.ImportEqualsDeclaration:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.ExpressionStatement:
            case ts$1.SyntaxKind.LabeledStatement:
            case ts$1.SyntaxKind.VariableStatement:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isJsxAttributedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.JsxOpeningElement:
            case ts$1.SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }
    static isJsxTagNamedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.JsxClosingElement:
            case ts$1.SyntaxKind.JsxOpeningElement:
            case ts$1.SyntaxKind.JsxSelfClosingElement:
                return true;
            default:
                return false;
        }
    }
    static isLeftHandSideExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.CallExpression:
            case ts$1.SyntaxKind.ElementAccessExpression:
            case ts$1.SyntaxKind.ImportKeyword:
            case ts$1.SyntaxKind.MetaProperty:
            case ts$1.SyntaxKind.NewExpression:
            case ts$1.SyntaxKind.NonNullExpression:
            case ts$1.SyntaxKind.PropertyAccessExpression:
            case ts$1.SyntaxKind.SuperKeyword:
            case ts$1.SyntaxKind.ThisKeyword:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.JsxElement:
            case ts$1.SyntaxKind.JsxFragment:
            case ts$1.SyntaxKind.JsxSelfClosingElement:
            case ts$1.SyntaxKind.BigIntLiteral:
            case ts$1.SyntaxKind.FalseKeyword:
            case ts$1.SyntaxKind.TrueKeyword:
            case ts$1.SyntaxKind.NullKeyword:
            case ts$1.SyntaxKind.NumericLiteral:
            case ts$1.SyntaxKind.RegularExpressionLiteral:
            case ts$1.SyntaxKind.StringLiteral:
            case ts$1.SyntaxKind.Identifier:
            case ts$1.SyntaxKind.ArrayLiteralExpression:
            case ts$1.SyntaxKind.ObjectLiteralExpression:
            case ts$1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case ts$1.SyntaxKind.TaggedTemplateExpression:
            case ts$1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static isLeftHandSideExpressionedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.CallExpression:
            case ts$1.SyntaxKind.ElementAccessExpression:
            case ts$1.SyntaxKind.NewExpression:
            case ts$1.SyntaxKind.PropertyAccessExpression:
            case ts$1.SyntaxKind.ExpressionWithTypeArguments:
                return true;
            default:
                return false;
        }
    }
    static isLiteralExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.BigIntLiteral:
            case ts$1.SyntaxKind.NumericLiteral:
            case ts$1.SyntaxKind.RegularExpressionLiteral:
            case ts$1.SyntaxKind.StringLiteral:
            case ts$1.SyntaxKind.NoSubstitutionTemplateLiteral:
                return true;
            default:
                return false;
        }
    }
    static isLiteralLikeNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.JsxText:
            case ts$1.SyntaxKind.BigIntLiteral:
            case ts$1.SyntaxKind.NumericLiteral:
            case ts$1.SyntaxKind.RegularExpressionLiteral:
            case ts$1.SyntaxKind.StringLiteral:
            case ts$1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case ts$1.SyntaxKind.TemplateHead:
            case ts$1.SyntaxKind.TemplateMiddle:
            case ts$1.SyntaxKind.TemplateTail:
                return true;
            default:
                return false;
        }
    }
    static isLiteralTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.LiteralType;
    }
    static isMemberExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.ElementAccessExpression:
            case ts$1.SyntaxKind.ImportKeyword:
            case ts$1.SyntaxKind.MetaProperty:
            case ts$1.SyntaxKind.NewExpression:
            case ts$1.SyntaxKind.PropertyAccessExpression:
            case ts$1.SyntaxKind.SuperKeyword:
            case ts$1.SyntaxKind.ThisKeyword:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.JsxElement:
            case ts$1.SyntaxKind.JsxFragment:
            case ts$1.SyntaxKind.JsxSelfClosingElement:
            case ts$1.SyntaxKind.BigIntLiteral:
            case ts$1.SyntaxKind.FalseKeyword:
            case ts$1.SyntaxKind.TrueKeyword:
            case ts$1.SyntaxKind.NullKeyword:
            case ts$1.SyntaxKind.NumericLiteral:
            case ts$1.SyntaxKind.RegularExpressionLiteral:
            case ts$1.SyntaxKind.StringLiteral:
            case ts$1.SyntaxKind.Identifier:
            case ts$1.SyntaxKind.ArrayLiteralExpression:
            case ts$1.SyntaxKind.ObjectLiteralExpression:
            case ts$1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case ts$1.SyntaxKind.TaggedTemplateExpression:
            case ts$1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static isModifierableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.Parameter:
            case ts$1.SyntaxKind.IndexSignature:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.VariableStatement:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
            case ts$1.SyntaxKind.VariableDeclarationList:
                return true;
            default:
                return false;
        }
    }
    static isModuledNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.SourceFile:
                return true;
            default:
                return false;
        }
    }
    static isNameableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
                return true;
            default:
                return false;
        }
    }
    static isNamedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.MetaProperty:
            case ts$1.SyntaxKind.PropertyAccessExpression:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.JsxAttribute:
            case ts$1.SyntaxKind.ImportEqualsDeclaration:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
            case ts$1.SyntaxKind.TypeParameter:
            case ts$1.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isNamespaceChildableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.VariableStatement:
                return true;
            default:
                return false;
        }
    }
    static isNamespaceDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ModuleDeclaration;
    }
    static isNullLiteral(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.NullKeyword;
    }
    static isOverloadableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.FunctionDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isParameterDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.Parameter;
    }
    static isParameteredNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.JSDocFunctionType:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.CallSignature:
            case ts$1.SyntaxKind.ConstructSignature:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.ConstructorType:
            case ts$1.SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }
    static isParenthesizedTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ParenthesizedType;
    }
    static isPrimaryExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.ImportKeyword:
            case ts$1.SyntaxKind.MetaProperty:
            case ts$1.SyntaxKind.NewExpression:
            case ts$1.SyntaxKind.SuperKeyword:
            case ts$1.SyntaxKind.ThisKeyword:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.JsxElement:
            case ts$1.SyntaxKind.JsxFragment:
            case ts$1.SyntaxKind.JsxSelfClosingElement:
            case ts$1.SyntaxKind.BigIntLiteral:
            case ts$1.SyntaxKind.FalseKeyword:
            case ts$1.SyntaxKind.TrueKeyword:
            case ts$1.SyntaxKind.NullKeyword:
            case ts$1.SyntaxKind.NumericLiteral:
            case ts$1.SyntaxKind.RegularExpressionLiteral:
            case ts$1.SyntaxKind.StringLiteral:
            case ts$1.SyntaxKind.Identifier:
            case ts$1.SyntaxKind.ArrayLiteralExpression:
            case ts$1.SyntaxKind.ObjectLiteralExpression:
            case ts$1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case ts$1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static isPropertyNamedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.EnumMember:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isQuestionDotTokenableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.CallExpression:
            case ts$1.SyntaxKind.ElementAccessExpression:
            case ts$1.SyntaxKind.PropertyAccessExpression:
                return true;
            default:
                return false;
        }
    }
    static isQuestionTokenableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.Parameter:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.PropertyAssignment:
            case ts$1.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isReadonlyableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.Parameter:
            case ts$1.SyntaxKind.IndexSignature:
            case ts$1.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }
    static isReferenceFindableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.BindingElement:
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.EnumMember:
            case ts$1.SyntaxKind.MetaProperty:
            case ts$1.SyntaxKind.PropertyAccessExpression:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.Parameter:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.JsxAttribute:
            case ts$1.SyntaxKind.ImportEqualsDeclaration:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.Identifier:
            case ts$1.SyntaxKind.PrivateIdentifier:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
            case ts$1.SyntaxKind.TypeParameter:
            case ts$1.SyntaxKind.VariableDeclaration:
            case ts$1.SyntaxKind.PropertyAssignment:
            case ts$1.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isRenameableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.BindingElement:
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.EnumMember:
            case ts$1.SyntaxKind.MetaProperty:
            case ts$1.SyntaxKind.PropertyAccessExpression:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.Parameter:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.JsxAttribute:
            case ts$1.SyntaxKind.ImportEqualsDeclaration:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.NamespaceExport:
            case ts$1.SyntaxKind.NamespaceImport:
            case ts$1.SyntaxKind.Identifier:
            case ts$1.SyntaxKind.PrivateIdentifier:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
            case ts$1.SyntaxKind.TypeParameter:
            case ts$1.SyntaxKind.VariableDeclaration:
            case ts$1.SyntaxKind.PropertyAssignment:
            case ts$1.SyntaxKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    }
    static isReturnTypedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.JSDocFunctionType:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.CallSignature:
            case ts$1.SyntaxKind.ConstructSignature:
            case ts$1.SyntaxKind.IndexSignature:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.ConstructorType:
            case ts$1.SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }
    static isScopeableNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.Parameter;
    }
    static isScopedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }
    static isSetAccessorDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.SetAccessor;
    }
    static isSignaturedDeclaration(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.JSDocFunctionType:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.CallSignature:
            case ts$1.SyntaxKind.ConstructSignature:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.ConstructorType:
            case ts$1.SyntaxKind.FunctionType:
                return true;
            default:
                return false;
        }
    }
    static isStatement(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.ExportAssignment:
            case ts$1.SyntaxKind.ExportDeclaration:
            case ts$1.SyntaxKind.ImportDeclaration:
            case ts$1.SyntaxKind.ImportEqualsDeclaration:
            case ts$1.SyntaxKind.ModuleBlock:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.Block:
            case ts$1.SyntaxKind.BreakStatement:
            case ts$1.SyntaxKind.ContinueStatement:
            case ts$1.SyntaxKind.DebuggerStatement:
            case ts$1.SyntaxKind.DoStatement:
            case ts$1.SyntaxKind.EmptyStatement:
            case ts$1.SyntaxKind.ExpressionStatement:
            case ts$1.SyntaxKind.ForInStatement:
            case ts$1.SyntaxKind.ForOfStatement:
            case ts$1.SyntaxKind.ForStatement:
            case ts$1.SyntaxKind.IfStatement:
            case ts$1.SyntaxKind.LabeledStatement:
            case ts$1.SyntaxKind.NotEmittedStatement:
            case ts$1.SyntaxKind.ReturnStatement:
            case ts$1.SyntaxKind.SwitchStatement:
            case ts$1.SyntaxKind.ThrowStatement:
            case ts$1.SyntaxKind.TryStatement:
            case ts$1.SyntaxKind.VariableStatement:
            case ts$1.SyntaxKind.WhileStatement:
            case ts$1.SyntaxKind.WithStatement:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isStatementedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.ModuleBlock:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.SourceFile:
            case ts$1.SyntaxKind.Block:
            case ts$1.SyntaxKind.CaseClause:
            case ts$1.SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }
    static isStaticableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
                return true;
            default:
                return false;
        }
    }
    static isSuperExpression(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.SuperKeyword;
    }
    static isTextInsertableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.SourceFile:
            case ts$1.SyntaxKind.Block:
            case ts$1.SyntaxKind.CaseBlock:
            case ts$1.SyntaxKind.CaseClause:
            case ts$1.SyntaxKind.DefaultClause:
                return true;
            default:
                return false;
        }
    }
    static isThisExpression(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ThisKeyword;
    }
    static isThisTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.ThisType;
    }
    static isTupleTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.TupleType;
    }
    static isTypeArgumentedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.CallExpression:
            case ts$1.SyntaxKind.NewExpression:
            case ts$1.SyntaxKind.ImportType:
                return true;
            default:
                return false;
        }
    }
    static isTypeAssertion(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.TypeAssertionExpression;
    }
    static isTypeElement(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.CallSignature:
            case ts$1.SyntaxKind.ConstructSignature:
            case ts$1.SyntaxKind.IndexSignature:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.PropertySignature:
                return true;
            default:
                return false;
        }
    }
    static isTypeElementMemberedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.TypeLiteral:
                return true;
            default:
                return false;
        }
    }
    static isTypeLiteralNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.TypeLiteral;
    }
    static isTypeNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.JSDocFunctionType:
            case ts$1.SyntaxKind.JSDocSignature:
            case ts$1.SyntaxKind.JSDocTypeExpression:
            case ts$1.SyntaxKind.ArrayType:
            case ts$1.SyntaxKind.ConditionalType:
            case ts$1.SyntaxKind.ConstructorType:
            case ts$1.SyntaxKind.ExpressionWithTypeArguments:
            case ts$1.SyntaxKind.FunctionType:
            case ts$1.SyntaxKind.ImportType:
            case ts$1.SyntaxKind.IndexedAccessType:
            case ts$1.SyntaxKind.InferType:
            case ts$1.SyntaxKind.IntersectionType:
            case ts$1.SyntaxKind.LiteralType:
            case ts$1.SyntaxKind.ParenthesizedType:
            case ts$1.SyntaxKind.ThisType:
            case ts$1.SyntaxKind.TupleType:
            case ts$1.SyntaxKind.TypeLiteral:
            case ts$1.SyntaxKind.TypePredicate:
            case ts$1.SyntaxKind.TypeReference:
            case ts$1.SyntaxKind.UnionType:
                return true;
            default:
                return false;
        }
    }
    static isTypeParameterDeclaration(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.TypeParameter;
    }
    static isTypeParameteredNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.ArrowFunction:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.CallSignature:
            case ts$1.SyntaxKind.ConstructSignature:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.FunctionType:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isTypePredicateNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.TypePredicate;
    }
    static isTypeReferenceNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.TypeReference;
    }
    static isTypedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.AsExpression:
            case ts$1.SyntaxKind.TypeAssertionExpression:
            case ts$1.SyntaxKind.Parameter:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
            case ts$1.SyntaxKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isUnaryExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.AwaitExpression:
            case ts$1.SyntaxKind.CallExpression:
            case ts$1.SyntaxKind.DeleteExpression:
            case ts$1.SyntaxKind.ElementAccessExpression:
            case ts$1.SyntaxKind.ImportKeyword:
            case ts$1.SyntaxKind.MetaProperty:
            case ts$1.SyntaxKind.NewExpression:
            case ts$1.SyntaxKind.NonNullExpression:
            case ts$1.SyntaxKind.PostfixUnaryExpression:
            case ts$1.SyntaxKind.PrefixUnaryExpression:
            case ts$1.SyntaxKind.PropertyAccessExpression:
            case ts$1.SyntaxKind.SuperKeyword:
            case ts$1.SyntaxKind.ThisKeyword:
            case ts$1.SyntaxKind.TypeAssertionExpression:
            case ts$1.SyntaxKind.TypeOfExpression:
            case ts$1.SyntaxKind.VoidExpression:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.JsxElement:
            case ts$1.SyntaxKind.JsxFragment:
            case ts$1.SyntaxKind.JsxSelfClosingElement:
            case ts$1.SyntaxKind.BigIntLiteral:
            case ts$1.SyntaxKind.FalseKeyword:
            case ts$1.SyntaxKind.TrueKeyword:
            case ts$1.SyntaxKind.NullKeyword:
            case ts$1.SyntaxKind.NumericLiteral:
            case ts$1.SyntaxKind.RegularExpressionLiteral:
            case ts$1.SyntaxKind.StringLiteral:
            case ts$1.SyntaxKind.Identifier:
            case ts$1.SyntaxKind.ArrayLiteralExpression:
            case ts$1.SyntaxKind.ObjectLiteralExpression:
            case ts$1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case ts$1.SyntaxKind.TaggedTemplateExpression:
            case ts$1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static isUnaryExpressionedNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.AwaitExpression:
            case ts$1.SyntaxKind.DeleteExpression:
            case ts$1.SyntaxKind.TypeAssertionExpression:
            case ts$1.SyntaxKind.TypeOfExpression:
            case ts$1.SyntaxKind.VoidExpression:
                return true;
            default:
                return false;
        }
    }
    static isUnionTypeNode(node) {
        return (node === null || node === void 0 ? void 0 : node.getKind()) === ts$1.SyntaxKind.UnionType;
    }
    static isUnwrappableNode(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.ModuleDeclaration:
                return true;
            default:
                return false;
        }
    }
    static isUpdateExpression(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassExpression:
            case ts$1.SyntaxKind.CallExpression:
            case ts$1.SyntaxKind.ElementAccessExpression:
            case ts$1.SyntaxKind.ImportKeyword:
            case ts$1.SyntaxKind.MetaProperty:
            case ts$1.SyntaxKind.NewExpression:
            case ts$1.SyntaxKind.NonNullExpression:
            case ts$1.SyntaxKind.PropertyAccessExpression:
            case ts$1.SyntaxKind.SuperKeyword:
            case ts$1.SyntaxKind.ThisKeyword:
            case ts$1.SyntaxKind.FunctionExpression:
            case ts$1.SyntaxKind.JsxElement:
            case ts$1.SyntaxKind.JsxFragment:
            case ts$1.SyntaxKind.JsxSelfClosingElement:
            case ts$1.SyntaxKind.BigIntLiteral:
            case ts$1.SyntaxKind.FalseKeyword:
            case ts$1.SyntaxKind.TrueKeyword:
            case ts$1.SyntaxKind.NullKeyword:
            case ts$1.SyntaxKind.NumericLiteral:
            case ts$1.SyntaxKind.RegularExpressionLiteral:
            case ts$1.SyntaxKind.StringLiteral:
            case ts$1.SyntaxKind.Identifier:
            case ts$1.SyntaxKind.ArrayLiteralExpression:
            case ts$1.SyntaxKind.ObjectLiteralExpression:
            case ts$1.SyntaxKind.NoSubstitutionTemplateLiteral:
            case ts$1.SyntaxKind.TaggedTemplateExpression:
            case ts$1.SyntaxKind.TemplateExpression:
                return true;
            default:
                return false;
        }
    }
    static _hasStructure(node) {
        switch (node === null || node === void 0 ? void 0 : node.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
            case ts$1.SyntaxKind.Constructor:
            case ts$1.SyntaxKind.GetAccessor:
            case ts$1.SyntaxKind.MethodDeclaration:
            case ts$1.SyntaxKind.PropertyDeclaration:
            case ts$1.SyntaxKind.SetAccessor:
            case ts$1.SyntaxKind.Decorator:
            case ts$1.SyntaxKind.JSDocComment:
            case ts$1.SyntaxKind.EnumDeclaration:
            case ts$1.SyntaxKind.EnumMember:
            case ts$1.SyntaxKind.FunctionDeclaration:
            case ts$1.SyntaxKind.Parameter:
            case ts$1.SyntaxKind.CallSignature:
            case ts$1.SyntaxKind.ConstructSignature:
            case ts$1.SyntaxKind.IndexSignature:
            case ts$1.SyntaxKind.InterfaceDeclaration:
            case ts$1.SyntaxKind.MethodSignature:
            case ts$1.SyntaxKind.PropertySignature:
            case ts$1.SyntaxKind.JsxAttribute:
            case ts$1.SyntaxKind.JsxElement:
            case ts$1.SyntaxKind.JsxSelfClosingElement:
            case ts$1.SyntaxKind.JsxSpreadAttribute:
            case ts$1.SyntaxKind.ExportAssignment:
            case ts$1.SyntaxKind.ExportDeclaration:
            case ts$1.SyntaxKind.ExportSpecifier:
            case ts$1.SyntaxKind.ImportDeclaration:
            case ts$1.SyntaxKind.ImportSpecifier:
            case ts$1.SyntaxKind.ModuleDeclaration:
            case ts$1.SyntaxKind.SourceFile:
            case ts$1.SyntaxKind.VariableStatement:
            case ts$1.SyntaxKind.TypeAliasDeclaration:
            case ts$1.SyntaxKind.TypeParameter:
            case ts$1.SyntaxKind.VariableDeclaration:
            case ts$1.SyntaxKind.PropertyAssignment:
            case ts$1.SyntaxKind.ShorthandPropertyAssignment:
            case ts$1.SyntaxKind.SpreadAssignment:
                return true;
            default:
                return false;
        }
    }
}
Node.isAnyKeyword = Node.is(ts$1.SyntaxKind.AnyKeyword);
Node.isArrayBindingPattern = Node.is(ts$1.SyntaxKind.ArrayBindingPattern);
Node.isArrayLiteralExpression = Node.is(ts$1.SyntaxKind.ArrayLiteralExpression);
Node.isArrowFunction = Node.is(ts$1.SyntaxKind.ArrowFunction);
Node.isAsExpression = Node.is(ts$1.SyntaxKind.AsExpression);
Node.isAwaitExpression = Node.is(ts$1.SyntaxKind.AwaitExpression);
Node.isBigIntLiteral = Node.is(ts$1.SyntaxKind.BigIntLiteral);
Node.isBinaryExpression = Node.is(ts$1.SyntaxKind.BinaryExpression);
Node.isBindingElement = Node.is(ts$1.SyntaxKind.BindingElement);
Node.isBlock = Node.is(ts$1.SyntaxKind.Block);
Node.isBooleanKeyword = Node.is(ts$1.SyntaxKind.BooleanKeyword);
Node.isBreakStatement = Node.is(ts$1.SyntaxKind.BreakStatement);
Node.isCallExpression = Node.is(ts$1.SyntaxKind.CallExpression);
Node.isCaseBlock = Node.is(ts$1.SyntaxKind.CaseBlock);
Node.isCaseClause = Node.is(ts$1.SyntaxKind.CaseClause);
Node.isCatchClause = Node.is(ts$1.SyntaxKind.CatchClause);
Node.isClassDeclaration = Node.is(ts$1.SyntaxKind.ClassDeclaration);
Node.isClassExpression = Node.is(ts$1.SyntaxKind.ClassExpression);
Node.isCommaListExpression = Node.is(ts$1.SyntaxKind.CommaListExpression);
Node.isComputedPropertyName = Node.is(ts$1.SyntaxKind.ComputedPropertyName);
Node.isConditionalExpression = Node.is(ts$1.SyntaxKind.ConditionalExpression);
Node.isContinueStatement = Node.is(ts$1.SyntaxKind.ContinueStatement);
Node.isDebuggerStatement = Node.is(ts$1.SyntaxKind.DebuggerStatement);
Node.isDecorator = Node.is(ts$1.SyntaxKind.Decorator);
Node.isDefaultClause = Node.is(ts$1.SyntaxKind.DefaultClause);
Node.isDeleteExpression = Node.is(ts$1.SyntaxKind.DeleteExpression);
Node.isDoStatement = Node.is(ts$1.SyntaxKind.DoStatement);
Node.isElementAccessExpression = Node.is(ts$1.SyntaxKind.ElementAccessExpression);
Node.isEmptyStatement = Node.is(ts$1.SyntaxKind.EmptyStatement);
Node.isEnumDeclaration = Node.is(ts$1.SyntaxKind.EnumDeclaration);
Node.isEnumMember = Node.is(ts$1.SyntaxKind.EnumMember);
Node.isExportAssignment = Node.is(ts$1.SyntaxKind.ExportAssignment);
Node.isExportDeclaration = Node.is(ts$1.SyntaxKind.ExportDeclaration);
Node.isExportSpecifier = Node.is(ts$1.SyntaxKind.ExportSpecifier);
Node.isExpressionStatement = Node.is(ts$1.SyntaxKind.ExpressionStatement);
Node.isExpressionWithTypeArguments = Node.is(ts$1.SyntaxKind.ExpressionWithTypeArguments);
Node.isExternalModuleReference = Node.is(ts$1.SyntaxKind.ExternalModuleReference);
Node.isFalseKeyword = Node.is(ts$1.SyntaxKind.FalseKeyword);
Node.isForInStatement = Node.is(ts$1.SyntaxKind.ForInStatement);
Node.isForOfStatement = Node.is(ts$1.SyntaxKind.ForOfStatement);
Node.isForStatement = Node.is(ts$1.SyntaxKind.ForStatement);
Node.isFunctionDeclaration = Node.is(ts$1.SyntaxKind.FunctionDeclaration);
Node.isFunctionExpression = Node.is(ts$1.SyntaxKind.FunctionExpression);
Node.isHeritageClause = Node.is(ts$1.SyntaxKind.HeritageClause);
Node.isIdentifier = Node.is(ts$1.SyntaxKind.Identifier);
Node.isIfStatement = Node.is(ts$1.SyntaxKind.IfStatement);
Node.isImportClause = Node.is(ts$1.SyntaxKind.ImportClause);
Node.isImportDeclaration = Node.is(ts$1.SyntaxKind.ImportDeclaration);
Node.isImportEqualsDeclaration = Node.is(ts$1.SyntaxKind.ImportEqualsDeclaration);
Node.isImportSpecifier = Node.is(ts$1.SyntaxKind.ImportSpecifier);
Node.isInferKeyword = Node.is(ts$1.SyntaxKind.InferKeyword);
Node.isInterfaceDeclaration = Node.is(ts$1.SyntaxKind.InterfaceDeclaration);
Node.isJSDocAugmentsTag = Node.is(ts$1.SyntaxKind.JSDocAugmentsTag);
Node.isJSDocClassTag = Node.is(ts$1.SyntaxKind.JSDocClassTag);
Node.isJSDocFunctionType = Node.is(ts$1.SyntaxKind.JSDocFunctionType);
Node.isJSDocParameterTag = Node.is(ts$1.SyntaxKind.JSDocParameterTag);
Node.isJSDocPrivateTag = Node.is(ts$1.SyntaxKind.JSDocPrivateTag);
Node.isJSDocPropertyTag = Node.is(ts$1.SyntaxKind.JSDocPropertyTag);
Node.isJSDocProtectedTag = Node.is(ts$1.SyntaxKind.JSDocProtectedTag);
Node.isJSDocPublicTag = Node.is(ts$1.SyntaxKind.JSDocPublicTag);
Node.isJSDocReadonlyTag = Node.is(ts$1.SyntaxKind.JSDocReadonlyTag);
Node.isJSDocReturnTag = Node.is(ts$1.SyntaxKind.JSDocReturnTag);
Node.isJSDocSignature = Node.is(ts$1.SyntaxKind.JSDocSignature);
Node.isJSDocTemplateTag = Node.is(ts$1.SyntaxKind.JSDocTemplateTag);
Node.isJSDocThisTag = Node.is(ts$1.SyntaxKind.JSDocThisTag);
Node.isJSDocTypeExpression = Node.is(ts$1.SyntaxKind.JSDocTypeExpression);
Node.isJSDocTypeTag = Node.is(ts$1.SyntaxKind.JSDocTypeTag);
Node.isJSDocTypedefTag = Node.is(ts$1.SyntaxKind.JSDocTypedefTag);
Node.isJsxAttribute = Node.is(ts$1.SyntaxKind.JsxAttribute);
Node.isJsxClosingElement = Node.is(ts$1.SyntaxKind.JsxClosingElement);
Node.isJsxClosingFragment = Node.is(ts$1.SyntaxKind.JsxClosingFragment);
Node.isJsxElement = Node.is(ts$1.SyntaxKind.JsxElement);
Node.isJsxExpression = Node.is(ts$1.SyntaxKind.JsxExpression);
Node.isJsxFragment = Node.is(ts$1.SyntaxKind.JsxFragment);
Node.isJsxOpeningElement = Node.is(ts$1.SyntaxKind.JsxOpeningElement);
Node.isJsxOpeningFragment = Node.is(ts$1.SyntaxKind.JsxOpeningFragment);
Node.isJsxSelfClosingElement = Node.is(ts$1.SyntaxKind.JsxSelfClosingElement);
Node.isJsxSpreadAttribute = Node.is(ts$1.SyntaxKind.JsxSpreadAttribute);
Node.isJsxText = Node.is(ts$1.SyntaxKind.JsxText);
Node.isLabeledStatement = Node.is(ts$1.SyntaxKind.LabeledStatement);
Node.isMetaProperty = Node.is(ts$1.SyntaxKind.MetaProperty);
Node.isMethodDeclaration = Node.is(ts$1.SyntaxKind.MethodDeclaration);
Node.isMethodSignature = Node.is(ts$1.SyntaxKind.MethodSignature);
Node.isModuleBlock = Node.is(ts$1.SyntaxKind.ModuleBlock);
Node.isNamedExports = Node.is(ts$1.SyntaxKind.NamedExports);
Node.isNamedImports = Node.is(ts$1.SyntaxKind.NamedImports);
Node.isNamespaceExport = Node.is(ts$1.SyntaxKind.NamespaceExport);
Node.isNamespaceImport = Node.is(ts$1.SyntaxKind.NamespaceImport);
Node.isNeverKeyword = Node.is(ts$1.SyntaxKind.NeverKeyword);
Node.isNewExpression = Node.is(ts$1.SyntaxKind.NewExpression);
Node.isNoSubstitutionTemplateLiteral = Node.is(ts$1.SyntaxKind.NoSubstitutionTemplateLiteral);
Node.isNonNullExpression = Node.is(ts$1.SyntaxKind.NonNullExpression);
Node.isNotEmittedStatement = Node.is(ts$1.SyntaxKind.NotEmittedStatement);
Node.isNumberKeyword = Node.is(ts$1.SyntaxKind.NumberKeyword);
Node.isNumericLiteral = Node.is(ts$1.SyntaxKind.NumericLiteral);
Node.isObjectBindingPattern = Node.is(ts$1.SyntaxKind.ObjectBindingPattern);
Node.isObjectKeyword = Node.is(ts$1.SyntaxKind.ObjectKeyword);
Node.isObjectLiteralExpression = Node.is(ts$1.SyntaxKind.ObjectLiteralExpression);
Node.isOmittedExpression = Node.is(ts$1.SyntaxKind.OmittedExpression);
Node.isParenthesizedExpression = Node.is(ts$1.SyntaxKind.ParenthesizedExpression);
Node.isPartiallyEmittedExpression = Node.is(ts$1.SyntaxKind.PartiallyEmittedExpression);
Node.isPostfixUnaryExpression = Node.is(ts$1.SyntaxKind.PostfixUnaryExpression);
Node.isPrefixUnaryExpression = Node.is(ts$1.SyntaxKind.PrefixUnaryExpression);
Node.isPrivateIdentifier = Node.is(ts$1.SyntaxKind.PrivateIdentifier);
Node.isPropertyAccessExpression = Node.is(ts$1.SyntaxKind.PropertyAccessExpression);
Node.isPropertyAssignment = Node.is(ts$1.SyntaxKind.PropertyAssignment);
Node.isPropertyDeclaration = Node.is(ts$1.SyntaxKind.PropertyDeclaration);
Node.isPropertySignature = Node.is(ts$1.SyntaxKind.PropertySignature);
Node.isQualifiedName = Node.is(ts$1.SyntaxKind.QualifiedName);
Node.isRegularExpressionLiteral = Node.is(ts$1.SyntaxKind.RegularExpressionLiteral);
Node.isReturnStatement = Node.is(ts$1.SyntaxKind.ReturnStatement);
Node.isSemicolonToken = Node.is(ts$1.SyntaxKind.SemicolonToken);
Node.isShorthandPropertyAssignment = Node.is(ts$1.SyntaxKind.ShorthandPropertyAssignment);
Node.isSourceFile = Node.is(ts$1.SyntaxKind.SourceFile);
Node.isSpreadAssignment = Node.is(ts$1.SyntaxKind.SpreadAssignment);
Node.isSpreadElement = Node.is(ts$1.SyntaxKind.SpreadElement);
Node.isStringKeyword = Node.is(ts$1.SyntaxKind.StringKeyword);
Node.isStringLiteral = Node.is(ts$1.SyntaxKind.StringLiteral);
Node.isSwitchStatement = Node.is(ts$1.SyntaxKind.SwitchStatement);
Node.isSymbolKeyword = Node.is(ts$1.SyntaxKind.SymbolKeyword);
Node.isSyntaxList = Node.is(ts$1.SyntaxKind.SyntaxList);
Node.isTaggedTemplateExpression = Node.is(ts$1.SyntaxKind.TaggedTemplateExpression);
Node.isTemplateExpression = Node.is(ts$1.SyntaxKind.TemplateExpression);
Node.isTemplateHead = Node.is(ts$1.SyntaxKind.TemplateHead);
Node.isTemplateMiddle = Node.is(ts$1.SyntaxKind.TemplateMiddle);
Node.isTemplateSpan = Node.is(ts$1.SyntaxKind.TemplateSpan);
Node.isTemplateTail = Node.is(ts$1.SyntaxKind.TemplateTail);
Node.isThrowStatement = Node.is(ts$1.SyntaxKind.ThrowStatement);
Node.isTrueKeyword = Node.is(ts$1.SyntaxKind.TrueKeyword);
Node.isTryStatement = Node.is(ts$1.SyntaxKind.TryStatement);
Node.isTypeAliasDeclaration = Node.is(ts$1.SyntaxKind.TypeAliasDeclaration);
Node.isTypeOfExpression = Node.is(ts$1.SyntaxKind.TypeOfExpression);
Node.isUndefinedKeyword = Node.is(ts$1.SyntaxKind.UndefinedKeyword);
Node.isVariableDeclaration = Node.is(ts$1.SyntaxKind.VariableDeclaration);
Node.isVariableDeclarationList = Node.is(ts$1.SyntaxKind.VariableDeclarationList);
Node.isVariableStatement = Node.is(ts$1.SyntaxKind.VariableStatement);
Node.isVoidExpression = Node.is(ts$1.SyntaxKind.VoidExpression);
Node.isWhileStatement = Node.is(ts$1.SyntaxKind.WhileStatement);
Node.isWithStatement = Node.is(ts$1.SyntaxKind.WithStatement);
Node.isYieldExpression = Node.is(ts$1.SyntaxKind.YieldExpression);
function getWrappedCondition(thisNode, condition) {
    return condition == null ? undefined : ((c) => condition(thisNode._getNodeFromCompilerNode(c)));
}
function insertWhiteSpaceTextAtPos(node, insertPos, textOrWriterFunction, methodName) {
    const parent = Node.isSourceFile(node) ? node.getChildSyntaxListOrThrow() : node.getParentSyntaxList() || node.getParentOrThrow();
    const newText = getTextFromStringOrWriter(node._getWriterWithQueuedIndentation(), textOrWriterFunction);
    if (!/^[\s\r\n]*$/.test(newText))
        throw new errors.InvalidOperationError(`Cannot insert non-whitespace into ${methodName}.`);
    insertIntoParentTextRange({
        parent,
        insertPos,
        newText,
    });
}
function* getCompilerForEachDescendantsIterator(node) {
    for (const child of getForEachChildren()) {
        yield child;
        yield* getCompilerForEachDescendantsIterator(child);
    }
    function getForEachChildren() {
        const children = [];
        node.forEachChild(child => {
            children.push(child);
        });
        return children;
    }
}
function* getCompilerDescendantsIterator(node, sourceFile) {
    for (const child of ExtendedParser.getCompilerChildren(node, sourceFile)) {
        yield child;
        yield* getCompilerDescendantsIterator(child, sourceFile);
    }
}
function useParseTreeSearchForKind(thisNodeOrSyntaxKind, searchingKind) {
    return searchingKind >= ts$1.SyntaxKind.FirstNode && searchingKind < ts$1.SyntaxKind.FirstJSDocNode
        && getThisKind() !== ts$1.SyntaxKind.SyntaxList;
    function getThisKind() {
        if (typeof thisNodeOrSyntaxKind === "number")
            return thisNodeOrSyntaxKind;
        return thisNodeOrSyntaxKind.compilerNode.kind;
    }
}

(function(Scope) {
    Scope["Public"] = "public";
    Scope["Protected"] = "protected";
    Scope["Private"] = "private";
})(exports.Scope || (exports.Scope = {}));

class SyntaxList extends Node {
    addChildText(textOrWriterFunction) {
        return this.insertChildText(this.getChildCount(), textOrWriterFunction);
    }
    insertChildText(index, textOrWriterFunction) {
        const initialChildCount = this.getChildCount();
        const newLineKind = this._context.manipulationSettings.getNewLineKindAsString();
        const parent = this.getParentOrThrow();
        index = verifyAndGetIndex(index, initialChildCount);
        const isInline = this !== parent.getChildSyntaxList();
        let insertText = getTextFromStringOrWriter(isInline ? parent._getWriterWithQueuedChildIndentation() : parent._getWriterWithChildIndentation(), textOrWriterFunction);
        if (insertText.length === 0)
            return [];
        if (isInline) {
            if (index === 0)
                insertText += " ";
            else
                insertText = " " + insertText;
        }
        else {
            if (index === 0 && Node.isSourceFile(parent)) {
                if (!insertText.endsWith("\n"))
                    insertText += newLineKind;
            }
            else {
                insertText = newLineKind + insertText;
                if (!Node.isSourceFile(parent) && index === initialChildCount && insertText.endsWith("\n"))
                    insertText = insertText.replace(/\r?\n$/, "");
            }
        }
        const insertPos = getInsertPosFromIndex(index, this, this.getChildren());
        insertIntoParentTextRange({
            insertPos,
            newText: insertText,
            parent: this,
        });
        const finalChildren = this.getChildren();
        return getNodesToReturn(initialChildCount, finalChildren, index, true);
    }
}

function setBodyTextForNode(body, textOrWriterFunction) {
    const newText = getBodyText(body._getWriterWithIndentation(), textOrWriterFunction);
    const openBrace = body.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenBraceToken);
    const closeBrace = body.getFirstChildByKindOrThrow(ts$1.SyntaxKind.CloseBraceToken);
    insertIntoParentTextRange({
        insertPos: openBrace.getEnd(),
        newText,
        parent: body,
        replacing: {
            textLength: closeBrace.getStart() - openBrace.getEnd(),
        },
    });
}

function BodiedNode(Base) {
    return class extends Base {
        getBody() {
            const body = this.compilerNode.body;
            if (body == null)
                throw new errors.InvalidOperationError("Bodied node should have a body.");
            return this._getNodeFromCompilerNode(body);
        }
        setBodyText(textOrWriterFunction) {
            const body = this.getBody();
            setBodyTextForNode(body, textOrWriterFunction);
            return this;
        }
        getBodyText() {
            return getBodyTextWithoutLeadingIndentation(this.getBody());
        }
    };
}

function BodyableNode(Base) {
    return class extends Base {
        getBodyOrThrow() {
            return errors.throwIfNullOrUndefined(this.getBody(), "Expected to find the node's body.");
        }
        getBody() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.body);
        }
        getBodyText() {
            const body = this.getBody();
            return body == null ? undefined : getBodyTextWithoutLeadingIndentation(body);
        }
        setBodyText(textOrWriterFunction) {
            this.addBody();
            setBodyTextForNode(this.getBodyOrThrow(), textOrWriterFunction);
            return this;
        }
        hasBody() {
            return this.compilerNode.body != null;
        }
        addBody() {
            var _a;
            if (this.hasBody())
                return this;
            const semiColon = this.getLastChildByKind(ts$1.SyntaxKind.SemicolonToken);
            insertIntoParentTextRange({
                parent: this,
                insertPos: semiColon == null ? this.getEnd() : semiColon.getStart(),
                newText: this._getWriterWithQueuedIndentation().space().block().toString(),
                replacing: {
                    textLength: (_a = semiColon === null || semiColon === void 0 ? void 0 : semiColon.getFullWidth()) !== null && _a !== void 0 ? _a : 0,
                },
            });
            return this;
        }
        removeBody() {
            const body = this.getBody();
            if (body == null)
                return this;
            insertIntoParentTextRange({
                parent: this,
                insertPos: body.getPos(),
                newText: ";",
                replacing: {
                    textLength: body.getFullWidth(),
                },
            });
            return this;
        }
    };
}

function ChildOrderableNode(Base) {
    return class extends Base {
        setOrder(order) {
            const childIndex = this.getChildIndex();
            const parent = this.getParentSyntaxList() || this.getParentSyntaxListOrThrow();
            errors.throwIfOutOfRange(order, [0, parent.getChildCount() - 1], "order");
            if (childIndex === order)
                return this;
            changeChildOrder({
                parent,
                getSiblingFormatting: getGeneralFormatting,
                oldIndex: childIndex,
                newIndex: order,
            });
            return this;
        }
    };
}

function DecoratableNode(Base) {
    return class extends Base {
        getDecorator(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getDecorators(), nameOrFindFunction);
        }
        getDecoratorOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getDecorator(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("decorator", nameOrFindFunction));
        }
        getDecorators() {
            var _a, _b;
            return (_b = (_a = this.compilerNode.decorators) === null || _a === void 0 ? void 0 : _a.map(d => this._getNodeFromCompilerNode(d))) !== null && _b !== void 0 ? _b : [];
        }
        addDecorator(structure) {
            return this.insertDecorator(getEndIndexFromArray(this.compilerNode.decorators), structure);
        }
        addDecorators(structures) {
            return this.insertDecorators(getEndIndexFromArray(this.compilerNode.decorators), structures);
        }
        insertDecorator(index, structure) {
            return this.insertDecorators(index, [structure])[0];
        }
        insertDecorators(index, structures) {
            if (ArrayUtils.isNullOrEmpty(structures))
                return [];
            const decoratorLines = getDecoratorLines(this, structures);
            const decorators = this.getDecorators();
            index = verifyAndGetIndex(index, decorators.length);
            const formattingKind = getDecoratorFormattingKind(this, decorators);
            const previousDecorator = decorators[index - 1];
            const decoratorCode = getNewInsertCode({
                structures,
                newCodes: decoratorLines,
                parent: this,
                indentationText: this.getIndentationText(),
                getSeparator: () => formattingKind,
                previousFormattingKind: previousDecorator == null ? FormattingKind.None : formattingKind,
                nextFormattingKind: previousDecorator == null ? formattingKind : FormattingKind.None,
            });
            insertIntoParentTextRange({
                parent: decorators.length === 0 ? this : decorators[0].getParentSyntaxListOrThrow(),
                insertPos: decorators[index - 1] == null ? this.getStart() : decorators[index - 1].getEnd(),
                newText: decoratorCode,
            });
            return getNodesToReturn(decorators, this.getDecorators(), index, false);
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.decorators != null) {
                this.getDecorators().forEach(d => d.remove());
                this.addDecorators(structure.decorators);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                decorators: this.getDecorators().map(d => d.getStructure()),
            });
        }
    };
}
function getDecoratorLines(node, structures) {
    const lines = [];
    for (const structure of structures) {
        const writer = node._getWriter();
        const structurePrinter = node._context.structurePrinterFactory.forDecorator();
        structurePrinter.printText(writer, structure);
        lines.push(writer.toString());
    }
    return lines;
}
function getDecoratorFormattingKind(parent, currentDecorators) {
    const sameLine = areDecoratorsOnSameLine(parent, currentDecorators);
    return sameLine ? FormattingKind.Space : FormattingKind.Newline;
}
function areDecoratorsOnSameLine(parent, currentDecorators) {
    if (currentDecorators.length <= 1)
        return parent.getKind() === ts$1.SyntaxKind.Parameter;
    const startLinePos = currentDecorators[0].getStartLinePos();
    for (let i = 1; i < currentDecorators.length; i++) {
        if (currentDecorators[i].getStartLinePos() !== startLinePos)
            return false;
    }
    return true;
}

function ExclamationTokenableNode(Base) {
    return class extends Base {
        hasExclamationToken() {
            return this.compilerNode.exclamationToken != null;
        }
        getExclamationTokenNode() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.exclamationToken);
        }
        getExclamationTokenNodeOrThrow() {
            return errors.throwIfNullOrUndefined(this.getExclamationTokenNode(), "Expected to find an exclamation token.");
        }
        setHasExclamationToken(value) {
            const exclamationTokenNode = this.getExclamationTokenNode();
            const hasExclamationToken = exclamationTokenNode != null;
            if (value === hasExclamationToken)
                return this;
            if (value) {
                if (Node.isQuestionTokenableNode(this))
                    this.setHasQuestionToken(false);
                const colonNode = this.getFirstChildByKind(ts$1.SyntaxKind.ColonToken);
                if (colonNode == null)
                    throw new errors.InvalidOperationError("Cannot add an exclamation token to a node that does not have a type.");
                insertIntoParentTextRange({
                    insertPos: colonNode.getStart(),
                    parent: this,
                    newText: "!",
                });
            }
            else {
                removeChildren({ children: [exclamationTokenNode] });
            }
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.hasExclamationToken != null)
                this.setHasExclamationToken(structure.hasExclamationToken);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                hasExclamationToken: this.hasExclamationToken(),
            });
        }
    };
}

function ModifierableNode(Base) {
    return class extends Base {
        getModifiers() {
            return this.getCompilerModifiers().map(m => this._getNodeFromCompilerNode(m));
        }
        getFirstModifierByKindOrThrow(kind) {
            return errors.throwIfNullOrUndefined(this.getFirstModifierByKind(kind), `Expected a modifier of syntax kind: ${common.getSyntaxKindName(kind)}`);
        }
        getFirstModifierByKind(kind) {
            for (const modifier of this.getCompilerModifiers()) {
                if (modifier.kind === kind)
                    return this._getNodeFromCompilerNode(modifier);
            }
            return undefined;
        }
        hasModifier(textOrKind) {
            if (typeof textOrKind === "string")
                return this.getModifiers().some(m => m.getText() === textOrKind);
            else
                return this.getCompilerModifiers().some(m => m.kind === textOrKind);
        }
        toggleModifier(text, value) {
            if (value == null)
                value = !this.hasModifier(text);
            if (value)
                this.addModifier(text);
            else
                this.removeModifier(text);
            return this;
        }
        addModifier(text) {
            const modifiers = this.getModifiers();
            const existingModifier = modifiers.find(m => m.getText() === text);
            if (existingModifier != null)
                return existingModifier;
            const insertPos = getInsertPos(this);
            let startPos;
            let newText;
            const isFirstModifier = modifiers.length === 0 || insertPos === modifiers[0].getStart();
            if (isFirstModifier) {
                newText = text + " ";
                startPos = insertPos;
            }
            else {
                newText = " " + text;
                startPos = insertPos + 1;
            }
            insertIntoParentTextRange({
                parent: modifiers.length === 0 ? this : modifiers[0].getParentSyntaxListOrThrow(),
                insertPos,
                newText,
            });
            return this.getModifiers().find(m => m.getStart() === startPos);
            function getInsertPos(node) {
                let pos = getInitialInsertPos();
                for (const addAfterText of getAddAfterModifierTexts(text)) {
                    for (let i = 0; i < modifiers.length; i++) {
                        const modifier = modifiers[i];
                        if (modifier.getText() === addAfterText) {
                            if (pos < modifier.getEnd())
                                pos = modifier.getEnd();
                            break;
                        }
                    }
                }
                return pos;
                function getInitialInsertPos() {
                    if (modifiers.length > 0)
                        return modifiers[0].getStart();
                    for (const child of node._getChildrenIterator()) {
                        if (child.getKind() === ts$1.SyntaxKind.SyntaxList || ts$1.isJSDocCommentContainingNode(child.compilerNode))
                            continue;
                        return child.getStart();
                    }
                    return node.getStart();
                }
            }
        }
        removeModifier(text) {
            const modifiers = this.getModifiers();
            const modifier = modifiers.find(m => m.getText() === text);
            if (modifier == null)
                return false;
            removeChildren({
                children: [modifiers.length === 1 ? modifier.getParentSyntaxListOrThrow() : modifier],
                removeFollowingSpaces: true,
            });
            return true;
        }
        getCompilerModifiers() {
            return this.compilerNode.modifiers || [];
        }
    };
}
function getAddAfterModifierTexts(text) {
    switch (text) {
        case "export":
            return [];
        case "default":
            return ["export"];
        case "declare":
            return ["export", "default"];
        case "abstract":
            return ["export", "default", "declare", "public", "private", "protected"];
        case "readonly":
            return ["export", "default", "declare", "public", "private", "protected", "abstract", "static"];
        case "public":
        case "protected":
        case "private":
            return [];
        case "static":
            return ["public", "protected", "private"];
        case "async":
            return ["export", "public", "protected", "private", "static", "abstract"];
        case "const":
            return [];
        default:
            throw new errors.NotImplementedError(`Not implemented modifier: ${text}`);
    }
}

function ExportGetableNode(Base) {
    return class extends Base {
        hasExportKeyword() {
            return this.getExportKeyword() != null;
        }
        getExportKeyword() {
            if (Node.isVariableDeclaration(this)) {
                const variableStatement = this.getVariableStatement();
                return variableStatement === null || variableStatement === void 0 ? void 0 : variableStatement.getExportKeyword();
            }
            if (!Node.isModifierableNode(this))
                return throwForNotModifierableNode();
            return this.getFirstModifierByKind(ts$1.SyntaxKind.ExportKeyword);
        }
        getExportKeywordOrThrow() {
            return errors.throwIfNullOrUndefined(this.getExportKeyword(), "Expected to find an export keyword.");
        }
        hasDefaultKeyword() {
            return this.getDefaultKeyword() != null;
        }
        getDefaultKeyword() {
            if (Node.isVariableDeclaration(this)) {
                const variableStatement = this.getVariableStatement();
                return variableStatement === null || variableStatement === void 0 ? void 0 : variableStatement.getDefaultKeyword();
            }
            if (!Node.isModifierableNode(this))
                return throwForNotModifierableNode();
            return this.getFirstModifierByKind(ts$1.SyntaxKind.DefaultKeyword);
        }
        getDefaultKeywordOrThrow() {
            return errors.throwIfNullOrUndefined(this.getDefaultKeyword(), "Expected to find a default keyword.");
        }
        isExported() {
            if (this.hasExportKeyword())
                return true;
            const thisSymbol = this.getSymbol();
            const sourceFileSymbol = this.getSourceFile().getSymbol();
            if (thisSymbol == null || sourceFileSymbol == null)
                return false;
            return sourceFileSymbol.getExports().some(e => e === thisSymbol || e.getAliasedSymbol() === thisSymbol);
        }
        isDefaultExport() {
            if (this.hasDefaultKeyword())
                return true;
            const thisSymbol = this.getSymbol();
            if (thisSymbol == null)
                return false;
            const defaultExportSymbol = this.getSourceFile().getDefaultExportSymbol();
            if (defaultExportSymbol == null)
                return false;
            if (thisSymbol === defaultExportSymbol)
                return true;
            const aliasedSymbol = defaultExportSymbol.getAliasedSymbol();
            return thisSymbol === aliasedSymbol;
        }
        isNamedExport() {
            const thisSymbol = this.getSymbol();
            const sourceFileSymbol = this.getSourceFile().getSymbol();
            if (thisSymbol == null || sourceFileSymbol == null)
                return false;
            return !isDefaultExport() && sourceFileSymbol.getExports().some(e => e === thisSymbol || e.getAliasedSymbol() === thisSymbol);
            function isDefaultExport() {
                const defaultExportSymbol = sourceFileSymbol.getExport("default");
                if (defaultExportSymbol == null)
                    return false;
                return thisSymbol === defaultExportSymbol || thisSymbol === defaultExportSymbol.getAliasedSymbol();
            }
        }
    };
}
function throwForNotModifierableNode() {
    throw new errors.NotImplementedError(`Not implemented situation where node was not a ${"ModifierableNode"}.`);
}

function ExportableNode(Base) {
    return apply(ExportGetableNode(Base));
}
function apply(Base) {
    return class extends Base {
        setIsDefaultExport(value) {
            if (value === this.isDefaultExport())
                return this;
            if (value && !Node.isSourceFile(this.getParentOrThrow()))
                throw new errors.InvalidOperationError("The parent must be a source file in order to set this node as a default export.");
            const sourceFile = this.getSourceFile();
            const fileDefaultExportSymbol = sourceFile.getDefaultExportSymbol();
            if (fileDefaultExportSymbol != null)
                sourceFile.removeDefaultExport(fileDefaultExportSymbol);
            if (!value)
                return this;
            if (Node.hasName(this) && shouldWriteAsSeparateStatement.call(this)) {
                const parentSyntaxList = this.getFirstAncestorByKindOrThrow(ts$1.SyntaxKind.SyntaxList);
                const name = this.getName();
                parentSyntaxList.insertChildText(this.getChildIndex() + 1, writer => {
                    writer.newLine().write(`export default ${name};`);
                });
            }
            else {
                this.addModifier("export");
                this.addModifier("default");
            }
            return this;
            function shouldWriteAsSeparateStatement() {
                if (Node.isEnumDeclaration(this) || Node.isNamespaceDeclaration(this) || Node.isTypeAliasDeclaration(this))
                    return true;
                if (Node.isAmbientableNode(this) && this.isAmbient())
                    return true;
                return false;
            }
        }
        setIsExported(value) {
            if (Node.isSourceFile(this.getParentOrThrow()))
                this.toggleModifier("default", false);
            this.toggleModifier("export", value);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.isExported != null)
                this.setIsExported(structure.isExported);
            if (structure.isDefaultExport != null)
                this.setIsDefaultExport(structure.isDefaultExport);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                isExported: this.hasExportKeyword(),
                isDefaultExport: this.hasDefaultKeyword(),
            });
        }
    };
}

class Printer {
    printTextOrWriterFunc(writer, textOrWriterFunc) {
        if (typeof textOrWriterFunc === "string")
            writer.write(textOrWriterFunc);
        else if (textOrWriterFunc != null)
            textOrWriterFunc(writer);
    }
    getNewWriter(writer) {
        return new CodeBlockWriter(writer.getOptions());
    }
    getNewWriterWithQueuedChildIndentation(writer) {
        const newWriter = new CodeBlockWriter(writer.getOptions());
        newWriter.queueIndentationLevel(1);
        return newWriter;
    }
    getText(writer, textOrWriterFunc) {
        const newWriter = this.getNewWriter(writer);
        this.printTextOrWriterFunc(newWriter, textOrWriterFunc);
        return newWriter.toString();
    }
    getTextWithQueuedChildIndentation(writer, textOrWriterFunc) {
        const queuedChildIndentationWriter = this.getNewWriterWithQueuedChildIndentation(writer);
        this.printTextOrWriterFunc(queuedChildIndentationWriter, textOrWriterFunc);
        return queuedChildIndentationWriter.toString();
    }
}

class InitializerExpressionableNodeStructurePrinter extends Printer {
    printText(writer, structure) {
        const { initializer } = structure;
        if (initializer == null)
            return;
        const initializerText = this.getText(writer, initializer);
        if (!StringUtils.isNullOrWhitespace(initializerText)) {
            writer.hangingIndent(() => {
                writer.spaceIfLastNot();
                writer.write(`= ${initializerText}`);
            });
        }
    }
}

class ModifierableNodeStructurePrinter extends Printer {
    printText(writer, structure) {
        const scope = structure.scope;
        if (structure.isDefaultExport)
            writer.write("export default ");
        else if (structure.isExported)
            writer.write("export ");
        if (structure.hasDeclareKeyword)
            writer.write("declare ");
        if (scope != null)
            writer.write(`${scope} `);
        if (structure.isAbstract)
            writer.write("abstract ");
        if (structure.isStatic)
            writer.write("static ");
        if (structure.isAsync)
            writer.write("async ");
        if (structure.isReadonly)
            writer.write("readonly ");
    }
}

class ReturnTypedNodeStructurePrinter extends Printer {
    constructor(alwaysWrite = false) {
        super();
        this.alwaysWrite = alwaysWrite;
    }
    printText(writer, structure) {
        let { returnType } = structure;
        if (returnType == null && this.alwaysWrite === false)
            return;
        returnType = returnType !== null && returnType !== void 0 ? returnType : "void";
        const returnTypeText = this.getText(writer, returnType);
        if (!StringUtils.isNullOrWhitespace(returnTypeText)) {
            writer.hangingIndent(() => {
                writer.write(`: ${returnTypeText}`);
            });
        }
    }
}

class TypedNodeStructurePrinter extends Printer {
    constructor(separator, alwaysWrite = false) {
        super();
        this.separator = separator;
        this.alwaysWrite = alwaysWrite;
    }
    printText(writer, structure) {
        let { type } = structure;
        if (type == null && this.alwaysWrite === false)
            return;
        type = type !== null && type !== void 0 ? type : "any";
        const typeText = this.getText(writer, type);
        if (!StringUtils.isNullOrWhitespace(typeText)) {
            writer.hangingIndent(() => {
                writer.write(`${this.separator} ${typeText}`);
            });
        }
    }
}

class NodePrinter extends Printer {
    constructor(factory) {
        super();
        this.factory = factory;
    }
    printTextWithoutTrivia(writer, structure) {
        this.printTextInternal(writer, structure);
    }
    printText(writer, structure) {
        this.printLeadingTrivia(writer, structure);
        writer.closeComment();
        this.printTextInternal(writer, structure);
        this.printTrailingTrivia(writer, structure);
    }
    printLeadingTrivia(writer, structure) {
        const leadingTrivia = structure["leadingTrivia"];
        if (leadingTrivia != null) {
            this.printTrivia(writer, leadingTrivia);
            if (writer.isInComment())
                writer.closeComment();
        }
    }
    printTrailingTrivia(writer, structure) {
        const trailingTrivia = structure["trailingTrivia"];
        if (trailingTrivia != null)
            this.printTrivia(writer, trailingTrivia);
    }
    printTrivia(writer, trivia) {
        if (trivia instanceof Array) {
            for (let i = 0; i < trivia.length; i++) {
                this.printTextOrWriterFunc(writer, trivia[i]);
                if (i !== trivia.length - 1)
                    writer.newLineIfLastNot();
            }
        }
        else {
            this.printTextOrWriterFunc(writer, trivia);
        }
    }
}

class BlankLineFormattingStructuresPrinter extends Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            writer.conditionalBlankLine(i > 0);
            this.printer.printText(writer, structures[i]);
        }
    }
}

class CommaSeparatedStructuresPrinter extends Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        printTextWithSeparator(this.printer, writer, structures, () => writer.spaceIfLastNot());
    }
}
function printTextWithSeparator(printer, writer, structures, separator) {
    if (structures == null)
        return;
    if (structures instanceof Function || typeof structures === "string")
        printer.printText(writer, structures);
    else {
        const commaAppendPositions = new Array(structures.length);
        for (let i = 0; i < structures.length; i++) {
            if (i > 0)
                separator();
            const structure = structures[i];
            const startPos = writer.getLength();
            printer.printText(writer, structure);
            const pos = getAppendCommaPos(WriterUtils.getLastCharactersToPos(writer, startPos));
            commaAppendPositions[i] = pos === -1 ? false : pos + startPos;
        }
        let foundFirst = false;
        for (let i = commaAppendPositions.length - 1; i >= 0; i--) {
            const pos = commaAppendPositions[i];
            if (pos === false)
                continue;
            else if (!foundFirst)
                foundFirst = true;
            else
                writer.unsafeInsert(pos, ",");
        }
    }
}

class CommaNewLineSeparatedStructuresPrinter extends Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        printTextWithSeparator(this.printer, writer, structures, () => writer.newLineIfLastNot());
    }
}

class NewLineFormattingStructuresPrinter extends Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            writer.conditionalNewLine(i > 0);
            this.printer.printText(writer, structures[i]);
        }
    }
}

class SpaceFormattingStructuresPrinter extends Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            writer.conditionalWrite(i > 0, " ");
            this.printer.printText(writer, structures[i]);
        }
    }
}

class ClassDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
        this.multipleWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        const isAmbient = structure.hasDeclareKeyword || this.options.isAmbient;
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forDecorator().printTexts(writer, structure.decorators);
        this.printHeader(writer, structure);
        writer.inlineBlock(() => {
            this.factory.forPropertyDeclaration().printTexts(writer, structure.properties);
            this.printCtors(writer, structure, isAmbient);
            this.printGetAndSet(writer, structure, isAmbient);
            if (!ArrayUtils.isNullOrEmpty(structure.methods)) {
                this.conditionalSeparator(writer, isAmbient);
                this.factory.forMethodDeclaration({ isAmbient }).printTexts(writer, structure.methods);
            }
        });
    }
    printHeader(writer, structure) {
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`class`);
        if (!StringUtils.isNullOrWhitespace(structure.name))
            writer.space().write(structure.name);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        writer.space();
        writer.hangingIndent(() => {
            if (structure.extends != null) {
                const extendsText = this.getText(writer, structure.extends);
                if (!StringUtils.isNullOrWhitespace(extendsText))
                    writer.write(`extends ${extendsText} `);
            }
            if (structure.implements != null) {
                const implementsText = structure.implements instanceof Array
                    ? structure.implements.map(i => this.getText(writer, i)).join(", ")
                    : this.getText(writer, structure.implements);
                if (!StringUtils.isNullOrWhitespace(implementsText))
                    writer.write(`implements ${implementsText} `);
            }
        });
    }
    printCtors(writer, structure, isAmbient) {
        if (ArrayUtils.isNullOrEmpty(structure.ctors))
            return;
        for (const ctor of structure.ctors) {
            this.conditionalSeparator(writer, isAmbient);
            this.factory.forConstructorDeclaration({ isAmbient }).printText(writer, ctor);
        }
    }
    printGetAndSet(writer, structure, isAmbient) {
        var _a, _b;
        const getAccessors = [...(_a = structure.getAccessors) !== null && _a !== void 0 ? _a : []];
        const setAccessors = [...(_b = structure.setAccessors) !== null && _b !== void 0 ? _b : []];
        const getAccessorWriter = this.factory.forGetAccessorDeclaration({ isAmbient });
        const setAccessorWriter = this.factory.forSetAccessorDeclaration({ isAmbient });
        for (const getAccessor of getAccessors) {
            this.conditionalSeparator(writer, isAmbient);
            getAccessorWriter.printText(writer, getAccessor);
            const setAccessorIndex = setAccessors.findIndex(item => item.name === getAccessor.name);
            if (setAccessorIndex >= 0) {
                this.conditionalSeparator(writer, isAmbient);
                setAccessorWriter.printText(writer, setAccessors[setAccessorIndex]);
                setAccessors.splice(setAccessorIndex, 1);
            }
        }
        for (const setAccessor of setAccessors) {
            this.conditionalSeparator(writer, isAmbient);
            setAccessorWriter.printText(writer, setAccessor);
        }
    }
    conditionalSeparator(writer, isAmbient) {
        if (writer.isAtStartOfFirstLineOfBlock())
            return;
        if (isAmbient)
            writer.newLine();
        else
            writer.blankLine();
    }
}

(function(StructureKind) {
    StructureKind[StructureKind["CallSignature"] = 0] = "CallSignature";
    StructureKind[StructureKind["Class"] = 1] = "Class";
    StructureKind[StructureKind["ConstructSignature"] = 2] = "ConstructSignature";
    StructureKind[StructureKind["Constructor"] = 3] = "Constructor";
    StructureKind[StructureKind["ConstructorOverload"] = 4] = "ConstructorOverload";
    StructureKind[StructureKind["Decorator"] = 5] = "Decorator";
    StructureKind[StructureKind["Enum"] = 6] = "Enum";
    StructureKind[StructureKind["EnumMember"] = 7] = "EnumMember";
    StructureKind[StructureKind["ExportAssignment"] = 8] = "ExportAssignment";
    StructureKind[StructureKind["ExportDeclaration"] = 9] = "ExportDeclaration";
    StructureKind[StructureKind["ExportSpecifier"] = 10] = "ExportSpecifier";
    StructureKind[StructureKind["Function"] = 11] = "Function";
    StructureKind[StructureKind["FunctionOverload"] = 12] = "FunctionOverload";
    StructureKind[StructureKind["GetAccessor"] = 13] = "GetAccessor";
    StructureKind[StructureKind["ImportDeclaration"] = 14] = "ImportDeclaration";
    StructureKind[StructureKind["ImportSpecifier"] = 15] = "ImportSpecifier";
    StructureKind[StructureKind["IndexSignature"] = 16] = "IndexSignature";
    StructureKind[StructureKind["Interface"] = 17] = "Interface";
    StructureKind[StructureKind["JsxAttribute"] = 18] = "JsxAttribute";
    StructureKind[StructureKind["JsxSpreadAttribute"] = 19] = "JsxSpreadAttribute";
    StructureKind[StructureKind["JsxElement"] = 20] = "JsxElement";
    StructureKind[StructureKind["JsxSelfClosingElement"] = 21] = "JsxSelfClosingElement";
    StructureKind[StructureKind["JSDoc"] = 22] = "JSDoc";
    StructureKind[StructureKind["JSDocTag"] = 23] = "JSDocTag";
    StructureKind[StructureKind["Method"] = 24] = "Method";
    StructureKind[StructureKind["MethodOverload"] = 25] = "MethodOverload";
    StructureKind[StructureKind["MethodSignature"] = 26] = "MethodSignature";
    StructureKind[StructureKind["Namespace"] = 27] = "Namespace";
    StructureKind[StructureKind["Parameter"] = 28] = "Parameter";
    StructureKind[StructureKind["Property"] = 29] = "Property";
    StructureKind[StructureKind["PropertyAssignment"] = 30] = "PropertyAssignment";
    StructureKind[StructureKind["PropertySignature"] = 31] = "PropertySignature";
    StructureKind[StructureKind["SetAccessor"] = 32] = "SetAccessor";
    StructureKind[StructureKind["ShorthandPropertyAssignment"] = 33] = "ShorthandPropertyAssignment";
    StructureKind[StructureKind["SourceFile"] = 34] = "SourceFile";
    StructureKind[StructureKind["SpreadAssignment"] = 35] = "SpreadAssignment";
    StructureKind[StructureKind["TypeAlias"] = 36] = "TypeAlias";
    StructureKind[StructureKind["TypeParameter"] = 37] = "TypeParameter";
    StructureKind[StructureKind["VariableDeclaration"] = 38] = "VariableDeclaration";
    StructureKind[StructureKind["VariableStatement"] = 39] = "VariableStatement";
})(exports.StructureKind || (exports.StructureKind = {}));

const Structure = {
    hasName(structure) {
        return typeof structure.name === "string";
    },
    isClass(structure) {
        return structure.kind === exports.StructureKind.Class;
    },
    isClassLikeDeclarationBase(structure) {
        return structure.kind === exports.StructureKind.Class;
    },
    isNameable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.Function:
                return true;
            default:
                return false;
        }
    },
    isImplementsClauseable(structure) {
        return structure.kind === exports.StructureKind.Class;
    },
    isDecoratable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Parameter:
                return true;
            default:
                return false;
        }
    },
    isTypeParametered(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.CallSignature:
            case exports.StructureKind.ConstructSignature:
            case exports.StructureKind.Interface:
            case exports.StructureKind.MethodSignature:
            case exports.StructureKind.TypeAlias:
                return true;
            default:
                return false;
        }
    },
    isJSDocable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Enum:
            case exports.StructureKind.EnumMember:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.CallSignature:
            case exports.StructureKind.ConstructSignature:
            case exports.StructureKind.IndexSignature:
            case exports.StructureKind.Interface:
            case exports.StructureKind.MethodSignature:
            case exports.StructureKind.PropertySignature:
            case exports.StructureKind.Namespace:
            case exports.StructureKind.VariableStatement:
            case exports.StructureKind.TypeAlias:
                return true;
            default:
                return false;
        }
    },
    isAbstractable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
                return true;
            default:
                return false;
        }
    },
    isAmbientable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.Property:
            case exports.StructureKind.Enum:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.Interface:
            case exports.StructureKind.Namespace:
            case exports.StructureKind.VariableStatement:
            case exports.StructureKind.TypeAlias:
                return true;
            default:
                return false;
        }
    },
    isExportable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Class:
            case exports.StructureKind.Enum:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.Interface:
            case exports.StructureKind.Namespace:
            case exports.StructureKind.VariableStatement:
            case exports.StructureKind.TypeAlias:
                return true;
            default:
                return false;
        }
    },
    isConstructor(structure) {
        return structure.kind === exports.StructureKind.Constructor;
    },
    isScoped(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
                return true;
            default:
                return false;
        }
    },
    isFunctionLike(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Constructor:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
                return true;
            default:
                return false;
        }
    },
    isSignatured(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.CallSignature:
            case exports.StructureKind.ConstructSignature:
            case exports.StructureKind.MethodSignature:
                return true;
            default:
                return false;
        }
    },
    isParametered(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.CallSignature:
            case exports.StructureKind.ConstructSignature:
            case exports.StructureKind.MethodSignature:
                return true;
            default:
                return false;
        }
    },
    isReturnTyped(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Constructor:
            case exports.StructureKind.ConstructorOverload:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
            case exports.StructureKind.CallSignature:
            case exports.StructureKind.ConstructSignature:
            case exports.StructureKind.IndexSignature:
            case exports.StructureKind.MethodSignature:
                return true;
            default:
                return false;
        }
    },
    isStatemented(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Constructor:
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.Function:
            case exports.StructureKind.Namespace:
            case exports.StructureKind.SourceFile:
                return true;
            default:
                return false;
        }
    },
    isConstructorDeclarationOverload(structure) {
        return structure.kind === exports.StructureKind.ConstructorOverload;
    },
    isGetAccessor(structure) {
        return structure.kind === exports.StructureKind.GetAccessor;
    },
    isPropertyNamed(structure) {
        switch (structure.kind) {
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
            case exports.StructureKind.EnumMember:
            case exports.StructureKind.MethodSignature:
            case exports.StructureKind.PropertySignature:
            case exports.StructureKind.PropertyAssignment:
                return true;
            default:
                return false;
        }
    },
    isStaticable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.GetAccessor:
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.SetAccessor:
                return true;
            default:
                return false;
        }
    },
    isMethod(structure) {
        return structure.kind === exports.StructureKind.Method;
    },
    isAsyncable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
                return true;
            default:
                return false;
        }
    },
    isGeneratorable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Function:
            case exports.StructureKind.FunctionOverload:
                return true;
            default:
                return false;
        }
    },
    isQuestionTokenable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Method:
            case exports.StructureKind.MethodOverload:
            case exports.StructureKind.Property:
            case exports.StructureKind.Parameter:
            case exports.StructureKind.MethodSignature:
            case exports.StructureKind.PropertySignature:
                return true;
            default:
                return false;
        }
    },
    isMethodDeclarationOverload(structure) {
        return structure.kind === exports.StructureKind.MethodOverload;
    },
    isProperty(structure) {
        return structure.kind === exports.StructureKind.Property;
    },
    isTyped(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Property:
            case exports.StructureKind.Parameter:
            case exports.StructureKind.PropertySignature:
            case exports.StructureKind.VariableDeclaration:
            case exports.StructureKind.TypeAlias:
                return true;
            default:
                return false;
        }
    },
    isExclamationTokenable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Property:
            case exports.StructureKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    },
    isReadonlyable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Property:
            case exports.StructureKind.Parameter:
            case exports.StructureKind.IndexSignature:
            case exports.StructureKind.PropertySignature:
                return true;
            default:
                return false;
        }
    },
    isInitializerExpressionable(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Property:
            case exports.StructureKind.EnumMember:
            case exports.StructureKind.Parameter:
            case exports.StructureKind.PropertySignature:
            case exports.StructureKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    },
    isSetAccessor(structure) {
        return structure.kind === exports.StructureKind.SetAccessor;
    },
    isDecorator(structure) {
        return structure.kind === exports.StructureKind.Decorator;
    },
    isJSDoc(structure) {
        return structure.kind === exports.StructureKind.JSDoc;
    },
    isJSDocTag(structure) {
        return structure.kind === exports.StructureKind.JSDocTag;
    },
    isEnum(structure) {
        return structure.kind === exports.StructureKind.Enum;
    },
    isNamed(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Enum:
            case exports.StructureKind.Interface:
            case exports.StructureKind.JsxAttribute:
            case exports.StructureKind.Namespace:
            case exports.StructureKind.TypeAlias:
            case exports.StructureKind.TypeParameter:
            case exports.StructureKind.ShorthandPropertyAssignment:
                return true;
            default:
                return false;
        }
    },
    isEnumMember(structure) {
        return structure.kind === exports.StructureKind.EnumMember;
    },
    isFunction(structure) {
        return structure.kind === exports.StructureKind.Function;
    },
    isFunctionDeclarationOverload(structure) {
        return structure.kind === exports.StructureKind.FunctionOverload;
    },
    isParameter(structure) {
        return structure.kind === exports.StructureKind.Parameter;
    },
    isBindingNamed(structure) {
        switch (structure.kind) {
            case exports.StructureKind.Parameter:
            case exports.StructureKind.VariableDeclaration:
                return true;
            default:
                return false;
        }
    },
    isScopeable(structure) {
        return structure.kind === exports.StructureKind.Parameter;
    },
    isCallSignature(structure) {
        return structure.kind === exports.StructureKind.CallSignature;
    },
    isConstructSignature(structure) {
        return structure.kind === exports.StructureKind.ConstructSignature;
    },
    isIndexSignature(structure) {
        return structure.kind === exports.StructureKind.IndexSignature;
    },
    isInterface(structure) {
        return structure.kind === exports.StructureKind.Interface;
    },
    isExtendsClauseable(structure) {
        return structure.kind === exports.StructureKind.Interface;
    },
    isTypeElementMembered(structure) {
        return structure.kind === exports.StructureKind.Interface;
    },
    isMethodSignature(structure) {
        return structure.kind === exports.StructureKind.MethodSignature;
    },
    isPropertySignature(structure) {
        return structure.kind === exports.StructureKind.PropertySignature;
    },
    isJsxAttribute(structure) {
        return structure.kind === exports.StructureKind.JsxAttribute;
    },
    isJsxElement(structure) {
        return structure.kind === exports.StructureKind.JsxElement;
    },
    isJsxSelfClosingElement(structure) {
        return structure.kind === exports.StructureKind.JsxSelfClosingElement;
    },
    isJsxTagNamed(structure) {
        return structure.kind === exports.StructureKind.JsxSelfClosingElement;
    },
    isJsxAttributed(structure) {
        return structure.kind === exports.StructureKind.JsxSelfClosingElement;
    },
    isJsxSpreadAttribute(structure) {
        return structure.kind === exports.StructureKind.JsxSpreadAttribute;
    },
    isExportAssignment(structure) {
        return structure.kind === exports.StructureKind.ExportAssignment;
    },
    isExportDeclaration(structure) {
        return structure.kind === exports.StructureKind.ExportDeclaration;
    },
    isExportSpecifier(structure) {
        return structure.kind === exports.StructureKind.ExportSpecifier;
    },
    isImportDeclaration(structure) {
        return structure.kind === exports.StructureKind.ImportDeclaration;
    },
    isImportSpecifier(structure) {
        return structure.kind === exports.StructureKind.ImportSpecifier;
    },
    isNamespace(structure) {
        return structure.kind === exports.StructureKind.Namespace;
    },
    isSourceFile(structure) {
        return structure.kind === exports.StructureKind.SourceFile;
    },
    isVariableDeclaration(structure) {
        return structure.kind === exports.StructureKind.VariableDeclaration;
    },
    isVariableStatement(structure) {
        return structure.kind === exports.StructureKind.VariableStatement;
    },
    isTypeAlias(structure) {
        return structure.kind === exports.StructureKind.TypeAlias;
    },
    isTypeParameter(structure) {
        return structure.kind === exports.StructureKind.TypeParameter;
    },
    isPropertyAssignment(structure) {
        return structure.kind === exports.StructureKind.PropertyAssignment;
    },
    isShorthandPropertyAssignment(structure) {
        return structure.kind === exports.StructureKind.ShorthandPropertyAssignment;
    },
    isSpreadAssignment(structure) {
        return structure.kind === exports.StructureKind.SpreadAssignment;
    },
    isExpressioned(structure) {
        return structure.kind === exports.StructureKind.SpreadAssignment;
    }
};

function isLastNonWhitespaceCharCloseBrace(writer) {
    return writer.iterateLastCharCodes(charCode => {
        if (charCode === CharCodes$1.CLOSE_BRACE)
            return true;
        else if (StringUtils.isWhitespaceCharCode(charCode))
            return undefined;
        else
            return false;
    }) || false;
}

class ClassMemberStructurePrinter extends Printer {
    constructor(factory, options) {
        super();
        this.factory = factory;
        this.options = options;
    }
    printTexts(writer, members) {
        if (members == null)
            return;
        if (typeof members === "string" || members instanceof Function)
            this.printText(writer, members);
        else {
            for (const member of members) {
                if (isLastNonWhitespaceCharCloseBrace(writer))
                    writer.blankLineIfLastNot();
                else if (!writer.isAtStartOfFirstLineOfBlock())
                    writer.newLineIfLastNot();
                this.printText(writer, member);
            }
        }
    }
    printText(writer, member) {
        if (typeof member === "string" || member instanceof Function || member == null) {
            this.printTextOrWriterFunc(writer, member);
            return;
        }
        switch (member.kind) {
            case exports.StructureKind.Method:
                if (!this.options.isAmbient)
                    ensureBlankLine();
                this.factory.forMethodDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.Property:
                this.factory.forPropertyDeclaration().printText(writer, member);
                break;
            case exports.StructureKind.GetAccessor:
                if (!this.options.isAmbient)
                    ensureBlankLine();
                this.factory.forGetAccessorDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.SetAccessor:
                if (!this.options.isAmbient)
                    ensureBlankLine();
                this.factory.forSetAccessorDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.Constructor:
                if (!this.options.isAmbient)
                    ensureBlankLine();
                this.factory.forConstructorDeclaration(this.options).printText(writer, member);
                break;
            default:
                errors.throwNotImplementedForNeverValueError(member);
        }
        function ensureBlankLine() {
            if (!writer.isAtStartOfFirstLineOfBlock())
                writer.blankLineIfLastNot();
        }
    }
}

class ConstructorDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
    }
    printTexts(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            if (i > 0) {
                if (this.options.isAmbient)
                    writer.newLine();
                else
                    writer.blankLine();
            }
            this.printText(writer, structures[i]);
        }
    }
    printTextInternal(writer, structure) {
        this.printOverloads(writer, getOverloadStructures());
        this.printHeader(writer, structure);
        if (this.options.isAmbient)
            writer.write(";");
        else {
            writer.space().inlineBlock(() => {
                this.factory.forStatementedNode(this.options).printText(writer, structure);
            });
        }
        function getOverloadStructures() {
            const overloads = common.ObjectUtils.clone(structure.overloads);
            if (overloads == null || overloads.length === 0)
                return;
            for (const overload of overloads)
                setValueIfUndefined(overload, "scope", structure.scope);
            return overloads;
        }
    }
    printOverloads(writer, structures) {
        if (structures == null || structures.length === 0)
            return;
        for (const structure of structures) {
            this.printOverload(writer, structure);
            writer.newLine();
        }
    }
    printOverload(writer, structure) {
        this.printHeader(writer, structure);
        writer.write(";");
    }
    printHeader(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write("constructor");
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
    }
}

class GetAccessorDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
        this.blankLineWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.blankLineWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forDecorator().printTexts(writer, structure.decorators);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`get ${structure.name}`);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
        if (this.options.isAmbient || structure.isAbstract)
            writer.write(";");
        else {
            writer.spaceIfLastNot().inlineBlock(() => {
                this.factory.forStatementedNode(this.options).printText(writer, structure);
            });
        }
    }
}

class MethodDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
    }
    printTexts(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            if (i > 0) {
                if (this.options.isAmbient)
                    writer.newLine();
                else
                    writer.blankLine();
            }
            this.printText(writer, structures[i]);
        }
    }
    printTextInternal(writer, structure) {
        this.printOverloads(writer, structure.name, getOverloadStructures());
        this.printHeader(writer, structure.name, structure);
        if (this.options.isAmbient || structure.isAbstract)
            writer.write(";");
        else {
            writer.spaceIfLastNot().inlineBlock(() => {
                this.factory.forStatementedNode(this.options).printText(writer, structure);
            });
        }
        function getOverloadStructures() {
            const overloads = common.ObjectUtils.clone(structure.overloads);
            if (overloads == null || overloads.length === 0)
                return;
            for (const overload of overloads) {
                setValueIfUndefined(overload, "scope", structure.scope);
                setValueIfUndefined(overload, "isStatic", structure.isStatic);
                setValueIfUndefined(overload, "isAbstract", structure.isAbstract);
                setValueIfUndefined(overload, "hasQuestionToken", structure.hasQuestionToken);
            }
            return overloads;
        }
    }
    printOverloads(writer, name, structures) {
        if (structures == null || structures.length === 0)
            return;
        for (const structure of structures) {
            this.printOverload(writer, name, structure);
            writer.newLine();
        }
    }
    printOverload(writer, name, structure) {
        this.printHeader(writer, name, structure);
        writer.write(";");
    }
    printHeader(writer, name, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        if (structure.decorators != null)
            this.factory.forDecorator().printTexts(writer, structure.decorators);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(name);
        writer.conditionalWrite(structure.hasQuestionToken, "?");
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
    }
}

class PropertyDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forDecorator().printTexts(writer, structure.decorators);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(structure.name);
        writer.conditionalWrite(structure.hasQuestionToken, "?");
        writer.conditionalWrite(structure.hasExclamationToken && !structure.hasQuestionToken, "!");
        this.factory.forTypedNode(":").printText(writer, structure);
        this.factory.forInitializerExpressionableNode().printText(writer, structure);
        writer.write(";");
    }
}

class SetAccessorDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
        this.multipleWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forDecorator().printTexts(writer, structure.decorators);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`set ${structure.name}`);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
        if (this.options.isAmbient || structure.isAbstract)
            writer.write(";");
        else {
            writer.spaceIfLastNot().inlineBlock(() => {
                this.factory.forStatementedNode(this.options).printText(writer, structure);
            });
        }
    }
}

class StringStructurePrinter extends Printer {
    printText(writer, textOrWriterFunc) {
        if (typeof textOrWriterFunc === "string")
            writer.write(textOrWriterFunc);
        else
            textOrWriterFunc(writer);
    }
}

class DecoratorStructurePrinter extends NodePrinter {
    printTexts(writer, structures) {
        this.printMultiple(writer, structures, () => writer.newLine());
    }
    printTextsInline(writer, structures) {
        this.printMultiple(writer, structures, () => writer.space());
    }
    printTextInternal(writer, structure) {
        writer.write(`@${structure.name}`);
        this.printArguments(writer, structure);
    }
    printArguments(writer, structure) {
        if (structure.arguments == null)
            return;
        writer.write("(");
        const args = structure.arguments instanceof Array ? structure.arguments : [structure.arguments];
        for (let i = 0; i < args.length; i++) {
            writer.conditionalWrite(i > 0, ", ");
            writer.write(this.getTextWithQueuedChildIndentation(writer, args[i]));
        }
        writer.write(")");
    }
    printMultiple(writer, structures, separator) {
        if (structures == null || structures.length === 0)
            return;
        for (const structure of structures) {
            this.printText(writer, structure);
            separator();
        }
    }
}

class JSDocStructurePrinter extends NodePrinter {
    printDocs(writer, structures) {
        if (structures == null)
            return;
        for (const structure of structures) {
            this.printText(writer, structure);
            writer.newLine();
        }
    }
    printTextInternal(writer, structure) {
        const text = getText(this);
        const lines = text.split(/\r?\n/);
        const startsWithNewLine = lines[0].length === 0;
        const isSingleLine = lines.length <= 1;
        const startIndex = startsWithNewLine ? 1 : 0;
        writer.write("/**");
        if (isSingleLine)
            writer.space();
        else
            writer.newLine();
        if (isSingleLine)
            writer.write(lines[startIndex]);
        else {
            for (let i = startIndex; i < lines.length; i++) {
                writer.write(` *`);
                if (lines[i].length > 0)
                    writer.write(` ${lines[i]}`);
                writer.newLine();
            }
        }
        writer.spaceIfLastNot();
        writer.write("*/");
        function getText(jsdocPrinter) {
            if (typeof structure === "string")
                return structure;
            const tempWriter = jsdocPrinter.getNewWriter(writer);
            if (typeof structure === "function")
                structure(tempWriter);
            else {
                if (structure.description)
                    printTextFromStringOrWriter(tempWriter, structure.description);
                if (structure.tags && structure.tags.length > 0) {
                    if (tempWriter.getLength() > 0)
                        tempWriter.newLine();
                    jsdocPrinter.factory.forJSDocTag({ printStarsOnNewLine: false }).printTexts(tempWriter, structure.tags);
                }
            }
            return tempWriter.toString();
        }
    }
}

class JSDocTagStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
    }
    printTexts(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            if (i > 0) {
                writer.newLine();
                writer.conditionalWrite(this.options.printStarsOnNewLine, " * ");
            }
            this.printText(writer, structures[i]);
        }
    }
    printTextInternal(writer, structure) {
        const text = getText(this);
        const lines = text.split(/\r?\n/);
        for (let i = 0; i < lines.length; i++) {
            if (i > 0) {
                writer.newLine();
                if (this.options.printStarsOnNewLine)
                    writer.write(` *`);
            }
            if (lines[i].length > 0) {
                if (this.options.printStarsOnNewLine && i > 0)
                    writer.space();
                writer.write(lines[i]);
            }
        }
        function getText(tagPrinter) {
            if (typeof structure === "string")
                return structure;
            const tempWriter = tagPrinter.getNewWriter(writer);
            if (typeof structure === "function")
                structure(tempWriter);
            else {
                if (structure.text)
                    printTextFromStringOrWriter(tempWriter, structure.text);
                const currentText = tempWriter.toString();
                tempWriter.unsafeInsert(0, `@${structure.tagName}` + (currentText.length > 0 && !StringUtils.startsWithNewLine(currentText) ? " " : ""));
            }
            return tempWriter.toString();
        }
    }
}

class EnumDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.conditionalWrite(structure.isConst, "const ");
        writer.write(`enum ${structure.name} `).inlineBlock(() => {
            this.factory.forEnumMember().printTexts(writer, structure.members);
        });
    }
}

class EnumMemberStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new CommaNewLineSeparatedStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        if (structure instanceof Function) {
            structure(writer);
            return;
        }
        else if (typeof structure === "string") {
            writer.write(structure);
            return;
        }
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        if (isValidVariableName(structure.name) || isSurroundedInQuotes(structure.name))
            writer.write(structure.name);
        else
            writer.quote(structure.name);
        if (typeof structure.value === "string") {
            const { value } = structure;
            writer.hangingIndent(() => writer.write(` = `).quote(value));
        }
        else if (typeof structure.value === "number")
            writer.write(` = ${structure.value}`);
        else
            this.factory.forInitializerExpressionableNode().printText(writer, structure);
    }
}
function isSurroundedInQuotes(text) {
    return text.startsWith("'") && text.endsWith("'") || text.startsWith("\"") && text.endsWith("\"");
}

class ObjectLiteralExpressionPropertyStructurePrinter extends Printer {
    constructor(factory) {
        super();
        this.factory = factory;
        this.multipleWriter = new CommaNewLineSeparatedStructuresPrinter(this);
        this.options = { isAmbient: false };
    }
    printTexts(writer, members) {
        this.multipleWriter.printText(writer, members);
    }
    printText(writer, member) {
        if (typeof member === "string" || member instanceof Function || member == null) {
            this.printTextOrWriterFunc(writer, member);
            return;
        }
        switch (member.kind) {
            case exports.StructureKind.PropertyAssignment:
                this.factory.forPropertyAssignment().printText(writer, member);
                break;
            case exports.StructureKind.ShorthandPropertyAssignment:
                this.factory.forShorthandPropertyAssignment().printText(writer, member);
                break;
            case exports.StructureKind.SpreadAssignment:
                this.factory.forSpreadAssignment().printText(writer, member);
                break;
            case exports.StructureKind.Method:
                this.factory.forMethodDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.GetAccessor:
                this.factory.forGetAccessorDeclaration(this.options).printText(writer, member);
                break;
            case exports.StructureKind.SetAccessor:
                this.factory.forSetAccessorDeclaration(this.options).printText(writer, member);
                break;
            default:
                errors.throwNotImplementedForNeverValueError(member);
        }
    }
}

class PropertyAssignmentStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.hangingIndent(() => {
            writer.write(`${structure.name}: `);
            printTextFromStringOrWriter(writer, structure.initializer);
        });
    }
}

class ShorthandPropertyAssignmentStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.write(`${structure.name}`);
    }
}

class SpreadAssignmentStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.hangingIndent(() => {
            writer.write("...");
            printTextFromStringOrWriter(writer, structure.expression);
        });
    }
}

class FunctionDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
    }
    printTexts(writer, structures) {
        if (structures == null)
            return;
        for (let i = 0; i < structures.length; i++) {
            const currentStructure = structures[i];
            if (i > 0) {
                const previousStructure = structures[i - 1];
                if (this.options.isAmbient || previousStructure.hasDeclareKeyword && currentStructure.hasDeclareKeyword)
                    writer.newLine();
                else
                    writer.blankLine();
            }
            this.printText(writer, currentStructure);
        }
    }
    printTextInternal(writer, structure) {
        this.printOverloads(writer, structure.name, getOverloadStructures());
        this.printHeader(writer, structure.name, structure);
        if (this.options.isAmbient || structure.hasDeclareKeyword)
            writer.write(";");
        else {
            writer.space().inlineBlock(() => {
                this.factory.forStatementedNode({ isAmbient: false }).printText(writer, structure);
            });
        }
        function getOverloadStructures() {
            const overloads = common.ObjectUtils.clone(structure.overloads);
            if (overloads == null || overloads.length === 0)
                return;
            for (const overload of overloads) {
                setValueIfUndefined(overload, "hasDeclareKeyword", structure.hasDeclareKeyword);
                setValueIfUndefined(overload, "isExported", structure.isExported);
                setValueIfUndefined(overload, "isDefaultExport", structure.isDefaultExport);
            }
            return overloads;
        }
    }
    printOverloads(writer, name, structures) {
        if (structures == null || structures.length === 0)
            return;
        for (const structure of structures) {
            this.printOverload(writer, name, structure);
            writer.newLine();
        }
    }
    printOverload(writer, name, structure) {
        this.printHeader(writer, name, structure);
        writer.write(";");
    }
    printHeader(writer, name, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`function`);
        writer.conditionalWrite(structure.isGenerator, "*");
        if (!StringUtils.isNullOrWhitespace(name))
            writer.write(` ${name}`);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
    }
}

class ParameterDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new CommaSeparatedStructuresPrinter(this);
    }
    printTextsWithParenthesis(writer, structures) {
        writer.write("(");
        if (structures != null)
            this.factory.forParameterDeclaration().printTexts(writer, structures);
        writer.write(`)`);
    }
    printTexts(writer, structures) {
        if (structures == null || structures.length === 0)
            return;
        writer.hangingIndent(() => {
            this.multipleWriter.printText(writer, structures);
        });
    }
    printTextInternal(writer, structure) {
        if (structure.name == null) {
            throw new common.errors
                .NotImplementedError("Not implemented scenario where parameter declaration structure doesn't have a name. Please open an issue if you need this.");
        }
        this.factory.forDecorator().printTextsInline(writer, structure.decorators);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.conditionalWrite(structure.isRestParameter, "...");
        writer.write(structure.name);
        writer.conditionalWrite(structure.hasQuestionToken, "?");
        this.factory.forTypedNode(":", structure.hasQuestionToken).printText(writer, structure);
        this.factory.forInitializerExpressionableNode().printText(writer, structure);
    }
}

class CallSignatureDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode(true).printText(writer, structure);
        writer.write(";");
    }
}

class ConstructSignatureDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        writer.write("new");
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
        writer.write(";");
    }
}

class IndexSignatureDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`[${structure.keyName || "key"}: ${structure.keyType || "string"}]`);
        this.factory.forReturnTypedNode().printText(writer, structure);
        writer.write(";");
    }
}

class InterfaceDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`interface ${structure.name}`);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        writer.space();
        if (structure.extends != null) {
            const extendsText = structure.extends instanceof Array
                ? structure.extends.map(i => this.getText(writer, i)).join(", ")
                : this.getText(writer, structure.extends);
            if (!StringUtils.isNullOrWhitespace(extendsText))
                writer.hangingIndent(() => writer.write(`extends ${extendsText} `));
        }
        writer.inlineBlock(() => {
            this.factory.forTypeElementMemberedNode().printText(writer, structure);
        });
    }
}

class MethodSignatureStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        writer.write(structure.name);
        writer.conditionalWrite(structure.hasQuestionToken, "?");
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forParameterDeclaration().printTextsWithParenthesis(writer, structure.parameters);
        this.factory.forReturnTypedNode().printText(writer, structure);
        writer.write(";");
    }
}

class PropertySignatureStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(structure.name);
        writer.conditionalWrite(structure.hasQuestionToken, "?");
        this.factory.forTypedNode(":").printText(writer, structure);
        this.factory.forInitializerExpressionableNode().printText(writer, structure);
        writer.write(";");
    }
}

class TypeElementMemberedNodeStructurePrinter extends Printer {
    constructor(factory) {
        super();
        this.factory = factory;
    }
    printText(writer, structure) {
        this.factory.forCallSignatureDeclaration().printTexts(writer, structure.callSignatures);
        this.conditionalSeparator(writer, structure.constructSignatures);
        this.factory.forConstructSignatureDeclaration().printTexts(writer, structure.constructSignatures);
        this.conditionalSeparator(writer, structure.indexSignatures);
        this.factory.forIndexSignatureDeclaration().printTexts(writer, structure.indexSignatures);
        this.conditionalSeparator(writer, structure.properties);
        this.factory.forPropertySignature().printTexts(writer, structure.properties);
        this.conditionalSeparator(writer, structure.methods);
        this.factory.forMethodSignature().printTexts(writer, structure.methods);
    }
    conditionalSeparator(writer, structures) {
        if (!ArrayUtils.isNullOrEmpty(structures) && !writer.isAtStartOfFirstLineOfBlock())
            writer.newLine();
    }
}

class TypeElementMemberStructurePrinter extends Printer {
    constructor(factory) {
        super();
        this.factory = factory;
    }
    printTexts(writer, members) {
        if (members == null)
            return;
        if (typeof members === "string" || members instanceof Function)
            this.printText(writer, members);
        else {
            for (const member of members) {
                if (isLastNonWhitespaceCharCloseBrace(writer))
                    writer.blankLineIfLastNot();
                else if (!writer.isAtStartOfFirstLineOfBlock())
                    writer.newLineIfLastNot();
                this.printText(writer, member);
            }
        }
    }
    printText(writer, members) {
        if (typeof members === "string" || members instanceof Function || members == null) {
            this.printTextOrWriterFunc(writer, members);
            return;
        }
        switch (members.kind) {
            case exports.StructureKind.PropertySignature:
                this.factory.forPropertySignature().printText(writer, members);
                break;
            case exports.StructureKind.MethodSignature:
                this.factory.forMethodSignature().printText(writer, members);
                break;
            case exports.StructureKind.CallSignature:
                this.factory.forCallSignatureDeclaration().printText(writer, members);
                break;
            case exports.StructureKind.IndexSignature:
                this.factory.forIndexSignatureDeclaration().printText(writer, members);
                break;
            case exports.StructureKind.ConstructSignature:
                this.factory.forConstructSignatureDeclaration().printText(writer, members);
                break;
            default:
                errors.throwNotImplementedForNeverValueError(members);
        }
    }
}

class JsxAttributeStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.write(structure.name);
        if (structure.initializer != null)
            writer.write("=").write(structure.initializer);
    }
}

class JsxChildDeciderStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        if (isJsxElement(structure))
            this.factory.forJsxElement().printText(writer, structure);
        else if (structure.kind === exports.StructureKind.JsxSelfClosingElement)
            this.factory.forJsxSelfClosingElement().printText(writer, structure);
        else
            errors.throwNotImplementedForNeverValueError(structure);
        function isJsxElement(struct) {
            return struct.kind == null || struct.kind === exports.StructureKind.JsxElement;
        }
    }
}

class JsxElementStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.hangingIndent(() => {
            writer.write(`<${structure.name}`);
            if (structure.attributes)
                this.printAttributes(writer, structure.attributes);
            writer.write(">");
        });
        this.printChildren(writer, structure.children);
        writer.write(`</${structure.name}>`);
    }
    printAttributes(writer, attributes) {
        const attributePrinter = this.factory.forJsxAttributeDecider();
        for (const attrib of attributes) {
            writer.space();
            attributePrinter.printText(writer, attrib);
        }
    }
    printChildren(writer, children) {
        if (children == null)
            return;
        writer.newLine();
        writer.indent(() => {
            for (const child of children) {
                this.factory.forJsxChildDecider().printText(writer, child);
                writer.newLine();
            }
        });
    }
}

class JsxAttributeDeciderStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        if (isJsxAttribute())
            this.factory.forJsxAttribute().printText(writer, structure);
        else if (structure.kind === exports.StructureKind.JsxSpreadAttribute)
            this.factory.forJsxSpreadAttribute().printText(writer, structure);
        else
            throw errors.throwNotImplementedForNeverValueError(structure);
        function isJsxAttribute(struct) {
            return structure.kind == null || structure.kind === exports.StructureKind.JsxAttribute;
        }
    }
}

class JsxSelfClosingElementStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.hangingIndent(() => {
            writer.write(`<${structure.name}`);
            if (structure.attributes)
                this.printAttributes(writer, structure.attributes);
            writer.write(" />");
        });
    }
    printAttributes(writer, attributes) {
        const attributePrinter = this.factory.forJsxAttributeDecider();
        for (const attrib of attributes) {
            writer.space();
            attributePrinter.printText(writer, attrib);
        }
    }
}

class JsxSpreadAttributeStructurePrinter extends NodePrinter {
    printTextInternal(writer, structure) {
        writer.hangingIndent(() => {
            writer.write("...");
            writer.write(structure.expression);
        });
    }
}

class ExportAssignmentStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        writer.write("export");
        if (structure.isExportEquals !== false)
            writer.write(" = ");
        else
            writer.write(" default ");
        writer.write(this.getTextWithQueuedChildIndentation(writer, structure.expression)).write(";");
    }
}

class ExportDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        const hasModuleSpecifier = structure.moduleSpecifier != null && structure.moduleSpecifier.length > 0;
        const hasNamedImport = structure.namedExports != null && structure.namedExports.length > 0;
        if (hasNamedImport && structure.namespaceExport != null)
            throw new errors.InvalidOperationError("An export declaration cannot have both a namespace export and a named export.");
        writer.write("export");
        if (structure.isTypeOnly)
            writer.write(" type");
        if (structure.namedExports != null && structure.namedExports.length > 0) {
            writer.space();
            this.factory.forNamedImportExportSpecifier().printTextsWithBraces(writer, structure.namedExports);
        }
        else if (structure.namespaceExport != null) {
            writer.write(" *");
            if (!StringUtils.isNullOrWhitespace(structure.namespaceExport))
                writer.write(` as ${structure.namespaceExport}`);
        }
        else if (!hasModuleSpecifier) {
            writer.write(" {")
                .conditionalWrite(this.factory.getFormatCodeSettings().insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces, " ")
                .write("}");
        }
        else {
            writer.write(` *`);
        }
        if (hasModuleSpecifier) {
            writer.write(" from ");
            writer.quote(structure.moduleSpecifier);
        }
        writer.write(";");
    }
}

class ImportDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        const hasNamedImport = structure.namedImports != null && structure.namedImports.length > 0;
        if (hasNamedImport && structure.namespaceImport != null)
            throw new errors.InvalidOperationError("An import declaration cannot have both a namespace import and a named import.");
        writer.write("import");
        if (structure.isTypeOnly)
            writer.write(" type");
        if (structure.defaultImport != null) {
            writer.write(` ${structure.defaultImport}`);
            writer.conditionalWrite(hasNamedImport || structure.namespaceImport != null, ",");
        }
        if (structure.namespaceImport != null)
            writer.write(` * as ${structure.namespaceImport}`);
        if (structure.namedImports != null && structure.namedImports.length > 0) {
            writer.space();
            this.factory.forNamedImportExportSpecifier().printTextsWithBraces(writer, structure.namedImports);
        }
        writer.conditionalWrite(structure.defaultImport != null || hasNamedImport || structure.namespaceImport != null, " from");
        writer.write(" ");
        writer.quote(structure.moduleSpecifier);
        writer.write(";");
    }
}

class NamespaceDeclarationStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
        this.blankLineFormattingWriter = new BlankLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.blankLineFormattingWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        structure = this.validateAndGetStructure(structure);
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        if (structure.declarationKind == null || structure.declarationKind !== exports.NamespaceDeclarationKind.Global)
            writer.write(`${structure.declarationKind || "namespace"} ${structure.name} `);
        else
            writer.write("global ");
        writer.inlineBlock(() => {
            this.factory.forStatementedNode({
                isAmbient: structure.hasDeclareKeyword || this.options.isAmbient,
            }).printText(writer, structure);
        });
    }
    validateAndGetStructure(structure) {
        const name = structure.name.trim();
        if (!name.startsWith("'") && !name.startsWith(`"`))
            return structure;
        if (structure.declarationKind === exports.NamespaceDeclarationKind.Namespace) {
            throw new errors.InvalidOperationError(`Cannot print a namespace with quotes for namespace with name ${structure.name}. `
                + `Use ${"NamespaceDeclarationKind.Module"} instead.`);
        }
        structure = common.ObjectUtils.clone(structure);
        setValueIfUndefined(structure, "hasDeclareKeyword", true);
        setValueIfUndefined(structure, "declarationKind", exports.NamespaceDeclarationKind.Module);
        return structure;
    }
}

class NamedImportExportSpecifierStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new CommaSeparatedStructuresPrinter(this);
    }
    printTextsWithBraces(writer, structures) {
        const formatSettings = this.factory.getFormatCodeSettings();
        writer.write("{");
        const specifierWriter = this.getNewWriter(writer);
        this.printTexts(specifierWriter, structures);
        const specifierText = specifierWriter.toString();
        if (formatSettings.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces && !StringUtils.startsWithNewLine(specifierText))
            writer.space();
        writer.write(specifierText);
        if (formatSettings.insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces && !StringUtils.endsWithNewLine(specifierText))
            writer.space();
        writer.write("}");
    }
    printTexts(writer, structures) {
        if (structures instanceof Function)
            this.printText(writer, structures);
        else
            this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        const specifierWriter = this.getNewWriterWithQueuedChildIndentation(writer);
        if (typeof structure === "string")
            specifierWriter.write(structure);
        else if (structure instanceof Function)
            structure(specifierWriter);
        else {
            specifierWriter.write(structure.name);
            if (!StringUtils.isNullOrWhitespace(structure.alias)) {
                if (!specifierWriter.isLastNewLine())
                    specifierWriter.space();
                specifierWriter.write(`as ${structure.alias}`);
            }
        }
        writer.write(specifierWriter.toString());
    }
}

class SourceFileStructurePrinter extends NodePrinter {
    constructor(factory, options) {
        super(factory);
        this.options = options;
    }
    printTextInternal(writer, structure) {
        this.factory.forStatementedNode(this.options).printText(writer, structure);
        writer.conditionalNewLine(!writer.isAtStartOfFirstLineOfBlock() && !writer.isLastNewLine());
    }
}

class StatementedNodeStructurePrinter extends Printer {
    constructor(factory, options) {
        super();
        this.factory = factory;
        this.options = options;
    }
    printText(writer, structure) {
        this.factory.forStatement(this.options).printTexts(writer, structure.statements);
    }
}

class StatementStructurePrinter extends Printer {
    constructor(factory, options) {
        super();
        this.factory = factory;
        this.options = options;
    }
    printTexts(writer, statements) {
        if (statements == null)
            return;
        if (typeof statements === "string" || statements instanceof Function)
            this.printText(writer, statements);
        else {
            for (const statement of statements) {
                if (isLastNonWhitespaceCharCloseBrace(writer))
                    writer.blankLineIfLastNot();
                else if (!writer.isAtStartOfFirstLineOfBlock())
                    writer.newLineIfLastNot();
                this.printText(writer, statement);
            }
        }
    }
    printText(writer, statement) {
        if (typeof statement === "string" || statement instanceof Function || statement == null) {
            this.printTextOrWriterFunc(writer, statement);
            return;
        }
        switch (statement.kind) {
            case exports.StructureKind.Function:
                if (!this.options.isAmbient)
                    ensureBlankLine();
                this.factory.forFunctionDeclaration(this.options).printText(writer, statement);
                break;
            case exports.StructureKind.Class:
                ensureBlankLine();
                this.factory.forClassDeclaration(this.options).printText(writer, statement);
                break;
            case exports.StructureKind.Interface:
                ensureBlankLine();
                this.factory.forInterfaceDeclaration().printText(writer, statement);
                break;
            case exports.StructureKind.TypeAlias:
                this.factory.forTypeAliasDeclaration().printText(writer, statement);
                break;
            case exports.StructureKind.VariableStatement:
                this.factory.forVariableStatement().printText(writer, statement);
                break;
            case exports.StructureKind.ImportDeclaration:
                this.factory.forImportDeclaration().printText(writer, statement);
                break;
            case exports.StructureKind.Namespace:
                ensureBlankLine();
                this.factory.forNamespaceDeclaration(this.options).printText(writer, statement);
                break;
            case exports.StructureKind.Enum:
                ensureBlankLine();
                this.factory.forEnumDeclaration().printText(writer, statement);
                break;
            case exports.StructureKind.ExportDeclaration:
                this.factory.forExportDeclaration().printText(writer, statement);
                break;
            case exports.StructureKind.ExportAssignment:
                this.factory.forExportAssignment().printText(writer, statement);
                break;
            default:
                errors.throwNotImplementedForNeverValueError(statement);
        }
        function ensureBlankLine() {
            if (!writer.isAtStartOfFirstLineOfBlock())
                writer.blankLineIfLastNot();
        }
    }
}

(function(VariableDeclarationKind) {
    VariableDeclarationKind["Var"] = "var";
    VariableDeclarationKind["Let"] = "let";
    VariableDeclarationKind["Const"] = "const";
})(exports.VariableDeclarationKind || (exports.VariableDeclarationKind = {}));

class VariableStatementStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        writer.hangingIndent(() => {
            this.factory.forModifierableNode().printText(writer, structure);
            writer.write(`${structure.declarationKind || exports.VariableDeclarationKind.Let} `);
            this.factory.forVariableDeclaration().printTexts(writer, structure.declarations);
            writer.write(";");
        });
    }
}

class VariableDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new CommaSeparatedStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        writer.write(structure.name);
        writer.conditionalWrite(structure.hasExclamationToken, "!");
        this.factory.forTypedNode(":").printText(writer, structure);
        this.factory.forInitializerExpressionableNode().printText(writer, structure);
    }
}

class TypeAliasDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new NewLineFormattingStructuresPrinter(this);
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        this.factory.forJSDoc().printDocs(writer, structure.docs);
        this.factory.forModifierableNode().printText(writer, structure);
        writer.write(`type ${structure.name}`);
        this.factory.forTypeParameterDeclaration().printTextsWithBrackets(writer, structure.typeParameters);
        this.factory.forTypedNode(" =").printText(writer, structure);
        writer.write(";");
    }
}

class TypeParameterDeclarationStructurePrinter extends NodePrinter {
    constructor() {
        super(...arguments);
        this.multipleWriter = new CommaSeparatedStructuresPrinter(this);
    }
    printTextsWithBrackets(writer, structures) {
        if (structures == null || structures.length === 0)
            return;
        writer.write("<");
        this.printTexts(writer, structures);
        writer.write(">");
    }
    printTexts(writer, structures) {
        this.multipleWriter.printText(writer, structures);
    }
    printTextInternal(writer, structure) {
        if (typeof structure === "string") {
            writer.write(structure);
            return;
        }
        writer.hangingIndent(() => {
            writer.write(structure.name);
            if (structure.constraint != null) {
                const constraintText = this.getText(writer, structure.constraint);
                if (!StringUtils.isNullOrWhitespace(constraintText))
                    writer.write(` extends ${constraintText}`);
            }
            if (structure.default != null) {
                const defaultText = this.getText(writer, structure.default);
                if (!StringUtils.isNullOrWhitespace(defaultText))
                    writer.write(` = ${defaultText}`);
            }
        });
    }
}

function ExtendsClauseableNode(Base) {
    return class extends Base {
        getExtends() {
            var _a;
            const extendsClause = this.getHeritageClauseByKind(ts$1.SyntaxKind.ExtendsKeyword);
            return (_a = extendsClause === null || extendsClause === void 0 ? void 0 : extendsClause.getTypeNodes()) !== null && _a !== void 0 ? _a : [];
        }
        addExtends(text) {
            return this.insertExtends(this.getExtends().length, text);
        }
        insertExtends(index, texts) {
            const originalExtends = this.getExtends();
            const wasStringInput = typeof texts === "string";
            if (typeof texts === "string") {
                errors.throwIfWhitespaceOrNotString(texts, "texts");
                texts = [texts];
            }
            else if (texts.length === 0) {
                return [];
            }
            const writer = this._getWriterWithQueuedChildIndentation();
            const structurePrinter = new CommaSeparatedStructuresPrinter(new StringStructurePrinter());
            structurePrinter.printText(writer, texts);
            index = verifyAndGetIndex(index, originalExtends.length);
            if (originalExtends.length > 0) {
                const extendsClause = this.getHeritageClauseByKindOrThrow(ts$1.SyntaxKind.ExtendsKeyword);
                insertIntoCommaSeparatedNodes({
                    parent: extendsClause.getFirstChildByKindOrThrow(ts$1.SyntaxKind.SyntaxList),
                    currentNodes: originalExtends,
                    insertIndex: index,
                    newText: writer.toString(),
                    useTrailingCommas: false,
                });
            }
            else {
                const openBraceToken = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenBraceToken);
                const openBraceStart = openBraceToken.getStart();
                const isLastSpace = /\s/.test(this.getSourceFile().getFullText()[openBraceStart - 1]);
                let insertText = `extends ${writer.toString()} `;
                if (!isLastSpace)
                    insertText = " " + insertText;
                insertIntoParentTextRange({
                    parent: this,
                    insertPos: openBraceStart,
                    newText: insertText,
                });
            }
            const newExtends = this.getExtends();
            return wasStringInput ? newExtends[index] : getNodesToReturn(originalExtends, newExtends, index, false);
        }
        removeExtends(implementsNodeOrIndex) {
            const extendsClause = this.getHeritageClauseByKind(ts$1.SyntaxKind.ExtendsKeyword);
            if (extendsClause == null)
                throw new errors.InvalidOperationError("Cannot remove an extends when none exist.");
            extendsClause.removeExpression(implementsNodeOrIndex);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.extends != null) {
                this.getExtends().forEach(e => this.removeExtends(e));
                this.addExtends(structure.extends);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                extends: this.getExtends().map(e => e.getText()),
            });
        }
    };
}

function GeneratorableNode(Base) {
    return class extends Base {
        isGenerator() {
            return this.compilerNode.asteriskToken != null;
        }
        getAsteriskToken() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.asteriskToken);
        }
        getAsteriskTokenOrThrow() {
            return errors.throwIfNullOrUndefined(this.getAsteriskToken(), "Expected to find an asterisk token.");
        }
        setIsGenerator(value) {
            const asteriskToken = this.getAsteriskToken();
            const isSet = asteriskToken != null;
            if (isSet === value)
                return this;
            if (asteriskToken == null) {
                insertIntoParentTextRange({
                    insertPos: getAsteriskInsertPos(this),
                    parent: this,
                    newText: "*",
                });
            }
            else {
                removeChildrenWithFormatting({
                    children: [asteriskToken],
                    getSiblingFormatting: () => FormattingKind.Space,
                });
            }
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.isGenerator != null)
                this.setIsGenerator(structure.isGenerator);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                isGenerator: this.isGenerator(),
            });
        }
    };
}
function getAsteriskInsertPos(node) {
    if (node.getKind() === ts$1.SyntaxKind.FunctionDeclaration)
        return node.getFirstChildByKindOrThrow(ts$1.SyntaxKind.FunctionKeyword).getEnd();
    const namedNode = node;
    if (namedNode.getName == null)
        throw new errors.NotImplementedError("Expected a name node for a non-function declaration.");
    return namedNode.getNameNode().getStart();
}

function HeritageClauseableNode(Base) {
    return class extends Base {
        getHeritageClauses() {
            var _a;
            const heritageClauses = this.compilerNode.heritageClauses;
            return (_a = heritageClauses === null || heritageClauses === void 0 ? void 0 : heritageClauses.map(c => this._getNodeFromCompilerNode(c))) !== null && _a !== void 0 ? _a : [];
        }
        getHeritageClauseByKindOrThrow(kind) {
            return errors.throwIfNullOrUndefined(this.getHeritageClauseByKind(kind), `Expected to have heritage clause of kind ${common.getSyntaxKindName(kind)}.`);
        }
        getHeritageClauseByKind(kind) {
            return this.getHeritageClauses().find(c => c.compilerNode.token === kind);
        }
    };
}

function ImplementsClauseableNode(Base) {
    return class extends Base {
        getImplements() {
            var _a;
            const implementsClause = this.getHeritageClauseByKind(ts$1.SyntaxKind.ImplementsKeyword);
            return (_a = implementsClause === null || implementsClause === void 0 ? void 0 : implementsClause.getTypeNodes()) !== null && _a !== void 0 ? _a : [];
        }
        addImplements(text) {
            return this.insertImplements(this.getImplements().length, text);
        }
        insertImplements(index, texts) {
            const originalImplements = this.getImplements();
            const wasStringInput = typeof texts === "string";
            if (typeof texts === "string") {
                errors.throwIfWhitespaceOrNotString(texts, "texts");
                texts = [texts];
            }
            else if (texts.length === 0) {
                return [];
            }
            const writer = this._getWriterWithQueuedChildIndentation();
            const structurePrinter = new CommaSeparatedStructuresPrinter(new StringStructurePrinter());
            structurePrinter.printText(writer, texts);
            const heritageClauses = this.getHeritageClauses();
            index = verifyAndGetIndex(index, originalImplements.length);
            if (originalImplements.length > 0) {
                const implementsClause = this.getHeritageClauseByKindOrThrow(ts$1.SyntaxKind.ImplementsKeyword);
                insertIntoCommaSeparatedNodes({
                    parent: implementsClause.getFirstChildByKindOrThrow(ts$1.SyntaxKind.SyntaxList),
                    currentNodes: originalImplements,
                    insertIndex: index,
                    newText: writer.toString(),
                    useTrailingCommas: false,
                });
            }
            else {
                const openBraceToken = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenBraceToken);
                const openBraceStart = openBraceToken.getStart();
                const isLastSpace = /\s/.test(this.getSourceFile().getFullText()[openBraceStart - 1]);
                let insertText = `implements ${writer.toString()} `;
                if (!isLastSpace)
                    insertText = " " + insertText;
                insertIntoParentTextRange({
                    parent: heritageClauses.length === 0 ? this : heritageClauses[0].getParentSyntaxListOrThrow(),
                    insertPos: openBraceStart,
                    newText: insertText,
                });
            }
            const newImplements = this.getImplements();
            return wasStringInput ? newImplements[0] : getNodesToReturn(originalImplements, newImplements, index, false);
        }
        removeImplements(implementsNodeOrIndex) {
            const implementsClause = this.getHeritageClauseByKind(ts$1.SyntaxKind.ImplementsKeyword);
            if (implementsClause == null)
                throw new errors.InvalidOperationError("Cannot remove an implements when none exist.");
            implementsClause.removeExpression(implementsNodeOrIndex);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.implements != null) {
                this.getImplements().forEach(expr => this.removeImplements(expr));
                this.addImplements(structure.implements);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                implements: this.getImplements().map(node => node.getText()),
            });
        }
    };
}

function InitializerExpressionGetableNode(Base) {
    return class extends Base {
        hasInitializer() {
            return this.compilerNode.initializer != null;
        }
        getInitializerIfKindOrThrow(kind) {
            return errors.throwIfNullOrUndefined(this.getInitializerIfKind(kind), `Expected to find an initializer of kind '${common.getSyntaxKindName(kind)}'.`);
        }
        getInitializerIfKind(kind) {
            const initializer = this.getInitializer();
            if (initializer != null && initializer.getKind() !== kind)
                return undefined;
            return initializer;
        }
        getInitializerOrThrow() {
            return errors.throwIfNullOrUndefined(this.getInitializer(), "Expected to find an initializer.");
        }
        getInitializer() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.initializer);
        }
    };
}

function InitializerExpressionableNode(Base) {
    return apply$1(InitializerExpressionGetableNode(Base));
}
function apply$1(Base) {
    return class extends Base {
        removeInitializer() {
            const initializer = this.getInitializer();
            if (initializer == null)
                return this;
            const previousSibling = initializer.getPreviousSiblingIfKindOrThrow(ts$1.SyntaxKind.EqualsToken);
            removeChildren({
                children: [previousSibling, initializer],
                removePrecedingSpaces: true,
            });
            return this;
        }
        setInitializer(textOrWriterFunction) {
            const text = getTextFromStringOrWriter(this._getWriterWithQueuedChildIndentation(), textOrWriterFunction);
            errors.throwIfWhitespaceOrNotString(text, "textOrWriterFunction");
            if (this.hasInitializer())
                this.removeInitializer();
            const semiColonToken = this.getLastChildIfKind(ts$1.SyntaxKind.SemicolonToken);
            insertIntoParentTextRange({
                insertPos: semiColonToken != null ? semiColonToken.getPos() : this.getEnd(),
                parent: this,
                newText: ` = ${text}`,
            });
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.initializer != null)
                this.setInitializer(structure.initializer);
            else if (structure.hasOwnProperty("initializer"))
                this.removeInitializer();
            return this;
        }
        getStructure() {
            const initializer = this.getInitializer();
            return callBaseGetStructure(Base.prototype, this, {
                initializer: initializer ? initializer.getText() : undefined,
            });
        }
    };
}

function JSDocableNode(Base) {
    return class extends Base {
        getJsDocs() {
            var _a;
            const nodes = this.compilerNode.jsDoc;
            return (_a = nodes === null || nodes === void 0 ? void 0 : nodes.map(n => this._getNodeFromCompilerNode(n))) !== null && _a !== void 0 ? _a : [];
        }
        addJsDoc(structure) {
            return this.addJsDocs([structure])[0];
        }
        addJsDocs(structures) {
            return this.insertJsDocs(getEndIndexFromArray(this.compilerNode.jsDoc), structures);
        }
        insertJsDoc(index, structure) {
            return this.insertJsDocs(index, [structure])[0];
        }
        insertJsDocs(index, structures) {
            if (ArrayUtils.isNullOrEmpty(structures))
                return [];
            const writer = this._getWriterWithQueuedIndentation();
            const structurePrinter = this._context.structurePrinterFactory.forJSDoc();
            structurePrinter.printDocs(writer, structures);
            writer.write("");
            const code = writer.toString();
            const nodes = this.getJsDocs();
            index = verifyAndGetIndex(index, nodes.length);
            const insertPos = index === nodes.length ? this.getStart() : nodes[index].getStart();
            insertIntoParentTextRange({
                insertPos,
                parent: this,
                newText: code,
            });
            return getNodesToReturn(nodes, this.getJsDocs(), index, false);
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.docs != null) {
                this.getJsDocs().forEach(doc => doc.remove());
                this.addJsDocs(structure.docs);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                docs: this.getJsDocs().map(jsdoc => jsdoc.getStructure()),
            });
        }
    };
}

function LiteralLikeNode(Base) {
    return class extends Base {
        getLiteralText() {
            return this.compilerNode.text;
        }
        isTerminated() {
            return !(this.compilerNode.isUnterminated || false);
        }
        hasExtendedUnicodeEscape() {
            return this.compilerNode.hasExtendedUnicodeEscape || false;
        }
    };
}

function ModuledNode(Base) {
    return class extends Base {
        addImportDeclaration(structure) {
            return this.addImportDeclarations([structure])[0];
        }
        addImportDeclarations(structures) {
            const compilerChildren = this._getCompilerStatementsWithComments();
            return this.insertImportDeclarations(getInsertIndex(), structures);
            function getInsertIndex() {
                let insertIndex = 0;
                let wasLastComment = true;
                for (let i = 0; i < compilerChildren.length; i++) {
                    const child = compilerChildren[i];
                    if (wasLastComment && child.kind === ts$1.SyntaxKind.MultiLineCommentTrivia)
                        insertIndex = i + 1;
                    else {
                        wasLastComment = false;
                        if (child.kind === ts$1.SyntaxKind.ImportDeclaration)
                            insertIndex = i + 1;
                    }
                }
                return insertIndex;
            }
        }
        insertImportDeclaration(index, structure) {
            return this.insertImportDeclarations(index, [structure])[0];
        }
        insertImportDeclarations(index, structures) {
            return this._insertChildren({
                expectedKind: ts$1.SyntaxKind.ImportDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forImportDeclaration().printTexts(writer, structures);
                    }, {
                        previousNewLine: previousMember => Node.isImportDeclaration(previousMember) || isComment(previousMember.compilerNode),
                        nextNewLine: nextMember => Node.isImportDeclaration(nextMember),
                    });
                },
            });
        }
        getImportDeclaration(conditionOrModuleSpecifier) {
            return this.getImportDeclarations().find(getCondition());
            function getCondition() {
                if (typeof conditionOrModuleSpecifier === "string")
                    return (dec) => dec.getModuleSpecifierValue() === conditionOrModuleSpecifier;
                else
                    return conditionOrModuleSpecifier;
            }
        }
        getImportDeclarationOrThrow(conditionOrModuleSpecifier) {
            return errors.throwIfNullOrUndefined(this.getImportDeclaration(conditionOrModuleSpecifier), "Expected to find an import with the provided condition.");
        }
        getImportDeclarations() {
            return this.getStatements().filter(Node.isImportDeclaration);
        }
        addExportDeclaration(structure) {
            return this.addExportDeclarations([structure])[0];
        }
        addExportDeclarations(structures) {
            return this.insertExportDeclarations(this.getChildSyntaxListOrThrow().getChildCount(), structures);
        }
        insertExportDeclaration(index, structure) {
            return this.insertExportDeclarations(index, [structure])[0];
        }
        insertExportDeclarations(index, structures) {
            return this._insertChildren({
                expectedKind: ts$1.SyntaxKind.ExportDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forExportDeclaration().printTexts(writer, structures);
                    }, {
                        previousNewLine: previousMember => Node.isExportDeclaration(previousMember) || isComment(previousMember.compilerNode),
                        nextNewLine: nextMember => Node.isExportDeclaration(nextMember),
                    });
                },
            });
        }
        getExportDeclaration(conditionOrModuleSpecifier) {
            return this.getExportDeclarations().find(getCondition());
            function getCondition() {
                if (typeof conditionOrModuleSpecifier === "string")
                    return (dec) => dec.getModuleSpecifierValue() === conditionOrModuleSpecifier;
                else
                    return conditionOrModuleSpecifier;
            }
        }
        getExportDeclarationOrThrow(conditionOrModuleSpecifier) {
            return errors.throwIfNullOrUndefined(this.getExportDeclaration(conditionOrModuleSpecifier), "Expected to find an export declaration with the provided condition.");
        }
        getExportDeclarations() {
            return this.getStatements().filter(Node.isExportDeclaration);
        }
        addExportAssignment(structure) {
            return this.addExportAssignments([structure])[0];
        }
        addExportAssignments(structures) {
            return this.insertExportAssignments(this.getChildSyntaxListOrThrow().getChildCount(), structures);
        }
        insertExportAssignment(index, structure) {
            return this.insertExportAssignments(index, [structure])[0];
        }
        insertExportAssignments(index, structures) {
            return this._insertChildren({
                expectedKind: ts$1.SyntaxKind.ExportAssignment,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forExportAssignment().printTexts(writer, structures);
                    }, {
                        previousNewLine: previousMember => Node.isExportAssignment(previousMember) || isComment(previousMember.compilerNode),
                        nextNewLine: nextMember => Node.isExportAssignment(nextMember),
                    });
                },
            });
        }
        getExportAssignment(condition) {
            return this.getExportAssignments().find(condition);
        }
        getExportAssignmentOrThrow(condition) {
            return errors.throwIfNullOrUndefined(this.getExportAssignment(condition), "Expected to find an export assignment with the provided condition.");
        }
        getExportAssignments() {
            return this.getStatements().filter(Node.isExportAssignment);
        }
        getDefaultExportSymbol() {
            const sourceFileSymbol = this.getSymbol();
            if (sourceFileSymbol == null)
                return undefined;
            return sourceFileSymbol.getExport("default");
        }
        getDefaultExportSymbolOrThrow() {
            return errors.throwIfNullOrUndefined(this.getDefaultExportSymbol(), "Expected to find a default export symbol");
        }
        getExportSymbols() {
            const symbol = this.getSymbol();
            return symbol == null ? [] : this._context.typeChecker.getExportsOfModule(symbol);
        }
        getExportedDeclarations() {
            const result = new Map();
            const exportSymbols = this.getExportSymbols();
            for (const symbol of exportSymbols) {
                for (const declaration of symbol.getDeclarations()) {
                    const declarations = Array.from(getDeclarationHandlingImportsAndExports(declaration));
                    const name = symbol.getName();
                    const existingArray = result.get(name);
                    if (existingArray != null)
                        existingArray.push(...declarations);
                    else
                        result.set(symbol.getName(), declarations);
                }
            }
            return result;
            function* getDeclarationHandlingImportsAndExports(declaration) {
                if (Node.isExportSpecifier(declaration)) {
                    for (const d of declaration.getLocalTargetDeclarations())
                        yield* getDeclarationHandlingImportsAndExports(d);
                }
                else if (Node.isExportAssignment(declaration)) {
                    const expression = declaration.getExpression();
                    if (expression == null || expression.getKind() !== ts$1.SyntaxKind.Identifier) {
                        yield expression;
                        return;
                    }
                    yield* getDeclarationsForSymbol(expression.getSymbol());
                }
                else if (Node.isImportSpecifier(declaration)) {
                    const identifier = declaration.getNameNode();
                    const symbol = identifier.getSymbol();
                    if (symbol == null)
                        return;
                    yield* getDeclarationsForSymbol(symbol.getAliasedSymbol() || symbol);
                }
                else if (Node.isImportClause(declaration)) {
                    const identifier = declaration.getDefaultImport();
                    if (identifier == null)
                        return;
                    const symbol = identifier.getSymbol();
                    if (symbol == null)
                        return;
                    yield* getDeclarationsForSymbol(symbol.getAliasedSymbol() || symbol);
                }
                else if (Node.isNamespaceImport(declaration)) {
                    const symbol = declaration.getNameNode().getSymbol();
                    if (symbol == null)
                        return;
                    yield* getDeclarationsForSymbol(symbol.getAliasedSymbol() || symbol);
                }
                else {
                    yield declaration;
                }
                function* getDeclarationsForSymbol(symbol) {
                    if (symbol == null)
                        return;
                    for (const d of symbol.getDeclarations())
                        yield* getDeclarationHandlingImportsAndExports(d);
                }
            }
        }
        removeDefaultExport(defaultExportSymbol) {
            defaultExportSymbol = defaultExportSymbol || this.getDefaultExportSymbol();
            if (defaultExportSymbol == null)
                return this;
            const declaration = defaultExportSymbol.getDeclarations()[0];
            if (declaration.compilerNode.kind === ts$1.SyntaxKind.ExportAssignment)
                removeChildrenWithFormatting({ children: [declaration], getSiblingFormatting: () => FormattingKind.Newline });
            else if (Node.isModifierableNode(declaration)) {
                declaration.toggleModifier("default", false);
                declaration.toggleModifier("export", false);
            }
            return this;
        }
    };
}

function ReferenceFindableNode(Base) {
    return class extends Base {
        findReferences() {
            return this._context.languageService.findReferences(getNodeForReferences(this));
        }
        findReferencesAsNodes() {
            return this._context.languageService.findReferencesAsNodes(getNodeForReferences(this));
        }
    };
}
function getNodeForReferences(node) {
    if (Node.isIdentifier(node))
        return node;
    const nameNode = node.getNodeProperty("name");
    if (nameNode != null)
        return nameNode;
    if (Node.isExportableNode(node))
        return node.getDefaultKeyword() || node;
    return node;
}

function RenameableNode(Base) {
    return class extends Base {
        rename(newName, options) {
            const languageService = this._context.languageService;
            renameNode(getNodeToRename(this));
            return this;
            function getNodeToRename(thisNode) {
                if (Node.isIdentifier(thisNode) || Node.isPrivateIdentifier(thisNode))
                    return thisNode;
                else if (thisNode.getNameNode != null) {
                    const node = thisNode.getNameNode();
                    errors.throwIfNullOrUndefined(node, "Expected to find a name node when renaming.");
                    if (Node.isArrayBindingPattern(node) || Node.isObjectBindingPattern(node))
                        throw new errors.NotImplementedError(`Not implemented renameable scenario for ${node.getKindName()}.`);
                    return node;
                }
                else {
                    throw new errors.NotImplementedError(`Not implemented renameable scenario for ${thisNode.getKindName()}`);
                }
            }
            function renameNode(node) {
                errors.throwIfWhitespaceOrNotString(newName, "newName");
                if (node.getText() === newName)
                    return;
                const renameLocations = languageService.findRenameLocations(node, options);
                const renameLocationsBySourceFile = new KeyValueCache();
                for (const renameLocation of renameLocations) {
                    const locations = renameLocationsBySourceFile.getOrCreate(renameLocation.getSourceFile(), () => []);
                    locations.push(renameLocation);
                }
                for (const [sourceFile, locations] of renameLocationsBySourceFile.getEntries()) {
                    replaceSourceFileTextForRename({
                        sourceFile,
                        renameLocations: locations,
                        newName,
                    });
                }
            }
        }
    };
}

function NamedNodeBase(Base) {
    return class extends Base {
        getNameNode() {
            return this._getNodeFromCompilerNode(this.compilerNode.name);
        }
        getName() {
            return this.getNameNode().getText();
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.name != null)
                this.getNameNode().replaceWithText(structure.name);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                name: this.getName(),
            });
        }
    };
}

function BindingNamedNode(Base) {
    const base = ReferenceFindableNode(RenameableNode(Base));
    return NamedNodeBase(base);
}

function NameableNode(Base) {
    return NameableNodeInternal(ReferenceFindableNode(RenameableNode(Base)));
}
function NameableNodeInternal(Base) {
    return class extends Base {
        getNameNode() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.name);
        }
        getNameNodeOrThrow() {
            return errors.throwIfNullOrUndefined(this.getNameNode(), "Expected to have a name node.");
        }
        getName() {
            var _a, _b;
            return (_b = (_a = this.getNameNode()) === null || _a === void 0 ? void 0 : _a.getText()) !== null && _b !== void 0 ? _b : undefined;
        }
        getNameOrThrow() {
            return errors.throwIfNullOrUndefined(this.getName(), "Expected to have a name.");
        }
        rename(newName) {
            if (newName === this.getName())
                return this;
            if (StringUtils.isNullOrWhitespace(newName)) {
                this.removeName();
                return this;
            }
            const nameNode = this.getNameNode();
            if (nameNode == null)
                addNameNode(this, newName);
            else
                Base.prototype.rename.call(this, newName);
            return this;
        }
        removeName() {
            const nameNode = this.getNameNode();
            if (nameNode == null)
                return this;
            removeChildren({ children: [nameNode], removePrecedingSpaces: true });
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.name != null) {
                errors.throwIfWhitespaceOrNotString(structure.name, "structure.name");
                const nameNode = this.getNameNode();
                if (nameNode == null)
                    addNameNode(this, structure.name);
                else
                    nameNode.replaceWithText(structure.name);
            }
            else if (structure.hasOwnProperty("name")) {
                this.removeName();
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                name: this.getName(),
            });
        }
    };
}
function addNameNode(node, newName) {
    if (Node.isClassDeclaration(node) || Node.isClassExpression(node)) {
        const classKeyword = node.getFirstChildByKindOrThrow(ts$1.SyntaxKind.ClassKeyword);
        insertIntoParentTextRange({
            insertPos: classKeyword.getEnd(),
            newText: " " + newName,
            parent: node,
        });
    }
    else {
        const openParenToken = node.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenParenToken);
        insertIntoParentTextRange({
            insertPos: openParenToken.getStart(),
            newText: " " + newName,
            parent: node,
        });
    }
}

function NamedNode(Base) {
    const base = RenameableNode(ReferenceFindableNode(Base));
    return NamedNodeBase(base);
}

function PropertyNamedNode(Base) {
    const base = ReferenceFindableNode(RenameableNode(Base));
    return NamedNodeBase(base);
}

function ParameteredNode(Base) {
    return class extends Base {
        getParameter(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getParameters(), nameOrFindFunction);
        }
        getParameterOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getParameter(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("parameter", nameOrFindFunction));
        }
        getParameters() {
            return this.compilerNode.parameters.map(p => this._getNodeFromCompilerNode(p));
        }
        addParameter(structure) {
            return this.addParameters([structure])[0];
        }
        addParameters(structures) {
            return this.insertParameters(getEndIndexFromArray(this.compilerNode.parameters), structures);
        }
        insertParameter(index, structure) {
            return this.insertParameters(index, [structure])[0];
        }
        insertParameters(index, structures) {
            if (ArrayUtils.isNullOrEmpty(structures))
                return [];
            const parameters = this.getParameters();
            const syntaxList = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenParenToken).getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.SyntaxList);
            index = verifyAndGetIndex(index, parameters.length);
            const writer = this._getWriterWithQueuedChildIndentation();
            const structurePrinter = this._context.structurePrinterFactory.forParameterDeclaration();
            structurePrinter.printTexts(writer, structures);
            insertIntoCommaSeparatedNodes({
                parent: syntaxList,
                currentNodes: parameters,
                insertIndex: index,
                newText: writer.toString(),
                useTrailingCommas: false,
            });
            return getNodesToReturn(parameters, this.getParameters(), index, false);
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.parameters != null) {
                this.getParameters().forEach(p => p.remove());
                this.addParameters(structure.parameters);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                parameters: this.getParameters().map(p => p.getStructure()),
            });
        }
    };
}

function QuestionDotTokenableNode(Base) {
    return class extends Base {
        hasQuestionDotToken() {
            return this.compilerNode.questionDotToken != null;
        }
        getQuestionDotTokenNode() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.questionDotToken);
        }
        getQuestionDotTokenNodeOrThrow() {
            return errors.throwIfNullOrUndefined(this.getQuestionDotTokenNode(), "Expected to find a question dot token.");
        }
        setHasQuestionDotToken(value) {
            const questionDotTokenNode = this.getQuestionDotTokenNode();
            const hasQuestionDotToken = questionDotTokenNode != null;
            if (value === hasQuestionDotToken)
                return this;
            if (value) {
                if (Node.isPropertyAccessExpression(this))
                    this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.DotToken).replaceWithText("?.");
                else {
                    insertIntoParentTextRange({
                        insertPos: getInsertPos.call(this),
                        parent: this,
                        newText: "?.",
                    });
                }
            }
            else {
                if (Node.isPropertyAccessExpression(this))
                    questionDotTokenNode.replaceWithText(".");
                else
                    removeChildren({ children: [questionDotTokenNode] });
            }
            return this;
            function getInsertPos() {
                if (Node.isCallExpression(this))
                    return this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenParenToken).getStart();
                if (Node.isElementAccessExpression(this))
                    return this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenBracketToken).getStart();
                errors.throwNotImplementedForSyntaxKindError(this.compilerNode.kind);
            }
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.hasQuestionDotToken != null)
                this.setHasQuestionDotToken(structure.hasQuestionDotToken);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                hasQuestionDotToken: this.hasQuestionDotToken(),
            });
        }
    };
}

function QuestionTokenableNode(Base) {
    return class extends Base {
        hasQuestionToken() {
            return this.compilerNode.questionToken != null;
        }
        getQuestionTokenNode() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.questionToken);
        }
        getQuestionTokenNodeOrThrow() {
            return errors.throwIfNullOrUndefined(this.getQuestionTokenNode(), "Expected to find a question token.");
        }
        setHasQuestionToken(value) {
            const questionTokenNode = this.getQuestionTokenNode();
            const hasQuestionToken = questionTokenNode != null;
            if (value === hasQuestionToken)
                return this;
            if (value) {
                if (Node.isExclamationTokenableNode(this))
                    this.setHasExclamationToken(false);
                insertIntoParentTextRange({
                    insertPos: getInsertPos.call(this),
                    parent: this,
                    newText: "?",
                });
            }
            else {
                removeChildren({ children: [questionTokenNode] });
            }
            return this;
            function getInsertPos() {
                if (Node.hasName(this))
                    return this.getNameNode().getEnd();
                const colonNode = this.getFirstChildByKind(ts$1.SyntaxKind.ColonToken);
                if (colonNode != null)
                    return colonNode.getStart();
                const semicolonToken = this.getLastChildByKind(ts$1.SyntaxKind.SemicolonToken);
                if (semicolonToken != null)
                    return semicolonToken.getStart();
                return this.getEnd();
            }
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.hasQuestionToken != null)
                this.setHasQuestionToken(structure.hasQuestionToken);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                hasQuestionToken: this.hasQuestionToken(),
            });
        }
    };
}

function ReadonlyableNode(Base) {
    return class extends Base {
        isReadonly() {
            return this.getReadonlyKeyword() != null;
        }
        getReadonlyKeyword() {
            return this.getFirstModifierByKind(ts$1.SyntaxKind.ReadonlyKeyword);
        }
        getReadonlyKeywordOrThrow() {
            return errors.throwIfNullOrUndefined(this.getReadonlyKeyword(), "Expected to find a readonly keyword.");
        }
        setIsReadonly(value) {
            this.toggleModifier("readonly", value);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.isReadonly != null)
                this.setIsReadonly(structure.isReadonly);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                isReadonly: this.isReadonly(),
            });
        }
    };
}

function ReturnTypedNode(Base) {
    return class extends Base {
        getReturnType() {
            return this.getSignature().getReturnType();
        }
        getReturnTypeNode() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.type);
        }
        getReturnTypeNodeOrThrow() {
            return errors.throwIfNullOrUndefined(this.getReturnTypeNode(), "Expected to find a return type node.");
        }
        setReturnType(textOrWriterFunction) {
            const text = getTextFromStringOrWriter(this._getWriterWithQueuedChildIndentation(), textOrWriterFunction);
            if (StringUtils.isNullOrWhitespace(text))
                return this.removeReturnType();
            const returnTypeNode = this.getReturnTypeNode();
            if (returnTypeNode != null) {
                if (returnTypeNode.getText() !== text)
                    returnTypeNode.replaceWithText(text);
                return this;
            }
            insertIntoParentTextRange({
                parent: this,
                insertPos: getEndNode(this).getEnd(),
                newText: `: ${text}`,
            });
            return this;
            function getEndNode(thisNode) {
                if (thisNode.getKind() === ts$1.SyntaxKind.IndexSignature)
                    return thisNode.getFirstChildByKindOrThrow(ts$1.SyntaxKind.CloseBracketToken);
                return thisNode.getFirstChildByKindOrThrow(ts$1.SyntaxKind.CloseParenToken);
            }
        }
        removeReturnType() {
            const returnTypeNode = this.getReturnTypeNode();
            if (returnTypeNode == null)
                return this;
            const colonToken = returnTypeNode.getPreviousSiblingIfKindOrThrow(ts$1.SyntaxKind.ColonToken);
            removeChildren({ children: [colonToken, returnTypeNode], removePrecedingSpaces: true });
            return this;
        }
        getSignature() {
            const signature = this._context.typeChecker.getSignatureFromNode(this);
            if (signature == null)
                throw new errors.NotImplementedError("Expected the node to have a signature.");
            return signature;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.returnType != null)
                this.setReturnType(structure.returnType);
            else if (structure.hasOwnProperty("returnType"))
                this.removeReturnType();
            return this;
        }
        getStructure() {
            const returnTypeNode = this.getReturnTypeNode();
            return callBaseGetStructure(Base.prototype, this, {
                returnType: returnTypeNode ? returnTypeNode.getText({ trimLeadingIndentation: true }) : undefined,
            });
        }
    };
}

function ScopeableNode(Base) {
    return class extends Base {
        getScope() {
            const scope = getScopeForNode(this);
            if (scope != null)
                return scope;
            if (Node.isParameterDeclaration(this) && this.isReadonly())
                return exports.Scope.Public;
            return undefined;
        }
        setScope(scope) {
            setScopeForNode(this, scope);
            return this;
        }
        getScopeKeyword() {
            return this.getModifiers().find(m => {
                const text = m.getText();
                return text === "public" || text === "protected" || text === "private";
            });
        }
        hasScopeKeyword() {
            return this.getScopeKeyword() != null;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.hasOwnProperty("scope"))
                this.setScope(structure.scope);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                scope: this.getScope(),
            });
        }
    };
}
function getScopeForNode(node) {
    const modifierFlags = node.getCombinedModifierFlags();
    if ((modifierFlags & ts$1.ModifierFlags.Private) !== 0)
        return exports.Scope.Private;
    else if ((modifierFlags & ts$1.ModifierFlags.Protected) !== 0)
        return exports.Scope.Protected;
    else if ((modifierFlags & ts$1.ModifierFlags.Public) !== 0)
        return exports.Scope.Public;
    else
        return undefined;
}
function setScopeForNode(node, scope) {
    node.toggleModifier("public", scope === exports.Scope.Public);
    node.toggleModifier("protected", scope === exports.Scope.Protected);
    node.toggleModifier("private", scope === exports.Scope.Private);
}

function ScopedNode(Base) {
    return class extends Base {
        getScope() {
            return getScopeForNode(this) || exports.Scope.Public;
        }
        setScope(scope) {
            setScopeForNode(this, scope);
            return this;
        }
        hasScopeKeyword() {
            return getScopeForNode(this) != null;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.hasOwnProperty("scope"))
                this.setScope(structure.scope);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                scope: this.hasScopeKeyword() ? this.getScope() : undefined,
            });
        }
    };
}

function SignaturedDeclaration(Base) {
    return ReturnTypedNode(ParameteredNode(Base));
}

function StaticableNode(Base) {
    return class extends Base {
        isStatic() {
            return this.hasModifier(ts$1.SyntaxKind.StaticKeyword);
        }
        getStaticKeyword() {
            return this.getFirstModifierByKind(ts$1.SyntaxKind.StaticKeyword);
        }
        getStaticKeywordOrThrow() {
            return errors.throwIfNullOrUndefined(this.getStaticKeyword(), "Expected to find a static keyword.");
        }
        setIsStatic(value) {
            this.toggleModifier("static", value);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.isStatic != null)
                this.setIsStatic(structure.isStatic);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                isStatic: this.isStatic(),
            });
        }
    };
}

function TextInsertableNode(Base) {
    return class extends Base {
        insertText(pos, textOrWriterFunction) {
            this.replaceText([pos, pos], textOrWriterFunction);
            return this;
        }
        removeText(pos, end) {
            if (pos == null)
                this.replaceText(getValidRange(this), "");
            else
                this.replaceText([pos, end], "");
            return this;
        }
        replaceText(range, textOrWriterFunction) {
            const childSyntaxList = this.getChildSyntaxListOrThrow();
            const validRange = getValidRange(this);
            const pos = range[0];
            const end = range[1];
            verifyArguments();
            insertIntoParentTextRange({
                insertPos: pos,
                newText: getTextFromStringOrWriter(this._getWriter(), textOrWriterFunction),
                parent: childSyntaxList.getParentOrThrow(),
                replacing: {
                    textLength: end - pos,
                    nodes: [childSyntaxList],
                },
            });
            return this;
            function verifyArguments() {
                verifyInRange(pos);
                verifyInRange(end);
                if (pos > end)
                    throw new errors.ArgumentError("range", "Cannot specify a start position greater than the end position.");
            }
            function verifyInRange(i) {
                if (i >= validRange[0] && i <= validRange[1])
                    return;
                throw new errors.InvalidOperationError(`Cannot insert or replace text outside the bounds of the node. `
                    + `Expected a position between [${validRange[0]}, ${validRange[1]}], but received ${i}.`);
            }
        }
    };
}
function getValidRange(thisNode) {
    const rangeNode = getRangeNode();
    const openBrace = Node.isSourceFile(rangeNode) ? undefined : rangeNode.getPreviousSiblingIfKind(ts$1.SyntaxKind.OpenBraceToken);
    const closeBrace = openBrace == null ? undefined : rangeNode.getNextSiblingIfKind(ts$1.SyntaxKind.CloseBraceToken);
    if (openBrace != null && closeBrace != null)
        return [openBrace.getEnd(), closeBrace.getStart()];
    else
        return [rangeNode.getPos(), rangeNode.getEnd()];
    function getRangeNode() {
        if (Node.isSourceFile(thisNode))
            return thisNode;
        return thisNode.getChildSyntaxListOrThrow();
    }
}

function TypeArgumentedNode(Base) {
    return class extends Base {
        getTypeArguments() {
            if (this.compilerNode.typeArguments == null)
                return [];
            return this.compilerNode.typeArguments.map(a => this._getNodeFromCompilerNode(a));
        }
        addTypeArgument(argumentText) {
            return this.addTypeArguments([argumentText])[0];
        }
        addTypeArguments(argumentTexts) {
            return this.insertTypeArguments(this.getTypeArguments().length, argumentTexts);
        }
        insertTypeArgument(index, argumentText) {
            return this.insertTypeArguments(index, [argumentText])[0];
        }
        insertTypeArguments(index, argumentTexts) {
            if (ArrayUtils.isNullOrEmpty(argumentTexts))
                return [];
            const typeArguments = this.getTypeArguments();
            index = verifyAndGetIndex(index, typeArguments.length);
            if (typeArguments.length === 0) {
                const identifier = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.Identifier);
                insertIntoParentTextRange({
                    insertPos: identifier.getEnd(),
                    parent: this,
                    newText: `<${argumentTexts.join(", ")}>`,
                });
            }
            else {
                insertIntoCommaSeparatedNodes({
                    parent: this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.LessThanToken).getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.SyntaxList),
                    currentNodes: typeArguments,
                    insertIndex: index,
                    newText: argumentTexts.join(", "),
                    useTrailingCommas: false,
                });
            }
            return getNodesToReturn(typeArguments, this.getTypeArguments(), index, false);
        }
        removeTypeArgument(typeArgOrIndex) {
            const typeArguments = this.getTypeArguments();
            if (typeArguments.length === 0)
                throw new errors.InvalidOperationError("Cannot remove a type argument when none exist.");
            const typeArgToRemove = typeof typeArgOrIndex === "number" ? getTypeArgFromIndex(typeArgOrIndex) : typeArgOrIndex;
            if (typeArguments.length === 1) {
                const childSyntaxList = typeArguments[0].getParentSyntaxListOrThrow();
                removeChildren({
                    children: [
                        childSyntaxList.getPreviousSiblingIfKindOrThrow(ts$1.SyntaxKind.LessThanToken),
                        childSyntaxList,
                        childSyntaxList.getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.GreaterThanToken),
                    ],
                });
            }
            else {
                removeCommaSeparatedChild(typeArgToRemove);
            }
            return this;
            function getTypeArgFromIndex(index) {
                return typeArguments[verifyAndGetIndex(index, typeArguments.length - 1)];
            }
        }
    };
}

function TypedNode(Base) {
    return class extends Base {
        getTypeNode() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.type);
        }
        getTypeNodeOrThrow() {
            return errors.throwIfNullOrUndefined(this.getTypeNode(), "Expected to find a type node.");
        }
        setType(textOrWriterFunction) {
            const text = getTextFromStringOrWriter(this._getWriterWithQueuedChildIndentation(), textOrWriterFunction);
            if (StringUtils.isNullOrWhitespace(text))
                return this.removeType();
            const typeNode = this.getTypeNode();
            if (typeNode != null && typeNode.getText() === text)
                return this;
            const separatorSyntaxKind = getSeparatorSyntaxKindForNode(this);
            const separatorNode = this.getFirstChildByKind(separatorSyntaxKind);
            let insertPos;
            let newText;
            if (separatorNode == null) {
                insertPos = getInsertPosWhenNoType(this);
                newText = (separatorSyntaxKind === ts$1.SyntaxKind.EqualsToken ? " = " : ": ") + text;
            }
            else {
                insertPos = typeNode.getStart();
                newText = text;
            }
            insertIntoParentTextRange({
                parent: this,
                insertPos,
                newText,
                replacing: {
                    textLength: typeNode == null ? 0 : typeNode.getWidth(),
                },
            });
            return this;
            function getInsertPosWhenNoType(node) {
                const identifier = node.getFirstChildByKindOrThrow(ts$1.SyntaxKind.Identifier);
                const nextSibling = identifier.getNextSibling();
                const insertAfterNode = isQuestionOrExclamation(nextSibling) ? nextSibling : identifier;
                return insertAfterNode.getEnd();
            }
            function isQuestionOrExclamation(node) {
                if (node == null)
                    return false;
                const kind = node.getKind();
                return kind === ts$1.SyntaxKind.QuestionToken || kind === ts$1.SyntaxKind.ExclamationToken;
            }
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.type != null)
                this.setType(structure.type);
            else if (structure.hasOwnProperty("type"))
                this.removeType();
            return this;
        }
        removeType() {
            if (this.getKind() === ts$1.SyntaxKind.TypeAliasDeclaration)
                throw new errors.NotSupportedError(`Cannot remove the type of a type alias. Use ${"setType"} instead.`);
            const typeNode = this.getTypeNode();
            if (typeNode == null)
                return this;
            const separatorToken = typeNode.getPreviousSiblingIfKindOrThrow(getSeparatorSyntaxKindForNode(this));
            removeChildren({ children: [separatorToken, typeNode], removePrecedingSpaces: true });
            return this;
        }
        getStructure() {
            const typeNode = this.getTypeNode();
            return callBaseGetStructure(Base.prototype, this, {
                type: typeNode ? typeNode.getText({ trimLeadingIndentation: true }) : undefined,
            });
        }
    };
}
function getSeparatorSyntaxKindForNode(node) {
    switch (node.getKind()) {
        case ts$1.SyntaxKind.TypeAliasDeclaration:
            return ts$1.SyntaxKind.EqualsToken;
        default:
            return ts$1.SyntaxKind.ColonToken;
    }
}

function TypeElementMemberedNode(Base) {
    return class extends Base {
        addMember(member) {
            return this.addMembers([member])[0];
        }
        addMembers(members) {
            return this.insertMembers(getEndIndexFromArray(this.getMembersWithComments()), members);
        }
        insertMember(index, member) {
            return this.insertMembers(index, [member])[0];
        }
        insertMembers(index, members) {
            return insertIntoBracesOrSourceFileWithGetChildrenWithComments({
                getIndexedChildren: () => this.getMembersWithComments(),
                index,
                parent: this,
                write: writer => {
                    writer.newLineIfLastNot();
                    const memberWriter = this._getWriter();
                    const memberPrinter = this._context.structurePrinterFactory.forTypeElementMember();
                    memberPrinter.printTexts(memberWriter, members);
                    writer.write(memberWriter.toString());
                    writer.newLineIfLastNot();
                },
            });
        }
        addConstructSignature(structure) {
            return this.addConstructSignatures([structure])[0];
        }
        addConstructSignatures(structures) {
            return this.insertConstructSignatures(getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertConstructSignature(index, structure) {
            return this.insertConstructSignatures(index, [structure])[0];
        }
        insertConstructSignatures(index, structures) {
            return insertChildren({
                thisNode: this,
                index,
                structures,
                expectedKind: ts$1.SyntaxKind.ConstructSignature,
                createStructurePrinter: () => this._context.structurePrinterFactory.forConstructSignatureDeclaration(),
            });
        }
        getConstructSignature(findFunction) {
            return this.getConstructSignatures().find(findFunction);
        }
        getConstructSignatureOrThrow(findFunction) {
            return errors.throwIfNullOrUndefined(this.getConstructSignature(findFunction), "Expected to find a construct signature with the provided condition.");
        }
        getConstructSignatures() {
            return this.compilerNode.members.filter(m => m.kind === ts$1.SyntaxKind.ConstructSignature)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        addCallSignature(structure) {
            return this.addCallSignatures([structure])[0];
        }
        addCallSignatures(structures) {
            return this.insertCallSignatures(getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertCallSignature(index, structure) {
            return this.insertCallSignatures(index, [structure])[0];
        }
        insertCallSignatures(index, structures) {
            return insertChildren({
                thisNode: this,
                index,
                structures,
                expectedKind: ts$1.SyntaxKind.CallSignature,
                createStructurePrinter: () => this._context.structurePrinterFactory.forCallSignatureDeclaration(),
            });
        }
        getCallSignature(findFunction) {
            return this.getCallSignatures().find(findFunction);
        }
        getCallSignatureOrThrow(findFunction) {
            return errors.throwIfNullOrUndefined(this.getCallSignature(findFunction), "Expected to find a call signature with the provided condition.");
        }
        getCallSignatures() {
            return this.compilerNode.members.filter(m => m.kind === ts$1.SyntaxKind.CallSignature)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        addIndexSignature(structure) {
            return this.addIndexSignatures([structure])[0];
        }
        addIndexSignatures(structures) {
            return this.insertIndexSignatures(getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertIndexSignature(index, structure) {
            return this.insertIndexSignatures(index, [structure])[0];
        }
        insertIndexSignatures(index, structures) {
            return insertChildren({
                thisNode: this,
                index,
                structures,
                expectedKind: ts$1.SyntaxKind.IndexSignature,
                createStructurePrinter: () => this._context.structurePrinterFactory.forIndexSignatureDeclaration(),
            });
        }
        getIndexSignature(findFunction) {
            return this.getIndexSignatures().find(findFunction);
        }
        getIndexSignatureOrThrow(findFunction) {
            return errors.throwIfNullOrUndefined(this.getIndexSignature(findFunction), "Expected to find a index signature with the provided condition.");
        }
        getIndexSignatures() {
            return this.compilerNode.members.filter(m => m.kind === ts$1.SyntaxKind.IndexSignature)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        addMethod(structure) {
            return this.addMethods([structure])[0];
        }
        addMethods(structures) {
            return this.insertMethods(getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertMethod(index, structure) {
            return this.insertMethods(index, [structure])[0];
        }
        insertMethods(index, structures) {
            return insertChildren({
                thisNode: this,
                index,
                structures,
                expectedKind: ts$1.SyntaxKind.MethodSignature,
                createStructurePrinter: () => this._context.structurePrinterFactory.forMethodSignature(),
            });
        }
        getMethod(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getMethods(), nameOrFindFunction);
        }
        getMethodOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getMethod(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("interface method signature", nameOrFindFunction));
        }
        getMethods() {
            return this.compilerNode.members.filter(m => m.kind === ts$1.SyntaxKind.MethodSignature)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        addProperty(structure) {
            return this.addProperties([structure])[0];
        }
        addProperties(structures) {
            return this.insertProperties(getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertProperty(index, structure) {
            return this.insertProperties(index, [structure])[0];
        }
        insertProperties(index, structures) {
            return insertChildren({
                thisNode: this,
                index,
                structures,
                expectedKind: ts$1.SyntaxKind.PropertySignature,
                createStructurePrinter: () => this._context.structurePrinterFactory.forPropertySignature(),
            });
        }
        getProperty(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getProperties(), nameOrFindFunction);
        }
        getPropertyOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("interface property signature", nameOrFindFunction));
        }
        getProperties() {
            return this.compilerNode.members.filter(m => m.kind === ts$1.SyntaxKind.PropertySignature)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        getMembers() {
            return this.compilerNode.members.map(m => this._getNodeFromCompilerNode(m));
        }
        getMembersWithComments() {
            const compilerNode = this.compilerNode;
            return ExtendedParser.getContainerArray(compilerNode, this._sourceFile.compilerNode)
                .map(m => this._getNodeFromCompilerNode(m));
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.callSignatures != null) {
                this.getCallSignatures().forEach(c => c.remove());
                this.addCallSignatures(structure.callSignatures);
            }
            if (structure.constructSignatures != null) {
                this.getConstructSignatures().forEach(c => c.remove());
                this.addConstructSignatures(structure.constructSignatures);
            }
            if (structure.indexSignatures != null) {
                this.getIndexSignatures().forEach(c => c.remove());
                this.addIndexSignatures(structure.indexSignatures);
            }
            if (structure.properties != null) {
                this.getProperties().forEach(c => c.remove());
                this.addProperties(structure.properties);
            }
            if (structure.methods != null) {
                this.getMethods().forEach(c => c.remove());
                this.addMethods(structure.methods);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                callSignatures: this.getCallSignatures().map(node => node.getStructure()),
                constructSignatures: this.getConstructSignatures().map(node => node.getStructure()),
                indexSignatures: this.getIndexSignatures().map(node => node.getStructure()),
                methods: this.getMethods().map(node => node.getStructure()),
                properties: this.getProperties().map(node => node.getStructure()),
            });
        }
    };
}
function insertChildren(opts) {
    return insertIntoBracesOrSourceFileWithGetChildren({
        getIndexedChildren: () => opts.thisNode.getMembersWithComments(),
        parent: opts.thisNode,
        index: opts.index,
        structures: opts.structures,
        expectedKind: opts.expectedKind,
        write: (writer, info) => {
            writer.newLineIfLastNot();
            opts.createStructurePrinter().printTexts(writer, opts.structures);
            writer.newLineIfLastNot();
        },
    });
}

function TypeParameteredNode(Base) {
    return class extends Base {
        getTypeParameter(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getTypeParameters(), nameOrFindFunction);
        }
        getTypeParameterOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getTypeParameter(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("type parameter", nameOrFindFunction));
        }
        getTypeParameters() {
            const typeParameters = this.compilerNode.typeParameters;
            if (typeParameters == null)
                return [];
            return typeParameters.map(t => this._getNodeFromCompilerNode(t));
        }
        addTypeParameter(structure) {
            return this.addTypeParameters([structure])[0];
        }
        addTypeParameters(structures) {
            return this.insertTypeParameters(getEndIndexFromArray(this.compilerNode.typeParameters), structures);
        }
        insertTypeParameter(index, structure) {
            return this.insertTypeParameters(index, [structure])[0];
        }
        insertTypeParameters(index, structures) {
            if (ArrayUtils.isNullOrEmpty(structures))
                return [];
            const typeParameters = this.getTypeParameters();
            const writer = this._getWriterWithQueuedChildIndentation();
            const structurePrinter = this._context.structurePrinterFactory.forTypeParameterDeclaration();
            index = verifyAndGetIndex(index, typeParameters.length);
            structurePrinter.printTexts(writer, structures);
            if (typeParameters.length === 0) {
                insertIntoParentTextRange({
                    insertPos: getInsertPos(this),
                    parent: this,
                    newText: `<${writer.toString()}>`,
                });
            }
            else {
                insertIntoCommaSeparatedNodes({
                    parent: this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.LessThanToken).getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.SyntaxList),
                    currentNodes: typeParameters,
                    insertIndex: index,
                    newText: writer.toString(),
                    useTrailingCommas: false,
                });
            }
            return getNodesToReturn(typeParameters, this.getTypeParameters(), index, false);
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.typeParameters != null) {
                this.getTypeParameters().forEach(t => t.remove());
                this.addTypeParameters(structure.typeParameters);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                typeParameters: this.getTypeParameters().map(p => p.getStructure()),
            });
        }
    };
}
function getInsertPos(node) {
    const namedNode = node;
    if (namedNode.getNameNode != null)
        return namedNode.getNameNode().getEnd();
    else if (Node.isCallSignatureDeclaration(node) || Node.isFunctionTypeNode(node))
        return node.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenParenToken).getStart();
    else
        throw new errors.NotImplementedError(`Not implemented scenario inserting type parameters for node with kind ${node.getKindName()}.`);
}

function UnwrappableNode(Base) {
    return class extends Base {
        unwrap() {
            unwrapNode(this);
        }
    };
}

class ArrayBindingPattern extends Node {
    getElements() {
        return this.compilerNode.elements.map(e => this._getNodeFromCompilerNode(e));
    }
}

const createBase = (ctor) => InitializerExpressionableNode(BindingNamedNode(ctor));
const BindingElementBase = createBase(Node);
class BindingElement extends BindingElementBase {
    getDotDotDotTokenOrThrow() {
        return errors.throwIfNullOrUndefined(this.getDotDotDotToken(), "Expected to find a dot dot dot token (...).");
    }
    getDotDotDotToken() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.dotDotDotToken);
    }
    getPropertyNameNodeOrThrow() {
        return errors.throwIfNullOrUndefined(this.getPropertyNameNode(), "Expected to find a property name node.");
    }
    getPropertyNameNode() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.propertyName);
    }
}

class ObjectBindingPattern extends Node {
    getElements() {
        return this.compilerNode.elements.map(e => this._getNodeFromCompilerNode(e));
    }
}

function AbstractableNode(Base) {
    return class extends Base {
        isAbstract() {
            return this.getAbstractKeyword() != null;
        }
        getAbstractKeyword() {
            return this.getFirstModifierByKind(ts$1.SyntaxKind.AbstractKeyword);
        }
        getAbstractKeywordOrThrow() {
            return errors.throwIfNullOrUndefined(this.getAbstractKeyword(), "Expected to find an abstract keyword.");
        }
        setIsAbstract(isAbstract) {
            this.toggleModifier("abstract", isAbstract);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.isAbstract != null)
                this.setIsAbstract(structure.isAbstract);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                isAbstract: this.isAbstract(),
            });
        }
    };
}

class Expression extends Node {
    getContextualType() {
        return this._context.typeChecker.getContextualType(this);
    }
}

const BinaryExpressionBase = Expression;
class BinaryExpression extends BinaryExpressionBase {
    getLeft() {
        return this._getNodeFromCompilerNode(this.compilerNode.left);
    }
    getOperatorToken() {
        return this._getNodeFromCompilerNode(this.compilerNode.operatorToken);
    }
    getRight() {
        return this._getNodeFromCompilerNode(this.compilerNode.right);
    }
}

class UnaryExpression extends Expression {
}

class UpdateExpression extends UnaryExpression {
}

class LeftHandSideExpression extends UpdateExpression {
}

class MemberExpression extends LeftHandSideExpression {
}

class PrimaryExpression extends MemberExpression {
}

class ArrayLiteralExpression extends PrimaryExpression {
    getElements() {
        return this.compilerNode.elements.map(e => this._getNodeFromCompilerNode(e));
    }
    addElement(textOrWriterFunction, options) {
        return this.addElements([textOrWriterFunction], options)[0];
    }
    addElements(textsOrWriterFunction, options) {
        return this.insertElements(this.compilerNode.elements.length, textsOrWriterFunction, options);
    }
    insertElement(index, textOrWriterFunction, options) {
        return this.insertElements(index, [textOrWriterFunction], options)[0];
    }
    insertElements(index, textsOrWriterFunction, options = {}) {
        const elements = this.getElements();
        index = verifyAndGetIndex(index, elements.length);
        const useNewLines = getUseNewLines(this);
        const writer = useNewLines ? this._getWriterWithChildIndentation() : this._getWriterWithQueuedChildIndentation();
        const stringStructurePrinter = new StringStructurePrinter();
        const structurePrinter = useNewLines
            ? new CommaNewLineSeparatedStructuresPrinter(stringStructurePrinter)
            : new CommaSeparatedStructuresPrinter(stringStructurePrinter);
        structurePrinter.printText(writer, textsOrWriterFunction);
        return insertTexts(this);
        function insertTexts(node) {
            insertIntoCommaSeparatedNodes({
                parent: node.getFirstChildByKindOrThrow(ts$1.SyntaxKind.SyntaxList),
                currentNodes: elements,
                insertIndex: index,
                newText: writer.toString(),
                useNewLines,
                useTrailingCommas: useNewLines && node._context.manipulationSettings.getUseTrailingCommas(),
            });
            const newElements = node.getElements();
            return getNodesToReturn(elements, newElements, index, false);
        }
        function getUseNewLines(node) {
            if (options.useNewLines != null)
                return options.useNewLines;
            if (elements.length > 1)
                return allElementsOnDifferentLines();
            return node.getStartLineNumber() !== node.getEndLineNumber();
            function allElementsOnDifferentLines() {
                let previousLine = elements[0].getStartLineNumber();
                for (let i = 1; i < elements.length; i++) {
                    const currentLine = elements[i].getStartLineNumber();
                    if (previousLine === currentLine)
                        return false;
                    previousLine = currentLine;
                }
                return true;
            }
        }
    }
    removeElement(elementOrIndex) {
        const elements = this.getElements();
        if (elements.length === 0)
            throw new errors.InvalidOperationError("Cannot remove an element when none exist.");
        const elementToRemove = typeof elementOrIndex === "number" ? getElementFromIndex(elementOrIndex) : elementOrIndex;
        removeCommaSeparatedChild(elementToRemove);
        function getElementFromIndex(index) {
            return elements[verifyAndGetIndex(index, elements.length - 1)];
        }
    }
}

function ExpressionedNode(Base) {
    return class extends Base {
        getExpression() {
            return this._getNodeFromCompilerNode(this.compilerNode.expression);
        }
        getExpressionIfKind(kind) {
            const { expression } = this.compilerNode;
            return expression.kind === kind ? this._getNodeFromCompilerNode(expression) : undefined;
        }
        getExpressionIfKindOrThrow(kind) {
            return errors.throwIfNullOrUndefined(this.getExpressionIfKind(kind), `An expression of the kind ${common.getSyntaxKindName(kind)} was expected.`);
        }
        setExpression(textOrWriterFunction) {
            this.getExpression().replaceWithText(textOrWriterFunction);
            return this;
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.expression != null)
                this.setExpression(structure.expression);
            return this;
        }
    };
}

function LeftHandSideExpressionedNode(Base) {
    return class extends Base {
        getExpression() {
            return this._getNodeFromCompilerNode(this.compilerNode.expression);
        }
    };
}

function UnaryExpressionedNode(Base) {
    return class extends Base {
        getExpression() {
            return this._getNodeFromCompilerNode(this.compilerNode.expression);
        }
    };
}

const createBase$1 = (ctor) => TypedNode(ExpressionedNode(ctor));
const AsExpressionBase = createBase$1(Expression);
class AsExpression extends AsExpressionBase {
}

const AwaitExpressionBase = UnaryExpressionedNode(UnaryExpression);
class AwaitExpression extends AwaitExpressionBase {
}

const createBase$2 = (ctor) => TypeArgumentedNode(ArgumentedNode(QuestionDotTokenableNode(LeftHandSideExpressionedNode(ctor))));
const CallExpressionBase = createBase$2(LeftHandSideExpression);
class CallExpression extends CallExpressionBase {
    getReturnType() {
        return this._context.typeChecker.getTypeAtLocation(this);
    }
}

const CommaListExpressionBase = Expression;
class CommaListExpression extends CommaListExpressionBase {
    getElements() {
        return this.compilerNode.elements.map(e => this._getNodeFromCompilerNode(e));
    }
}

const ConditionalExpressionBase = Expression;
class ConditionalExpression extends ConditionalExpressionBase {
    getCondition() {
        return this._getNodeFromCompilerNode(this.compilerNode.condition);
    }
    getQuestionToken() {
        return this._getNodeFromCompilerNode(this.compilerNode.questionToken);
    }
    getWhenTrue() {
        return this._getNodeFromCompilerNode(this.compilerNode.whenTrue);
    }
    getColonToken() {
        return this._getNodeFromCompilerNode(this.compilerNode.colonToken);
    }
    getWhenFalse() {
        return this._getNodeFromCompilerNode(this.compilerNode.whenFalse);
    }
}

const DeleteExpressionBase = UnaryExpressionedNode(UnaryExpression);
class DeleteExpression extends DeleteExpressionBase {
}

const createBase$3 = (ctor) => QuestionDotTokenableNode(LeftHandSideExpressionedNode(ctor));
const ElementAccessExpressionBase = createBase$3(MemberExpression);
class ElementAccessExpression extends ElementAccessExpressionBase {
    getArgumentExpression() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.argumentExpression);
    }
    getArgumentExpressionOrThrow() {
        return errors.throwIfNullOrUndefined(this.getArgumentExpression(), "Expected to find an argument expression.");
    }
}

const ImportExpressionBase = PrimaryExpression;
class ImportExpression extends ImportExpressionBase {
}

const LiteralExpressionBase = LiteralLikeNode(PrimaryExpression);
class LiteralExpression extends LiteralExpressionBase {
}

const MetaPropertyBase = NamedNode(PrimaryExpression);
class MetaProperty extends MetaPropertyBase {
    getKeywordToken() {
        return this.compilerNode.keywordToken;
    }
}

const createBase$4 = (ctor) => TypeArgumentedNode(ArgumentedNode(LeftHandSideExpressionedNode(ctor)));
const NewExpressionBase = createBase$4(PrimaryExpression);
class NewExpression extends NewExpressionBase {
}

const NonNullExpressionBase = ExpressionedNode(LeftHandSideExpression);
class NonNullExpression extends NonNullExpressionBase {
}

class ObjectLiteralElement extends Node {
    remove() {
        removeCommaSeparatedChild(this);
    }
}

class CommentObjectLiteralElement extends ObjectLiteralElement {
}

const ObjectLiteralExpressionBase = PrimaryExpression;
class ObjectLiteralExpression extends ObjectLiteralExpressionBase {
    getPropertyOrThrow(nameOrFindFunction) {
        return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("property", nameOrFindFunction));
    }
    getProperty(nameOrFindFunction) {
        let findFunc;
        if (typeof nameOrFindFunction === "string") {
            findFunc = prop => {
                if (prop["getName"] == null)
                    return false;
                return prop.getName() === nameOrFindFunction;
            };
        }
        else {
            findFunc = nameOrFindFunction;
        }
        return this.getProperties().find(findFunc);
    }
    getProperties() {
        return this.compilerNode.properties.map(p => this._getNodeFromCompilerNode(p));
    }
    getPropertiesWithComments() {
        const members = ExtendedParser.getContainerArray(this.compilerNode, this.getSourceFile().compilerNode);
        return members.map(p => this._getNodeFromCompilerNode(p));
    }
    _getAddIndex() {
        const members = ExtendedParser.getContainerArray(this.compilerNode, this.getSourceFile().compilerNode);
        return members.length;
    }
    addProperty(structure) {
        return this.insertProperties(this._getAddIndex(), [structure])[0];
    }
    addProperties(structures) {
        return this.insertProperties(this._getAddIndex(), structures);
    }
    insertProperty(index, structure) {
        return this.insertProperties(index, [structure])[0];
    }
    insertProperties(index, structures) {
        const properties = this.getPropertiesWithComments();
        index = verifyAndGetIndex(index, properties.length);
        const writer = this._getWriterWithChildIndentation();
        const structurePrinter = this._context.structurePrinterFactory.forObjectLiteralExpressionProperty();
        structurePrinter.printTexts(writer, structures);
        insertIntoCommaSeparatedNodes({
            parent: this.getChildSyntaxListOrThrow(),
            currentNodes: properties,
            insertIndex: index,
            newText: writer.toString(),
            useNewLines: true,
            useTrailingCommas: this._context.manipulationSettings.getUseTrailingCommas(),
        });
        return getNodesToReturn(properties, this.getPropertiesWithComments(), index, true);
    }
    addPropertyAssignment(structure) {
        return this.addPropertyAssignments([structure])[0];
    }
    addPropertyAssignments(structures) {
        return this.insertPropertyAssignments(this._getAddIndex(), structures);
    }
    insertPropertyAssignment(index, structure) {
        return this.insertPropertyAssignments(index, [structure])[0];
    }
    insertPropertyAssignments(index, structures) {
        return this._insertProperty(index, structures, () => this._context.structurePrinterFactory.forPropertyAssignment());
    }
    addShorthandPropertyAssignment(structure) {
        return this.addShorthandPropertyAssignments([structure])[0];
    }
    addShorthandPropertyAssignments(structures) {
        return this.insertShorthandPropertyAssignments(this._getAddIndex(), structures);
    }
    insertShorthandPropertyAssignment(index, structure) {
        return this.insertShorthandPropertyAssignments(index, [structure])[0];
    }
    insertShorthandPropertyAssignments(index, structures) {
        return this._insertProperty(index, structures, () => this._context.structurePrinterFactory.forShorthandPropertyAssignment());
    }
    addSpreadAssignment(structure) {
        return this.addSpreadAssignments([structure])[0];
    }
    addSpreadAssignments(structures) {
        return this.insertSpreadAssignments(this._getAddIndex(), structures);
    }
    insertSpreadAssignment(index, structure) {
        return this.insertSpreadAssignments(index, [structure])[0];
    }
    insertSpreadAssignments(index, structures) {
        return this._insertProperty(index, structures, () => this._context.structurePrinterFactory.forSpreadAssignment());
    }
    addMethod(structure) {
        return this.addMethods([structure])[0];
    }
    addMethods(structures) {
        return this.insertMethods(this._getAddIndex(), structures);
    }
    insertMethod(index, structure) {
        return this.insertMethods(index, [structure])[0];
    }
    insertMethods(index, structures) {
        return this._insertProperty(index, structures, () => this._context.structurePrinterFactory.forMethodDeclaration({ isAmbient: false }));
    }
    addGetAccessor(structure) {
        return this.addGetAccessors([structure])[0];
    }
    addGetAccessors(structures) {
        return this.insertGetAccessors(this._getAddIndex(), structures);
    }
    insertGetAccessor(index, structure) {
        return this.insertGetAccessors(index, [structure])[0];
    }
    insertGetAccessors(index, structures) {
        return this._insertProperty(index, structures, () => this._context.structurePrinterFactory.forGetAccessorDeclaration({ isAmbient: false }));
    }
    addSetAccessor(structure) {
        return this.addSetAccessors([structure])[0];
    }
    addSetAccessors(structures) {
        return this.insertSetAccessors(this._getAddIndex(), structures);
    }
    insertSetAccessor(index, structure) {
        return this.insertSetAccessors(index, [structure])[0];
    }
    insertSetAccessors(index, structures) {
        return this._insertProperty(index, structures, () => this._context.structurePrinterFactory.forSetAccessorDeclaration({ isAmbient: false }));
    }
    _insertProperty(index, structures, createStructurePrinter) {
        index = verifyAndGetIndex(index, this._getAddIndex());
        const writer = this._getWriterWithChildIndentation();
        const structurePrinter = new CommaNewLineSeparatedStructuresPrinter(createStructurePrinter());
        const oldProperties = this.getPropertiesWithComments();
        structurePrinter.printText(writer, structures);
        insertIntoCommaSeparatedNodes({
            parent: this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.SyntaxList),
            currentNodes: oldProperties,
            insertIndex: index,
            newText: writer.toString(),
            useNewLines: true,
            useTrailingCommas: this._context.manipulationSettings.getUseTrailingCommas(),
        });
        return getNodesToReturn(oldProperties, this.getPropertiesWithComments(), index, false);
    }
}

const createBase$5 = (ctor) => InitializerExpressionGetableNode(QuestionTokenableNode(PropertyNamedNode(ctor)));
const PropertyAssignmentBase = createBase$5(ObjectLiteralElement);
class PropertyAssignment extends PropertyAssignmentBase {
    removeInitializer() {
        const initializer = this.getInitializerOrThrow();
        const colonToken = initializer.getPreviousSiblingIfKindOrThrow(ts$1.SyntaxKind.ColonToken);
        const childIndex = this.getChildIndex();
        const sourceFileText = this._sourceFile.getFullText();
        const insertPos = this.getStart();
        const newText = sourceFileText.substring(insertPos, colonToken.getPos()) + sourceFileText.substring(initializer.getEnd(), this.getEnd());
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        insertIntoParentTextRange({
            insertPos,
            newText,
            parent,
            replacing: {
                textLength: this.getWidth(),
            },
        });
        return parent.getChildAtIndexIfKindOrThrow(childIndex, ts$1.SyntaxKind.ShorthandPropertyAssignment);
    }
    setInitializer(textOrWriterFunction) {
        const initializer = this.getInitializerOrThrow();
        insertIntoParentTextRange({
            insertPos: initializer.getStart(),
            newText: getTextFromStringOrWriter(this._getWriterWithQueuedChildIndentation(), textOrWriterFunction),
            parent: this,
            replacing: {
                textLength: initializer.getWidth(),
            },
        });
        return this;
    }
    set(structure) {
        callBaseSet(PropertyAssignmentBase.prototype, this, structure);
        if (structure.initializer != null)
            this.setInitializer(structure.initializer);
        else if (structure.hasOwnProperty("initializer"))
            return this.removeInitializer();
        return this;
    }
    getStructure() {
        const initializer = this.getInitializerOrThrow();
        const structure = callBaseGetStructure(PropertyAssignmentBase.prototype, this, {
            kind: exports.StructureKind.PropertyAssignment,
            initializer: initializer.getText(),
        });
        delete structure.hasQuestionToken;
        return structure;
    }
}

const createBase$6 = (ctor) => InitializerExpressionGetableNode(QuestionTokenableNode(NamedNode(ctor)));
const ShorthandPropertyAssignmentBase = createBase$6(ObjectLiteralElement);
class ShorthandPropertyAssignment extends ShorthandPropertyAssignmentBase {
    hasObjectAssignmentInitializer() {
        return this.compilerNode.objectAssignmentInitializer != null;
    }
    getObjectAssignmentInitializerOrThrow() {
        return errors.throwIfNullOrUndefined(this.getObjectAssignmentInitializer(), "Expected to find an object assignment initializer.");
    }
    getObjectAssignmentInitializer() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.objectAssignmentInitializer);
    }
    getEqualsTokenOrThrow() {
        return errors.throwIfNullOrUndefined(this.getEqualsToken(), "Expected to find an equals token.");
    }
    getEqualsToken() {
        const equalsToken = this.compilerNode.equalsToken;
        if (equalsToken == null)
            return undefined;
        return this._getNodeFromCompilerNode(equalsToken);
    }
    removeObjectAssignmentInitializer() {
        if (!this.hasObjectAssignmentInitializer())
            return this;
        removeChildren({
            children: [this.getEqualsTokenOrThrow(), this.getObjectAssignmentInitializerOrThrow()],
            removePrecedingSpaces: true,
        });
        return this;
    }
    setInitializer(text) {
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        const childIndex = this.getChildIndex();
        insertIntoParentTextRange({
            insertPos: this.getStart(),
            newText: this.getText() + `: ${text}`,
            parent,
            replacing: {
                textLength: this.getWidth(),
            },
        });
        return parent.getChildAtIndexIfKindOrThrow(childIndex, ts$1.SyntaxKind.PropertyAssignment);
    }
    set(structure) {
        callBaseSet(ShorthandPropertyAssignmentBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        const structure = callBaseGetStructure(ShorthandPropertyAssignmentBase.prototype, this, {
            kind: exports.StructureKind.ShorthandPropertyAssignment,
        });
        delete structure.hasQuestionToken;
        return structure;
    }
}

const SpreadAssignmentBase = ExpressionedNode(ObjectLiteralElement);
class SpreadAssignment extends SpreadAssignmentBase {
    set(structure) {
        callBaseSet(SpreadAssignmentBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(SpreadAssignmentBase.prototype, this, {
            kind: exports.StructureKind.SpreadAssignment,
            expression: this.getExpression().getText(),
        });
    }
}

const OmittedExpressionBase = Expression;
class OmittedExpression extends OmittedExpressionBase {
}

const ParenthesizedExpressionBase = ExpressionedNode(Expression);
class ParenthesizedExpression extends ParenthesizedExpressionBase {
}

const PartiallyEmittedExpressionBase = ExpressionedNode(Expression);
class PartiallyEmittedExpression extends PartiallyEmittedExpressionBase {
}

const PostfixUnaryExpressionBase = UnaryExpression;
class PostfixUnaryExpression extends PostfixUnaryExpressionBase {
    getOperatorToken() {
        return this.compilerNode.operator;
    }
    getOperand() {
        return this._getNodeFromCompilerNode(this.compilerNode.operand);
    }
}

const PrefixUnaryExpressionBase = UnaryExpression;
class PrefixUnaryExpression extends PrefixUnaryExpressionBase {
    getOperatorToken() {
        return this.compilerNode.operator;
    }
    getOperand() {
        return this._getNodeFromCompilerNode(this.compilerNode.operand);
    }
}

const createBase$7 = (ctor) => NamedNode(QuestionDotTokenableNode(LeftHandSideExpressionedNode(ctor)));
const PropertyAccessExpressionBase = createBase$7(MemberExpression);
class PropertyAccessExpression extends PropertyAccessExpressionBase {
}

const SpreadElementBase = ExpressionedNode(Expression);
class SpreadElement extends SpreadElementBase {
}

const SuperExpressionBase = PrimaryExpression;
class SuperExpression extends SuperExpressionBase {
}

const ThisExpressionBase = PrimaryExpression;
class ThisExpression extends ThisExpressionBase {
}

const createBase$8 = (ctor) => TypedNode(UnaryExpressionedNode(ctor));
const TypeAssertionBase = createBase$8(UnaryExpression);
class TypeAssertion extends TypeAssertionBase {
}

const TypeOfExpressionBase = UnaryExpressionedNode(UnaryExpression);
class TypeOfExpression extends TypeOfExpressionBase {
}

const VoidExpressionBase = UnaryExpressionedNode(UnaryExpression);
class VoidExpression extends VoidExpressionBase {
}

const YieldExpressionBase = GeneratorableNode(Expression);
class YieldExpression extends YieldExpressionBase {
    getExpression() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.expression);
    }
    getExpressionOrThrow() {
        return errors.throwIfNullOrUndefined(this.getExpression(), "Expected to find an expression.");
    }
}

const StatementBase = ChildOrderableNode(Node);
class Statement extends StatementBase {
    remove() {
        removeStatementedNodeChild(this);
    }
}

function StatementedNode(Base) {
    return class extends Base {
        getStatements() {
            var _a;
            const statementsContainer = this._getCompilerStatementsContainer();
            const statements = (_a = statementsContainer === null || statementsContainer === void 0 ? void 0 : statementsContainer.statements) !== null && _a !== void 0 ? _a : [];
            return statements.map(s => this._getNodeFromCompilerNode(s));
        }
        getStatementsWithComments() {
            return this._getCompilerStatementsWithComments().map(s => this._getNodeFromCompilerNode(s));
        }
        getStatement(findFunction) {
            return this.getStatements().find(findFunction);
        }
        getStatementOrThrow(findFunction) {
            return errors.throwIfNullOrUndefined(this.getStatement(findFunction), "Expected to find a statement matching the provided condition.");
        }
        getStatementByKind(kind) {
            const statement = this._getCompilerStatementsWithComments().find(s => s.kind === kind);
            return this._getNodeFromCompilerNodeIfExists(statement);
        }
        getStatementByKindOrThrow(kind) {
            return errors.throwIfNullOrUndefined(this.getStatementByKind(kind), `Expected to find a statement with syntax kind ${common.getSyntaxKindName(kind)}.`);
        }
        addStatements(textOrWriterFunction) {
            return this.insertStatements(this._getCompilerStatementsWithComments().length, textOrWriterFunction);
        }
        insertStatements(index, statements) {
            addBodyIfNotExists(this);
            const writerFunction = (writer) => {
                const statementsPrinter = this._context.structurePrinterFactory.forStatement({ isAmbient: isNodeAmbientOrInAmbientContext(this) });
                statementsPrinter.printTexts(writer, statements);
            };
            return getChildSyntaxList.call(this).insertChildText(index, writerFunction);
            function getChildSyntaxList() {
                const childSyntaxList = this.getChildSyntaxListOrThrow();
                if (Node.isCaseClause(this) || Node.isDefaultClause(this)) {
                    const block = childSyntaxList.getFirstChildIfKind(ts$1.SyntaxKind.Block);
                    if (block != null)
                        return block.getChildSyntaxListOrThrow();
                }
                return childSyntaxList;
            }
        }
        removeStatement(index) {
            index = verifyAndGetIndex(index, this._getCompilerStatementsWithComments().length - 1);
            return this.removeStatements([index, index]);
        }
        removeStatements(indexRange) {
            const statements = this.getStatementsWithComments();
            errors.throwIfRangeOutOfRange(indexRange, [0, statements.length], "indexRange");
            removeStatementedNodeChildren(statements.slice(indexRange[0], indexRange[1] + 1));
            return this;
        }
        addClass(structure) {
            return this.addClasses([structure])[0];
        }
        addClasses(structures) {
            return this.insertClasses(this._getCompilerStatementsWithComments().length, structures);
        }
        insertClass(index, structure) {
            return this.insertClasses(index, [structure])[0];
        }
        insertClasses(index, structures) {
            return this._insertChildren({
                expectedKind: ts$1.SyntaxKind.ClassDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forClassDeclaration({ isAmbient: isNodeAmbientOrInAmbientContext(this) })
                            .printTexts(writer, structures);
                    });
                },
            });
        }
        getClasses() {
            return this.getStatements().filter(Node.isClassDeclaration);
        }
        getClass(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getClasses(), nameOrFindFunction);
        }
        getClassOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getClass(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class", nameOrFindFunction));
        }
        addEnum(structure) {
            return this.addEnums([structure])[0];
        }
        addEnums(structures) {
            return this.insertEnums(this._getCompilerStatementsWithComments().length, structures);
        }
        insertEnum(index, structure) {
            return this.insertEnums(index, [structure])[0];
        }
        insertEnums(index, structures) {
            return this._insertChildren({
                expectedKind: ts$1.SyntaxKind.EnumDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forEnumDeclaration().printTexts(writer, structures);
                    });
                },
            });
        }
        getEnums() {
            return this.getStatements().filter(Node.isEnumDeclaration);
        }
        getEnum(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getEnums(), nameOrFindFunction);
        }
        getEnumOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getEnum(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("enum", nameOrFindFunction));
        }
        addFunction(structure) {
            return this.addFunctions([structure])[0];
        }
        addFunctions(structures) {
            return this.insertFunctions(this._getCompilerStatementsWithComments().length, structures);
        }
        insertFunction(index, structure) {
            return this.insertFunctions(index, [structure])[0];
        }
        insertFunctions(index, structures) {
            return this._insertChildren({
                expectedKind: ts$1.SyntaxKind.FunctionDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forFunctionDeclaration({
                            isAmbient: isNodeAmbientOrInAmbientContext(this),
                        }).printTexts(writer, structures);
                    }, {
                        previousNewLine: previousMember => structures[0].hasDeclareKeyword === true
                            && Node.isFunctionDeclaration(previousMember)
                            && previousMember.getBody() == null,
                        nextNewLine: nextMember => structures[structures.length - 1].hasDeclareKeyword === true
                            && Node.isFunctionDeclaration(nextMember)
                            && nextMember.getBody() == null,
                    });
                },
            });
        }
        getFunctions() {
            return this.getStatements().filter(Node.isFunctionDeclaration).filter(f => f.isAmbient() || f.isImplementation());
        }
        getFunction(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getFunctions(), nameOrFindFunction);
        }
        getFunctionOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getFunction(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("function", nameOrFindFunction));
        }
        addInterface(structure) {
            return this.addInterfaces([structure])[0];
        }
        addInterfaces(structures) {
            return this.insertInterfaces(this._getCompilerStatementsWithComments().length, structures);
        }
        insertInterface(index, structure) {
            return this.insertInterfaces(index, [structure])[0];
        }
        insertInterfaces(index, structures) {
            return this._insertChildren({
                expectedKind: ts$1.SyntaxKind.InterfaceDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forInterfaceDeclaration().printTexts(writer, structures);
                    });
                },
            });
        }
        getInterfaces() {
            return this.getStatements().filter(Node.isInterfaceDeclaration);
        }
        getInterface(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getInterfaces(), nameOrFindFunction);
        }
        getInterfaceOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getInterface(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("interface", nameOrFindFunction));
        }
        addNamespace(structure) {
            return this.addNamespaces([structure])[0];
        }
        addNamespaces(structures) {
            return this.insertNamespaces(this._getCompilerStatementsWithComments().length, structures);
        }
        insertNamespace(index, structure) {
            return this.insertNamespaces(index, [structure])[0];
        }
        insertNamespaces(index, structures) {
            return this._insertChildren({
                expectedKind: ts$1.SyntaxKind.ModuleDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forNamespaceDeclaration({ isAmbient: isNodeAmbientOrInAmbientContext(this) })
                            .printTexts(writer, structures);
                    });
                },
            });
        }
        getNamespaces() {
            return this.getStatements().filter(Node.isNamespaceDeclaration);
        }
        getNamespace(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getNamespaces(), nameOrFindFunction);
        }
        getNamespaceOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getNamespace(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("namespace", nameOrFindFunction));
        }
        addTypeAlias(structure) {
            return this.addTypeAliases([structure])[0];
        }
        addTypeAliases(structures) {
            return this.insertTypeAliases(this._getCompilerStatementsWithComments().length, structures);
        }
        insertTypeAlias(index, structure) {
            return this.insertTypeAliases(index, [structure])[0];
        }
        insertTypeAliases(index, structures) {
            return this._insertChildren({
                expectedKind: ts$1.SyntaxKind.TypeAliasDeclaration,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forTypeAliasDeclaration().printTexts(writer, structures);
                    }, {
                        previousNewLine: previousMember => Node.isTypeAliasDeclaration(previousMember),
                        nextNewLine: nextMember => Node.isTypeAliasDeclaration(nextMember),
                    });
                },
            });
        }
        getTypeAliases() {
            return this.getStatements().filter(Node.isTypeAliasDeclaration);
        }
        getTypeAlias(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getTypeAliases(), nameOrFindFunction);
        }
        getTypeAliasOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getTypeAlias(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("type alias", nameOrFindFunction));
        }
        getVariableStatements() {
            return this.getStatements().filter(Node.isVariableStatement);
        }
        getVariableStatement(nameOrFindFunction) {
            return this.getVariableStatements().find(getFindFunction());
            function getFindFunction() {
                if (typeof nameOrFindFunction === "string")
                    return (statement) => statement.getDeclarations().some(d => nodeHasName(d, nameOrFindFunction));
                return nameOrFindFunction;
            }
        }
        getVariableStatementOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getVariableStatement(nameOrFindFunction), "Expected to find a variable statement that matched the provided condition.");
        }
        addVariableStatement(structure) {
            return this.addVariableStatements([structure])[0];
        }
        addVariableStatements(structures) {
            return this.insertVariableStatements(this._getCompilerStatementsWithComments().length, structures);
        }
        insertVariableStatement(index, structure) {
            return this.insertVariableStatements(index, [structure])[0];
        }
        insertVariableStatements(index, structures) {
            return this._insertChildren({
                expectedKind: ts$1.SyntaxKind.VariableStatement,
                index,
                structures,
                write: (writer, info) => {
                    this._standardWrite(writer, info, () => {
                        this._context.structurePrinterFactory.forVariableStatement().printTexts(writer, structures);
                    }, {
                        previousNewLine: previousMember => Node.isVariableStatement(previousMember),
                        nextNewLine: nextMember => Node.isVariableStatement(nextMember),
                    });
                },
            });
        }
        getVariableDeclarations() {
            const variables = [];
            for (const list of this.getVariableStatements())
                variables.push(...list.getDeclarations());
            return variables;
        }
        getVariableDeclaration(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getVariableDeclarations(), nameOrFindFunction);
        }
        getVariableDeclarationOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getVariableDeclaration(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("variable declaration", nameOrFindFunction));
        }
        getStructure() {
            const structure = {};
            if (Node.isBodyableNode(this) && !this.hasBody())
                structure.statements = undefined;
            else {
                structure.statements = this.getStatements().map(s => {
                    if (Node._hasStructure(s))
                        return s.getStructure();
                    return s.getText({ trimLeadingIndentation: true });
                });
            }
            return callBaseGetStructure(Base.prototype, this, structure);
        }
        set(structure) {
            if (Node.isBodyableNode(this) && structure.statements == null && structure.hasOwnProperty("statements"))
                this.removeBody();
            else if (structure.statements != null) {
                const statementCount = this._getCompilerStatementsWithComments().length;
                if (statementCount > 0)
                    this.removeStatements([0, statementCount - 1]);
            }
            callBaseSet(Base.prototype, this, structure);
            if (structure.statements != null)
                this.addStatements(structure.statements);
            return this;
        }
        _getCompilerStatementsWithComments() {
            const statementsContainer = this._getCompilerStatementsContainer();
            if (statementsContainer == null)
                return [];
            else {
                return ExtendedParser.getContainerArray(statementsContainer, this._sourceFile.compilerNode);
            }
        }
        _getCompilerStatementsContainer() {
            var _a;
            if (Node.isSourceFile(this) || Node.isCaseClause(this) || Node.isDefaultClause(this))
                return this.compilerNode;
            else if (Node.isNamespaceDeclaration(this)) {
                return this._getInnerBody().compilerNode;
            }
            else if (Node.isBodyableNode(this) || Node.isBodiedNode(this))
                return (_a = this.getBody()) === null || _a === void 0 ? void 0 : _a.compilerNode;
            else if (Node.isBlock(this) || Node.isModuleBlock(this))
                return this.compilerNode;
            else
                throw new errors.NotImplementedError(`Could not find the statements for node kind: ${this.getKindName()}, text: ${this.getText()}`);
        }
        _insertChildren(opts) {
            addBodyIfNotExists(this);
            return insertIntoBracesOrSourceFileWithGetChildren({
                expectedKind: opts.expectedKind,
                getIndexedChildren: () => this.getStatementsWithComments(),
                index: opts.index,
                parent: this,
                structures: opts.structures,
                write: (writer, info) => opts.write(writer, info),
            });
        }
        _standardWrite(writer, info, writeStructures, opts = {}) {
            if (info.previousMember != null && (opts.previousNewLine == null || !opts.previousNewLine(info.previousMember))
                && !Node.isCommentNode(info.previousMember)) {
                writer.blankLine();
            }
            else if (!info.isStartOfFile) {
                writer.newLineIfLastNot();
            }
            writeStructures();
            if (info.nextMember != null && (opts.nextNewLine == null || !opts.nextNewLine(info.nextMember)))
                writer.blankLine();
            else
                writer.newLineIfLastNot();
        }
    };
}
function addBodyIfNotExists(node) {
    if (Node.isBodyableNode(node) && !node.hasBody())
        node.addBody();
}

const createBase$9 = (ctor) => TextInsertableNode(StatementedNode(ctor));
const BlockBase = createBase$9(Statement);
class Block extends BlockBase {
}

class BreakStatement extends Statement {
    getLabel() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.label);
    }
    getLabelOrThrow() {
        return errors.throwIfNullOrUndefined(this.getLabel(), "Expected to find a label.");
    }
}

const CaseBlockBase = TextInsertableNode(Node);
class CaseBlock extends CaseBlockBase {
    getClauses() {
        const clauses = this.compilerNode.clauses || [];
        return clauses.map(s => this._getNodeFromCompilerNode(s));
    }
    removeClause(index) {
        index = verifyAndGetIndex(index, this.getClauses().length - 1);
        return this.removeClauses([index, index]);
    }
    removeClauses(indexRange) {
        const clauses = this.getClauses();
        errors.throwIfRangeOutOfRange(indexRange, [0, clauses.length], "indexRange");
        removeClausedNodeChildren(clauses.slice(indexRange[0], indexRange[1] + 1));
        return this;
    }
}

const createBase$a = (ctor) => TextInsertableNode(StatementedNode(ctor));
const CaseClauseBase = createBase$a(Node);
class CaseClause extends CaseClauseBase {
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
    remove() {
        removeClausedNodeChild(this);
    }
}

const CatchClauseBase = Node;
class CatchClause extends CatchClauseBase {
    getBlock() {
        return this._getNodeFromCompilerNode(this.compilerNode.block);
    }
    getVariableDeclaration() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.variableDeclaration);
    }
    getVariableDeclarationOrThrow() {
        return errors.throwIfNullOrUndefined(this.getVariableDeclaration(), "Expected to find a variable declaration.");
    }
}

class CommentStatement extends Statement {
}

class ContinueStatement extends Statement {
    getLabel() {
        return this.compilerNode.label == null
            ? undefined
            : this._getNodeFromCompilerNode(this.compilerNode.label);
    }
    getLabelOrThrow() {
        return errors.throwIfNullOrUndefined(this.getLabel(), "Expected to find a label.");
    }
}

const DebuggerStatementBase = Statement;
class DebuggerStatement extends DebuggerStatementBase {
}

const createBase$b = (ctor) => TextInsertableNode(StatementedNode(ctor));
const DefaultClauseBase = createBase$b(Node);
class DefaultClause extends DefaultClauseBase {
    remove() {
        removeClausedNodeChild(this);
    }
}

class IterationStatement extends Statement {
    getStatement() {
        return this._getNodeFromCompilerNode(this.compilerNode.statement);
    }
}

const DoStatementBase = IterationStatement;
class DoStatement extends DoStatementBase {
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
}

const EmptyStatementBase = Statement;
class EmptyStatement extends EmptyStatementBase {
}

const ExpressionStatementBase = JSDocableNode(Statement);
class ExpressionStatement extends ExpressionStatementBase {
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
}

const ForInStatementBase = IterationStatement;
class ForInStatement extends ForInStatementBase {
    getInitializer() {
        return this._getNodeFromCompilerNode(this.compilerNode.initializer);
    }
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
}

const ForOfStatementBase = AwaitableNode(IterationStatement);
class ForOfStatement extends ForOfStatementBase {
    getInitializer() {
        return this._getNodeFromCompilerNode(this.compilerNode.initializer);
    }
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
}

const ForStatementBase = IterationStatement;
class ForStatement extends ForStatementBase {
    getInitializer() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.initializer);
    }
    getInitializerOrThrow() {
        return errors.throwIfNullOrUndefined(this.getInitializer(), "Expected to find an initializer.");
    }
    getCondition() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.condition);
    }
    getConditionOrThrow() {
        return errors.throwIfNullOrUndefined(this.getCondition(), "Expected to find a condition.");
    }
    getIncrementor() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.incrementor);
    }
    getIncrementorOrThrow() {
        return errors.throwIfNullOrUndefined(this.getIncrementor(), "Expected to find an incrementor.");
    }
}

class IfStatement extends Statement {
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
    getThenStatement() {
        return this._getNodeFromCompilerNode(this.compilerNode.thenStatement);
    }
    getElseStatement() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.elseStatement);
    }
    remove() {
        const nodes = [];
        if (Node.isIfStatement(this.getParentOrThrow()))
            nodes.push(this.getPreviousSiblingIfKindOrThrow(ts$1.SyntaxKind.ElseKeyword));
        nodes.push(this);
        removeStatementedNodeChildren(nodes);
    }
}

const LabeledStatementBase = JSDocableNode(Statement);
class LabeledStatement extends LabeledStatementBase {
    getLabel() {
        return this._getNodeFromCompilerNode(this.compilerNode.label);
    }
    getStatement() {
        return this._getNodeFromCompilerNode(this.compilerNode.statement);
    }
}

const NotEmittedStatementBase = Statement;
class NotEmittedStatement extends NotEmittedStatementBase {
}

class ReturnStatement extends Statement {
    getExpressionOrThrow() {
        return errors.throwIfNullOrUndefined(this.getExpression(), "Expected to find a return expression's expression.");
    }
    getExpression() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.expression);
    }
}

class SwitchStatement extends Statement {
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
    getCaseBlock() {
        return this._getNodeFromCompilerNode(this.compilerNode.caseBlock);
    }
    getClauses() {
        return this.getCaseBlock().getClauses();
    }
    removeClause(index) {
        return this.getCaseBlock().removeClause(index);
    }
    removeClauses(indexRange) {
        return this.getCaseBlock().removeClauses(indexRange);
    }
}

const ThrowStatementBase = Statement;
class ThrowStatement extends ThrowStatementBase {
    getExpression() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.expression);
    }
    getExpressionOrThrow() {
        return errors.throwIfNullOrUndefined(this.getExpression(), "Expected to find the throw statement's expression.");
    }
}

const TryStatementBase = Statement;
class TryStatement extends TryStatementBase {
    getTryBlock() {
        return this._getNodeFromCompilerNode(this.compilerNode.tryBlock);
    }
    getCatchClause() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.catchClause);
    }
    getCatchClauseOrThrow() {
        return errors.throwIfNullOrUndefined(this.getCatchClause(), "Expected to find a catch clause.");
    }
    getFinallyBlock() {
        if (this.compilerNode.finallyBlock == null || this.compilerNode.finallyBlock.getFullWidth() === 0)
            return undefined;
        return this._getNodeFromCompilerNode(this.compilerNode.finallyBlock);
    }
    getFinallyBlockOrThrow() {
        return errors.throwIfNullOrUndefined(this.getFinallyBlock(), "Expected to find a finally block.");
    }
}

const ExportAssignmentBase = Statement;
class ExportAssignment extends ExportAssignmentBase {
    isExportEquals() {
        return this.compilerNode.isExportEquals || false;
    }
    setIsExportEquals(value) {
        if (this.isExportEquals() === value)
            return this;
        if (value)
            this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.DefaultKeyword).replaceWithText("=");
        else
            this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.EqualsToken).replaceWithText("default");
        return this;
    }
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
    setExpression(textOrWriterFunction) {
        this.getExpression().replaceWithText(textOrWriterFunction, this._getWriterWithQueuedChildIndentation());
        return this;
    }
    set(structure) {
        callBaseSet(ExportAssignmentBase.prototype, this, structure);
        if (structure.expression != null)
            this.setExpression(structure.expression);
        if (structure.isExportEquals != null)
            this.setIsExportEquals(structure.isExportEquals);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(Statement.prototype, this, {
            kind: exports.StructureKind.ExportAssignment,
            expression: this.getExpression().getText(),
            isExportEquals: this.isExportEquals(),
        });
    }
}

const ExportDeclarationBase = Statement;
class ExportDeclaration extends ExportDeclarationBase {
    isTypeOnly() {
        return this.compilerNode.isTypeOnly;
    }
    setIsTypeOnly(value) {
        var _a;
        if (this.isTypeOnly() === value)
            return this;
        if (value) {
            insertIntoParentTextRange({
                parent: this,
                insertPos: ((_a = this.getNodeProperty("exportClause")) !== null && _a !== void 0 ? _a : this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.AsteriskToken)).getStart(),
                newText: "type ",
            });
        }
        else {
            const typeKeyword = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.TypeKeyword);
            removeChildren({
                children: [typeKeyword],
                removeFollowingSpaces: true,
            });
        }
        return this;
    }
    getNamespaceExport() {
        const exportClause = this.getNodeProperty("exportClause");
        return exportClause != null && Node.isNamespaceExport(exportClause) ? exportClause : undefined;
    }
    getNamespaceExportOrThrow() {
        return errors.throwIfNullOrUndefined(this.getNamespaceExport(), "Expected to find a namespace export.");
    }
    setNamespaceExport(name) {
        const exportClause = this.getNodeProperty("exportClause");
        const newText = StringUtils.isNullOrWhitespace(name) ? "*" : `* as ${name}`;
        if (exportClause == null) {
            const asteriskToken = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.AsteriskToken);
            insertIntoParentTextRange({
                insertPos: asteriskToken.getStart(),
                parent: this,
                newText,
                replacing: {
                    textLength: 1,
                },
            });
        }
        else if (Node.isNamespaceExport(exportClause))
            exportClause.getNameNode().replaceWithText(name);
        else {
            insertIntoParentTextRange({
                insertPos: exportClause.getStart(),
                parent: this,
                newText,
                replacing: {
                    textLength: exportClause.getWidth(),
                },
            });
        }
        return this;
    }
    setModuleSpecifier(textOrSourceFile) {
        const text = typeof textOrSourceFile === "string" ? textOrSourceFile : this._sourceFile.getRelativePathAsModuleSpecifierTo(textOrSourceFile);
        if (StringUtils.isNullOrEmpty(text)) {
            this.removeModuleSpecifier();
            return this;
        }
        const stringLiteral = this.getModuleSpecifier();
        if (stringLiteral == null) {
            const semiColonToken = this.getLastChildIfKind(ts$1.SyntaxKind.SemicolonToken);
            const quoteKind = this._context.manipulationSettings.getQuoteKind();
            insertIntoParentTextRange({
                insertPos: semiColonToken != null ? semiColonToken.getPos() : this.getEnd(),
                parent: this,
                newText: ` from ${quoteKind}${text}${quoteKind}`,
            });
        }
        else {
            stringLiteral.setLiteralValue(text);
        }
        return this;
    }
    getModuleSpecifier() {
        const moduleSpecifier = this._getNodeFromCompilerNodeIfExists(this.compilerNode.moduleSpecifier);
        if (moduleSpecifier == null)
            return undefined;
        if (!Node.isStringLiteral(moduleSpecifier))
            throw new errors.InvalidOperationError("Expected the module specifier to be a string literal.");
        return moduleSpecifier;
    }
    getModuleSpecifierValue() {
        const moduleSpecifier = this.getModuleSpecifier();
        return moduleSpecifier === null || moduleSpecifier === void 0 ? void 0 : moduleSpecifier.getLiteralValue();
    }
    getModuleSpecifierSourceFileOrThrow() {
        return errors.throwIfNullOrUndefined(this.getModuleSpecifierSourceFile(), `A module specifier source file was expected.`);
    }
    getModuleSpecifierSourceFile() {
        const stringLiteral = this.getLastChildByKind(ts$1.SyntaxKind.StringLiteral);
        if (stringLiteral == null)
            return undefined;
        const symbol = stringLiteral.getSymbol();
        if (symbol == null)
            return undefined;
        const declaration = symbol.getDeclarations()[0];
        return declaration != null && Node.isSourceFile(declaration) ? declaration : undefined;
    }
    isModuleSpecifierRelative() {
        const moduleSpecifierValue = this.getModuleSpecifierValue();
        if (moduleSpecifierValue == null)
            return false;
        return ModuleUtils.isModuleSpecifierRelative(moduleSpecifierValue);
    }
    removeModuleSpecifier() {
        const moduleSpecifier = this.getModuleSpecifier();
        if (moduleSpecifier == null)
            return this;
        if (!this.hasNamedExports())
            throw new errors.InvalidOperationError(`Cannot remove the module specifier from an export declaration that has no named exports.`);
        removeChildren({
            children: [this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.FromKeyword), moduleSpecifier],
            removePrecedingNewLines: true,
            removePrecedingSpaces: true,
        });
        return this;
    }
    hasModuleSpecifier() {
        return this.getLastChildByKind(ts$1.SyntaxKind.StringLiteral) != null;
    }
    isNamespaceExport() {
        return !this.hasNamedExports();
    }
    hasNamedExports() {
        var _a;
        return ((_a = this.compilerNode.exportClause) === null || _a === void 0 ? void 0 : _a.kind) === ts$1.SyntaxKind.NamedExports;
    }
    addNamedExport(namedExport) {
        return this.addNamedExports([namedExport])[0];
    }
    addNamedExports(namedExports) {
        return this.insertNamedExports(this.getNamedExports().length, namedExports);
    }
    insertNamedExport(index, namedExport) {
        return this.insertNamedExports(index, [namedExport])[0];
    }
    insertNamedExports(index, namedExports) {
        if (!(namedExports instanceof Function) && ArrayUtils.isNullOrEmpty(namedExports))
            return [];
        const originalNamedExports = this.getNamedExports();
        const writer = this._getWriterWithIndentation();
        const namedExportStructurePrinter = this._context.structurePrinterFactory.forNamedImportExportSpecifier();
        index = verifyAndGetIndex(index, originalNamedExports.length);
        const exportClause = this.getNodeProperty("exportClause");
        if (exportClause == null) {
            namedExportStructurePrinter.printTextsWithBraces(writer, namedExports);
            const asteriskToken = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.AsteriskToken);
            insertIntoParentTextRange({
                insertPos: asteriskToken.getStart(),
                parent: this,
                newText: writer.toString(),
                replacing: {
                    textLength: 1,
                },
            });
        }
        else if (exportClause.getKind() === ts$1.SyntaxKind.NamespaceExport) {
            namedExportStructurePrinter.printTextsWithBraces(writer, namedExports);
            insertIntoParentTextRange({
                insertPos: exportClause.getStart(),
                parent: this,
                newText: writer.toString(),
                replacing: {
                    textLength: exportClause.getWidth(),
                },
            });
        }
        else {
            namedExportStructurePrinter.printTexts(writer, namedExports);
            insertIntoCommaSeparatedNodes({
                parent: this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.NamedExports).getFirstChildByKindOrThrow(ts$1.SyntaxKind.SyntaxList),
                currentNodes: originalNamedExports,
                insertIndex: index,
                newText: writer.toString(),
                surroundWithSpaces: this._context.getFormatCodeSettings().insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces,
                useTrailingCommas: false,
            });
        }
        const newNamedExports = this.getNamedExports();
        return getNodesToReturn(originalNamedExports, newNamedExports, index, false);
    }
    getNamedExports() {
        const namedExports = this.compilerNode.exportClause;
        if (namedExports == null || ts$1.isNamespaceExport(namedExports))
            return [];
        return namedExports.elements.map(e => this._getNodeFromCompilerNode(e));
    }
    toNamespaceExport() {
        if (!this.hasModuleSpecifier())
            throw new errors.InvalidOperationError("Cannot change to a namespace export when no module specifier exists.");
        const namedExportsNode = this.getNodeProperty("exportClause");
        if (namedExportsNode == null)
            return this;
        insertIntoParentTextRange({
            parent: this,
            newText: "*",
            insertPos: namedExportsNode.getStart(),
            replacing: {
                textLength: namedExportsNode.getWidth(),
            },
        });
        return this;
    }
    set(structure) {
        callBaseSet(ExportDeclarationBase.prototype, this, structure);
        if (structure.namedExports != null) {
            setEmptyNamedExport(this);
            this.addNamedExports(structure.namedExports);
        }
        else if (structure.hasOwnProperty("namedExports") && structure.moduleSpecifier == null) {
            this.toNamespaceExport();
        }
        if (structure.moduleSpecifier != null)
            this.setModuleSpecifier(structure.moduleSpecifier);
        else if (structure.hasOwnProperty("moduleSpecifier"))
            this.removeModuleSpecifier();
        if (structure.namedExports == null && structure.hasOwnProperty("namedExports"))
            this.toNamespaceExport();
        if (structure.namespaceExport != null)
            this.setNamespaceExport(structure.namespaceExport);
        if (structure.isTypeOnly != null)
            this.setIsTypeOnly(structure.isTypeOnly);
        return this;
    }
    getStructure() {
        var _a;
        const moduleSpecifier = this.getModuleSpecifier();
        return callBaseGetStructure(ExportDeclarationBase.prototype, this, {
            kind: exports.StructureKind.ExportDeclaration,
            isTypeOnly: this.isTypeOnly(),
            moduleSpecifier: moduleSpecifier === null || moduleSpecifier === void 0 ? void 0 : moduleSpecifier.getLiteralText(),
            namedExports: this.getNamedExports().map(node => node.getStructure()),
            namespaceExport: (_a = this.getNamespaceExport()) === null || _a === void 0 ? void 0 : _a.getName(),
        });
    }
}
function setEmptyNamedExport(node) {
    const namedExportsNode = node.getNodeProperty("exportClause");
    let replaceNode;
    if (namedExportsNode != null) {
        if (node.getNamedExports().length === 0)
            return;
        replaceNode = namedExportsNode;
    }
    else {
        replaceNode = node.getFirstChildByKindOrThrow(ts$1.SyntaxKind.AsteriskToken);
    }
    insertIntoParentTextRange({
        parent: node,
        newText: "{ }",
        insertPos: replaceNode.getStart(),
        replacing: {
            textLength: replaceNode.getWidth(),
        },
    });
}

const ExportSpecifierBase = Node;
class ExportSpecifier extends ExportSpecifierBase {
    setName(name) {
        const nameNode = this.getNameNode();
        if (nameNode.getText() === name)
            return this;
        nameNode.replaceWithText(name);
        return this;
    }
    getName() {
        return this.getNameNode().getText();
    }
    getNameNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.propertyName || this.compilerNode.name);
    }
    renameAlias(alias) {
        if (StringUtils.isNullOrWhitespace(alias)) {
            this.removeAliasWithRename();
            return this;
        }
        let aliasIdentifier = this.getAliasNode();
        if (aliasIdentifier == null) {
            this.setAlias(this.getName());
            aliasIdentifier = this.getAliasNode();
        }
        aliasIdentifier.rename(alias);
        return this;
    }
    setAlias(alias) {
        if (StringUtils.isNullOrWhitespace(alias)) {
            this.removeAlias();
            return this;
        }
        const aliasIdentifier = this.getAliasNode();
        if (aliasIdentifier == null) {
            insertIntoParentTextRange({
                insertPos: this.getNameNode().getEnd(),
                parent: this,
                newText: ` as ${alias}`,
            });
        }
        else {
            aliasIdentifier.replaceWithText(alias);
        }
        return this;
    }
    removeAlias() {
        const aliasIdentifier = this.getAliasNode();
        if (aliasIdentifier == null)
            return this;
        removeChildren({
            children: [this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.AsKeyword), aliasIdentifier],
            removePrecedingSpaces: true,
            removePrecedingNewLines: true,
        });
        return this;
    }
    removeAliasWithRename() {
        const aliasIdentifier = this.getAliasNode();
        if (aliasIdentifier == null)
            return this;
        aliasIdentifier.rename(this.getName());
        this.removeAlias();
        return this;
    }
    getAliasNode() {
        if (this.compilerNode.propertyName == null)
            return undefined;
        return this._getNodeFromCompilerNode(this.compilerNode.name);
    }
    getExportDeclaration() {
        return this.getFirstAncestorByKindOrThrow(ts$1.SyntaxKind.ExportDeclaration);
    }
    getLocalTargetSymbolOrThrow() {
        return errors.throwIfNullOrUndefined(this.getLocalTargetSymbol(), `The export specifier's local target symbol was expected.`);
    }
    getLocalTargetSymbol() {
        return this._context.typeChecker.getExportSpecifierLocalTargetSymbol(this);
    }
    getLocalTargetDeclarations() {
        var _a, _b;
        return (_b = (_a = this.getLocalTargetSymbol()) === null || _a === void 0 ? void 0 : _a.getDeclarations()) !== null && _b !== void 0 ? _b : [];
    }
    remove() {
        const exportDeclaration = this.getExportDeclaration();
        const exports = exportDeclaration.getNamedExports();
        if (exports.length > 1)
            removeCommaSeparatedChild(this);
        else if (exportDeclaration.hasModuleSpecifier())
            exportDeclaration.toNamespaceExport();
        else
            exportDeclaration.remove();
    }
    set(structure) {
        callBaseSet(ExportSpecifierBase.prototype, this, structure);
        if (structure.name != null)
            this.setName(structure.name);
        if (structure.alias != null)
            this.setAlias(structure.alias);
        else if (structure.hasOwnProperty("alias"))
            this.removeAlias();
        return this;
    }
    getStructure() {
        const alias = this.getAliasNode();
        return callBaseGetStructure(Node.prototype, this, {
            kind: exports.StructureKind.ExportSpecifier,
            alias: alias ? alias.getText() : undefined,
            name: this.getNameNode().getText(),
        });
    }
}

class ExternalModuleReference extends Node {
    getExpression() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.expression);
    }
    getExpressionOrThrow() {
        return errors.throwIfNullOrUndefined(this.getExpression(), "Expected to find an expression.");
    }
    getReferencedSourceFileOrThrow() {
        return errors.throwIfNullOrUndefined(this.getReferencedSourceFile(), "Expected to find the referenced source file.");
    }
    isRelative() {
        const expression = this.getExpression();
        if (expression == null || !Node.isStringLiteral(expression))
            return false;
        return ModuleUtils.isModuleSpecifierRelative(expression.getLiteralText());
    }
    getReferencedSourceFile() {
        const expression = this.getExpression();
        if (expression == null)
            return undefined;
        const symbol = expression.getSymbol();
        if (symbol == null)
            return undefined;
        return ModuleUtils.getReferencedSourceFileFromSymbol(symbol);
    }
}

const ImportClauseBase = Node;
class ImportClause extends ImportClauseBase {
    isTypeOnly() {
        return this.compilerNode.isTypeOnly;
    }
    setIsTypeOnly(value) {
        if (this.isTypeOnly() === value)
            return this;
        if (value) {
            insertIntoParentTextRange({
                parent: this,
                insertPos: this.getStart(),
                newText: "type ",
            });
        }
        else {
            const typeKeyword = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.TypeKeyword);
            removeChildren({
                children: [typeKeyword],
                removeFollowingSpaces: true,
            });
        }
        return this;
    }
    getDefaultImportOrThrow() {
        return errors.throwIfNullOrUndefined(this.getDefaultImport(), "Expected to find a default import.");
    }
    getDefaultImport() {
        return this.getNodeProperty("name");
    }
    getNamedBindingsOrThrow() {
        return errors.throwIfNullOrUndefined(this.getNamedBindings(), "Expected to find an import declaration's named bindings.");
    }
    getNamedBindings() {
        return this.getNodeProperty("namedBindings");
    }
    getNamespaceImportOrThrow() {
        return errors.throwIfNullOrUndefined(this.getNamespaceImport(), "Expected to find a namespace import.");
    }
    getNamespaceImport() {
        const namedBindings = this.getNamedBindings();
        if (namedBindings == null || !Node.isNamespaceImport(namedBindings))
            return undefined;
        return namedBindings.getNameNode();
    }
    getNamedImports() {
        const namedBindings = this.getNamedBindings();
        if (namedBindings == null || !Node.isNamedImports(namedBindings))
            return [];
        return namedBindings.getElements();
    }
}

const ImportDeclarationBase = Statement;
class ImportDeclaration extends ImportDeclarationBase {
    isTypeOnly() {
        var _a, _b;
        return (_b = (_a = this.getImportClause()) === null || _a === void 0 ? void 0 : _a.isTypeOnly()) !== null && _b !== void 0 ? _b : false;
    }
    setIsTypeOnly(value) {
        const importClause = this.getImportClause();
        if (importClause == null) {
            if (!value)
                return this;
            else
                throw new errors.InvalidOperationError("Cannot set an import as type only when there is no import clause.");
        }
        importClause.setIsTypeOnly(value);
        return this;
    }
    setModuleSpecifier(textOrSourceFile) {
        const text = typeof textOrSourceFile === "string" ? textOrSourceFile : this._sourceFile.getRelativePathAsModuleSpecifierTo(textOrSourceFile);
        this.getModuleSpecifier().setLiteralValue(text);
        return this;
    }
    getModuleSpecifier() {
        const moduleSpecifier = this._getNodeFromCompilerNode(this.compilerNode.moduleSpecifier);
        if (!Node.isStringLiteral(moduleSpecifier))
            throw new errors.InvalidOperationError("Expected the module specifier to be a string literal.");
        return moduleSpecifier;
    }
    getModuleSpecifierValue() {
        return this.getModuleSpecifier().getLiteralValue();
    }
    getModuleSpecifierSourceFileOrThrow() {
        return errors.throwIfNullOrUndefined(this.getModuleSpecifierSourceFile(), `A module specifier source file was expected.`);
    }
    getModuleSpecifierSourceFile() {
        const symbol = this.getModuleSpecifier().getSymbol();
        if (symbol == null)
            return undefined;
        return ModuleUtils.getReferencedSourceFileFromSymbol(symbol);
    }
    isModuleSpecifierRelative() {
        return ModuleUtils.isModuleSpecifierRelative(this.getModuleSpecifierValue());
    }
    setDefaultImport(text) {
        if (StringUtils.isNullOrWhitespace(text))
            return this.removeDefaultImport();
        const defaultImport = this.getDefaultImport();
        if (defaultImport != null) {
            defaultImport.replaceWithText(text);
            return this;
        }
        const importKeyword = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.ImportKeyword);
        const importClause = this.getImportClause();
        if (importClause == null) {
            insertIntoParentTextRange({
                insertPos: importKeyword.getEnd(),
                parent: this,
                newText: ` ${text} from`,
            });
            return this;
        }
        insertIntoParentTextRange({
            insertPos: importKeyword.getEnd(),
            parent: importClause,
            newText: ` ${text},`,
        });
        return this;
    }
    renameDefaultImport(text) {
        if (StringUtils.isNullOrWhitespace(text))
            return this.removeDefaultImport();
        const defaultImport = this.getDefaultImport();
        if (defaultImport != null) {
            defaultImport.rename(text);
            return this;
        }
        this.setDefaultImport(text);
        return this;
    }
    getDefaultImportOrThrow() {
        return errors.throwIfNullOrUndefined(this.getDefaultImport(), "Expected to find a default import.");
    }
    getDefaultImport() {
        var _a, _b;
        return (_b = (_a = this.getImportClause()) === null || _a === void 0 ? void 0 : _a.getDefaultImport()) !== null && _b !== void 0 ? _b : undefined;
    }
    setNamespaceImport(text) {
        if (StringUtils.isNullOrWhitespace(text))
            return this.removeNamespaceImport();
        const namespaceImport = this.getNamespaceImport();
        if (namespaceImport != null) {
            namespaceImport.rename(text);
            return this;
        }
        if (this.getNamedImports().length > 0)
            throw new errors.InvalidOperationError("Cannot add a namespace import to an import declaration that has named imports.");
        const defaultImport = this.getDefaultImport();
        if (defaultImport != null) {
            insertIntoParentTextRange({
                insertPos: defaultImport.getEnd(),
                parent: this.getImportClause(),
                newText: `, * as ${text}`,
            });
            return this;
        }
        insertIntoParentTextRange({
            insertPos: this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.ImportKeyword).getEnd(),
            parent: this,
            newText: ` * as ${text} from`,
        });
        return this;
    }
    removeNamespaceImport() {
        const namespaceImport = this.getNamespaceImport();
        if (namespaceImport == null)
            return this;
        removeChildren({
            children: getChildrenToRemove.call(this),
            removePrecedingSpaces: true,
            removePrecedingNewLines: true,
        });
        return this;
        function getChildrenToRemove() {
            const defaultImport = this.getDefaultImport();
            if (defaultImport == null)
                return [this.getImportClauseOrThrow(), this.getLastChildByKindOrThrow(ts$1.SyntaxKind.FromKeyword)];
            else
                return [defaultImport.getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.CommaToken), namespaceImport];
        }
    }
    removeDefaultImport() {
        const importClause = this.getImportClause();
        if (importClause == null)
            return this;
        const defaultImport = importClause.getDefaultImport();
        if (defaultImport == null)
            return this;
        const hasOnlyDefaultImport = importClause.getChildCount() === 1;
        if (hasOnlyDefaultImport) {
            removeChildren({
                children: [importClause, importClause.getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.FromKeyword)],
                removePrecedingSpaces: true,
                removePrecedingNewLines: true,
            });
        }
        else {
            removeChildren({
                children: [defaultImport, defaultImport.getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.CommaToken)],
                removePrecedingSpaces: true,
                removePrecedingNewLines: true,
            });
        }
        return this;
    }
    getNamespaceImportOrThrow() {
        return errors.throwIfNullOrUndefined(this.getNamespaceImport(), "Expected to find a namespace import.");
    }
    getNamespaceImport() {
        var _a, _b;
        return (_b = (_a = this.getImportClause()) === null || _a === void 0 ? void 0 : _a.getNamespaceImport()) !== null && _b !== void 0 ? _b : undefined;
    }
    addNamedImport(namedImport) {
        return this.addNamedImports([namedImport])[0];
    }
    addNamedImports(namedImports) {
        return this.insertNamedImports(this.getNamedImports().length, namedImports);
    }
    insertNamedImport(index, namedImport) {
        return this.insertNamedImports(index, [namedImport])[0];
    }
    insertNamedImports(index, namedImports) {
        if (!(namedImports instanceof Function) && ArrayUtils.isNullOrEmpty(namedImports))
            return [];
        const originalNamedImports = this.getNamedImports();
        const writer = this._getWriterWithQueuedIndentation();
        const namedImportStructurePrinter = this._context.structurePrinterFactory.forNamedImportExportSpecifier();
        const importClause = this.getImportClause();
        index = verifyAndGetIndex(index, originalNamedImports.length);
        if (originalNamedImports.length === 0) {
            namedImportStructurePrinter.printTextsWithBraces(writer, namedImports);
            if (importClause == null) {
                insertIntoParentTextRange({
                    insertPos: this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.ImportKeyword).getEnd(),
                    parent: this,
                    newText: ` ${writer.toString()} from`,
                });
            }
            else if (this.getNamespaceImport() != null)
                throw getErrorWhenNamespaceImportsExist();
            else if (importClause.getNamedBindings() != null) {
                const namedBindings = importClause.getNamedBindingsOrThrow();
                insertIntoParentTextRange({
                    insertPos: namedBindings.getStart(),
                    replacing: {
                        textLength: namedBindings.getWidth(),
                    },
                    parent: importClause,
                    newText: writer.toString(),
                });
            }
            else {
                insertIntoParentTextRange({
                    insertPos: this.getDefaultImport().getEnd(),
                    parent: importClause,
                    newText: `, ${writer.toString()}`,
                });
            }
        }
        else {
            if (importClause == null)
                throw new errors.NotImplementedError("Expected to have an import clause.");
            namedImportStructurePrinter.printTexts(writer, namedImports);
            insertIntoCommaSeparatedNodes({
                parent: importClause.getFirstChildByKindOrThrow(ts$1.SyntaxKind.NamedImports).getFirstChildByKindOrThrow(ts$1.SyntaxKind.SyntaxList),
                currentNodes: originalNamedImports,
                insertIndex: index,
                newText: writer.toString(),
                surroundWithSpaces: this._context.getFormatCodeSettings().insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces,
                useTrailingCommas: false,
            });
        }
        const newNamedImports = this.getNamedImports();
        return getNodesToReturn(originalNamedImports, newNamedImports, index, false);
    }
    getNamedImports() {
        var _a, _b;
        return (_b = (_a = this.getImportClause()) === null || _a === void 0 ? void 0 : _a.getNamedImports()) !== null && _b !== void 0 ? _b : [];
    }
    removeNamedImports() {
        const importClause = this.getImportClause();
        if (importClause == null)
            return this;
        const namedImportsNode = importClause.getNamedBindings();
        if (namedImportsNode == null || namedImportsNode.getKind() !== ts$1.SyntaxKind.NamedImports)
            return this;
        const defaultImport = this.getDefaultImport();
        if (defaultImport != null) {
            const commaToken = defaultImport.getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.CommaToken);
            removeChildren({ children: [commaToken, namedImportsNode] });
            return this;
        }
        const fromKeyword = importClause.getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.FromKeyword);
        removeChildren({ children: [importClause, fromKeyword], removePrecedingSpaces: true });
        return this;
    }
    getImportClauseOrThrow() {
        return errors.throwIfNullOrUndefined(this.getImportClause(), "Expected to find an import clause.");
    }
    getImportClause() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.importClause);
    }
    set(structure) {
        callBaseSet(ImportDeclarationBase.prototype, this, structure);
        if (structure.defaultImport != null)
            this.setDefaultImport(structure.defaultImport);
        else if (structure.hasOwnProperty("defaultImport"))
            this.removeDefaultImport();
        if (structure.hasOwnProperty("namedImports"))
            this.removeNamedImports();
        if (structure.namespaceImport != null)
            this.setNamespaceImport(structure.namespaceImport);
        else if (structure.hasOwnProperty("namespaceImport"))
            this.removeNamespaceImport();
        if (structure.namedImports != null) {
            setEmptyNamedImport(this);
            this.addNamedImports(structure.namedImports);
        }
        if (structure.moduleSpecifier != null)
            this.setModuleSpecifier(structure.moduleSpecifier);
        if (structure.isTypeOnly != null)
            this.setIsTypeOnly(structure.isTypeOnly);
        return this;
    }
    getStructure() {
        const namespaceImport = this.getNamespaceImport();
        const defaultImport = this.getDefaultImport();
        return callBaseGetStructure(ImportDeclarationBase.prototype, this, {
            kind: exports.StructureKind.ImportDeclaration,
            isTypeOnly: this.isTypeOnly(),
            defaultImport: defaultImport ? defaultImport.getText() : undefined,
            moduleSpecifier: this.getModuleSpecifier().getLiteralText(),
            namedImports: this.getNamedImports().map(node => node.getStructure()),
            namespaceImport: namespaceImport ? namespaceImport.getText() : undefined,
        });
    }
}
function setEmptyNamedImport(node) {
    const importClause = node.getNodeProperty("importClause");
    const writer = node._getWriterWithQueuedChildIndentation();
    const namedImportStructurePrinter = node._context.structurePrinterFactory.forNamedImportExportSpecifier();
    namedImportStructurePrinter.printTextsWithBraces(writer, []);
    const emptyBracesText = writer.toString();
    if (node.getNamespaceImport() != null)
        throw getErrorWhenNamespaceImportsExist();
    if (importClause == null) {
        insertIntoParentTextRange({
            insertPos: node.getFirstChildByKindOrThrow(ts$1.SyntaxKind.ImportKeyword).getEnd(),
            parent: node,
            newText: ` ${emptyBracesText} from`,
        });
        return;
    }
    const replaceNode = importClause.getNamedBindings();
    if (replaceNode != null) {
        insertIntoParentTextRange({
            parent: importClause,
            newText: emptyBracesText,
            insertPos: replaceNode.getStart(),
            replacing: {
                textLength: replaceNode.getWidth(),
            },
        });
        return;
    }
    const defaultImport = importClause.getDefaultImport();
    if (defaultImport != null) {
        insertIntoParentTextRange({
            insertPos: defaultImport.getEnd(),
            parent: importClause,
            newText: `, ${emptyBracesText}`,
        });
        return;
    }
}
function getErrorWhenNamespaceImportsExist() {
    return new errors.InvalidOperationError("Cannot add a named import to an import declaration that has a namespace import.");
}

const createBase$c = (ctor) => JSDocableNode(NamedNode(ctor));
const ImportEqualsDeclarationBase = createBase$c(Statement);
class ImportEqualsDeclaration extends ImportEqualsDeclarationBase {
    getModuleReference() {
        return this._getNodeFromCompilerNode(this.compilerNode.moduleReference);
    }
    isExternalModuleReferenceRelative() {
        const moduleReference = this.getModuleReference();
        if (!Node.isExternalModuleReference(moduleReference))
            return false;
        return moduleReference.isRelative();
    }
    setExternalModuleReference(textOrSourceFile) {
        const text = typeof textOrSourceFile === "string" ? textOrSourceFile : this._sourceFile.getRelativePathAsModuleSpecifierTo(textOrSourceFile);
        const moduleReference = this.getModuleReference();
        if (Node.isExternalModuleReference(moduleReference) && moduleReference.getExpression() != null)
            moduleReference.getExpressionOrThrow().replaceWithText(writer => writer.quote(text));
        else
            moduleReference.replaceWithText(writer => writer.write("require(").quote(text).write(")"));
        return this;
    }
    getExternalModuleReferenceSourceFileOrThrow() {
        return errors.throwIfNullOrUndefined(this.getExternalModuleReferenceSourceFile(), "Expected to find an external module reference's referenced source file.");
    }
    getExternalModuleReferenceSourceFile() {
        const moduleReference = this.getModuleReference();
        if (!Node.isExternalModuleReference(moduleReference))
            return undefined;
        return moduleReference.getReferencedSourceFile();
    }
}

const ImportSpecifierBase = Node;
class ImportSpecifier extends ImportSpecifierBase {
    setName(name) {
        const nameNode = this.getNameNode();
        if (nameNode.getText() === name)
            return this;
        nameNode.replaceWithText(name);
        return this;
    }
    getName() {
        return this.getNameNode().getText();
    }
    getNameNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.propertyName || this.compilerNode.name);
    }
    renameAlias(alias) {
        if (StringUtils.isNullOrWhitespace(alias)) {
            this.removeAliasWithRename();
            return this;
        }
        let aliasIdentifier = this.getAliasNode();
        if (aliasIdentifier == null) {
            this.setAlias(this.getName());
            aliasIdentifier = this.getAliasNode();
        }
        aliasIdentifier.rename(alias);
        return this;
    }
    setAlias(alias) {
        if (StringUtils.isNullOrWhitespace(alias)) {
            this.removeAlias();
            return this;
        }
        const aliasIdentifier = this.getAliasNode();
        if (aliasIdentifier == null) {
            insertIntoParentTextRange({
                insertPos: this.getNameNode().getEnd(),
                parent: this,
                newText: ` as ${alias}`,
            });
        }
        else {
            aliasIdentifier.replaceWithText(alias);
        }
        return this;
    }
    removeAlias() {
        const aliasIdentifier = this.getAliasNode();
        if (aliasIdentifier == null)
            return this;
        removeChildren({
            children: [this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.AsKeyword), aliasIdentifier],
            removePrecedingSpaces: true,
            removePrecedingNewLines: true,
        });
        return this;
    }
    removeAliasWithRename() {
        const aliasIdentifier = this.getAliasNode();
        if (aliasIdentifier == null)
            return this;
        aliasIdentifier.rename(this.getName());
        this.removeAlias();
        return this;
    }
    getAliasNode() {
        if (this.compilerNode.propertyName == null)
            return undefined;
        return this._getNodeFromCompilerNode(this.compilerNode.name);
    }
    getImportDeclaration() {
        return this.getFirstAncestorByKindOrThrow(ts$1.SyntaxKind.ImportDeclaration);
    }
    remove() {
        const importDeclaration = this.getImportDeclaration();
        const namedImports = importDeclaration.getNamedImports();
        if (namedImports.length > 1)
            removeCommaSeparatedChild(this);
        else
            importDeclaration.removeNamedImports();
    }
    set(structure) {
        callBaseSet(ImportSpecifierBase.prototype, this, structure);
        if (structure.name != null)
            this.setName(structure.name);
        if (structure.alias != null)
            this.setAlias(structure.alias);
        else if (structure.hasOwnProperty("alias"))
            this.removeAlias();
        return this;
    }
    getStructure() {
        const alias = this.getAliasNode();
        return callBaseGetStructure(ImportSpecifierBase.prototype, this, {
            kind: exports.StructureKind.ImportSpecifier,
            name: this.getName(),
            alias: alias ? alias.getText() : undefined,
        });
    }
}

const ModuleBlockBase = StatementedNode(Statement);
class ModuleBlock extends ModuleBlockBase {
}

const NamedExportsBase = Node;
class NamedExports extends NamedExportsBase {
    getElements() {
        return this.compilerNode.elements.map(e => this._getNodeFromCompilerNode(e));
    }
}

const NamedImportsBase = Node;
class NamedImports extends NamedImportsBase {
    getElements() {
        return this.compilerNode.elements.map(e => this._getNodeFromCompilerNode(e));
    }
}

function NamespaceChildableNode(Base) {
    return class extends Base {
        getParentNamespaceOrThrow() {
            return errors.throwIfNullOrUndefined(this.getParentNamespace(), "Expected to find the parent namespace.");
        }
        getParentNamespace() {
            let parent = this.getParentOrThrow();
            if (!Node.isModuleBlock(parent))
                return undefined;
            while (parent.getParentOrThrow().getKind() === ts$1.SyntaxKind.ModuleDeclaration)
                parent = parent.getParentOrThrow();
            return parent;
        }
    };
}

(function(NamespaceDeclarationKind) {
    NamespaceDeclarationKind["Namespace"] = "namespace";
    NamespaceDeclarationKind["Module"] = "module";
    NamespaceDeclarationKind["Global"] = "global";
})(exports.NamespaceDeclarationKind || (exports.NamespaceDeclarationKind = {}));

const createBase$d = (ctor) => ModuledNode(UnwrappableNode(TextInsertableNode(BodiedNode(NamespaceChildableNode(StatementedNode(JSDocableNode(AmbientableNode(ExportableNode(ModifierableNode(NamedNode(ctor)))))))))));
const NamespaceDeclarationBase = createBase$d(Statement);
class NamespaceDeclaration extends NamespaceDeclarationBase {
    getName() {
        return this.getNameNodes().map(n => n.getText()).join(".");
    }
    setName(newName) {
        const nameNodes = this.getNameNodes();
        const openIssueText = `Please open an issue if you really need this and I'll up the priority.`;
        if (nameNodes.length > 1)
            throw new errors.NotImplementedError(`Not implemented to set a namespace name that uses dot notation. ${openIssueText}`);
        if (newName.indexOf(".") >= 0)
            throw new errors.NotImplementedError(`Not implemented to set a namespace name to a name containing a period. ${openIssueText}`);
        if (newName !== "global")
            addNamespaceKeywordIfNecessary(this);
        nameNodes[0].replaceWithText(newName);
        return this;
    }
    rename(newName) {
        const nameNodes = this.getNameNodes();
        if (nameNodes.length > 1) {
            throw new errors.NotSupportedError(`Cannot rename a namespace name that uses dot notation. Rename the individual nodes via .${"getNameNodes"}()`);
        }
        if (newName.indexOf(".") >= 0)
            throw new errors.NotSupportedError(`Cannot rename a namespace name to a name containing a period.`);
        if (newName !== "global")
            addNamespaceKeywordIfNecessary(this);
        nameNodes[0].rename(newName);
        return this;
    }
    getNameNodes() {
        const nodes = [];
        let current = this;
        do {
            nodes.push(this._getNodeFromCompilerNode(current.compilerNode.name));
            current = current.getFirstChildByKind(ts$1.SyntaxKind.ModuleDeclaration);
        } while (current != null);
        return nodes;
    }
    hasNamespaceKeyword() {
        return this.getDeclarationKind() === exports.NamespaceDeclarationKind.Namespace;
    }
    hasModuleKeyword() {
        return this.getDeclarationKind() === exports.NamespaceDeclarationKind.Module;
    }
    setDeclarationKind(kind) {
        if (this.getDeclarationKind() === kind)
            return this;
        if (kind === exports.NamespaceDeclarationKind.Global) {
            const declarationKindKeyword = this.getDeclarationKindKeyword();
            this.getNameNode().replaceWithText("global");
            if (declarationKindKeyword != null) {
                removeChildren({
                    children: [declarationKindKeyword],
                    removeFollowingNewLines: true,
                    removeFollowingSpaces: true,
                });
            }
        }
        else {
            const declarationKindKeyword = this.getDeclarationKindKeyword();
            if (declarationKindKeyword != null)
                declarationKindKeyword.replaceWithText(kind);
            else {
                insertIntoParentTextRange({
                    parent: this,
                    insertPos: this.getNameNode().getStart(),
                    newText: kind + " ",
                });
            }
        }
        return this;
    }
    getDeclarationKind() {
        const declarationKeyword = this.getDeclarationKindKeyword();
        if (declarationKeyword == null)
            return exports.NamespaceDeclarationKind.Global;
        return declarationKeyword.getKind() === ts$1.SyntaxKind.NamespaceKeyword ? exports.NamespaceDeclarationKind.Namespace : exports.NamespaceDeclarationKind.Module;
    }
    getDeclarationKindKeyword() {
        return this.getFirstChild(child => child.getKind() === ts$1.SyntaxKind.NamespaceKeyword
            || child.getKind() === ts$1.SyntaxKind.ModuleKeyword);
    }
    set(structure) {
        if (structure.name != null && structure.name !== "global")
            addNamespaceKeywordIfNecessary(this);
        callBaseSet(NamespaceDeclarationBase.prototype, this, structure);
        if (structure.declarationKind != null)
            this.setDeclarationKind(structure.declarationKind);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(NamespaceDeclarationBase.prototype, this, {
            kind: exports.StructureKind.Namespace,
            declarationKind: this.getDeclarationKind(),
        });
    }
    _getInnerBody() {
        let node = this.getBody();
        while (Node.isBodiedNode(node) && node.compilerNode.statements == null)
            node = node.getBody();
        return node;
    }
}
function addNamespaceKeywordIfNecessary(namespaceDec) {
    if (namespaceDec.getDeclarationKind() === exports.NamespaceDeclarationKind.Global)
        namespaceDec.setDeclarationKind(exports.NamespaceDeclarationKind.Namespace);
}

const NamespaceExportBase = RenameableNode(Node);
class NamespaceExport extends NamespaceExportBase {
    setName(name) {
        const nameNode = this.getNameNode();
        if (nameNode.getText() === name)
            return this;
        nameNode.replaceWithText(name);
        return this;
    }
    getName() {
        return this.getNameNode().getText();
    }
    getNameNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.name);
    }
}

const NamespaceImportBase = RenameableNode(Node);
class NamespaceImport extends NamespaceImportBase {
    setName(name) {
        const nameNode = this.getNameNode();
        if (nameNode.getText() === name)
            return this;
        nameNode.replaceWithText(name);
        return this;
    }
    getName() {
        return this.getNameNode().getText();
    }
    getNameNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.name);
    }
}

class FileReference extends TextRange {
    constructor(compilerObject, sourceFile) {
        super(compilerObject, sourceFile);
    }
    getFileName() {
        return this.compilerObject.fileName;
    }
}

(function(FileSystemRefreshResult) {
    FileSystemRefreshResult[FileSystemRefreshResult["NoChange"] = 0] = "NoChange";
    FileSystemRefreshResult[FileSystemRefreshResult["Updated"] = 1] = "Updated";
    FileSystemRefreshResult[FileSystemRefreshResult["Deleted"] = 2] = "Deleted";
})(exports.FileSystemRefreshResult || (exports.FileSystemRefreshResult = {}));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate$1(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __awaiter$1(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function(resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const SourceFileBase = ModuledNode(TextInsertableNode(StatementedNode(Node)));
class SourceFile extends SourceFileBase {
    constructor(context, node) {
        super(context, node, undefined);
        this._isSaved = false;
        this._modifiedEventContainer = new EventContainer();
        this._preModifiedEventContainer = new EventContainer();
        this._referenceContainer = new SourceFileReferenceContainer(this);
        this.__sourceFile = this;
        const onPreModified = () => {
            this.isFromExternalLibrary();
            this._preModifiedEventContainer.unsubscribe(onPreModified);
        };
        this._preModifiedEventContainer.subscribe(onPreModified);
    }
    _replaceCompilerNodeFromFactory(compilerNode) {
        super._replaceCompilerNodeFromFactory(compilerNode);
        this._context.resetProgram();
        this._isSaved = false;
        this._modifiedEventContainer.fire(this);
    }
    _clearInternals() {
        super._clearInternals();
        clearTextRanges(this._referencedFiles);
        clearTextRanges(this._typeReferenceDirectives);
        clearTextRanges(this._libReferenceDirectives);
        delete this._referencedFiles;
        delete this._typeReferenceDirectives;
        delete this._libReferenceDirectives;
        function clearTextRanges(textRanges) {
            textRanges === null || textRanges === void 0 ? void 0 : textRanges.forEach(r => r._forget());
        }
    }
    getFilePath() {
        return this.compilerNode.fileName;
    }
    getBaseName() {
        return FileUtils.getBaseName(this.getFilePath());
    }
    getBaseNameWithoutExtension() {
        const baseName = this.getBaseName();
        const extension = this.getExtension();
        return baseName.substring(0, baseName.length - extension.length);
    }
    getExtension() {
        return FileUtils.getExtension(this.getFilePath());
    }
    getDirectory() {
        return this._context.compilerFactory.getDirectoryFromCache(this.getDirectoryPath());
    }
    getDirectoryPath() {
        return this._context.fileSystemWrapper.getStandardizedAbsolutePath(FileUtils.getDirPath(this.compilerNode.fileName));
    }
    getFullText() {
        return this.compilerNode.text;
    }
    getLineAndColumnAtPos(pos) {
        const fullText = this.getFullText();
        return {
            line: StringUtils.getLineNumberAtPos(fullText, pos),
            column: StringUtils.getLengthFromLineStartAtPos(fullText, pos) + 1,
        };
    }
    getLengthFromLineStartAtPos(pos) {
        return StringUtils.getLengthFromLineStartAtPos(this.getFullText(), pos);
    }
    copyToDirectory(dirPathOrDirectory, options) {
        const dirPath = typeof dirPathOrDirectory === "string" ? dirPathOrDirectory : dirPathOrDirectory.getPath();
        return this.copy(FileUtils.pathJoin(dirPath, this.getBaseName()), options);
    }
    copy(filePath, options = {}) {
        const result = this._copyInternal(filePath, options);
        if (result === false)
            return this;
        const copiedSourceFile = result;
        if (copiedSourceFile.getDirectoryPath() !== this.getDirectoryPath())
            copiedSourceFile._updateReferencesForCopyInternal(this._getReferencesForCopyInternal());
        return copiedSourceFile;
    }
    _copyInternal(fileAbsoluteOrRelativePath, options = {}) {
        const { overwrite = false } = options;
        const { compilerFactory, fileSystemWrapper } = this._context;
        const standardizedFilePath = fileSystemWrapper.getStandardizedAbsolutePath(fileAbsoluteOrRelativePath, this.getDirectoryPath());
        if (standardizedFilePath === this.getFilePath())
            return false;
        return getCopiedSourceFile(this);
        function getCopiedSourceFile(currentFile) {
            try {
                return compilerFactory.createSourceFileFromText(standardizedFilePath, currentFile.getFullText(), { overwrite, markInProject: getShouldBeInProject() });
            }
            catch (err) {
                if (err instanceof errors.InvalidOperationError)
                    throw new errors.InvalidOperationError(`Did you mean to provide the overwrite option? ` + err.message);
                else
                    throw err;
            }
            function getShouldBeInProject() {
                if (currentFile._isInProject())
                    return true;
                const destinationFile = compilerFactory.getSourceFileFromCacheFromFilePath(standardizedFilePath);
                return destinationFile != null && destinationFile._isInProject();
            }
        }
    }
    _getReferencesForCopyInternal() {
        return Array.from(this._referenceContainer.getLiteralsReferencingOtherSourceFilesEntries());
    }
    _updateReferencesForCopyInternal(literalReferences) {
        for (const reference of literalReferences)
            reference[0] = this.getChildSyntaxListOrThrow().getDescendantAtStartWithWidth(reference[0].getStart(), reference[0].getWidth());
        updateStringLiteralReferences(literalReferences);
    }
    copyImmediately(filePath, options) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const newSourceFile = this.copy(filePath, options);
            yield newSourceFile.save();
            return newSourceFile;
        });
    }
    copyImmediatelySync(filePath, options) {
        const newSourceFile = this.copy(filePath, options);
        newSourceFile.saveSync();
        return newSourceFile;
    }
    moveToDirectory(dirPathOrDirectory, options) {
        const dirPath = typeof dirPathOrDirectory === "string" ? dirPathOrDirectory : dirPathOrDirectory.getPath();
        return this.move(FileUtils.pathJoin(dirPath, this.getBaseName()), options);
    }
    move(filePath, options = {}) {
        const oldDirPath = this.getDirectoryPath();
        const sourceFileReferences = this._getReferencesForMoveInternal();
        const oldFilePath = this.getFilePath();
        if (!this._moveInternal(filePath, options))
            return this;
        this._context.fileSystemWrapper.queueFileDelete(oldFilePath);
        this._updateReferencesForMoveInternal(sourceFileReferences, oldDirPath);
        this._context.lazyReferenceCoordinator.clearDirtySourceFiles();
        this._context.lazyReferenceCoordinator.addDirtySourceFile(this);
        return this;
    }
    _moveInternal(fileRelativeOrAbsolutePath, options = {}) {
        const { overwrite = false } = options;
        const filePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(fileRelativeOrAbsolutePath, this.getDirectoryPath());
        if (filePath === this.getFilePath())
            return false;
        let markAsInProject = false;
        if (overwrite) {
            const existingSourceFile = this._context.compilerFactory.getSourceFileFromCacheFromFilePath(filePath);
            if (existingSourceFile != null) {
                markAsInProject = existingSourceFile._isInProject();
                existingSourceFile.forget();
            }
        }
        else {
            this._context.compilerFactory.throwIfFileExists(filePath, "Did you mean to provide the overwrite option?");
        }
        replaceSourceFileForFilePathMove({
            newFilePath: filePath,
            sourceFile: this,
        });
        if (markAsInProject)
            this._markAsInProject();
        if (this._isInProject())
            this.getDirectory()._markAsInProject();
        return true;
    }
    _getReferencesForMoveInternal() {
        return {
            literalReferences: Array.from(this._referenceContainer.getLiteralsReferencingOtherSourceFilesEntries()),
            referencingLiterals: Array.from(this._referenceContainer.getReferencingLiteralsInOtherSourceFiles()),
        };
    }
    _updateReferencesForMoveInternal(sourceFileReferences, oldDirPath) {
        const { literalReferences, referencingLiterals } = sourceFileReferences;
        if (oldDirPath !== this.getDirectoryPath())
            updateStringLiteralReferences(literalReferences);
        updateStringLiteralReferences(referencingLiterals.map(node => ([node, this])));
    }
    moveImmediately(filePath, options) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const oldFilePath = this.getFilePath();
            const newFilePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(filePath, this.getDirectoryPath());
            this.move(filePath, options);
            if (oldFilePath !== newFilePath) {
                yield this._context.fileSystemWrapper.moveFileImmediately(oldFilePath, newFilePath, this.getFullText());
                this._isSaved = true;
            }
            else {
                yield this.save();
            }
            return this;
        });
    }
    moveImmediatelySync(filePath, options) {
        const oldFilePath = this.getFilePath();
        const newFilePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(filePath, this.getDirectoryPath());
        this.move(filePath, options);
        if (oldFilePath !== newFilePath) {
            this._context.fileSystemWrapper.moveFileImmediatelySync(oldFilePath, newFilePath, this.getFullText());
            this._isSaved = true;
        }
        else {
            this.saveSync();
        }
        return this;
    }
    delete() {
        const filePath = this.getFilePath();
        this.forget();
        this._context.fileSystemWrapper.queueFileDelete(filePath);
    }
    deleteImmediately() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const filePath = this.getFilePath();
            this.forget();
            yield this._context.fileSystemWrapper.deleteFileImmediately(filePath);
        });
    }
    deleteImmediatelySync() {
        const filePath = this.getFilePath();
        this.forget();
        this._context.fileSystemWrapper.deleteFileImmediatelySync(filePath);
    }
    save() {
        return __awaiter$1(this, void 0, void 0, function*() {
            yield this._context.fileSystemWrapper.writeFile(this.getFilePath(), this._getTextForSave());
            this._isSaved = true;
        });
    }
    saveSync() {
        this._context.fileSystemWrapper.writeFileSync(this.getFilePath(), this._getTextForSave());
        this._isSaved = true;
    }
    _getTextForSave() {
        const text = this.getFullText();
        return this._hasBom ? "\uFEFF" + text : text;
    }
    getPathReferenceDirectives() {
        if (this._referencedFiles == null) {
            this._referencedFiles = (this.compilerNode.referencedFiles || [])
                .map(f => new FileReference(f, this));
        }
        return this._referencedFiles;
    }
    getTypeReferenceDirectives() {
        if (this._typeReferenceDirectives == null) {
            this._typeReferenceDirectives = (this.compilerNode.typeReferenceDirectives || [])
                .map(f => new FileReference(f, this));
        }
        return this._typeReferenceDirectives;
    }
    getLibReferenceDirectives() {
        if (this._libReferenceDirectives == null) {
            this._libReferenceDirectives = (this.compilerNode.libReferenceDirectives || [])
                .map(f => new FileReference(f, this));
        }
        return this._libReferenceDirectives;
    }
    getReferencingSourceFiles() {
        return Array.from(this._referenceContainer.getDependentSourceFiles());
    }
    getReferencingNodesInOtherSourceFiles() {
        const literals = this.getReferencingLiteralsInOtherSourceFiles();
        return Array.from(getNodes());
        function* getNodes() {
            for (const literal of literals)
                yield getReferencingNodeFromStringLiteral(literal);
        }
    }
    getReferencingLiteralsInOtherSourceFiles() {
        return Array.from(this._referenceContainer.getReferencingLiteralsInOtherSourceFiles());
    }
    getReferencedSourceFiles() {
        const entries = this._referenceContainer.getLiteralsReferencingOtherSourceFilesEntries();
        return Array.from(new Set(getSourceFilesFromEntries()).values());
        function* getSourceFilesFromEntries() {
            for (const [, sourceFile] of entries)
                yield sourceFile;
        }
    }
    getNodesReferencingOtherSourceFiles() {
        const entries = this._referenceContainer.getLiteralsReferencingOtherSourceFilesEntries();
        return Array.from(getNodes());
        function* getNodes() {
            for (const [literal] of entries)
                yield getReferencingNodeFromStringLiteral(literal);
        }
    }
    getLiteralsReferencingOtherSourceFiles() {
        const entries = this._referenceContainer.getLiteralsReferencingOtherSourceFilesEntries();
        return Array.from(getLiteralsFromEntries());
        function* getLiteralsFromEntries() {
            for (const [literal] of entries)
                yield literal;
        }
    }
    getImportStringLiterals() {
        this._ensureBound();
        const literals = (this.compilerNode.imports || []);
        return literals.filter(l => (l.flags & ts$1.NodeFlags.Synthesized) === 0).map(l => this._getNodeFromCompilerNode(l));
    }
    getLanguageVersion() {
        return this.compilerNode.languageVersion;
    }
    getLanguageVariant() {
        return this.compilerNode.languageVariant;
    }
    getScriptKind() {
        return this.compilerNode.scriptKind;
    }
    isDeclarationFile() {
        return this.compilerNode.isDeclarationFile;
    }
    isFromExternalLibrary() {
        if (!this._context.program._isCompilerProgramCreated())
            return false;
        const compilerProgram = this._context.program.compilerObject;
        return compilerProgram.isSourceFileFromExternalLibrary(this.compilerNode);
    }
    isInNodeModules() {
        return this.getFilePath().indexOf("/node_modules/") >= 0;
    }
    isSaved() {
        return this._isSaved;
    }
    _setIsSaved(value) {
        this._isSaved = value;
    }
    getPreEmitDiagnostics() {
        return this._context.getPreEmitDiagnostics(this);
    }
    unindent(positionRangeOrPos, times = 1) {
        return this.indent(positionRangeOrPos, times * -1);
    }
    indent(positionRangeOrPos, times = 1) {
        if (times === 0)
            return this;
        const sourceFileText = this.getFullText();
        const positionRange = typeof positionRangeOrPos === "number" ? [positionRangeOrPos, positionRangeOrPos] : positionRangeOrPos;
        errors.throwIfRangeOutOfRange(positionRange, [0, sourceFileText.length], "positionRange");
        const startLinePos = getPreviousMatchingPos(sourceFileText, positionRange[0], char => char === CharCodes$1.NEWLINE);
        const endLinePos = getNextMatchingPos(sourceFileText, positionRange[1], char => char === CharCodes$1.CARRIAGE_RETURN || char === CharCodes$1.NEWLINE);
        const correctedText = StringUtils.indent(sourceFileText.substring(startLinePos, endLinePos), times, {
            indentText: this._context.manipulationSettings.getIndentationText(),
            indentSizeInSpaces: this._context.manipulationSettings._getIndentSizeInSpaces(),
            isInStringAtPos: pos => this.isInStringAtPos(pos + startLinePos),
        });
        replaceSourceFileTextForFormatting({
            sourceFile: this,
            newText: sourceFileText.substring(0, startLinePos) + correctedText + sourceFileText.substring(endLinePos),
        });
        return this;
    }
    emit(options) {
        return this._context.program.emit(Object.assign({ targetSourceFile: this }, options));
    }
    emitSync(options) {
        return this._context.program.emitSync(Object.assign({ targetSourceFile: this }, options));
    }
    getEmitOutput(options = {}) {
        return this._context.languageService.getEmitOutput(this, options.emitOnlyDtsFiles || false);
    }
    formatText(settings = {}) {
        replaceSourceFileTextForFormatting({
            sourceFile: this,
            newText: this._context.languageService.getFormattedDocumentText(this.getFilePath(), settings),
        });
    }
    refreshFromFileSystem() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const fileReadResult = yield this._context.fileSystemWrapper.readFileOrNotExists(this.getFilePath(), this._context.getEncoding());
            return this._refreshFromFileSystemInternal(fileReadResult);
        });
    }
    refreshFromFileSystemSync() {
        const fileReadResult = this._context.fileSystemWrapper.readFileOrNotExistsSync(this.getFilePath(), this._context.getEncoding());
        return this._refreshFromFileSystemInternal(fileReadResult);
    }
    getRelativePathTo(sourceFileOrDir) {
        return this.getDirectory().getRelativePathTo(sourceFileOrDir);
    }
    getRelativePathAsModuleSpecifierTo(sourceFileOrDir) {
        return this.getDirectory().getRelativePathAsModuleSpecifierTo(sourceFileOrDir);
    }
    onModified(subscription, subscribe = true) {
        if (subscribe)
            this._modifiedEventContainer.subscribe(subscription);
        else
            this._modifiedEventContainer.unsubscribe(subscription);
        return this;
    }
    _doActionPreNextModification(action) {
        const wrappedSubscription = () => {
            action();
            this._preModifiedEventContainer.unsubscribe(wrappedSubscription);
        };
        this._preModifiedEventContainer.subscribe(wrappedSubscription);
        return this;
    }
    _firePreModified() {
        this._preModifiedEventContainer.fire(this);
    }
    organizeImports(formatSettings = {}, userPreferences = {}) {
        this._context.languageService.organizeImports(this, formatSettings, userPreferences).forEach(fileTextChanges => fileTextChanges.applyChanges());
        return this;
    }
    fixUnusedIdentifiers(formatSettings = {}, userPreferences = {}) {
        this._context.languageService.getCombinedCodeFix(this, "unusedIdentifier_delete", formatSettings, userPreferences).applyChanges();
        return this;
    }
    fixMissingImports(formatSettings = {}, userPreferences = {}) {
        const combinedCodeFix = this._context.languageService.getCombinedCodeFix(this, "fixMissingImport", formatSettings, userPreferences);
        const sourceFile = this;
        for (const fileTextChanges of combinedCodeFix.getChanges()) {
            const changes = fileTextChanges.getTextChanges();
            removeUnnecessaryDoubleBlankLines(changes);
            applyTextChanges(changes);
        }
        return this;
        function removeUnnecessaryDoubleBlankLines(changes) {
            changes.sort((a, b) => a.getSpan().getStart() - b.getSpan().getStart());
            for (let i = 0; i < changes.length - 1; i++) {
                const { compilerObject } = changes[i];
                compilerObject.newText = compilerObject.newText.replace(/(\r?)\n\r?\n$/, "$1\n");
            }
        }
        function applyTextChanges(changes) {
            const groups = ArrayUtils.groupBy(changes, change => change.getSpan().getStart());
            let addedLength = 0;
            for (const group of groups) {
                const insertPos = group[0].getSpan().getStart() + addedLength;
                const newText = group.map(item => item.getNewText()).join("");
                insertIntoTextRange({
                    sourceFile,
                    insertPos,
                    newText,
                });
                addedLength += newText.length;
            }
        }
    }
    applyTextChanges(textChanges) {
        if (textChanges.length === 0)
            return this;
        this.forgetDescendants();
        replaceNodeText({
            sourceFile: this._sourceFile,
            start: 0,
            replacingLength: this.getFullWidth(),
            newText: getTextFromTextChanges(this, textChanges),
        });
        return this;
    }
    set(structure) {
        callBaseSet(SourceFileBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(SourceFileBase.prototype, this, {
            kind: exports.StructureKind.SourceFile,
        });
    }
    _refreshFromFileSystemInternal(fileReadResult) {
        if (fileReadResult === false) {
            this.forget();
            return exports.FileSystemRefreshResult.Deleted;
        }
        const fileText = fileReadResult;
        if (fileText === this.getFullText())
            return exports.FileSystemRefreshResult.NoChange;
        this.replaceText([0, this.getEnd()], fileText);
        this._setIsSaved(true);
        return exports.FileSystemRefreshResult.Updated;
    }
    _isInProject() {
        return this._context.inProjectCoordinator.isSourceFileInProject(this);
    }
    _markAsInProject() {
        this._context.inProjectCoordinator.markSourceFileAsInProject(this);
    }
}
__decorate$1([
    Memoize
], SourceFile.prototype, "isFromExternalLibrary", null);
function updateStringLiteralReferences(nodeReferences) {
    for (const [stringLiteral, sourceFile] of nodeReferences) {
        if (ModuleUtils.isModuleSpecifierRelative(stringLiteral.getLiteralText()))
            stringLiteral.setLiteralValue(stringLiteral._sourceFile.getRelativePathAsModuleSpecifierTo(sourceFile));
    }
}
function getReferencingNodeFromStringLiteral(literal) {
    const parent = literal.getParentOrThrow();
    const grandParent = parent.getParent();
    if (grandParent != null && Node.isImportEqualsDeclaration(grandParent))
        return grandParent;
    else
        return parent;
}

const createBase$e = (ctor) => NamespaceChildableNode(JSDocableNode(AmbientableNode(ExportableNode(ModifierableNode(ctor)))));
const VariableStatementBase = createBase$e(Statement);
class VariableStatement extends VariableStatementBase {
    getDeclarationList() {
        return this._getNodeFromCompilerNode(this.compilerNode.declarationList);
    }
    getDeclarations() {
        return this.getDeclarationList().getDeclarations();
    }
    getDeclarationKind() {
        return this.getDeclarationList().getDeclarationKind();
    }
    getDeclarationKindKeyword() {
        return this.getDeclarationList().getDeclarationKindKeyword();
    }
    setDeclarationKind(type) {
        return this.getDeclarationList().setDeclarationKind(type);
    }
    addDeclaration(structure) {
        return this.getDeclarationList().addDeclaration(structure);
    }
    addDeclarations(structures) {
        return this.getDeclarationList().addDeclarations(structures);
    }
    insertDeclaration(index, structure) {
        return this.getDeclarationList().insertDeclaration(index, structure);
    }
    insertDeclarations(index, structures) {
        return this.getDeclarationList().insertDeclarations(index, structures);
    }
    set(structure) {
        callBaseSet(VariableStatementBase.prototype, this, structure);
        if (structure.declarationKind != null)
            this.setDeclarationKind(structure.declarationKind);
        if (structure.declarations != null) {
            const existingDeclarations = this.getDeclarations();
            this.addDeclarations(structure.declarations);
            existingDeclarations.forEach(d => d.remove());
        }
        return this;
    }
    getStructure() {
        return callBaseGetStructure(VariableStatementBase.prototype, this, {
            kind: exports.StructureKind.VariableStatement,
            declarationKind: this.getDeclarationKind(),
            declarations: this.getDeclarations().map(declaration => declaration.getStructure()),
        });
    }
}

const WhileStatementBase = IterationStatement;
class WhileStatement extends WhileStatementBase {
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
}

class WithStatement extends Statement {
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
    getStatement() {
        return this._getNodeFromCompilerNode(this.compilerNode.statement);
    }
}

function FunctionLikeDeclaration(Base) {
    return JSDocableNode(TypeParameteredNode(SignaturedDeclaration(StatementedNode(ModifierableNode(Base)))));
}

const createBase$f = (ctor) => TextInsertableNode(BodiedNode(AsyncableNode(FunctionLikeDeclaration(ctor))));
const ArrowFunctionBase = createBase$f(Expression);
class ArrowFunction extends ArrowFunctionBase {
    getEqualsGreaterThan() {
        return this._getNodeFromCompilerNode(this.compilerNode.equalsGreaterThanToken);
    }
}

function OverloadableNode(Base) {
    return class extends Base {
        getOverloads() {
            return getOverloadsAndImplementation(this).filter(n => n.isOverload());
        }
        getImplementation() {
            if (this.isImplementation())
                return this;
            return getOverloadsAndImplementation(this).find(n => n.isImplementation());
        }
        getImplementationOrThrow() {
            return errors.throwIfNullOrUndefined(this.getImplementation(), "Expected to find a corresponding implementation for the overload.");
        }
        isOverload() {
            return !this.isImplementation();
        }
        isImplementation() {
            return this.getBody() != null;
        }
    };
}
function getOverloadsAndImplementation(node) {
    const parent = node.getParentOrThrow();
    const name = getNameIfNamedNode(node);
    const kind = node.getKind();
    return parent.forEachChildAsArray().filter(n => {
        const hasSameName = getNameIfNamedNode(n) === name;
        const hasSameKind = n.getKind() === kind;
        return hasSameName && hasSameKind;
    });
}
function getNameIfNamedNode(node) {
    const nodeAsNamedNode = node;
    if (nodeAsNamedNode.getName instanceof Function)
        return nodeAsNamedNode.getName();
    return undefined;
}
function insertOverloads(opts) {
    if (opts.structures.length === 0)
        return [];
    const parentSyntaxList = opts.node.getParentSyntaxListOrThrow();
    const implementationNode = opts.node.getImplementation() || opts.node;
    const overloads = opts.node.getOverloads();
    const overloadsCount = overloads.length;
    const firstIndex = overloads.length > 0 ? overloads[0].getChildIndex() : implementationNode.getChildIndex();
    const index = verifyAndGetIndex(opts.index, overloadsCount);
    const mainIndex = firstIndex + index;
    const thisStructure = opts.getThisStructure(implementationNode);
    const structures = opts.structures.map(structure => common.ObjectUtils.assign(common.ObjectUtils.assign({}, thisStructure), structure));
    const writer = implementationNode._getWriterWithQueuedIndentation();
    for (const structure of structures) {
        if (writer.getLength() > 0)
            writer.newLine();
        opts.printStructure(writer, structure);
    }
    writer.newLine();
    writer.write("");
    insertIntoParentTextRange({
        parent: parentSyntaxList,
        insertPos: (overloads[index] || implementationNode).getNonWhitespaceStart(),
        newText: writer.toString(),
    });
    return getRangeWithoutCommentsFromArray(parentSyntaxList.getChildren(), mainIndex, structures.length, opts.expectedSyntaxKind);
}

const createBase$g = (ctor) => UnwrappableNode(TextInsertableNode(OverloadableNode(BodyableNode(AsyncableNode(GeneratorableNode(AmbientableNode(ExportableNode(FunctionLikeDeclaration(NamespaceChildableNode(NameableNode(ctor)))))))))));
const FunctionDeclarationBase = createBase$g(Statement);
const createOverloadBase = (ctor) => UnwrappableNode(TextInsertableNode(AsyncableNode(GeneratorableNode(SignaturedDeclaration(AmbientableNode(NamespaceChildableNode(JSDocableNode(TypeParameteredNode(ExportableNode(ModifierableNode(ctor)))))))))));
const FunctionDeclarationOverloadBase = createOverloadBase(Statement);
class FunctionDeclaration extends FunctionDeclarationBase {
    addOverload(structure) {
        return this.addOverloads([structure])[0];
    }
    addOverloads(structures) {
        return this.insertOverloads(this.getOverloads().length, structures);
    }
    insertOverload(index, structure) {
        return this.insertOverloads(index, [structure])[0];
    }
    insertOverloads(index, structures) {
        const thisName = this.getName();
        const printer = this._context.structurePrinterFactory.forFunctionDeclaration({
            isAmbient: this.isAmbient(),
        });
        return insertOverloads({
            node: this,
            index,
            structures,
            printStructure: (writer, structure) => {
                printer.printOverload(writer, thisName, structure);
            },
            getThisStructure: fromFunctionDeclarationOverload,
            expectedSyntaxKind: ts$1.SyntaxKind.FunctionDeclaration,
        });
    }
    remove() {
        removeOverloadableStatementedNodeChild(this);
    }
    set(structure) {
        callBaseSet(FunctionDeclarationBase.prototype, this, structure);
        if (structure.overloads != null) {
            this.getOverloads().forEach(o => o.remove());
            this.addOverloads(structure.overloads);
        }
        return this;
    }
    getStructure() {
        const isOverload = this.isOverload();
        const hasImplementation = this.getImplementation();
        const basePrototype = isOverload && hasImplementation ? FunctionDeclarationOverloadBase.prototype : FunctionDeclarationBase.prototype;
        return callBaseGetStructure(basePrototype, this, getStructure(this));
        function getStructure(thisNode) {
            if (hasImplementation && isOverload)
                return getOverloadSpecificStructure();
            return getSpecificStructure();
            function getOverloadSpecificStructure() {
                return { kind: exports.StructureKind.FunctionOverload };
            }
            function getSpecificStructure() {
                if (!hasImplementation)
                    return { kind: exports.StructureKind.Function };
                else {
                    return {
                        kind: exports.StructureKind.Function,
                        overloads: thisNode.getOverloads().map(o => o.getStructure()),
                    };
                }
            }
        }
    }
}

const createBase$h = (ctor) => JSDocableNode(TextInsertableNode(BodiedNode(AsyncableNode(GeneratorableNode(StatementedNode(TypeParameteredNode(SignaturedDeclaration(ModifierableNode(NameableNode(ctor))))))))));
const FunctionExpressionBase = createBase$h(PrimaryExpression);
class FunctionExpression extends FunctionExpressionBase {
}

const createBase$i = (ctor) => QuestionTokenableNode(DecoratableNode(ScopeableNode(ReadonlyableNode(ModifierableNode(TypedNode(InitializerExpressionableNode(BindingNamedNode(ctor))))))));
const ParameterDeclarationBase = createBase$i(Node);
class ParameterDeclaration extends ParameterDeclarationBase {
    getDotDotDotToken() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.dotDotDotToken);
    }
    isRestParameter() {
        return this.compilerNode.dotDotDotToken != null;
    }
    isParameterProperty() {
        return this.getScope() != null || this.isReadonly();
    }
    setIsRestParameter(value) {
        if (this.isRestParameter() === value)
            return this;
        if (value) {
            addParensIfNecessary(this);
            insertIntoParentTextRange({
                insertPos: this.getNameNode().getStart(),
                parent: this,
                newText: "...",
            });
        }
        else {
            removeChildren({ children: [this.getDotDotDotToken()] });
        }
        return this;
    }
    isOptional() {
        return this.compilerNode.questionToken != null || this.isRestParameter() || this.hasInitializer();
    }
    remove() {
        removeCommaSeparatedChild(this);
    }
    set(structure) {
        callBaseSet(ParameterDeclarationBase.prototype, this, structure);
        if (structure.isRestParameter != null)
            this.setIsRestParameter(structure.isRestParameter);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(ParameterDeclarationBase.prototype, this, {
            kind: exports.StructureKind.Parameter,
            isRestParameter: this.isRestParameter(),
        });
    }
    setHasQuestionToken(value) {
        if (value)
            addParensIfNecessary(this);
        super.setHasQuestionToken(value);
        return this;
    }
    setInitializer(textOrWriterFunction) {
        addParensIfNecessary(this);
        super.setInitializer(textOrWriterFunction);
        return this;
    }
    setType(textOrWriterFunction) {
        addParensIfNecessary(this);
        super.setType.call(this, textOrWriterFunction);
        return this;
    }
}
function addParensIfNecessary(parameter) {
    const parent = parameter.getParentOrThrow();
    if (isParameterWithoutParens())
        addParens();
    function isParameterWithoutParens() {
        return Node.isArrowFunction(parent)
            && parent.compilerNode.parameters.length === 1
            && parameter.getParentSyntaxListOrThrow().getPreviousSiblingIfKind(ts$1.SyntaxKind.OpenParenToken) == null;
    }
    function addParens() {
        const paramText = parameter.getText();
        insertIntoParentTextRange({
            parent,
            insertPos: parameter.getStart(),
            newText: `(${paramText})`,
            replacing: {
                textLength: paramText.length,
            },
            customMappings: newParent => {
                return [{ currentNode: parameter, newNode: newParent.parameters[0] }];
            },
        });
    }
}

class ClassElement extends Node {
    remove() {
        const parent = this.getParentOrThrow();
        if (Node.isClassDeclaration(parent) || Node.isClassExpression(parent))
            removeClassMember(this);
        else if (Node.isObjectLiteralExpression(parent))
            removeCommaSeparatedChild(this);
        else
            errors.throwNotImplementedForSyntaxKindError(parent.getKind());
    }
}

const createBase$j = (ctor) => ChildOrderableNode(TextInsertableNode(OverloadableNode(BodyableNode(DecoratableNode(AbstractableNode(ScopedNode(QuestionTokenableNode(StaticableNode(AsyncableNode(GeneratorableNode(FunctionLikeDeclaration(PropertyNamedNode(ctor)))))))))))));
const MethodDeclarationBase = createBase$j(ClassElement);
const createOverloadBase$1 = (ctor) => JSDocableNode(ChildOrderableNode(TextInsertableNode(ScopedNode(TypeParameteredNode(AbstractableNode(QuestionTokenableNode(StaticableNode(AsyncableNode(ModifierableNode(GeneratorableNode(SignaturedDeclaration(ctor))))))))))));
const MethodDeclarationOverloadBase = createOverloadBase$1(ClassElement);
class MethodDeclaration extends MethodDeclarationBase {
    set(structure) {
        callBaseSet(MethodDeclarationBase.prototype, this, structure);
        if (structure.overloads != null) {
            this.getOverloads().forEach(o => o.remove());
            this.addOverloads(structure.overloads);
        }
        return this;
    }
    addOverload(structure) {
        return this.addOverloads([structure])[0];
    }
    addOverloads(structures) {
        return this.insertOverloads(this.getOverloads().length, structures);
    }
    insertOverload(index, structure) {
        return this.insertOverloads(index, [structure])[0];
    }
    insertOverloads(index, structures) {
        const thisName = this.getName();
        const printer = this._context.structurePrinterFactory.forMethodDeclaration({
            isAmbient: isNodeAmbientOrInAmbientContext(this),
        });
        return insertOverloads({
            node: this,
            index,
            structures,
            printStructure: (writer, structure) => {
                printer.printOverload(writer, thisName, structure);
            },
            getThisStructure: fromMethodDeclarationOverload,
            expectedSyntaxKind: ts$1.SyntaxKind.MethodDeclaration,
        });
    }
    getStructure() {
        const hasImplementation = this.getImplementation() != null;
        const isOverload = this.isOverload();
        const basePrototype = isOverload && hasImplementation ? MethodDeclarationOverloadBase.prototype : MethodDeclarationBase.prototype;
        return callBaseGetStructure(basePrototype, this, getStructure(this));
        function getStructure(thisNode) {
            if (hasImplementation && isOverload)
                return getOverloadSpecificStructure();
            return getSpecificStructure();
            function getOverloadSpecificStructure() {
                return { kind: exports.StructureKind.MethodOverload };
            }
            function getSpecificStructure() {
                if (!hasImplementation)
                    return { kind: exports.StructureKind.Method };
                else {
                    return {
                        kind: exports.StructureKind.Method,
                        overloads: thisNode.getOverloads().map(o => o.getStructure()),
                    };
                }
            }
        }
    }
}

function ClassLikeDeclarationBase(Base) {
    return ClassLikeDeclarationBaseSpecific(NameableNode(TextInsertableNode(ImplementsClauseableNode(HeritageClauseableNode(AbstractableNode(JSDocableNode(TypeParameteredNode(DecoratableNode(ModifierableNode(Base))))))))));
}
function ClassLikeDeclarationBaseSpecific(Base) {
    return class extends Base {
        setExtends(text) {
            text = this._getTextWithQueuedChildIndentation(text);
            if (StringUtils.isNullOrWhitespace(text))
                return this.removeExtends();
            const extendsClause = this.getHeritageClauseByKind(ts$1.SyntaxKind.ExtendsKeyword);
            if (extendsClause != null) {
                const childSyntaxList = extendsClause.getFirstChildByKindOrThrow(ts$1.SyntaxKind.SyntaxList);
                const childSyntaxListStart = childSyntaxList.getStart();
                insertIntoParentTextRange({
                    parent: extendsClause,
                    newText: text,
                    insertPos: childSyntaxListStart,
                    replacing: {
                        textLength: childSyntaxList.getEnd() - childSyntaxListStart,
                    },
                });
            }
            else {
                const implementsClause = this.getHeritageClauseByKind(ts$1.SyntaxKind.ImplementsKeyword);
                let insertPos;
                if (implementsClause != null)
                    insertPos = implementsClause.getStart();
                else
                    insertPos = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.OpenBraceToken).getStart();
                const isLastSpace = /\s/.test(this.getSourceFile().getFullText()[insertPos - 1]);
                let newText = `extends ${text} `;
                if (!isLastSpace)
                    newText = " " + newText;
                insertIntoParentTextRange({
                    parent: implementsClause == null ? this : implementsClause.getParentSyntaxListOrThrow(),
                    insertPos,
                    newText,
                });
            }
            return this;
        }
        removeExtends() {
            const extendsClause = this.getHeritageClauseByKind(ts$1.SyntaxKind.ExtendsKeyword);
            if (extendsClause == null)
                return this;
            extendsClause.removeExpression(0);
            return this;
        }
        getExtendsOrThrow() {
            return errors.throwIfNullOrUndefined(this.getExtends(), `Expected to find the extends expression for the class ${this.getName()}.`);
        }
        getExtends() {
            const extendsClause = this.getHeritageClauseByKind(ts$1.SyntaxKind.ExtendsKeyword);
            if (extendsClause == null)
                return undefined;
            const types = extendsClause.getTypeNodes();
            return types.length === 0 ? undefined : types[0];
        }
        addMembers(members) {
            return this.insertMembers(getEndIndexFromArray(this.getMembersWithComments()), members);
        }
        addMember(member) {
            return this.insertMember(getEndIndexFromArray(this.getMembersWithComments()), member);
        }
        insertMember(index, member) {
            return this.insertMembers(index, [member])[0];
        }
        insertMembers(index, members) {
            const isAmbient = isNodeAmbientOrInAmbientContext(this);
            return insertIntoBracesOrSourceFileWithGetChildrenWithComments({
                getIndexedChildren: () => this.getMembersWithComments(),
                index,
                parent: this,
                write: (writer, info) => {
                    const previousMemberHasBody = !isAmbient && info.previousMember != null && Node.isBodyableNode(info.previousMember)
                        && info.previousMember.hasBody();
                    const firstStructureHasBody = !isAmbient && members instanceof Array && structureHasBody(members[0]);
                    if (previousMemberHasBody || info.previousMember != null && firstStructureHasBody)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    const memberWriter = this._getWriter();
                    const memberPrinter = this._context.structurePrinterFactory.forClassMember({ isAmbient });
                    memberPrinter.printTexts(memberWriter, members);
                    writer.write(memberWriter.toString());
                    const lastStructureHasBody = !isAmbient && members instanceof Array && structureHasBody(members[members.length - 1]);
                    const nextMemberHasBody = !isAmbient && info.nextMember != null && Node.isBodyableNode(info.nextMember) && info.nextMember.hasBody();
                    if (info.nextMember != null && lastStructureHasBody || nextMemberHasBody)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                },
            });
            function structureHasBody(value) {
                if (isAmbient || value == null || typeof value.kind !== "number")
                    return false;
                const structure = value;
                return Structure.isMethod(structure)
                    || Structure.isGetAccessor(structure)
                    || Structure.isSetAccessor(structure)
                    || Structure.isConstructor(structure);
            }
        }
        addConstructor(structure = {}) {
            return this.insertConstructor(getEndIndexFromArray(this.getMembersWithComments()), structure);
        }
        addConstructors(structures) {
            return this.insertConstructors(getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertConstructor(index, structure = {}) {
            return this.insertConstructors(index, [structure])[0];
        }
        insertConstructors(index, structures) {
            const isAmbient = isNodeAmbientOrInAmbientContext(this);
            return insertChildren$1(this, {
                index,
                structures,
                expectedKind: ts$1.SyntaxKind.Constructor,
                write: (writer, info) => {
                    if (!isAmbient && info.previousMember != null && !Node.isCommentNode(info.previousMember))
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    this._context.structurePrinterFactory.forConstructorDeclaration({ isAmbient }).printTexts(writer, structures);
                    if (!isAmbient && info.nextMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                },
            });
        }
        getConstructors() {
            return this.getMembers().filter(m => Node.isConstructorDeclaration(m));
        }
        addGetAccessor(structure) {
            return this.addGetAccessors([structure])[0];
        }
        addGetAccessors(structures) {
            return this.insertGetAccessors(getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertGetAccessor(index, structure) {
            return this.insertGetAccessors(index, [structure])[0];
        }
        insertGetAccessors(index, structures) {
            return insertChildren$1(this, {
                index,
                structures,
                expectedKind: ts$1.SyntaxKind.GetAccessor,
                write: (writer, info) => {
                    if (info.previousMember != null && !Node.isCommentNode(info.previousMember))
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    this._context.structurePrinterFactory.forGetAccessorDeclaration({
                        isAmbient: isNodeAmbientOrInAmbientContext(this),
                    }).printTexts(writer, structures);
                    if (info.nextMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                },
            });
        }
        addSetAccessor(structure) {
            return this.addSetAccessors([structure])[0];
        }
        addSetAccessors(structures) {
            return this.insertSetAccessors(getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertSetAccessor(index, structure) {
            return this.insertSetAccessors(index, [structure])[0];
        }
        insertSetAccessors(index, structures) {
            return insertChildren$1(this, {
                index,
                structures,
                expectedKind: ts$1.SyntaxKind.SetAccessor,
                write: (writer, info) => {
                    if (info.previousMember != null && !Node.isCommentNode(info.previousMember))
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    this._context.structurePrinterFactory.forSetAccessorDeclaration({
                        isAmbient: isNodeAmbientOrInAmbientContext(this),
                    }).printTexts(writer, structures);
                    if (info.nextMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                },
            });
        }
        addProperty(structure) {
            return this.addProperties([structure])[0];
        }
        addProperties(structures) {
            return this.insertProperties(getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertProperty(index, structure) {
            return this.insertProperties(index, [structure])[0];
        }
        insertProperties(index, structures) {
            return insertChildren$1(this, {
                index,
                structures,
                expectedKind: ts$1.SyntaxKind.PropertyDeclaration,
                write: (writer, info) => {
                    if (info.previousMember != null && Node.hasBody(info.previousMember))
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    this._context.structurePrinterFactory.forPropertyDeclaration().printTexts(writer, structures);
                    if (info.nextMember != null && Node.hasBody(info.nextMember))
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                },
            });
        }
        addMethod(structure) {
            return this.addMethods([structure])[0];
        }
        addMethods(structures) {
            return this.insertMethods(getEndIndexFromArray(this.getMembersWithComments()), structures);
        }
        insertMethod(index, structure) {
            return this.insertMethods(index, [structure])[0];
        }
        insertMethods(index, structures) {
            const isAmbient = isNodeAmbientOrInAmbientContext(this);
            structures = structures.map(s => (Object.assign({}, s)));
            return insertChildren$1(this, {
                index,
                write: (writer, info) => {
                    if (!isAmbient && info.previousMember != null && !Node.isCommentNode(info.previousMember))
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                    this._context.structurePrinterFactory.forMethodDeclaration({ isAmbient }).printTexts(writer, structures);
                    if (!isAmbient && info.nextMember != null)
                        writer.blankLineIfLastNot();
                    else
                        writer.newLineIfLastNot();
                },
                structures,
                expectedKind: ts$1.SyntaxKind.MethodDeclaration,
            });
        }
        getInstanceProperty(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getInstanceProperties(), nameOrFindFunction);
        }
        getInstancePropertyOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getInstanceProperty(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class instance property", nameOrFindFunction));
        }
        getInstanceProperties() {
            return this.getInstanceMembers()
                .filter(m => isClassPropertyType(m));
        }
        getStaticProperty(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getStaticProperties(), nameOrFindFunction);
        }
        getStaticPropertyOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getStaticProperty(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class static property", nameOrFindFunction));
        }
        getStaticProperties() {
            return this.getStaticMembers()
                .filter(m => isClassPropertyType(m));
        }
        getProperty(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getProperties(), nameOrFindFunction);
        }
        getPropertyOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class property declaration", nameOrFindFunction));
        }
        getProperties() {
            return this.getMembers()
                .filter(m => Node.isPropertyDeclaration(m));
        }
        getGetAccessor(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getGetAccessors(), nameOrFindFunction);
        }
        getGetAccessorOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getGetAccessor(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class getAccessor declaration", nameOrFindFunction));
        }
        getGetAccessors() {
            return this.getMembers()
                .filter(m => Node.isGetAccessorDeclaration(m));
        }
        getSetAccessor(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getSetAccessors(), nameOrFindFunction);
        }
        getSetAccessorOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getSetAccessor(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class setAccessor declaration", nameOrFindFunction));
        }
        getSetAccessors() {
            return this.getMembers()
                .filter(m => Node.isSetAccessorDeclaration(m));
        }
        getMethod(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getMethods(), nameOrFindFunction);
        }
        getMethodOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getMethod(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class method declaration", nameOrFindFunction));
        }
        getMethods() {
            return this.getMembers()
                .filter(m => Node.isMethodDeclaration(m));
        }
        getInstanceMethod(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getInstanceMethods(), nameOrFindFunction);
        }
        getInstanceMethodOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getInstanceMethod(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class instance method", nameOrFindFunction));
        }
        getInstanceMethods() {
            return this.getInstanceMembers().filter(m => m instanceof MethodDeclaration);
        }
        getStaticMethod(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getStaticMethods(), nameOrFindFunction);
        }
        getStaticMethodOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getStaticMethod(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class static method", nameOrFindFunction));
        }
        getStaticMethods() {
            return this.getStaticMembers().filter(m => m instanceof MethodDeclaration);
        }
        getInstanceMember(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getInstanceMembers(), nameOrFindFunction);
        }
        getInstanceMemberOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getInstanceMember(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class instance member", nameOrFindFunction));
        }
        getInstanceMembers() {
            return this.getMembersWithParameterProperties().filter(m => {
                if (Node.isConstructorDeclaration(m))
                    return false;
                return Node.isParameterDeclaration(m) || !m.isStatic();
            });
        }
        getStaticMember(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getStaticMembers(), nameOrFindFunction);
        }
        getStaticMemberOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getStaticMember(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class static member", nameOrFindFunction));
        }
        getStaticMembers() {
            return this.getMembers().filter(m => {
                if (Node.isConstructorDeclaration(m))
                    return false;
                return !Node.isParameterDeclaration(m) && m.isStatic();
            });
        }
        getMembersWithParameterProperties() {
            const members = this.getMembers();
            const implementationCtors = members.filter(c => Node.isConstructorDeclaration(c) && c.isImplementation());
            for (const ctor of implementationCtors) {
                let insertIndex = members.indexOf(ctor) + 1;
                for (const param of ctor.getParameters()) {
                    if (param.isParameterProperty()) {
                        members.splice(insertIndex, 0, param);
                        insertIndex++;
                    }
                }
            }
            return members;
        }
        getMembers() {
            return getAllMembers(this, this.compilerNode.members).filter(m => isSupportedClassMember(m));
        }
        getMembersWithComments() {
            const compilerNode = this.compilerNode;
            const members = ExtendedParser.getContainerArray(compilerNode, this.getSourceFile().compilerNode);
            return getAllMembers(this, members)
                .filter(m => isSupportedClassMember(m) || Node.isCommentClassElement(m));
        }
        getMember(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getMembers(), nameOrFindFunction);
        }
        getMemberOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getMember(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("class member", nameOrFindFunction));
        }
        getBaseTypes() {
            return this.getType().getBaseTypes();
        }
        getBaseClassOrThrow() {
            return errors.throwIfNullOrUndefined(this.getBaseClass(), `Expected to find the base class of ${this.getName()}.`);
        }
        getBaseClass() {
            const baseTypes = ArrayUtils.flatten(this.getBaseTypes().map(t => t.isIntersection() ? t.getIntersectionTypes() : [t]));
            const declarations = baseTypes
                .map(t => t.getSymbol())
                .filter(s => s != null)
                .map(s => s.getDeclarations())
                .reduce((a, b) => a.concat(b), [])
                .filter(d => d.getKind() === ts$1.SyntaxKind.ClassDeclaration);
            if (declarations.length !== 1)
                return undefined;
            return declarations[0];
        }
        getDerivedClasses() {
            const classes = getImmediateDerivedClasses(this);
            for (let i = 0; i < classes.length; i++) {
                const derivedClasses = getImmediateDerivedClasses(classes[i]);
                for (const derivedClass of derivedClasses) {
                    if (derivedClass !== this && classes.indexOf(derivedClass) === -1)
                        classes.push(derivedClass);
                }
            }
            return classes;
        }
    };
}
function getAllMembers(classDec, compilerMembers) {
    const isAmbient = isNodeAmbientOrInAmbientContext(classDec);
    const members = compilerMembers.map(m => classDec._getNodeFromCompilerNode(m));
    return isAmbient ? members : members.filter(m => {
        if (!(Node.isConstructorDeclaration(m) || Node.isMethodDeclaration(m)))
            return true;
        if (Node.isMethodDeclaration(m) && m.isAbstract())
            return true;
        return m.isImplementation();
    });
}
function getImmediateDerivedClasses(classDec) {
    const classes = [];
    const nameNode = classDec.getNameNode();
    if (nameNode == null)
        return classes;
    for (const node of nameNode.findReferencesAsNodes()) {
        const nodeParent = node.getParentIfKind(ts$1.SyntaxKind.ExpressionWithTypeArguments);
        if (nodeParent == null)
            continue;
        const heritageClause = nodeParent.getParentIfKind(ts$1.SyntaxKind.HeritageClause);
        if (heritageClause == null || heritageClause.getToken() !== ts$1.SyntaxKind.ExtendsKeyword)
            continue;
        const derivedClass = heritageClause.getParentIfKind(ts$1.SyntaxKind.ClassDeclaration);
        if (derivedClass == null)
            continue;
        classes.push(derivedClass);
    }
    return classes;
}
function isClassPropertyType(m) {
    return Node.isPropertyDeclaration(m)
        || Node.isSetAccessorDeclaration(m)
        || Node.isGetAccessorDeclaration(m)
        || Node.isParameterDeclaration(m);
}
function isSupportedClassMember(m) {
    return Node.isMethodDeclaration(m)
        || Node.isPropertyDeclaration(m)
        || Node.isGetAccessorDeclaration(m)
        || Node.isSetAccessorDeclaration(m)
        || Node.isConstructorDeclaration(m);
}
function insertChildren$1(classDeclaration, opts) {
    return insertIntoBracesOrSourceFileWithGetChildren(Object.assign({ getIndexedChildren: () => classDeclaration.getMembersWithComments(), parent: classDeclaration }, opts));
}

class CommentClassElement extends ClassElement {
}

const createBase$k = (ctor) => NamespaceChildableNode(AmbientableNode(ExportableNode(ClassLikeDeclarationBase(ctor))));
const ClassDeclarationBase = createBase$k(Statement);
class ClassDeclaration extends ClassDeclarationBase {
    set(structure) {
        callBaseSet(ClassDeclarationBase.prototype, this, structure);
        if (structure.extends != null)
            this.setExtends(structure.extends);
        else if (structure.hasOwnProperty("extends"))
            this.removeExtends();
        if (structure.ctors != null) {
            this.getConstructors().forEach(c => c.remove());
            this.addConstructors(structure.ctors);
        }
        if (structure.properties != null) {
            this.getProperties().forEach(p => p.remove());
            this.addProperties(structure.properties);
        }
        if (structure.getAccessors != null) {
            this.getGetAccessors().forEach(a => a.remove());
            this.addGetAccessors(structure.getAccessors);
        }
        if (structure.setAccessors != null) {
            this.getSetAccessors().forEach(a => a.remove());
            this.addSetAccessors(structure.setAccessors);
        }
        if (structure.methods != null) {
            this.getMethods().forEach(m => m.remove());
            this.addMethods(structure.methods);
        }
        return this;
    }
    getStructure() {
        const getExtends = this.getExtends();
        const isAmbient = this.isAmbient();
        return callBaseGetStructure(ClassDeclarationBase.prototype, this, {
            kind: exports.StructureKind.Class,
            ctors: this.getConstructors().filter(ctor => isAmbient || !ctor.isOverload()).map(ctor => ctor.getStructure()),
            methods: this.getMethods().filter(method => isAmbient || !method.isOverload()).map(method => method.getStructure()),
            properties: this.getProperties().map(property => property.getStructure()),
            extends: getExtends ? getExtends.getText() : undefined,
            getAccessors: this.getGetAccessors().map(getAccessor => getAccessor.getStructure()),
            setAccessors: this.getSetAccessors().map(accessor => accessor.getStructure()),
        });
    }
    extractInterface(name) {
        const { constructors, properties, methods, accessors } = getExtractedClassDetails(this, false);
        const parameterProperties = ArrayUtils.flatten(constructors.map(c => c.getParameters().filter(p => p.isParameterProperty())))
            .filter(p => p.getName() != null && p.getScope() === exports.Scope.Public);
        return {
            kind: exports.StructureKind.Interface,
            name: getDefaultExtractedName(name, this),
            docs: this.getJsDocs().map(d => d.getStructure()),
            typeParameters: this.getTypeParameters().map(p => p.getStructure()),
            properties: [
                ...parameterProperties.map(p => {
                    const jsDocComment = ArrayUtils.flatten(p.getParentOrThrow().getJsDocs().map(j => j.getTags()))
                        .filter(Node.isJSDocParameterTag)
                        .filter(t => t.getTagName() === "param" && t.getName() === p.getName() && t.getComment() != null)
                        .map(t => t.getComment().trim())[0];
                    return {
                        kind: exports.StructureKind.PropertySignature,
                        docs: jsDocComment == null ? [] : [{ kind: exports.StructureKind.JSDoc, description: jsDocComment }],
                        name: p.getName(),
                        type: p.getType().getText(p),
                        hasQuestionToken: p.hasQuestionToken(),
                        isReadonly: p.isReadonly(),
                    };
                }),
                ...properties.map(getExtractedInterfacePropertyStructure),
                ...accessors.map(getExtractedInterfaceAccessorStructure),
            ],
            methods: methods.map(getExtractedInterfaceMethodStructure),
        };
    }
    extractStaticInterface(name) {
        const { constructors, properties, methods, accessors } = getExtractedClassDetails(this, true);
        const instanceName = getDefaultExtractedName(undefined, this);
        return {
            kind: exports.StructureKind.Interface,
            name,
            properties: [
                ...properties.map(getExtractedInterfacePropertyStructure),
                ...accessors.map(getExtractedInterfaceAccessorStructure),
            ],
            methods: methods.map(getExtractedInterfaceMethodStructure),
            constructSignatures: constructors.map(c => ({
                kind: exports.StructureKind.ConstructSignature,
                docs: c.getJsDocs().map(d => d.getStructure()),
                parameters: c.getParameters().map(p => (Object.assign(Object.assign({}, getExtractedInterfaceParameterStructure(p)), { scope: undefined, isReadonly: false }))),
                returnType: instanceName,
            })),
        };
    }
}
function getExtractedClassDetails(classDec, isStatic) {
    const constructors = ArrayUtils.flatten(classDec.getConstructors().map(c => c.getOverloads().length > 0 ? c.getOverloads() : [c]));
    const properties = classDec.getProperties().filter(p => p.isStatic() === isStatic && p.getScope() === exports.Scope.Public);
    const methods = ArrayUtils.flatten(classDec.getMethods()
        .filter(p => p.isStatic() === isStatic && p.getScope() === exports.Scope.Public)
        .map(m => m.getOverloads().length > 0 ? m.getOverloads() : [m]));
    return { constructors, properties, methods, accessors: getAccessors() };
    function getAccessors() {
        const result = new KeyValueCache();
        for (const accessor of [...classDec.getGetAccessors(), ...classDec.getSetAccessors()]) {
            if (accessor.isStatic() === isStatic && accessor.getScope() === exports.Scope.Public)
                result.getOrCreate(accessor.getName(), () => []).push(accessor);
        }
        return result.getValuesAsArray();
    }
}
function getDefaultExtractedName(name, classDec) {
    name = StringUtils.isNullOrWhitespace(name) ? undefined : name;
    return name || classDec.getName() || classDec.getSourceFile().getBaseNameWithoutExtension().replace(/[^a-zA-Z0-9_$]/g, "");
}
function getExtractedInterfacePropertyStructure(prop) {
    return {
        kind: exports.StructureKind.PropertySignature,
        docs: prop.getJsDocs().map(d => d.getStructure()),
        name: prop.getName(),
        type: prop.getType().getText(prop),
        hasQuestionToken: prop.hasQuestionToken(),
        isReadonly: prop.isReadonly(),
    };
}
function getExtractedInterfaceAccessorStructure(getAndSet) {
    return {
        kind: exports.StructureKind.PropertySignature,
        docs: getAndSet[0].getJsDocs().map(d => d.getStructure()),
        name: getAndSet[0].getName(),
        type: getAndSet[0].getType().getText(getAndSet[0]),
        hasQuestionToken: false,
        isReadonly: getAndSet.every(Node.isGetAccessorDeclaration),
    };
}
function getExtractedInterfaceMethodStructure(method) {
    return {
        kind: exports.StructureKind.MethodSignature,
        docs: method.getJsDocs().map(d => d.getStructure()),
        name: method.getName(),
        hasQuestionToken: method.hasQuestionToken(),
        returnType: method.getReturnType().getText(method),
        parameters: method.getParameters().map(getExtractedInterfaceParameterStructure),
        typeParameters: method.getTypeParameters().map(p => p.getStructure()),
    };
}
function getExtractedInterfaceParameterStructure(param) {
    return Object.assign(Object.assign({}, param.getStructure()), { decorators: [] });
}

const ClassExpressionBase = ClassLikeDeclarationBase(PrimaryExpression);
class ClassExpression extends ClassExpressionBase {
}

const createBase$l = (ctor) => ChildOrderableNode(TextInsertableNode(OverloadableNode(ScopedNode(FunctionLikeDeclaration(BodyableNode(ctor))))));
const ConstructorDeclarationBase = createBase$l(ClassElement);
const createOverloadBase$2 = (ctor) => TypeParameteredNode(JSDocableNode(ChildOrderableNode(TextInsertableNode(ScopedNode(ModifierableNode(SignaturedDeclaration(ctor)))))));
const ConstructorDeclarationOverloadBase = createOverloadBase$2(ClassElement);
class ConstructorDeclaration extends ConstructorDeclarationBase {
    set(structure) {
        callBaseSet(ConstructorDeclarationBase.prototype, this, structure);
        if (structure.overloads != null) {
            this.getOverloads().forEach(o => o.remove());
            this.addOverloads(structure.overloads);
        }
        return this;
    }
    addOverload(structure) {
        return this.addOverloads([structure])[0];
    }
    addOverloads(structures) {
        return this.insertOverloads(this.getOverloads().length, structures);
    }
    insertOverload(index, structure) {
        return this.insertOverloads(index, [structure])[0];
    }
    insertOverloads(index, structures) {
        const printer = this._context.structurePrinterFactory.forConstructorDeclaration({
            isAmbient: isNodeAmbientOrInAmbientContext(this),
        });
        return insertOverloads({
            node: this,
            index,
            structures,
            printStructure: (writer, structure) => {
                printer.printOverload(writer, structure);
            },
            getThisStructure: fromConstructorDeclarationOverload,
            expectedSyntaxKind: ts$1.SyntaxKind.Constructor,
        });
    }
    getStructure() {
        const hasImplementation = this.getImplementation() != null;
        const isOverload = this.isOverload();
        const basePrototype = isOverload && hasImplementation ? ConstructorDeclarationOverloadBase.prototype : ConstructorDeclarationBase.prototype;
        return callBaseGetStructure(basePrototype, this, getStructure(this));
        function getStructure(thisNode) {
            if (hasImplementation && isOverload)
                return getSpecificOverloadStructure();
            return getSpecificStructure();
            function getSpecificOverloadStructure() {
                return { kind: exports.StructureKind.ConstructorOverload };
            }
            function getSpecificStructure() {
                if (!hasImplementation)
                    return { kind: exports.StructureKind.Constructor };
                else {
                    return {
                        kind: exports.StructureKind.Constructor,
                        overloads: thisNode.getOverloads().map(o => o.getStructure()),
                    };
                }
            }
        }
    }
}

const createBase$m = (ctor) => ChildOrderableNode(TextInsertableNode(DecoratableNode(AbstractableNode(ScopedNode(StaticableNode(FunctionLikeDeclaration(BodyableNode(PropertyNamedNode(ctor)))))))));
const GetAccessorDeclarationBase = createBase$m(ClassElement);
class GetAccessorDeclaration extends GetAccessorDeclarationBase {
    set(structure) {
        callBaseSet(GetAccessorDeclarationBase.prototype, this, structure);
        return this;
    }
    getSetAccessor() {
        const thisName = this.getName();
        const isStatic = this.isStatic();
        return this.getParentOrThrow().forEachChild(sibling => {
            if (Node.isSetAccessorDeclaration(sibling) && sibling.getName() === thisName && sibling.isStatic() === isStatic)
                return sibling;
            return undefined;
        });
    }
    getSetAccessorOrThrow() {
        return errors.throwIfNullOrUndefined(this.getSetAccessor(), () => `Expected to find a corresponding set accessor for ${this.getName()}.`);
    }
    getStructure() {
        return callBaseGetStructure(GetAccessorDeclarationBase.prototype, this, {
            kind: exports.StructureKind.GetAccessor,
        });
    }
}

const createBase$n = (ctor) => ChildOrderableNode(AmbientableNode(DecoratableNode(AbstractableNode(ScopedNode(StaticableNode(JSDocableNode(ReadonlyableNode(ExclamationTokenableNode(QuestionTokenableNode(InitializerExpressionableNode(TypedNode(PropertyNamedNode(ModifierableNode(ctor))))))))))))));
const PropertyDeclarationBase = createBase$n(ClassElement);
class PropertyDeclaration extends PropertyDeclarationBase {
    set(structure) {
        callBaseSet(PropertyDeclarationBase.prototype, this, structure);
        return this;
    }
    remove() {
        const parent = this.getParentOrThrow();
        switch (parent.getKind()) {
            case ts$1.SyntaxKind.ClassDeclaration:
                super.remove();
                break;
            default:
                throw new errors.NotImplementedError(`Not implemented parent syntax kind: ${parent.getKindName()}`);
        }
    }
    getStructure() {
        return callBaseGetStructure(PropertyDeclarationBase.prototype, this, {
            kind: exports.StructureKind.Property,
        });
    }
}

const createBase$o = (ctor) => ChildOrderableNode(TextInsertableNode(DecoratableNode(AbstractableNode(ScopedNode(StaticableNode(FunctionLikeDeclaration(BodyableNode(PropertyNamedNode(ctor)))))))));
const SetAccessorDeclarationBase = createBase$o(ClassElement);
class SetAccessorDeclaration extends SetAccessorDeclarationBase {
    set(structure) {
        callBaseSet(SetAccessorDeclarationBase.prototype, this, structure);
        return this;
    }
    getGetAccessor() {
        const thisName = this.getName();
        const isStatic = this.isStatic();
        return this.getParentOrThrow().forEachChild(sibling => {
            if (Node.isGetAccessorDeclaration(sibling) && sibling.getName() === thisName && sibling.isStatic() === isStatic)
                return sibling;
            return undefined;
        });
    }
    getGetAccessorOrThrow() {
        return errors.throwIfNullOrUndefined(this.getGetAccessor(), () => `Expected to find a corresponding get accessor for ${this.getName()}.`);
    }
    getStructure() {
        return callBaseGetStructure(SetAccessorDeclarationBase.prototype, this, {
            kind: exports.StructureKind.SetAccessor,
        });
    }
}

const DecoratorBase = Node;
class Decorator extends DecoratorBase {
    getName() {
        return this.getNameNode().getText();
    }
    getNameNode() {
        if (this.isDecoratorFactory()) {
            const callExpression = this.getCallExpression();
            return getIdentifierFromName(callExpression.getExpression());
        }
        return getIdentifierFromName(this.getExpression());
        function getIdentifierFromName(expression) {
            const identifier = getNameFromExpression(expression);
            if (!Node.isIdentifier(identifier)) {
                throw new errors.NotImplementedError(`Expected the decorator expression '${identifier.getText()}' to be an identifier, `
                    + `but it wasn't. Please report this as a bug.`);
            }
            return identifier;
        }
        function getNameFromExpression(expression) {
            if (Node.isPropertyAccessExpression(expression))
                return expression.getNameNode();
            return expression;
        }
    }
    getFullName() {
        const sourceFile = this.getSourceFile();
        if (this.isDecoratorFactory())
            return this.getCallExpression().getExpression().getText();
        return this.compilerNode.expression.getText(sourceFile.compilerNode);
    }
    isDecoratorFactory() {
        return this.compilerNode.expression.kind === ts$1.SyntaxKind.CallExpression;
    }
    setIsDecoratorFactory(isDecoratorFactory) {
        if (this.isDecoratorFactory() === isDecoratorFactory)
            return this;
        if (isDecoratorFactory) {
            const expression = this.getExpression();
            const expressionText = expression.getText();
            insertIntoParentTextRange({
                parent: this,
                insertPos: expression.getStart(),
                newText: `${expressionText}()`,
                replacing: {
                    textLength: expressionText.length,
                },
                customMappings: newParent => {
                    return [{ currentNode: expression, newNode: newParent.expression.expression }];
                },
            });
        }
        else {
            const callExpression = this.getCallExpressionOrThrow();
            const expression = callExpression.getExpression();
            const expressionText = expression.getText();
            insertIntoParentTextRange({
                parent: this,
                insertPos: callExpression.getStart(),
                newText: `${expressionText}`,
                replacing: {
                    textLength: callExpression.getWidth(),
                },
                customMappings: newParent => {
                    return [{ currentNode: expression, newNode: newParent.expression }];
                },
            });
        }
        return this;
    }
    getCallExpressionOrThrow() {
        return errors.throwIfNullOrUndefined(this.getCallExpression(), "Expected to find a call expression.");
    }
    getCallExpression() {
        if (!this.isDecoratorFactory())
            return undefined;
        return this.getExpression();
    }
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
    getArguments() {
        var _a, _b;
        return (_b = (_a = this.getCallExpression()) === null || _a === void 0 ? void 0 : _a.getArguments()) !== null && _b !== void 0 ? _b : [];
    }
    getTypeArguments() {
        var _a, _b;
        return (_b = (_a = this.getCallExpression()) === null || _a === void 0 ? void 0 : _a.getTypeArguments()) !== null && _b !== void 0 ? _b : [];
    }
    addTypeArgument(argumentText) {
        return this.getCallExpressionOrThrow().addTypeArgument(argumentText);
    }
    addTypeArguments(argumentTexts) {
        return this.getCallExpressionOrThrow().addTypeArguments(argumentTexts);
    }
    insertTypeArgument(index, argumentText) {
        return this.getCallExpressionOrThrow().insertTypeArgument(index, argumentText);
    }
    insertTypeArguments(index, argumentTexts) {
        return this.getCallExpressionOrThrow().insertTypeArguments(index, argumentTexts);
    }
    removeTypeArgument(typeArgOrIndex) {
        const callExpression = this.getCallExpression();
        if (callExpression == null)
            throw new errors.InvalidOperationError("Cannot remove a type argument from a decorator that has no type arguments.");
        callExpression.removeTypeArgument(typeArgOrIndex);
        return this;
    }
    addArgument(argumentText) {
        return this.addArguments([argumentText])[0];
    }
    addArguments(argumentTexts) {
        return this.insertArguments(this.getArguments().length, argumentTexts);
    }
    insertArgument(index, argumentText) {
        return this.insertArguments(index, [argumentText])[0];
    }
    insertArguments(index, argumentTexts) {
        this.setIsDecoratorFactory(true);
        return this.getCallExpressionOrThrow().insertArguments(index, argumentTexts);
    }
    removeArgument(argOrIndex) {
        const callExpression = this.getCallExpression();
        if (callExpression == null)
            throw new errors.InvalidOperationError("Cannot remove an argument from a decorator that has no arguments.");
        callExpression.removeArgument(argOrIndex);
        return this;
    }
    remove() {
        const thisStartLinePos = this.getStartLinePos();
        const previousDecorator = this.getPreviousSiblingIfKind(ts$1.SyntaxKind.Decorator);
        if (previousDecorator != null && previousDecorator.getStartLinePos() === thisStartLinePos) {
            removeChildren({
                children: [this],
                removePrecedingSpaces: true,
            });
        }
        else {
            removeChildrenWithFormattingFromCollapsibleSyntaxList({
                children: [this],
                getSiblingFormatting: (parent, sibling) => sibling.getStartLinePos() === thisStartLinePos ? FormattingKind.Space : FormattingKind.Newline,
            });
        }
    }
    set(structure) {
        callBaseSet(DecoratorBase.prototype, this, structure);
        if (structure.name != null)
            this.getNameNode().replaceWithText(structure.name);
        if (structure.arguments != null) {
            this.setIsDecoratorFactory(true);
            this.getArguments().map(a => this.removeArgument(a));
            this.addArguments(structure.arguments);
        }
        if (structure.typeArguments != null && structure.typeArguments.length > 0) {
            this.setIsDecoratorFactory(true);
            this.getTypeArguments().map(a => this.removeTypeArgument(a));
            this.addTypeArguments(structure.typeArguments);
        }
        return this;
    }
    getStructure() {
        const isDecoratorFactory = this.isDecoratorFactory();
        return callBaseGetStructure(DecoratorBase.prototype, this, {
            kind: exports.StructureKind.Decorator,
            name: this.getName(),
            arguments: isDecoratorFactory ? this.getArguments().map(arg => arg.getText()) : undefined,
            typeArguments: isDecoratorFactory ? this.getTypeArguments().map(arg => arg.getText()) : undefined,
        });
    }
}

function JSDocPropertyLikeTag(Base) {
    return class extends Base {
        getTypeExpression() {
            return this._getNodeFromCompilerNodeIfExists(this.compilerNode.typeExpression);
        }
        getTypeExpressionOrThrow() {
            return errors.throwIfNullOrUndefined(this.getTypeExpression(), `Expected to find a JS doc type expression.`);
        }
        getName() {
            return this.getNameNode().getText();
        }
        getNameNode() {
            return this._getNodeFromCompilerNode(this.compilerNode.name);
        }
        isBracketed() {
            return this.compilerNode.isBracketed;
        }
    };
}

function JSDocTypeExpressionableTag(Base) {
    return class extends Base {
        getTypeExpression() {
            const result = this._getNodeFromCompilerNodeIfExists(this.compilerNode.typeExpression);
            if (result != null && result.getWidth() === 0)
                return undefined;
            return result;
        }
        getTypeExpressionOrThrow() {
            return errors.throwIfNullOrUndefined(this.getTypeExpression(), `Expected to find the JS doc tag's type expression.`);
        }
    };
}

function JSDocTypeParameteredTag(Base) {
    return class extends Base {
        getTypeParameters() {
            return this.compilerNode.typeParameters
                .map(p => this._getNodeFromCompilerNode(p))
                .filter(p => p.getWidth() > 0);
        }
    };
}

function getTextWithoutStars(inputText) {
    const innerTextWithStars = inputText.replace(/^\/\*\*[^\S\n]*\n?/, "").replace(/(\r?\n)?[^\S\n]*\*\/$/, "");
    return innerTextWithStars.split(/\n/).map(line => {
        const starPos = getStarPosIfFirstNonWhitespaceChar(line);
        if (starPos === -1)
            return line;
        const substringStart = line[starPos + 1] === " " ? starPos + 2 : starPos + 1;
        return line.substring(substringStart);
    }).join("\n");
    function getStarPosIfFirstNonWhitespaceChar(text) {
        for (let i = 0; i < text.length; i++) {
            const charCode = text.charCodeAt(i);
            if (charCode === CharCodes$1.ASTERISK)
                return i;
            else if (!StringUtils.isWhitespaceCharCode(charCode))
                break;
        }
        return -1;
    }
}

const JSDocBase = Node;
class JSDoc extends JSDocBase {
    isMultiLine() {
        return this.getText().includes("\n");
    }
    getTags() {
        var _a, _b;
        return (_b = (_a = this.compilerNode.tags) === null || _a === void 0 ? void 0 : _a.map(t => this._getNodeFromCompilerNode(t))) !== null && _b !== void 0 ? _b : [];
    }
    getInnerText() {
        return getTextWithoutStars(this.getText());
    }
    getDescription() {
        var _a, _b;
        const sourceFileText = this.getSourceFile().getFullText();
        const endSearchStart = (_b = (_a = this.getTags()[0]) === null || _a === void 0 ? void 0 : _a.getStart()) !== null && _b !== void 0 ? _b : this.getEnd() - 2;
        const start = getStart(this);
        return getTextWithoutStars(sourceFileText.substring(start, Math.max(start, getEndPos())));
        function getStart(jsDoc) {
            const startOrSpacePos = jsDoc.getStart() + 3;
            if (sourceFileText.charCodeAt(startOrSpacePos) === CharCodes$1.SPACE)
                return startOrSpacePos + 1;
            return startOrSpacePos;
        }
        function getEndPos() {
            const endOrNewLinePos = getPreviousMatchingPos(sourceFileText, endSearchStart, charCode => charCode === CharCodes$1.NEWLINE || !StringUtils.isWhitespaceCharCode(charCode) && charCode !== CharCodes$1.ASTERISK);
            return getPreviousMatchingPos(sourceFileText, endOrNewLinePos, charCode => charCode !== CharCodes$1.NEWLINE && charCode !== CharCodes$1.CARRIAGE_RETURN);
        }
    }
    setDescription(textOrWriterFunction) {
        const tags = this.getTags();
        const startEditPos = this.getStart() + 3;
        const endEditPos = tags.length > 0
            ? getPreviousMatchingPos(this._sourceFile.getFullText(), tags[0].getStart(), c => c === CharCodes$1.ASTERISK) - 1
            : this.getEnd() - 2;
        replaceTextPossiblyCreatingChildNodes({
            parent: this,
            newText: getNewText.call(this),
            replacePos: startEditPos,
            replacingLength: endEditPos - startEditPos,
        });
        return this;
        function getNewText() {
            var _a, _b;
            const indentationText = this.getIndentationText();
            const newLineKind = this._context.manipulationSettings.getNewLineKindAsString();
            const rawLines = getTextFromStringOrWriter(this._getWriter(), textOrWriterFunction).split(/\r?\n/);
            const startsWithNewLine = rawLines[0].length === 0;
            const isSingleLine = rawLines.length === 1 && ((_b = (_a = this.compilerNode.tags) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0;
            const linesText = isSingleLine ? rawLines[0] : rawLines.map(l => l.length === 0 ? `${indentationText} *` : `${indentationText} * ${l}`)
                .slice(startsWithNewLine ? 1 : 0)
                .join(newLineKind);
            return isSingleLine ? " " + linesText + " " : newLineKind + linesText + newLineKind + indentationText + " ";
        }
    }
    addTag(structure) {
        return this.addTags([structure])[0];
    }
    addTags(structures) {
        var _a, _b;
        return this.insertTags((_b = (_a = this.compilerNode.tags) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0, structures);
    }
    insertTag(index, structure) {
        return this.insertTags(index, [structure])[0];
    }
    insertTags(index, structures) {
        if (ArrayUtils.isNullOrEmpty(structures))
            return [];
        const writer = this._getWriterWithQueuedIndentation();
        const tags = this.getTags();
        index = verifyAndGetIndex(index, tags.length);
        if (tags.length === 0 && !this.isMultiLine()) {
            const structurePrinter = this._context.structurePrinterFactory.forJSDoc();
            this.replaceWithText(writer => {
                structurePrinter.printText(writer, {
                    description: this.getDescription(),
                    tags: structures,
                });
            });
        }
        else {
            const structurePrinter = this._context.structurePrinterFactory.forJSDocTag({ printStarsOnNewLine: true });
            writer.newLine().write(" * ");
            structurePrinter.printTexts(writer, structures);
            writer.newLine().write(" *");
            writer.conditionalWrite(index < tags.length, " ");
            const replaceStart = getReplaceStart.call(this);
            const replaceEnd = getReplaceEnd.call(this);
            insertIntoParentTextRange({
                parent: this,
                insertPos: replaceStart,
                replacing: { textLength: replaceEnd - replaceStart },
                newText: writer.toString(),
            });
        }
        return getNodesToReturn(tags, this.getTags(), index, false);
        function getReplaceStart() {
            const searchStart = index < tags.length ? tags[index].getStart() : this.getEnd() - 2;
            const maxMin = this.getStart() + 3;
            return Math.max(maxMin, getPreviousMatchingPos(this.getSourceFile().getFullText(), searchStart, charCode => !StringUtils.isWhitespaceCharCode(charCode) && charCode !== CharCodes$1.ASTERISK));
        }
        function getReplaceEnd() {
            if (index < tags.length)
                return tags[index].getStart();
            return this.getEnd() - 1;
        }
    }
    remove() {
        removeChildren({
            children: [this],
            removeFollowingSpaces: true,
            removeFollowingNewLines: true,
        });
    }
    set(structure) {
        callBaseSet(JSDocBase.prototype, this, structure);
        if (structure.tags != null) {
            return this.replaceWithText(writer => {
                var _a;
                this._context.structurePrinterFactory.forJSDoc().printText(writer, {
                    description: (_a = structure.description) !== null && _a !== void 0 ? _a : this.getDescription(),
                    tags: structure.tags,
                });
            });
        }
        else if (structure.description != null) {
            this.setDescription(structure.description);
        }
        return this;
    }
    getStructure() {
        return callBaseGetStructure(JSDocBase.prototype, this, {
            kind: exports.StructureKind.JSDoc,
            description: this.getDescription(),
            tags: this.getTags().map(t => t.getStructure()),
        });
    }
}

const JSDocTagBase = Node;
class JSDocTag extends JSDocTagBase {
    getTagName() {
        return this.getTagNameNode().getText();
    }
    getTagNameNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.tagName);
    }
    setTagName(tagName) {
        return this.set({ tagName });
    }
    getComment() {
        return this.compilerNode.comment;
    }
    remove() {
        const jsDocBodyStart = this.getParentOrThrow().getStart() + 3;
        const nextJsDocTag = getNextJsDocTag(this);
        const isLastJsDoc = nextJsDocTag == null;
        const removalStart = getRemovalStart.call(this);
        removeChildren({
            children: [this],
            customRemovalPos: removalStart,
            customRemovalEnd: getNextTagStartOrDocEnd(this, nextJsDocTag),
            replaceTrivia: getReplaceTrivia.call(this),
        });
        function getRemovalStart() {
            return Math.max(jsDocBodyStart, getPreviousNonWhiteSpacePos(this, this.getStart()));
        }
        function getReplaceTrivia() {
            if (removalStart === jsDocBodyStart && isLastJsDoc)
                return "";
            const newLineKind = this._context.manipulationSettings.getNewLineKindAsString();
            const indentationText = this.getParentOrThrow().getIndentationText();
            return `${newLineKind}${indentationText} ` + (isLastJsDoc ? "" : "* ");
        }
    }
    set(structure) {
        callBaseSet(JSDocTagBase.prototype, this, structure);
        if (structure.text != null || structure.tagName != null) {
            return this.replaceWithText(writer => {
                var _a;
                this._context.structurePrinterFactory.forJSDocTag({ printStarsOnNewLine: true }).printText(writer, {
                    tagName: (_a = structure.tagName) !== null && _a !== void 0 ? _a : this.getTagName(),
                    text: structure.text != null ? structure.text : getText(this),
                });
            });
        }
        return this;
    }
    replaceWithText(textOrWriterFunction) {
        const newText = getTextFromStringOrWriter(this._getWriterWithQueuedIndentation(), textOrWriterFunction);
        const parent = this.getParentOrThrow();
        const childIndex = this.getChildIndex();
        const start = this.getStart();
        insertIntoParentTextRange({
            parent,
            insertPos: start,
            newText,
            replacing: {
                textLength: getTagEnd(this) - start,
            },
        });
        return parent.getChildren()[childIndex];
    }
    getStructure() {
        const text = getText(this);
        return callBaseGetStructure(JSDocTagBase.prototype, this, {
            kind: exports.StructureKind.JSDocTag,
            tagName: this.getTagName(),
            text: text.length === 0 ? undefined : text,
        });
    }
}
function getText(jsDocTag) {
    const text = jsDocTag.getSourceFile().getFullText();
    const nameEnd = jsDocTag.getTagNameNode().getEnd();
    const tagEnd = getTagEnd(jsDocTag);
    const startPos = Math.min(text.charCodeAt(nameEnd) === CharCodes$1.SPACE ? nameEnd + 1 : nameEnd, tagEnd);
    return getTextWithoutStars(text.substring(startPos, tagEnd));
}
function getTagEnd(jsDocTag) {
    return getPreviousNonWhiteSpacePos(jsDocTag, getNextTagStartOrDocEnd(jsDocTag));
}
function getNextTagStartOrDocEnd(jsDocTag, nextJsDocTag) {
    nextJsDocTag = nextJsDocTag !== null && nextJsDocTag !== void 0 ? nextJsDocTag : getNextJsDocTag(jsDocTag);
    return nextJsDocTag != null
        ? nextJsDocTag.getStart()
        : jsDocTag.getParentOrThrow().getEnd() - 2;
}
function getNextJsDocTag(jsDocTag) {
    const parent = jsDocTag.getParentIfKindOrThrow(ts$1.SyntaxKind.JSDocComment);
    const tags = parent.getTags();
    const thisIndex = tags.indexOf(jsDocTag);
    return tags[thisIndex + 1];
}
function getPreviousNonWhiteSpacePos(jsDocTag, pos) {
    const sourceFileText = jsDocTag.getSourceFile().getFullText();
    return getPreviousMatchingPos(sourceFileText, pos, charCode => charCode !== CharCodes$1.ASTERISK && !StringUtils.isWhitespaceCharCode(charCode));
}

class JSDocAugmentsTag extends JSDocTag {
}

class JSDocClassTag extends JSDocTag {
}

class TypeNode extends Node {
}

class ArrayTypeNode extends TypeNode {
    getElementTypeNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.elementType);
    }
}

class ConditionalTypeNode extends TypeNode {
    getCheckType() {
        return this._getNodeFromCompilerNode(this.compilerNode.checkType);
    }
    getExtendsType() {
        return this._getNodeFromCompilerNode(this.compilerNode.extendsType);
    }
    getTrueType() {
        return this._getNodeFromCompilerNode(this.compilerNode.trueType);
    }
    getFalseType() {
        return this._getNodeFromCompilerNode(this.compilerNode.falseType);
    }
}

const FunctionOrConstructorTypeNodeBaseBase = SignaturedDeclaration(TypeNode);
class FunctionOrConstructorTypeNodeBase extends FunctionOrConstructorTypeNodeBaseBase {
}

class ConstructorTypeNode extends FunctionOrConstructorTypeNodeBase {
}

const ExpressionWithTypeArgumentsBase = LeftHandSideExpressionedNode(TypeNode);
class ExpressionWithTypeArguments extends ExpressionWithTypeArgumentsBase {
    getTypeArguments() {
        var _a, _b;
        return (_b = (_a = this.compilerNode.typeArguments) === null || _a === void 0 ? void 0 : _a.map(a => this._getNodeFromCompilerNode(a))) !== null && _b !== void 0 ? _b : [];
    }
}

const FunctionTypeNodeBase = TypeParameteredNode(FunctionOrConstructorTypeNodeBase);
class FunctionTypeNode extends FunctionTypeNodeBase {
}

const ImportTypeNodeBase = TypeArgumentedNode(TypeNode);
class ImportTypeNode extends ImportTypeNodeBase {
    setArgument(text) {
        const arg = this.getArgument();
        if (Node.isLiteralTypeNode(arg)) {
            const literal = arg.getLiteral();
            if (Node.isStringLiteral(literal)) {
                literal.setLiteralValue(text);
                return this;
            }
        }
        arg.replaceWithText(writer => writer.quote(text), this._getWriterWithQueuedChildIndentation());
        return this;
    }
    getArgument() {
        return this._getNodeFromCompilerNode(this.compilerNode.argument);
    }
    setQualifier(text) {
        const qualifier = this.getQualifier();
        if (qualifier != null)
            qualifier.replaceWithText(text, this._getWriterWithQueuedChildIndentation());
        else {
            const paren = this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.CloseParenToken);
            insertIntoParentTextRange({
                insertPos: paren.getEnd(),
                parent: this,
                newText: this._getWriterWithQueuedIndentation().write(".").write(text).toString(),
            });
        }
        return this;
    }
    getQualifierOrThrow() {
        return errors.throwIfNullOrUndefined(this.getQualifier(), () => `Expected to find a qualifier for the import type: ${this.getText()}`);
    }
    getQualifier() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.qualifier);
    }
}

class IndexedAccessTypeNode extends TypeNode {
    getObjectTypeNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.objectType);
    }
    getIndexTypeNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.indexType);
    }
}

class InferTypeNode extends TypeNode {
    getTypeParameter() {
        return this._getNodeFromCompilerNode(this.compilerNode.typeParameter);
    }
}

class IntersectionTypeNode extends TypeNode {
    getTypeNodes() {
        return this.compilerNode.types.map(t => this._getNodeFromCompilerNode(t));
    }
}

class LiteralTypeNode extends TypeNode {
    getLiteral() {
        const tsLiteral = this.compilerNode.literal;
        return this._getNodeFromCompilerNode(tsLiteral);
    }
}

class ParenthesizedTypeNode extends TypeNode {
    getTypeNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.type);
    }
    setType(textOrWriterFunction) {
        this.getTypeNode().replaceWithText(textOrWriterFunction);
        return this;
    }
}

class ThisTypeNode extends TypeNode {
}

class TupleTypeNode extends TypeNode {
    getElementTypeNodes() {
        return this.compilerNode.elementTypes.map(t => this._getNodeFromCompilerNode(t));
    }
}

const createBase$p = (ctor) => TypeParameteredNode(TypedNode(JSDocableNode(AmbientableNode(ExportableNode(ModifierableNode(NamedNode(ctor)))))));
const TypeAliasDeclarationBase = createBase$p(Statement);
class TypeAliasDeclaration extends TypeAliasDeclarationBase {
    set(structure) {
        callBaseSet(TypeAliasDeclarationBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(TypeAliasDeclarationBase.prototype, this, {
            kind: exports.StructureKind.TypeAlias,
            type: this.getTypeNodeOrThrow().getText(),
        });
    }
}

const TypeLiteralNodeBase = TypeElementMemberedNode(TypeNode);
class TypeLiteralNode extends TypeLiteralNodeBase {
}

const TypeParameterDeclarationBase = NamedNode(Node);
class TypeParameterDeclaration extends TypeParameterDeclarationBase {
    getConstraint() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.constraint);
    }
    getConstraintOrThrow() {
        return errors.throwIfNullOrUndefined(this.getConstraint(), "Expected to find the type parameter's constraint.");
    }
    setConstraint(text) {
        text = this.getParentOrThrow()._getTextWithQueuedChildIndentation(text);
        if (StringUtils.isNullOrWhitespace(text)) {
            this.removeConstraint();
            return this;
        }
        const constraint = this.getConstraint();
        if (constraint != null) {
            constraint.replaceWithText(text);
            return this;
        }
        const nameNode = this.getNameNode();
        insertIntoParentTextRange({
            parent: this,
            insertPos: nameNode.getEnd(),
            newText: ` extends ${text}`,
        });
        return this;
    }
    removeConstraint() {
        removeConstraintOrDefault(this.getConstraint(), ts$1.SyntaxKind.ExtendsKeyword);
        return this;
    }
    getDefault() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.default);
    }
    getDefaultOrThrow() {
        return errors.throwIfNullOrUndefined(this.getDefault(), "Expected to find the type parameter's default.");
    }
    setDefault(text) {
        text = this.getParentOrThrow()._getTextWithQueuedChildIndentation(text);
        if (StringUtils.isNullOrWhitespace(text)) {
            this.removeDefault();
            return this;
        }
        const defaultNode = this.getDefault();
        if (defaultNode != null) {
            defaultNode.replaceWithText(text);
            return this;
        }
        const insertAfterNode = this.getConstraint() || this.getNameNode();
        insertIntoParentTextRange({
            parent: this,
            insertPos: insertAfterNode.getEnd(),
            newText: ` = ${text}`,
        });
        return this;
    }
    removeDefault() {
        removeConstraintOrDefault(this.getDefault(), ts$1.SyntaxKind.EqualsToken);
        return this;
    }
    remove() {
        const parentSyntaxList = this.getParentSyntaxListOrThrow();
        const typeParameters = parentSyntaxList.getChildrenOfKind(ts$1.SyntaxKind.TypeParameter);
        if (typeParameters.length === 1)
            removeAllTypeParameters();
        else
            removeCommaSeparatedChild(this);
        function removeAllTypeParameters() {
            const children = [
                parentSyntaxList.getPreviousSiblingIfKindOrThrow(ts$1.SyntaxKind.LessThanToken),
                parentSyntaxList,
                parentSyntaxList.getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.GreaterThanToken),
            ];
            removeChildren({ children });
        }
    }
    set(structure) {
        callBaseSet(TypeParameterDeclarationBase.prototype, this, structure);
        if (structure.constraint != null)
            this.setConstraint(structure.constraint);
        else if (structure.hasOwnProperty("constraint"))
            this.removeConstraint();
        if (structure.default != null)
            this.setDefault(structure.default);
        else if (structure.hasOwnProperty("default"))
            this.removeDefault();
        return this;
    }
    getStructure() {
        const constraintNode = this.getConstraint();
        const defaultNode = this.getDefault();
        return callBaseGetStructure(TypeParameterDeclarationBase.prototype, this, {
            kind: exports.StructureKind.TypeParameter,
            constraint: constraintNode != null ? constraintNode.getText({ trimLeadingIndentation: true }) : undefined,
            default: defaultNode ? defaultNode.getText({ trimLeadingIndentation: true }) : undefined,
        });
    }
}
function removeConstraintOrDefault(nodeToRemove, siblingKind) {
    if (nodeToRemove == null)
        return;
    removeChildren({
        children: [nodeToRemove.getPreviousSiblingIfKindOrThrow(siblingKind), nodeToRemove],
        removePrecedingSpaces: true,
    });
}

class TypePredicateNode extends TypeNode {
    getParameterNameNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.parameterName);
    }
    hasAssertsModifier() {
        return this.compilerNode.assertsModifier != null;
    }
    getAssertsModifier() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.assertsModifier);
    }
    getAssertsModifierOrThrow() {
        return errors.throwIfNullOrUndefined(this.getAssertsModifier(), "Expected to find an asserts modifier.");
    }
    getTypeNode() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.type);
    }
    getTypeNodeOrThrow() {
        return errors.throwIfNullOrUndefined(this.getTypeNode(), "Expected to find a type node.");
    }
}

class TypeReferenceNode extends TypeNode {
    getTypeName() {
        return this._getNodeFromCompilerNode(this.compilerNode.typeName);
    }
    getTypeArguments() {
        if (this.compilerNode.typeArguments == null)
            return [];
        return this.compilerNode.typeArguments.map(a => this._getNodeFromCompilerNode(a));
    }
}

class UnionTypeNode extends TypeNode {
    getTypeNodes() {
        return this.compilerNode.types.map(t => this._getNodeFromCompilerNode(t));
    }
}

class JSDocType extends TypeNode {
}

const JSDocFunctionTypeBase = SignaturedDeclaration(JSDocType);
class JSDocFunctionType extends JSDocFunctionTypeBase {
}

const JSDocParameterTagBase = JSDocPropertyLikeTag(JSDocTag);
class JSDocParameterTag extends JSDocParameterTagBase {
}

class JSDocPrivateTag extends JSDocTag {
}

const JSDocPropertyTagBase = JSDocPropertyLikeTag(JSDocTag);
class JSDocPropertyTag extends JSDocPropertyTagBase {
}

class JSDocProtectedTag extends JSDocTag {
}

class JSDocPublicTag extends JSDocTag {
}

class JSDocReadonlyTag extends JSDocTag {
}

const JSDocReturnTagBase = JSDocTypeExpressionableTag(JSDocTag);
class JSDocReturnTag extends JSDocReturnTagBase {
}

class JSDocSignature extends JSDocType {
    getTypeNode() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.type);
    }
}

class JSDocTagInfo {
    constructor(compilerObject) {
        this._compilerObject = compilerObject;
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getName() {
        return this.compilerObject.name;
    }
    getText() {
        return this.compilerObject.text;
    }
}

const JSDocTemplateTagBase = JSDocTypeParameteredTag(JSDocTag);
class JSDocTemplateTag extends JSDocTemplateTagBase {
    getConstraint() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.constraint);
    }
    getConstraintOrThrow() {
        return errors.throwIfNullOrUndefined(this.getConstraint(), "Expected to find the JS doc template tag's constraint.");
    }
}

const JSDocThisTagBase = JSDocTypeExpressionableTag(JSDocTag);
class JSDocThisTag extends JSDocThisTagBase {
}

class JSDocTypedefTag extends JSDocTag {
}

class JSDocTypeTag extends JSDocTag {
    getTypeExpression() {
        const node = this.compilerNode.typeExpression;
        if (node != null && node.pos === node.end)
            return undefined;
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.typeExpression);
    }
}

class JSDocUnknownTag extends JSDocTag {
}

class JSDocTypeExpression extends TypeNode {
    getTypeNode() {
        return this._getNodeFromCompilerNode(this.compilerNode.type);
    }
}

class CommentEnumMember extends Node {
    remove() {
        removeChildrenWithFormatting({
            children: [this],
            getSiblingFormatting: () => FormattingKind.Newline,
        });
    }
}

const createBase$q = (ctor) => TextInsertableNode(NamespaceChildableNode(JSDocableNode(AmbientableNode(ExportableNode(ModifierableNode(NamedNode(ctor)))))));
const EnumDeclarationBase = createBase$q(Statement);
class EnumDeclaration extends EnumDeclarationBase {
    set(structure) {
        callBaseSet(EnumDeclarationBase.prototype, this, structure);
        if (structure.isConst != null)
            this.setIsConstEnum(structure.isConst);
        if (structure.members != null) {
            this.getMembers().forEach(m => m.remove());
            this.addMembers(structure.members);
        }
        return this;
    }
    addMember(structure) {
        return this.addMembers([structure])[0];
    }
    addMembers(structures) {
        return this.insertMembers(this.getMembers().length, structures);
    }
    insertMember(index, structure) {
        return this.insertMembers(index, [structure])[0];
    }
    insertMembers(index, structures) {
        if (structures.length === 0)
            return [];
        const members = this.getMembersWithComments();
        index = verifyAndGetIndex(index, members.length);
        const writer = this._getWriterWithChildIndentation();
        const structurePrinter = this._context.structurePrinterFactory.forEnumMember();
        structurePrinter.printTexts(writer, structures);
        insertIntoCommaSeparatedNodes({
            parent: this.getChildSyntaxListOrThrow(),
            currentNodes: members,
            insertIndex: index,
            newText: writer.toString(),
            useNewLines: true,
            useTrailingCommas: this._context.manipulationSettings.getUseTrailingCommas(),
        });
        return getNodesToReturn(members, this.getMembersWithComments(), index, !areAllStructuresStructures());
        function areAllStructuresStructures() {
            if (!(structures instanceof Array))
                return false;
            return structures.every(s => typeof s === "object");
        }
    }
    getMember(nameOrFindFunction) {
        return getNodeByNameOrFindFunction(this.getMembers(), nameOrFindFunction);
    }
    getMemberOrThrow(nameOrFindFunction) {
        return errors.throwIfNullOrUndefined(this.getMember(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("enum member", nameOrFindFunction));
    }
    getMembers() {
        return this.compilerNode.members.map(m => this._getNodeFromCompilerNode(m));
    }
    getMembersWithComments() {
        const compilerNode = this.compilerNode;
        return ExtendedParser.getContainerArray(compilerNode, this.getSourceFile().compilerNode)
            .map(m => this._getNodeFromCompilerNode(m));
    }
    setIsConstEnum(value) {
        return this.toggleModifier("const", value);
    }
    isConstEnum() {
        return this.getConstKeyword() != null;
    }
    getConstKeyword() {
        return this.getFirstModifierByKind(ts$1.SyntaxKind.ConstKeyword);
    }
    getStructure() {
        return callBaseGetStructure(EnumDeclarationBase.prototype, this, {
            kind: exports.StructureKind.Enum,
            isConst: this.isConstEnum(),
            members: this.getMembers().map(member => member.getStructure()),
        });
    }
}

const createBase$r = (ctor) => JSDocableNode(InitializerExpressionableNode(PropertyNamedNode(ctor)));
const EnumMemberBase = createBase$r(Node);
class EnumMember extends EnumMemberBase {
    getValue() {
        return this._context.typeChecker.getConstantValue(this);
    }
    setValue(value) {
        let text;
        if (typeof value === "string") {
            const quoteKind = this._context.manipulationSettings.getQuoteKind();
            text = quoteKind + StringUtils.escapeForWithinString(value, quoteKind) + quoteKind;
        }
        else {
            text = value.toString();
        }
        this.setInitializer(text);
        return this;
    }
    remove() {
        const childrenToRemove = [this];
        const commaToken = this.getNextSiblingIfKind(ts$1.SyntaxKind.CommaToken);
        if (commaToken != null)
            childrenToRemove.push(commaToken);
        removeChildrenWithFormatting({
            children: childrenToRemove,
            getSiblingFormatting: () => FormattingKind.Newline,
        });
    }
    set(structure) {
        callBaseSet(EnumMemberBase.prototype, this, structure);
        if (structure.value != null)
            this.setValue(structure.value);
        else if (structure.hasOwnProperty("value") && structure.initializer == null)
            this.removeInitializer();
        return this;
    }
    getStructure() {
        return callBaseGetStructure(EnumMemberBase.prototype, this, {
            kind: exports.StructureKind.EnumMember,
            value: undefined,
        });
    }
}

class HeritageClause extends Node {
    getTypeNodes() {
        var _a, _b;
        return (_b = (_a = this.compilerNode.types) === null || _a === void 0 ? void 0 : _a.map(t => this._getNodeFromCompilerNode(t))) !== null && _b !== void 0 ? _b : [];
    }
    getToken() {
        return this.compilerNode.token;
    }
    removeExpression(expressionNodeOrIndex) {
        const expressions = this.getTypeNodes();
        const expressionNodeToRemove = typeof expressionNodeOrIndex === "number" ? getExpressionFromIndex(expressionNodeOrIndex) : expressionNodeOrIndex;
        if (expressions.length === 1) {
            const heritageClauses = this.getParentSyntaxListOrThrow().getChildren();
            if (heritageClauses.length === 1)
                removeChildren({ children: [heritageClauses[0].getParentSyntaxListOrThrow()], removePrecedingSpaces: true });
            else
                removeChildren({ children: [this], removePrecedingSpaces: true });
        }
        else {
            removeCommaSeparatedChild(expressionNodeToRemove);
        }
        return this;
        function getExpressionFromIndex(index) {
            return expressions[verifyAndGetIndex(index, expressions.length - 1)];
        }
    }
}

class TypeElement extends Node {
    remove() {
        removeInterfaceMember(this);
    }
}

const createBase$s = (ctor) => TypeParameteredNode(ChildOrderableNode(JSDocableNode(SignaturedDeclaration(ctor))));
const CallSignatureDeclarationBase = createBase$s(TypeElement);
class CallSignatureDeclaration extends CallSignatureDeclarationBase {
    set(structure) {
        callBaseSet(CallSignatureDeclarationBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(CallSignatureDeclarationBase.prototype, this, {
            kind: exports.StructureKind.CallSignature,
        });
    }
}

class CommentTypeElement extends TypeElement {
}

const createBase$t = (ctor) => TypeParameteredNode(ChildOrderableNode(JSDocableNode(SignaturedDeclaration(ctor))));
const ConstructSignatureDeclarationBase = createBase$t(TypeElement);
class ConstructSignatureDeclaration extends ConstructSignatureDeclarationBase {
    set(structure) {
        callBaseSet(ConstructSignatureDeclarationBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(ConstructSignatureDeclarationBase.prototype, this, {
            kind: exports.StructureKind.ConstructSignature,
        });
    }
}

const createBase$u = (ctor) => ReturnTypedNode(ChildOrderableNode(JSDocableNode(ReadonlyableNode(ModifierableNode(ctor)))));
const IndexSignatureDeclarationBase = createBase$u(TypeElement);
class IndexSignatureDeclaration extends IndexSignatureDeclarationBase {
    getKeyName() {
        return this.getKeyNameNode().getText();
    }
    setKeyName(name) {
        errors.throwIfWhitespaceOrNotString(name, "name");
        if (this.getKeyName() === name)
            return;
        this.getKeyNameNode().replaceWithText(name, this._getWriterWithQueuedChildIndentation());
    }
    getKeyNameNode() {
        const param = this.compilerNode.parameters[0];
        return this._getNodeFromCompilerNode(param.name);
    }
    getKeyType() {
        return this.getKeyNameNode().getType();
    }
    setKeyType(type) {
        errors.throwIfWhitespaceOrNotString(type, "type");
        const keyTypeNode = this.getKeyTypeNode();
        if (keyTypeNode.getText() === type)
            return this;
        keyTypeNode.replaceWithText(type, this._getWriterWithQueuedChildIndentation());
        return this;
    }
    getKeyTypeNode() {
        const param = this.compilerNode.parameters[0];
        return this._getNodeFromCompilerNode(param.type);
    }
    set(structure) {
        callBaseSet(IndexSignatureDeclarationBase.prototype, this, structure);
        if (structure.keyName != null)
            this.setKeyName(structure.keyName);
        if (structure.keyType != null)
            this.setKeyType(structure.keyType);
        return this;
    }
    getStructure() {
        const keyTypeNode = this.getKeyTypeNode();
        return callBaseGetStructure(IndexSignatureDeclarationBase.prototype, this, {
            kind: exports.StructureKind.IndexSignature,
            keyName: this.getKeyName(),
            keyType: keyTypeNode.getText(),
        });
    }
}

const createBase$v = (ctor) => TypeElementMemberedNode(TextInsertableNode(ExtendsClauseableNode(HeritageClauseableNode(TypeParameteredNode(JSDocableNode(AmbientableNode(NamespaceChildableNode(ExportableNode(ModifierableNode(NamedNode(ctor)))))))))));
const InterfaceDeclarationBase = createBase$v(Statement);
class InterfaceDeclaration extends InterfaceDeclarationBase {
    getBaseTypes() {
        return this.getType().getBaseTypes();
    }
    getBaseDeclarations() {
        return ArrayUtils.flatten(this.getType().getBaseTypes().map(t => {
            var _a, _b;
            return (_b = (_a = t.getSymbol()) === null || _a === void 0 ? void 0 : _a.getDeclarations()) !== null && _b !== void 0 ? _b : [];
        }));
    }
    getImplementations() {
        return this.getNameNode().getImplementations();
    }
    set(structure) {
        callBaseSet(InterfaceDeclarationBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(InterfaceDeclarationBase.prototype, this, {
            kind: exports.StructureKind.Interface,
        });
    }
}

const createBase$w = (ctor) => ChildOrderableNode(JSDocableNode(QuestionTokenableNode(TypeParameteredNode(SignaturedDeclaration(PropertyNamedNode(ctor))))));
const MethodSignatureBase = createBase$w(TypeElement);
class MethodSignature extends MethodSignatureBase {
    set(structure) {
        callBaseSet(MethodSignatureBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(MethodSignatureBase.prototype, this, {
            kind: exports.StructureKind.MethodSignature,
        });
    }
}

const createBase$x = (ctor) => ChildOrderableNode(JSDocableNode(ReadonlyableNode(QuestionTokenableNode(InitializerExpressionableNode(TypedNode(PropertyNamedNode(ModifierableNode(ctor))))))));
const PropertySignatureBase = createBase$x(TypeElement);
class PropertySignature extends PropertySignatureBase {
    set(structure) {
        callBaseSet(PropertySignatureBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(PropertySignatureBase.prototype, this, {
            kind: exports.StructureKind.PropertySignature,
        });
    }
}

function JsxAttributedNode(Base) {
    return class extends Base {
        getAttributes() {
            return this.compilerNode.attributes.properties.map(p => this._getNodeFromCompilerNode(p));
        }
        getAttributeOrThrow(nameOrFindFunction) {
            return errors.throwIfNullOrUndefined(this.getAttribute(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("attribute", nameOrFindFunction));
        }
        getAttribute(nameOrFindFunction) {
            return getNodeByNameOrFindFunction(this.getAttributes(), nameOrFindFunction);
        }
        addAttribute(structure) {
            return this.addAttributes([structure])[0];
        }
        addAttributes(structures) {
            return this.insertAttributes(this.compilerNode.attributes.properties.length, structures);
        }
        insertAttribute(index, structure) {
            return this.insertAttributes(index, [structure])[0];
        }
        insertAttributes(index, structures) {
            if (structures.length === 0)
                return [];
            const originalChildrenCount = this.compilerNode.attributes.properties.length;
            index = verifyAndGetIndex(index, originalChildrenCount);
            const insertPos = index === 0 ? this.getTagNameNode().getEnd() : this.getAttributes()[index - 1].getEnd();
            const writer = this._getWriterWithQueuedChildIndentation();
            const structuresPrinter = new SpaceFormattingStructuresPrinter(this._context.structurePrinterFactory.forJsxAttributeDecider());
            structuresPrinter.printText(writer, structures);
            insertIntoParentTextRange({
                insertPos,
                newText: " " + writer.toString(),
                parent: this.getNodeProperty("attributes").getFirstChildByKindOrThrow(ts$1.SyntaxKind.SyntaxList),
            });
            return getNodesToReturn(originalChildrenCount, this.getAttributes(), index, false);
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.attributes != null) {
                this.getAttributes().forEach(a => a.remove());
                this.addAttributes(structure.attributes);
            }
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                attributes: this.getAttributes().map(a => a.getStructure()),
            });
        }
    };
}

function JsxTagNamedNode(Base) {
    return class extends Base {
        getTagNameNode() {
            return this._getNodeFromCompilerNode(this.compilerNode.tagName);
        }
        set(structure) {
            callBaseSet(Base.prototype, this, structure);
            if (structure.name != null)
                this.getTagNameNode().replaceWithText(structure.name);
            return this;
        }
        getStructure() {
            return callBaseGetStructure(Base.prototype, this, {
                name: this.getTagNameNode().getText(),
            });
        }
    };
}

const JsxAttributeBase = NamedNode(Node);
class JsxAttribute extends JsxAttributeBase {
    getInitializerOrThrow() {
        return errors.throwIfNullOrUndefined(this.getInitializer(), `Expected to find an initializer for the JSX attribute '${this.getName()}'`);
    }
    getInitializer() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.initializer);
    }
    setInitializer(textOrWriterFunction) {
        const text = getTextFromStringOrWriter(this._getWriterWithQueuedIndentation(), textOrWriterFunction);
        if (StringUtils.isNullOrWhitespace(text)) {
            this.removeInitializer();
            return this;
        }
        const initializer = this.getInitializer();
        if (initializer != null) {
            initializer.replaceWithText(text);
            return this;
        }
        insertIntoParentTextRange({
            insertPos: this.getNameNode().getEnd(),
            parent: this,
            newText: `=${text}`,
        });
        return this;
    }
    removeInitializer() {
        const initializer = this.getInitializer();
        if (initializer == null)
            return this;
        removeChildren({
            children: [initializer.getPreviousSiblingIfKindOrThrow(ts$1.SyntaxKind.EqualsToken), initializer],
            removePrecedingSpaces: true,
            removePrecedingNewLines: true,
        });
        return this;
    }
    remove() {
        removeChildren({
            children: [this],
            removePrecedingNewLines: true,
            removePrecedingSpaces: true,
        });
    }
    set(structure) {
        callBaseSet(JsxAttributeBase.prototype, this, structure);
        if (structure.initializer != null)
            this.setInitializer(structure.initializer);
        else if (structure.hasOwnProperty("initializer"))
            this.removeInitializer();
        return this;
    }
    getStructure() {
        const initializer = this.getInitializer();
        return callBaseGetStructure(JsxAttributeBase.prototype, this, {
            kind: exports.StructureKind.JsxAttribute,
            initializer: initializer === null || initializer === void 0 ? void 0 : initializer.getText(),
        });
    }
}

const createBase$y = (ctor) => JsxTagNamedNode(ctor);
const JsxClosingElementBase = createBase$y(Node);
class JsxClosingElement extends JsxClosingElementBase {
}

class JsxClosingFragment extends Expression {
}

const JsxElementBase = PrimaryExpression;
class JsxElement extends JsxElementBase {
    getJsxChildren() {
        return this.compilerNode.children.map(c => this._getNodeFromCompilerNode(c));
    }
    getOpeningElement() {
        return this._getNodeFromCompilerNode(this.compilerNode.openingElement);
    }
    getClosingElement() {
        return this._getNodeFromCompilerNode(this.compilerNode.closingElement);
    }
    setBodyText(textOrWriterFunction) {
        const newText = getBodyText(this._getWriterWithIndentation(), textOrWriterFunction);
        setText(this, newText);
        return this;
    }
    setBodyTextInline(textOrWriterFunction) {
        const writer = this._getWriterWithQueuedChildIndentation();
        printTextFromStringOrWriter(writer, textOrWriterFunction);
        if (writer.isLastNewLine()) {
            writer.setIndentationLevel(Math.max(0, this.getIndentationLevel() - 1));
            writer.write("");
        }
        setText(this, writer.toString());
        return this;
    }
    set(structure) {
        callBaseSet(JsxElementBase.prototype, this, structure);
        if (structure.attributes != null) {
            const openingElement = this.getOpeningElement();
            openingElement.getAttributes().forEach(a => a.remove());
            openingElement.addAttributes(structure.attributes);
        }
        if (structure.children != null)
            throw new errors.NotImplementedError("Setting JSX children is currently not implemented. Please open an issue if you need this.");
        if (structure.bodyText != null)
            this.setBodyText(structure.bodyText);
        else if (structure.hasOwnProperty("bodyText"))
            this.setBodyTextInline("");
        if (structure.name != null) {
            this.getOpeningElement().getTagNameNode().replaceWithText(structure.name);
            this.getClosingElement().getTagNameNode().replaceWithText(structure.name);
        }
        return this;
    }
    getStructure() {
        const openingElement = this.getOpeningElement();
        const structure = callBaseGetStructure(JsxElementBase.prototype, this, {
            kind: exports.StructureKind.JsxElement,
            name: openingElement.getTagNameNode().getText(),
            attributes: openingElement.getAttributes().map(a => a.getStructure()),
            children: undefined,
            bodyText: getBodyTextWithoutLeadingIndentation(this),
        });
        delete structure.children;
        return structure;
    }
}
function setText(element, newText) {
    const openingElement = element.getOpeningElement();
    const closingElement = element.getClosingElement();
    insertIntoParentTextRange({
        insertPos: openingElement.getEnd(),
        newText,
        parent: element.getChildSyntaxListOrThrow(),
        replacing: {
            textLength: closingElement.getStart() - openingElement.getEnd(),
        },
    });
}

class JsxExpression extends Expression {
    getDotDotDotTokenOrThrow() {
        return errors.throwIfNullOrUndefined(this.getDotDotDotToken(), "Expected to find a dot dot dot token for the JSX expression.");
    }
    getDotDotDotToken() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.dotDotDotToken);
    }
    getExpressionOrThrow() {
        return errors.throwIfNullOrUndefined(this.getExpression(), "Expected to find an expression for the JSX expression.");
    }
    getExpression() {
        return this._getNodeFromCompilerNodeIfExists(this.compilerNode.expression);
    }
}

class JsxFragment extends PrimaryExpression {
    getJsxChildren() {
        return this.compilerNode.children.map(c => this._getNodeFromCompilerNode(c));
    }
    getOpeningFragment() {
        return this._getNodeFromCompilerNode(this.compilerNode.openingFragment);
    }
    getClosingFragment() {
        return this._getNodeFromCompilerNode(this.compilerNode.closingFragment);
    }
}

const createBase$z = (ctor) => JsxAttributedNode(JsxTagNamedNode(ctor));
const JsxOpeningElementBase = createBase$z(Expression);
class JsxOpeningElement extends JsxOpeningElementBase {
}

class JsxOpeningFragment extends Expression {
}

const createBase$A = (ctor) => JsxAttributedNode(JsxTagNamedNode(ctor));
const JsxSelfClosingElementBase = createBase$A(PrimaryExpression);
class JsxSelfClosingElement extends JsxSelfClosingElementBase {
    set(structure) {
        callBaseSet(JsxSelfClosingElementBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(JsxSelfClosingElementBase.prototype, this, {
            kind: exports.StructureKind.JsxSelfClosingElement,
        });
    }
}

const JsxSpreadAttributeBase = Node;
class JsxSpreadAttribute extends JsxSpreadAttributeBase {
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
    setExpression(textOrWriterFunction) {
        this.getExpression().replaceWithText(textOrWriterFunction);
        return this;
    }
    remove() {
        removeChildren({
            children: [this],
            removePrecedingNewLines: true,
            removePrecedingSpaces: true,
        });
    }
    set(structure) {
        callBaseSet(JsxSpreadAttributeBase.prototype, this, structure);
        if (structure.expression != null)
            this.setExpression(structure.expression);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(JsxSpreadAttributeBase.prototype, this, {
            kind: exports.StructureKind.JsxSpreadAttribute,
            expression: this.getExpression().getText(),
        });
    }
}

const JsxTextBase = LiteralLikeNode(Node);
class JsxText extends JsxTextBase {
    containsOnlyTriviaWhiteSpaces() {
        const oldCompilerNode = this.compilerNode;
        if (typeof oldCompilerNode.containsOnlyWhiteSpaces === "boolean")
            return oldCompilerNode.containsOnlyWhiteSpaces;
        return this.compilerNode.containsOnlyTriviaWhiteSpaces;
    }
}

const BigIntLiteralBase = LiteralExpression;
class BigIntLiteral extends BigIntLiteralBase {
    getLiteralValue() {
        const text = this.compilerNode.text;
        if (typeof BigInt === "undefined")
            throw new errors.InvalidOperationError("Runtime environment does not support BigInts. Perhaps work with the text instead?");
        const textWithoutN = text.substring(0, text.length - 1);
        return BigInt(textWithoutN);
    }
    setLiteralValue(value) {
        if (typeof value !== "bigint")
            throw new errors.ArgumentTypeError("value", "bigint", typeof value);
        replaceNodeText({
            sourceFile: this._sourceFile,
            start: this.getStart(),
            replacingLength: this.getWidth(),
            newText: value.toString() + "n",
        });
        return this;
    }
}

const BooleanLiteralBase = PrimaryExpression;
class BooleanLiteral extends BooleanLiteralBase {
    getLiteralValue() {
        return this.getKind() === ts$1.SyntaxKind.TrueKeyword;
    }
    setLiteralValue(value) {
        if (this.getLiteralValue() === value)
            return this;
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        const index = this.getChildIndex();
        this.replaceWithText(value ? "true" : "false");
        return parent.getChildAtIndex(index);
    }
}

const NullLiteralBase = PrimaryExpression;
class NullLiteral extends NullLiteralBase {
}

const NumericLiteralBase = LiteralExpression;
class NumericLiteral extends NumericLiteralBase {
    getLiteralValue() {
        const text = this.compilerNode.text;
        if (text.indexOf(".") >= 0)
            return parseFloat(text);
        return parseInt(text, 10);
    }
    setLiteralValue(value) {
        replaceNodeText({
            sourceFile: this._sourceFile,
            start: this.getStart(),
            replacingLength: this.getWidth(),
            newText: value.toString(10),
        });
        return this;
    }
}

(function(QuoteKind) {
    QuoteKind["Single"] = "'";
    QuoteKind["Double"] = "\"";
})(exports.QuoteKind || (exports.QuoteKind = {}));

const RegularExpressionLiteralBase = LiteralExpression;
class RegularExpressionLiteral extends RegularExpressionLiteralBase {
    getLiteralValue() {
        const pattern = /^\/(.*)\/([^\/]*)$/;
        const text = this.compilerNode.text;
        const matches = pattern.exec(text);
        return new RegExp(matches[1], matches[2]);
    }
    setLiteralValue(regExpOrPattern, flags) {
        let pattern;
        if (typeof regExpOrPattern === "string")
            pattern = regExpOrPattern;
        else {
            pattern = regExpOrPattern.source;
            flags = regExpOrPattern.flags;
        }
        replaceNodeText({
            sourceFile: this._sourceFile,
            start: this.getStart(),
            replacingLength: this.getWidth(),
            newText: `/${pattern}/${flags || ""}`,
        });
        return this;
    }
}

const StringLiteralBase = LiteralExpression;
class StringLiteral extends StringLiteralBase {
    getLiteralValue() {
        return this.compilerNode.text;
    }
    setLiteralValue(value) {
        replaceNodeText({
            sourceFile: this._sourceFile,
            start: this.getStart() + 1,
            replacingLength: this.getWidth() - 2,
            newText: StringUtils.escapeForWithinString(value, this.getQuoteKind()),
        });
        return this;
    }
    getQuoteKind() {
        return this.getText()[0] === "'" ? exports.QuoteKind.Single : exports.QuoteKind.Double;
    }
}

const NoSubstitutionTemplateLiteralBase = LiteralExpression;
class NoSubstitutionTemplateLiteral extends NoSubstitutionTemplateLiteralBase {
    getLiteralValue() {
        return this.compilerNode.text;
    }
    setLiteralValue(value) {
        const childIndex = this.getChildIndex();
        const parent = this.getParentSyntaxList() || this.getParentOrThrow();
        replaceNodeText({
            sourceFile: this._sourceFile,
            start: this.getStart() + 1,
            replacingLength: this.getWidth() - 2,
            newText: value,
        });
        return parent.getChildAtIndex(childIndex);
    }
}

class TaggedTemplateExpression extends MemberExpression {
    getTag() {
        return this._getNodeFromCompilerNode(this.compilerNode.tag);
    }
    getTemplate() {
        return this._getNodeFromCompilerNode(this.compilerNode.template);
    }
    removeTag() {
        var _a;
        const parent = (_a = this.getParentSyntaxList()) !== null && _a !== void 0 ? _a : this.getParentOrThrow();
        const index = this.getChildIndex();
        const template = this.getTemplate();
        insertIntoParentTextRange({
            customMappings: (newParent, newSourceFile) => [{ currentNode: template, newNode: newParent.getChildren(newSourceFile)[index] }],
            parent,
            insertPos: this.getStart(),
            newText: this.getTemplate().getText(),
            replacing: {
                textLength: this.getWidth(),
                nodes: [this],
            },
        });
        return parent.getChildAtIndex(index);
    }
}

const TemplateExpressionBase = PrimaryExpression;
class TemplateExpression extends TemplateExpressionBase {
    getHead() {
        return this._getNodeFromCompilerNode(this.compilerNode.head);
    }
    getTemplateSpans() {
        return this.compilerNode.templateSpans.map(s => this._getNodeFromCompilerNode(s));
    }
    setLiteralValue(value) {
        var _a;
        const childIndex = this.getChildIndex();
        const parent = (_a = this.getParentSyntaxList()) !== null && _a !== void 0 ? _a : this.getParentOrThrow();
        replaceNodeText({
            sourceFile: this._sourceFile,
            start: this.getStart() + 1,
            replacingLength: this.getWidth() - 2,
            newText: value,
        });
        return parent.getChildAtIndex(childIndex);
    }
}

const TemplateHeadBase = LiteralLikeNode(Node);
class TemplateHead extends TemplateHeadBase {
}

const TemplateMiddleBase = LiteralLikeNode(Node);
class TemplateMiddle extends TemplateMiddleBase {
}

const TemplateSpanBase = ExpressionedNode(Node);
class TemplateSpan extends TemplateSpanBase {
    getLiteral() {
        return this._getNodeFromCompilerNode(this.compilerNode.literal);
    }
}

const TemplateTailBase = LiteralLikeNode(Node);
class TemplateTail extends TemplateTailBase {
}

function CommonIdentifierBase(Base) {
    return class extends Base {
        getText() {
            return this.compilerNode.text;
        }
        getDefinitionNodes() {
            return this.getDefinitions().map(d => d.getDeclarationNode()).filter(d => d != null);
        }
        getDefinitions() {
            return this._context.languageService.getDefinitions(this);
        }
    };
}

class ComputedPropertyName extends Node {
    getExpression() {
        return this._getNodeFromCompilerNode(this.compilerNode.expression);
    }
}

const IdentifierBase = CommonIdentifierBase(ReferenceFindableNode(RenameableNode(PrimaryExpression)));
class Identifier extends IdentifierBase {
    getImplementations() {
        return this._context.languageService.getImplementations(this);
    }
}

const PrivateIdentifierBase = CommonIdentifierBase(ReferenceFindableNode(RenameableNode(Node)));
class PrivateIdentifier extends PrivateIdentifierBase {
}

class QualifiedName extends Node {
    getLeft() {
        return this._getNodeFromCompilerNode(this.compilerNode.left);
    }
    getRight() {
        return this._getNodeFromCompilerNode(this.compilerNode.right);
    }
}

const createBase$B = (ctor) => ExportGetableNode(ExclamationTokenableNode(TypedNode(InitializerExpressionableNode(BindingNamedNode(ctor)))));
const VariableDeclarationBase = createBase$B(Node);
class VariableDeclaration extends VariableDeclarationBase {
    remove() {
        const parent = this.getParentOrThrow();
        switch (parent.getKind()) {
            case ts$1.SyntaxKind.VariableDeclarationList:
                removeFromDeclarationList(this);
                break;
            case ts$1.SyntaxKind.CatchClause:
                removeFromCatchClause(this);
                break;
            default:
                throw new errors.NotImplementedError(`Not implemented for syntax kind: ${parent.getKindName()}`);
        }
        function removeFromDeclarationList(node) {
            const variableStatement = parent.getParentIfKindOrThrow(ts$1.SyntaxKind.VariableStatement);
            const declarations = variableStatement.getDeclarations();
            if (declarations.length === 1)
                variableStatement.remove();
            else
                removeCommaSeparatedChild(node);
        }
        function removeFromCatchClause(node) {
            removeChildren({
                children: [
                    node.getPreviousSiblingIfKindOrThrow(ts$1.SyntaxKind.OpenParenToken),
                    node,
                    node.getNextSiblingIfKindOrThrow(ts$1.SyntaxKind.CloseParenToken),
                ],
                removePrecedingSpaces: true,
            });
        }
    }
    getVariableStatementOrThrow() {
        return errors.throwIfNullOrUndefined(this.getVariableStatement(), "Expected the grandparent to be a variable statement.");
    }
    getVariableStatement() {
        const grandParent = this.getParentOrThrow().getParentOrThrow();
        return Node.isVariableStatement(grandParent) ? grandParent : undefined;
    }
    set(structure) {
        callBaseSet(VariableDeclarationBase.prototype, this, structure);
        return this;
    }
    getStructure() {
        return callBaseGetStructure(VariableDeclarationBase.prototype, this, {
            kind: exports.StructureKind.VariableDeclaration,
        });
    }
}

const VariableDeclarationListBase = ModifierableNode(Node);
class VariableDeclarationList extends VariableDeclarationListBase {
    getDeclarations() {
        return this.compilerNode.declarations.map(d => this._getNodeFromCompilerNode(d));
    }
    getDeclarationKind() {
        const nodeFlags = this.compilerNode.flags;
        if (nodeFlags & ts$1.NodeFlags.Let)
            return exports.VariableDeclarationKind.Let;
        else if (nodeFlags & ts$1.NodeFlags.Const)
            return exports.VariableDeclarationKind.Const;
        else
            return exports.VariableDeclarationKind.Var;
    }
    getDeclarationKindKeyword() {
        const declarationKind = this.getDeclarationKind();
        switch (declarationKind) {
            case exports.VariableDeclarationKind.Const:
                return this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.ConstKeyword);
            case exports.VariableDeclarationKind.Let:
                return this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.LetKeyword);
            case exports.VariableDeclarationKind.Var:
                return this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.VarKeyword);
            default:
                return errors.throwNotImplementedForNeverValueError(declarationKind);
        }
    }
    setDeclarationKind(type) {
        if (this.getDeclarationKind() === type)
            return this;
        const keyword = this.getDeclarationKindKeyword();
        insertIntoParentTextRange({
            insertPos: keyword.getStart(),
            newText: type,
            parent: this,
            replacing: {
                textLength: keyword.getWidth(),
            },
        });
        return this;
    }
    addDeclaration(structure) {
        return this.addDeclarations([structure])[0];
    }
    addDeclarations(structures) {
        return this.insertDeclarations(this.getDeclarations().length, structures);
    }
    insertDeclaration(index, structure) {
        return this.insertDeclarations(index, [structure])[0];
    }
    insertDeclarations(index, structures) {
        const writer = this._getWriterWithQueuedChildIndentation();
        const structurePrinter = new CommaSeparatedStructuresPrinter(this._context.structurePrinterFactory.forVariableDeclaration());
        const originalChildrenCount = this.compilerNode.declarations.length;
        index = verifyAndGetIndex(index, originalChildrenCount);
        structurePrinter.printText(writer, structures);
        insertIntoCommaSeparatedNodes({
            parent: this.getFirstChildByKindOrThrow(ts$1.SyntaxKind.SyntaxList),
            currentNodes: this.getDeclarations(),
            insertIndex: index,
            newText: writer.toString(),
            useTrailingCommas: false,
        });
        return getNodesToReturn(originalChildrenCount, this.getDeclarations(), index, false);
    }
}

class Signature {
    constructor(context, signature) {
        this._context = context;
        this._compilerSignature = signature;
    }
    get compilerSignature() {
        return this._compilerSignature;
    }
    getTypeParameters() {
        const typeParameters = this.compilerSignature.typeParameters || [];
        return typeParameters.map(t => this._context.compilerFactory.getTypeParameter(t));
    }
    getParameters() {
        return this.compilerSignature.parameters.map(p => this._context.compilerFactory.getSymbol(p));
    }
    getReturnType() {
        return this._context.compilerFactory.getType(this.compilerSignature.getReturnType());
    }
    getDocumentationComments() {
        const docs = this.compilerSignature.getDocumentationComment(this._context.typeChecker.compilerObject);
        return docs.map(d => this._context.compilerFactory.getSymbolDisplayPart(d));
    }
    getJsDocTags() {
        const tags = this.compilerSignature.getJsDocTags();
        return tags.map(t => this._context.compilerFactory.getJSDocTagInfo(t));
    }
    getDeclaration() {
        const { compilerFactory } = this._context;
        const compilerSignatureDeclaration = this.compilerSignature.getDeclaration();
        return compilerFactory.getNodeFromCompilerNode(compilerSignatureDeclaration, compilerFactory.getSourceFileForNode(compilerSignatureDeclaration));
    }
}

class Symbol$1 {
    constructor(context, symbol) {
        this._context = context;
        this._compilerSymbol = symbol;
        this.getValueDeclaration();
        this.getDeclarations();
    }
    get compilerSymbol() {
        return this._compilerSymbol;
    }
    getName() {
        return this.compilerSymbol.getName();
    }
    getEscapedName() {
        return this.compilerSymbol.getEscapedName();
    }
    getAliasedSymbolOrThrow() {
        return errors.throwIfNullOrUndefined(this.getAliasedSymbol(), "Expected to find an aliased symbol.");
    }
    getAliasedSymbol() {
        return this._context.typeChecker.getAliasedSymbol(this);
    }
    getExportSymbol() {
        return this._context.typeChecker.getExportSymbolOfSymbol(this);
    }
    isAlias() {
        return (this.getFlags() & common.SymbolFlags.Alias) === common.SymbolFlags.Alias;
    }
    getFlags() {
        return this.compilerSymbol.getFlags();
    }
    hasFlags(flags) {
        return (this.compilerSymbol.flags & flags) === flags;
    }
    getValueDeclarationOrThrow() {
        return errors.throwIfNullOrUndefined(this.getValueDeclaration(), () => `Expected to find the value declaration of symbol '${this.getName()}'.`);
    }
    getValueDeclaration() {
        const declaration = this.compilerSymbol.valueDeclaration;
        if (declaration == null)
            return undefined;
        return this._context.compilerFactory.getNodeFromCompilerNode(declaration, this._context.compilerFactory.getSourceFileForNode(declaration));
    }
    getDeclarations() {
        return (this.compilerSymbol.declarations || [])
            .map(d => this._context.compilerFactory.getNodeFromCompilerNode(d, this._context.compilerFactory.getSourceFileForNode(d)));
    }
    getExportOrThrow(name) {
        return errors.throwIfNullOrUndefined(this.getExport(name), `Expected to find export with name: ${name}`);
    }
    getExport(name) {
        if (this.compilerSymbol.exports == null)
            return undefined;
        const tsSymbol = this.compilerSymbol.exports.get(ts$1.escapeLeadingUnderscores(name));
        return tsSymbol == null ? undefined : this._context.compilerFactory.getSymbol(tsSymbol);
    }
    getExports() {
        if (this.compilerSymbol.exports == null)
            return [];
        return ArrayUtils.from(this.compilerSymbol.exports.values()).map(symbol => this._context.compilerFactory.getSymbol(symbol));
    }
    getGlobalExportOrThrow(name) {
        return errors.throwIfNullOrUndefined(this.getGlobalExport(name), `Expected to find global export with name: ${name}`);
    }
    getGlobalExport(name) {
        if (this.compilerSymbol.globalExports == null)
            return undefined;
        const tsSymbol = this.compilerSymbol.globalExports.get(ts$1.escapeLeadingUnderscores(name));
        return tsSymbol == null ? undefined : this._context.compilerFactory.getSymbol(tsSymbol);
    }
    getGlobalExports() {
        if (this.compilerSymbol.globalExports == null)
            return [];
        return ArrayUtils.from(this.compilerSymbol.globalExports.values()).map(symbol => this._context.compilerFactory.getSymbol(symbol));
    }
    getMemberOrThrow(name) {
        return errors.throwIfNullOrUndefined(this.getMember(name), `Expected to find member with name: ${name}`);
    }
    getMember(name) {
        if (this.compilerSymbol.members == null)
            return undefined;
        const tsSymbol = this.compilerSymbol.members.get(ts$1.escapeLeadingUnderscores(name));
        return tsSymbol == null ? undefined : this._context.compilerFactory.getSymbol(tsSymbol);
    }
    getMembers() {
        if (this.compilerSymbol.members == null)
            return [];
        return ArrayUtils.from(this.compilerSymbol.members.values()).map(symbol => this._context.compilerFactory.getSymbol(symbol));
    }
    getDeclaredType() {
        return this._context.typeChecker.getDeclaredTypeOfSymbol(this);
    }
    getTypeAtLocation(node) {
        return this._context.typeChecker.getTypeOfSymbolAtLocation(this, node);
    }
    getFullyQualifiedName() {
        return this._context.typeChecker.getFullyQualifiedName(this);
    }
}

class TextSpan {
    constructor(compilerObject) {
        this._compilerObject = compilerObject;
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getStart() {
        return this.compilerObject.start;
    }
    getEnd() {
        return this.compilerObject.start + this.compilerObject.length;
    }
    getLength() {
        return this.compilerObject.length;
    }
}

class TextChange {
    constructor(compilerObject) {
        this._compilerObject = compilerObject;
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getSpan() {
        return new TextSpan(this.compilerObject.span);
    }
    getNewText() {
        return this.compilerObject.newText;
    }
}
__decorate$1([
    Memoize
], TextChange.prototype, "getSpan", null);

class FileTextChanges {
    constructor(context, compilerObject) {
        this._context = context;
        this._compilerObject = compilerObject;
        const file = context.compilerFactory
            .getSourceFileFromCacheFromFilePath(context.fileSystemWrapper.getStandardizedAbsolutePath(compilerObject.fileName));
        this._existingFileExists = file != null;
        if (!compilerObject.isNewFile)
            this._sourceFile = file;
    }
    getFilePath() {
        return this._compilerObject.fileName;
    }
    getSourceFile() {
        return this._sourceFile;
    }
    getTextChanges() {
        return this._compilerObject.textChanges.map(c => new TextChange(c));
    }
    applyChanges(options = {}) {
        if (this._isApplied)
            return;
        if (this.isNewFile() && this._existingFileExists && !options.overwrite) {
            throw new errors.InvalidOperationError(`Cannot apply file text change for creating a new file when the `
                + `file exists at path ${this.getFilePath()}. Did you mean to provide the overwrite option?`);
        }
        let file;
        if (this.isNewFile())
            file = this._context.project.createSourceFile(this.getFilePath(), "", { overwrite: options.overwrite });
        else
            file = this.getSourceFile();
        if (file == null) {
            throw new errors.InvalidOperationError(`Cannot apply file text change to modify existing file `
                + `that doesn't exist at path: ${this.getFilePath()}`);
        }
        file.applyTextChanges(this.getTextChanges());
        this._isApplied = true;
        return this;
    }
    isNewFile() {
        return !!this._compilerObject.isNewFile;
    }
}
__decorate$1([
    Memoize
], FileTextChanges.prototype, "getTextChanges", null);

class CodeAction {
    constructor(context, compilerObject) {
        this._context = context;
        this._compilerObject = compilerObject;
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getDescription() {
        return this.compilerObject.description;
    }
    getChanges() {
        return this.compilerObject.changes.map(change => new FileTextChanges(this._context, change));
    }
}

class CombinedCodeActions {
    constructor(context, compilerObject) {
        this._context = context;
        this._compilerObject = compilerObject;
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getChanges() {
        return this.compilerObject.changes.map(change => new FileTextChanges(this._context, change));
    }
    applyChanges(options) {
        for (const change of this.getChanges())
            change.applyChanges(options);
        return this;
    }
}
__decorate$1([
    Memoize
], CombinedCodeActions.prototype, "getChanges", null);

class CodeFixAction extends CodeAction {
    getFixName() {
        return this.compilerObject.fixName;
    }
    getFixId() {
        return this.compilerObject.fixId;
    }
    getFixAllDescription() {
        return this.compilerObject.fixAllDescription;
    }
}

class DocumentSpan {
    constructor(context, compilerObject) {
        this._context = context;
        this._compilerObject = compilerObject;
        this._sourceFile = this._context.compilerFactory
            .getSourceFileFromCacheFromFilePath(context.fileSystemWrapper.getStandardizedAbsolutePath(this.compilerObject.fileName));
        this._sourceFile._doActionPreNextModification(() => this.getNode());
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getSourceFile() {
        return this._sourceFile;
    }
    getTextSpan() {
        return new TextSpan(this.compilerObject.textSpan);
    }
    getNode() {
        const textSpan = this.getTextSpan();
        const sourceFile = this.getSourceFile();
        const start = textSpan.getStart();
        const width = textSpan.getEnd();
        return findBestMatchingNode();
        function findBestMatchingNode() {
            let bestNode;
            sourceFile._context.compilerFactory.forgetNodesCreatedInBlock(remember => {
                let foundNode;
                let nextNode = sourceFile;
                while (nextNode != null) {
                    if (foundNode == null)
                        bestNode = nextNode;
                    if (nextNode.getStart() === start && nextNode.getWidth() === width)
                        bestNode = foundNode = nextNode;
                    else if (foundNode != null)
                        break;
                    nextNode = nextNode.getChildAtPos(start);
                }
                if (bestNode != null)
                    remember(bestNode);
            });
            return bestNode;
        }
    }
    getOriginalTextSpan() {
        const { originalTextSpan } = this.compilerObject;
        return originalTextSpan == null ? undefined : new TextSpan(originalTextSpan);
    }
    getOriginalFileName() {
        return this.compilerObject.originalFileName;
    }
}
__decorate$1([
    Memoize
], DocumentSpan.prototype, "getTextSpan", null);
__decorate$1([
    Memoize
], DocumentSpan.prototype, "getNode", null);
__decorate$1([
    Memoize
], DocumentSpan.prototype, "getOriginalTextSpan", null);

class DefinitionInfo extends DocumentSpan {
    constructor(context, compilerObject) {
        super(context, compilerObject);
        this.getSourceFile()._doActionPreNextModification(() => this.getDeclarationNode());
    }
    getKind() {
        return this.compilerObject.kind;
    }
    getName() {
        return this.compilerObject.name;
    }
    getContainerKind() {
        return this.compilerObject.containerKind;
    }
    getContainerName() {
        return this.compilerObject.containerName;
    }
    getDeclarationNode() {
        if (this.getKind() === "module" && this.getTextSpan().getLength() === this.getSourceFile().getFullWidth())
            return this.getSourceFile();
        const start = this.getTextSpan().getStart();
        const identifier = findIdentifier(this.getSourceFile());
        return identifier == null ? undefined : identifier.getParentOrThrow();
        function findIdentifier(node) {
            if (node.getKind() === ts$1.SyntaxKind.Identifier && node.getStart() === start)
                return node;
            for (const child of node._getChildrenIterator()) {
                if (child.getPos() <= start && child.getEnd() >= start)
                    return findIdentifier(child);
            }
            return undefined;
        }
    }
}
__decorate$1([
    Memoize
], DefinitionInfo.prototype, "getDeclarationNode", null);

class DiagnosticMessageChain {
    constructor(compilerObject) {
        this._compilerObject = compilerObject;
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getMessageText() {
        return this.compilerObject.messageText;
    }
    getNext() {
        const next = this.compilerObject.next;
        if (next == null)
            return undefined;
        if (next instanceof Array)
            return next.map(n => new DiagnosticMessageChain(n));
        return [new DiagnosticMessageChain(next)];
    }
    getCode() {
        return this.compilerObject.code;
    }
    getCategory() {
        return this.compilerObject.category;
    }
}

class Diagnostic {
    constructor(context, compilerObject) {
        this._context = context;
        this._compilerObject = compilerObject;
        this.getSourceFile();
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getSourceFile() {
        if (this._context == null)
            return undefined;
        const file = this.compilerObject.file;
        return file == null ? undefined : this._context.compilerFactory.getSourceFile(file, { markInProject: false });
    }
    getMessageText() {
        const messageText = this._compilerObject.messageText;
        if (typeof messageText === "string")
            return messageText;
        if (this._context == null)
            return new DiagnosticMessageChain(messageText);
        else
            return this._context.compilerFactory.getDiagnosticMessageChain(messageText);
    }
    getLineNumber() {
        const sourceFile = this.getSourceFile();
        const start = this.getStart();
        if (sourceFile == null || start == null)
            return undefined;
        return StringUtils.getLineNumberAtPos(sourceFile.getFullText(), start);
    }
    getStart() {
        return this.compilerObject.start;
    }
    getLength() {
        return this.compilerObject.length;
    }
    getCategory() {
        return this.compilerObject.category;
    }
    getCode() {
        return this.compilerObject.code;
    }
    getSource() {
        return this.compilerObject.source;
    }
}
__decorate$1([
    Memoize
], Diagnostic.prototype, "getSourceFile", null);

class DiagnosticWithLocation extends Diagnostic {
    constructor(context, compilerObject) {
        super(context, compilerObject);
    }
    getLineNumber() {
        return super.getLineNumber();
    }
    getStart() {
        return super.getStart();
    }
    getLength() {
        return super.getLength();
    }
    getSourceFile() {
        return super.getSourceFile();
    }
}

class OutputFile {
    constructor(context, compilerObject) {
        this._compilerObject = compilerObject;
        this._context = context;
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getFilePath() {
        return this._context.fileSystemWrapper.getStandardizedAbsolutePath(this.compilerObject.name);
    }
    getWriteByteOrderMark() {
        return this.compilerObject.writeByteOrderMark || false;
    }
    getText() {
        return this.compilerObject.text;
    }
}

class EmitOutput {
    constructor(context, compilerObject) {
        this._context = context;
        this._compilerObject = compilerObject;
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getEmitSkipped() {
        return this.compilerObject.emitSkipped;
    }
    getOutputFiles() {
        return this.compilerObject.outputFiles.map(f => new OutputFile(this._context, f));
    }
}
__decorate$1([
    Memoize
], EmitOutput.prototype, "getOutputFiles", null);

class EmitResult {
    constructor(context, compilerObject) {
        this._context = context;
        this._compilerObject = compilerObject;
        this.getDiagnostics();
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getEmitSkipped() {
        return this.compilerObject.emitSkipped;
    }
    getDiagnostics() {
        return this.compilerObject.diagnostics.map(d => this._context.compilerFactory.getDiagnostic(d));
    }
}
__decorate$1([
    Memoize
], EmitResult.prototype, "getDiagnostics", null);

class ImplementationLocation extends DocumentSpan {
    constructor(context, compilerObject) {
        super(context, compilerObject);
    }
    getKind() {
        return this.compilerObject.kind;
    }
    getDisplayParts() {
        return this.compilerObject.displayParts.map(p => this._context.compilerFactory.getSymbolDisplayPart(p));
    }
}
__decorate$1([
    Memoize
], ImplementationLocation.prototype, "getDisplayParts", null);

class MemoryEmitResult extends EmitResult {
    constructor(context, compilerObject, _files) {
        super(context, compilerObject);
        this._files = _files;
    }
    getFiles() {
        return this._files;
    }
    saveFiles() {
        const fileSystem = this._context.fileSystemWrapper;
        const promises = this._files.map(f => fileSystem.writeFile(f.filePath, f.writeByteOrderMark ? "\uFEFF" + f.text : f.text));
        return Promise.all(promises);
    }
    saveFilesSync() {
        const fileSystem = this._context.fileSystemWrapper;
        for (const file of this._files)
            fileSystem.writeFileSync(file.filePath, file.writeByteOrderMark ? "\uFEFF" + file.text : file.text);
    }
}

class RefactorEditInfo {
    constructor(context, compilerObject) {
        this._context = context;
        this._compilerObject = compilerObject;
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getEdits() {
        return this.compilerObject.edits.map(edit => new FileTextChanges(this._context, edit));
    }
    getRenameFilePath() {
        return this.compilerObject.renameFilename;
    }
    getRenameLocation() {
        return this.compilerObject.renameLocation;
    }
    applyChanges(options) {
        for (const change of this.getEdits())
            change.applyChanges(options);
        return this;
    }
}
__decorate$1([
    Memoize
], RefactorEditInfo.prototype, "getEdits", null);

class ReferencedSymbol {
    constructor(context, compilerObject) {
        this._context = context;
        this._compilerObject = compilerObject;
        this._references = this.compilerObject.references.map(r => context.compilerFactory.getReferenceEntry(r));
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getDefinition() {
        return this._context.compilerFactory.getReferencedSymbolDefinitionInfo(this.compilerObject.definition);
    }
    getReferences() {
        return this._references;
    }
}
__decorate$1([
    Memoize
], ReferencedSymbol.prototype, "getDefinition", null);

class ReferencedSymbolDefinitionInfo extends DefinitionInfo {
    constructor(context, compilerObject) {
        super(context, compilerObject);
    }
    getDisplayParts() {
        return this.compilerObject.displayParts.map(p => this._context.compilerFactory.getSymbolDisplayPart(p));
    }
}
__decorate$1([
    Memoize
], ReferencedSymbolDefinitionInfo.prototype, "getDisplayParts", null);

class ReferenceEntry extends DocumentSpan {
    constructor(context, compilerObject) {
        super(context, compilerObject);
    }
    isWriteAccess() {
        return this.compilerObject.isWriteAccess;
    }
    isDefinition() {
        return this.compilerObject.isDefinition;
    }
    isInString() {
        return this.compilerObject.isInString;
    }
}

class RenameLocation extends DocumentSpan {
    getPrefixText() {
        return this._compilerObject.prefixText;
    }
    getSuffixText() {
        return this._compilerObject.suffixText;
    }
}

class SymbolDisplayPart {
    constructor(compilerObject) {
        this._compilerObject = compilerObject;
    }
    get compilerObject() {
        return this._compilerObject;
    }
    getText() {
        return this.compilerObject.text;
    }
    getKind() {
        return this.compilerObject.kind;
    }
}

class TypeChecker {
    constructor(context) {
        this._context = context;
    }
    get compilerObject() {
        return this._getCompilerObject();
    }
    _reset(getTypeChecker) {
        this._getCompilerObject = getTypeChecker;
    }
    getAmbientModules() {
        return this.compilerObject.getAmbientModules().map(s => this._context.compilerFactory.getSymbol(s));
    }
    getApparentType(type) {
        return this._context.compilerFactory.getType(this.compilerObject.getApparentType(type.compilerType));
    }
    getConstantValue(node) {
        return this.compilerObject.getConstantValue(node.compilerNode);
    }
    getFullyQualifiedName(symbol) {
        return this.compilerObject.getFullyQualifiedName(symbol.compilerSymbol);
    }
    getTypeAtLocation(node) {
        return this._context.compilerFactory.getType(this.compilerObject.getTypeAtLocation(node.compilerNode));
    }
    getContextualType(expression) {
        const contextualType = this.compilerObject.getContextualType(expression.compilerNode);
        return contextualType == null ? undefined : this._context.compilerFactory.getType(contextualType);
    }
    getTypeOfSymbolAtLocation(symbol, node) {
        return this._context.compilerFactory.getType(this.compilerObject.getTypeOfSymbolAtLocation(symbol.compilerSymbol, node.compilerNode));
    }
    getDeclaredTypeOfSymbol(symbol) {
        return this._context.compilerFactory.getType(this.compilerObject.getDeclaredTypeOfSymbol(symbol.compilerSymbol));
    }
    getSymbolAtLocation(node) {
        const compilerSymbol = this.compilerObject.getSymbolAtLocation(node.compilerNode);
        return compilerSymbol == null ? undefined : this._context.compilerFactory.getSymbol(compilerSymbol);
    }
    getAliasedSymbol(symbol) {
        if (!symbol.hasFlags(common.SymbolFlags.Alias))
            return undefined;
        const tsAliasSymbol = this.compilerObject.getAliasedSymbol(symbol.compilerSymbol);
        return tsAliasSymbol == null ? undefined : this._context.compilerFactory.getSymbol(tsAliasSymbol);
    }
    getExportSymbolOfSymbol(symbol) {
        return this._context.compilerFactory.getSymbol(this.compilerObject.getExportSymbolOfSymbol(symbol.compilerSymbol));
    }
    getPropertiesOfType(type) {
        return this.compilerObject.getPropertiesOfType(type.compilerType).map(p => this._context.compilerFactory.getSymbol(p));
    }
    getTypeText(type, enclosingNode, typeFormatFlags) {
        if (typeFormatFlags == null)
            typeFormatFlags = this._getDefaultTypeFormatFlags(enclosingNode);
        return this.compilerObject.typeToString(type.compilerType, enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.compilerNode, typeFormatFlags);
    }
    getReturnTypeOfSignature(signature) {
        return this._context.compilerFactory.getType(this.compilerObject.getReturnTypeOfSignature(signature.compilerSignature));
    }
    getSignatureFromNode(node) {
        const signature = this.compilerObject.getSignatureFromDeclaration(node.compilerNode);
        return signature == null ? undefined : this._context.compilerFactory.getSignature(signature);
    }
    getExportsOfModule(moduleSymbol) {
        const symbols = this.compilerObject.getExportsOfModule(moduleSymbol.compilerSymbol);
        return (symbols || []).map(s => this._context.compilerFactory.getSymbol(s));
    }
    getExportSpecifierLocalTargetSymbol(exportSpecifier) {
        const symbol = this.compilerObject.getExportSpecifierLocalTargetSymbol(exportSpecifier.compilerNode);
        return symbol == null ? undefined : this._context.compilerFactory.getSymbol(symbol);
    }
    getResolvedSignature(node) {
        const resolvedSignature = this.compilerObject.getResolvedSignature(node.compilerNode);
        if (!resolvedSignature || !resolvedSignature.declaration)
            return undefined;
        return this._context.compilerFactory.getSignature(resolvedSignature);
    }
    getResolvedSignatureOrThrow(node) {
        return errors.throwIfNullOrUndefined(this.getResolvedSignature(node), "Signature could not be resolved.");
    }
    getBaseTypeOfLiteralType(type) {
        return this._context.compilerFactory.getType(this.compilerObject.getBaseTypeOfLiteralType(type.compilerType));
    }
    getSymbolsInScope(node, meaning) {
        return this.compilerObject.getSymbolsInScope(node.compilerNode, meaning)
            .map(s => this._context.compilerFactory.getSymbol(s));
    }
    getTypeArguments(typeReference) {
        return this.compilerObject.getTypeArguments(typeReference.compilerType)
            .map(arg => this._context.compilerFactory.getType(arg));
    }
    _getDefaultTypeFormatFlags(enclosingNode) {
        let formatFlags = (common.TypeFormatFlags.UseTypeOfFunction | common.TypeFormatFlags.NoTruncation | common.TypeFormatFlags.UseFullyQualifiedType
            | common.TypeFormatFlags.WriteTypeArgumentsOfSignature);
        if (enclosingNode != null && enclosingNode.getKind() === ts$1.SyntaxKind.TypeAliasDeclaration)
            formatFlags |= common.TypeFormatFlags.InTypeAlias;
        return formatFlags;
    }
}

class Program {
    constructor(context, rootNames, host) {
        this._context = context;
        this._typeChecker = new TypeChecker(this._context);
        this._reset(rootNames, host);
    }
    get compilerObject() {
        return this._getOrCreateCompilerObject();
    }
    _isCompilerProgramCreated() {
        return this._createdCompilerObject != null;
    }
    _reset(rootNames, host) {
        const compilerOptions = this._context.compilerOptions.get();
        this._getOrCreateCompilerObject = () => {
            if (this._createdCompilerObject == null) {
                this._createdCompilerObject = ts$1.createProgram(rootNames, compilerOptions, host, this._oldProgram);
                delete this._oldProgram;
            }
            return this._createdCompilerObject;
        };
        if (this._createdCompilerObject != null) {
            this._oldProgram = this._createdCompilerObject;
            delete this._createdCompilerObject;
        }
        this._typeChecker._reset(() => this.compilerObject.getTypeChecker());
    }
    getTypeChecker() {
        return this._typeChecker;
    }
    emit(options = {}) {
        return __awaiter$1(this, void 0, void 0, function*() {
            if (options.writeFile) {
                const message = `Cannot specify a ${"writeFile"} option when emitting asynchrously. `
                    + `Use ${"emitSync"}() instead.`;
                throw new errors.InvalidOperationError(message);
            }
            const { fileSystemWrapper } = this._context;
            const promises = [];
            const emitResult = this._emit(Object.assign({
                writeFile: (filePath, text, writeByteOrderMark) => {
                    promises
                        .push(fileSystemWrapper.writeFile(fileSystemWrapper.getStandardizedAbsolutePath(filePath), writeByteOrderMark ? "\uFEFF" + text : text));
                }
            }, options));
            yield Promise.all(promises);
            return new EmitResult(this._context, emitResult);
        });
    }
    emitSync(options = {}) {
        return new EmitResult(this._context, this._emit(options));
    }
    emitToMemory(options = {}) {
        const sourceFiles = [];
        const { fileSystemWrapper } = this._context;
        const emitResult = this._emit(Object.assign({
            writeFile: (filePath, text, writeByteOrderMark) => {
                sourceFiles.push({
                    filePath: fileSystemWrapper.getStandardizedAbsolutePath(filePath),
                    text,
                    writeByteOrderMark: writeByteOrderMark || false,
                });
            }
        }, options));
        return new MemoryEmitResult(this._context, emitResult, sourceFiles);
    }
    _emit(options = {}) {
        const targetSourceFile = options.targetSourceFile != null ? options.targetSourceFile.compilerNode : undefined;
        const { emitOnlyDtsFiles, customTransformers, writeFile } = options;
        const cancellationToken = undefined;
        return this.compilerObject.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);
    }
    getSyntacticDiagnostics(sourceFile) {
        const compilerDiagnostics = this.compilerObject.getSyntacticDiagnostics(sourceFile == null ? undefined : sourceFile.compilerNode);
        return compilerDiagnostics.map(d => this._context.compilerFactory.getDiagnosticWithLocation(d));
    }
    getSemanticDiagnostics(sourceFile) {
        const compilerDiagnostics = this.compilerObject.getSemanticDiagnostics(sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.compilerNode);
        return compilerDiagnostics.map(d => this._context.compilerFactory.getDiagnostic(d));
    }
    getDeclarationDiagnostics(sourceFile) {
        const compilerDiagnostics = this.compilerObject.getDeclarationDiagnostics(sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.compilerNode);
        return compilerDiagnostics.map(d => this._context.compilerFactory.getDiagnosticWithLocation(d));
    }
    getGlobalDiagnostics() {
        const compilerDiagnostics = this.compilerObject.getGlobalDiagnostics();
        return compilerDiagnostics.map(d => this._context.compilerFactory.getDiagnostic(d));
    }
    getEmitModuleResolutionKind() {
        return common.getEmitModuleResolutionKind(this.compilerObject.getCompilerOptions());
    }
    isSourceFileFromExternalLibrary(sourceFile) {
        return sourceFile.isFromExternalLibrary();
    }
}

class LanguageService {
    constructor(context, opts) {
        const { resolutionHost = {} } = opts;
        this._context = context;
        const { languageServiceHost, compilerHost } = createHosts({
            transactionalFileSystem: this._context.fileSystemWrapper,
            sourceFileContainer: this._context.getSourceFileContainer(),
            compilerOptions: this._context.compilerOptions,
            getNewLine: () => this._context.manipulationSettings.getNewLineKindAsString(),
            resolutionHost,
        });
        this._compilerHost = compilerHost;
        this._compilerObject = ts$1.createLanguageService(languageServiceHost, this._context.compilerFactory.documentRegistry);
        this._program = new Program(this._context, Array.from(this._context.compilerFactory.getSourceFilePaths()), this._compilerHost);
        this._context.compilerFactory.onSourceFileAdded(() => this._resetProgram());
        this._context.compilerFactory.onSourceFileRemoved(() => this._resetProgram());
    }
    get compilerObject() {
        return this._compilerObject;
    }
    _resetProgram() {
        this._program._reset(Array.from(this._context.compilerFactory.getSourceFilePaths()), this._compilerHost);
    }
    getProgram() {
        return this._program;
    }
    getDefinitions(node) {
        return this.getDefinitionsAtPosition(node._sourceFile, node.getStart());
    }
    getDefinitionsAtPosition(sourceFile, pos) {
        const results = this.compilerObject.getDefinitionAtPosition(sourceFile.getFilePath(), pos) || [];
        return results.map(info => this._context.compilerFactory.getDefinitionInfo(info));
    }
    getImplementations(node) {
        return this.getImplementationsAtPosition(node._sourceFile, node.getStart());
    }
    getImplementationsAtPosition(sourceFile, pos) {
        const results = this.compilerObject.getImplementationAtPosition(sourceFile.getFilePath(), pos) || [];
        return results.map(location => new ImplementationLocation(this._context, location));
    }
    findReferences(node) {
        return this.findReferencesAtPosition(node._sourceFile, node.getStart());
    }
    findReferencesAsNodes(node) {
        const referencedSymbols = this.findReferences(node);
        return Array.from(getReferencingNodes());
        function* getReferencingNodes() {
            for (const referencedSymbol of referencedSymbols) {
                const isAlias = referencedSymbol.getDefinition().getKind() === ts$1.ScriptElementKind.alias;
                const references = referencedSymbol.getReferences();
                for (let i = 0; i < references.length; i++) {
                    const reference = references[i];
                    if (isAlias || !reference.isDefinition() || i > 0)
                        yield reference.getNode();
                }
            }
        }
    }
    findReferencesAtPosition(sourceFile, pos) {
        const results = this.compilerObject.findReferences(sourceFile.getFilePath(), pos) || [];
        return results.map(s => this._context.compilerFactory.getReferencedSymbol(s));
    }
    findRenameLocations(node, options = {}) {
        const usePrefixAndSuffixText = options.usePrefixAndSuffixText == null
            ? this._context.manipulationSettings.getUsePrefixAndSuffixTextForRename()
            : options.usePrefixAndSuffixText;
        const renameLocations = this.compilerObject.findRenameLocations(node._sourceFile.getFilePath(), node.getStart(), options.renameInStrings || false, options.renameInComments || false, usePrefixAndSuffixText) || [];
        return renameLocations.map(l => new RenameLocation(this._context, l));
    }
    getSuggestionDiagnostics(filePathOrSourceFile) {
        const filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);
        const suggestionDiagnostics = this.compilerObject.getSuggestionDiagnostics(filePath);
        return suggestionDiagnostics.map(d => this._context.compilerFactory.getDiagnosticWithLocation(d));
    }
    getFormattingEditsForRange(filePath, range, formatSettings) {
        return (this.compilerObject.getFormattingEditsForRange(filePath, range[0], range[1], this._getFilledSettings(formatSettings)) || []).map(e => new TextChange(e));
    }
    getFormattingEditsForDocument(filePath, formatSettings) {
        const standardizedFilePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);
        return (this.compilerObject.getFormattingEditsForDocument(standardizedFilePath, this._getFilledSettings(formatSettings)) || [])
            .map(e => new TextChange(e));
    }
    getFormattedDocumentText(filePath, formatSettings) {
        const standardizedFilePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);
        const sourceFile = this._context.compilerFactory.getSourceFileFromCacheFromFilePath(standardizedFilePath);
        if (sourceFile == null)
            throw new errors.FileNotFoundError(standardizedFilePath);
        formatSettings = this._getFilledSettings(formatSettings);
        const formattingEdits = this.getFormattingEditsForDocument(standardizedFilePath, formatSettings);
        let newText = getTextFromTextChanges(sourceFile, formattingEdits);
        const newLineChar = formatSettings.newLineCharacter;
        if (formatSettings.ensureNewLineAtEndOfFile && !newText.endsWith(newLineChar))
            newText += newLineChar;
        return newText.replace(/\r?\n/g, newLineChar);
    }
    getEmitOutput(filePathOrSourceFile, emitOnlyDtsFiles) {
        const filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);
        const compilerObject = this.compilerObject;
        return new EmitOutput(this._context, getCompilerEmitOutput());
        function getCompilerEmitOutput() {
            const program = compilerObject.getProgram();
            if (program == null || program.getSourceFile(filePath) == null)
                return { emitSkipped: true, outputFiles: [] };
            return compilerObject.getEmitOutput(filePath, emitOnlyDtsFiles);
        }
    }
    getIdentationAtPosition(filePathOrSourceFile, position, settings) {
        const filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);
        if (settings == null)
            settings = this._context.manipulationSettings.getEditorSettings();
        else
            fillDefaultEditorSettings(settings, this._context.manipulationSettings);
        return this.compilerObject.getIndentationAtPosition(filePath, position, settings);
    }
    organizeImports(filePathOrSourceFile, formatSettings = {}, userPreferences = {}) {
        const scope = {
            type: "file",
            fileName: this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile),
        };
        return this.compilerObject.organizeImports(scope, this._getFilledSettings(formatSettings), this._getFilledUserPreferences(userPreferences))
            .map(fileTextChanges => new FileTextChanges(this._context, fileTextChanges));
    }
    getEditsForRefactor(filePathOrSourceFile, formatSettings, positionOrRange, refactorName, actionName, preferences = {}) {
        const filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);
        const position = typeof positionOrRange === "number" ? positionOrRange : { pos: positionOrRange.getPos(), end: positionOrRange.getEnd() };
        const compilerObject = this.compilerObject.getEditsForRefactor(filePath, this._getFilledSettings(formatSettings), position, refactorName, actionName, this._getFilledUserPreferences(preferences));
        return compilerObject != null ? new RefactorEditInfo(this._context, compilerObject) : undefined;
    }
    getCombinedCodeFix(filePathOrSourceFile, fixId, formatSettings = {}, preferences = {}) {
        const compilerResult = this.compilerObject.getCombinedCodeFix({
            type: "file",
            fileName: this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile),
        }, fixId, this._getFilledSettings(formatSettings), this._getFilledUserPreferences(preferences || {}));
        return new CombinedCodeActions(this._context, compilerResult);
    }
    getCodeFixesAtPosition(filePathOrSourceFile, start, end, errorCodes, formatOptions = {}, preferences = {}) {
        const filePath = this._getFilePathFromFilePathOrSourceFile(filePathOrSourceFile);
        const compilerResult = this.compilerObject.getCodeFixesAtPosition(filePath, start, end, errorCodes, this._getFilledSettings(formatOptions), this._getFilledUserPreferences(preferences || {}));
        return compilerResult.map(compilerObject => new CodeFixAction(this._context, compilerObject));
    }
    _getFilePathFromFilePathOrSourceFile(filePathOrSourceFile) {
        const filePath = typeof filePathOrSourceFile === "string"
            ? this._context.fileSystemWrapper.getStandardizedAbsolutePath(filePathOrSourceFile)
            : filePathOrSourceFile.getFilePath();
        if (!this._context.compilerFactory.containsSourceFileAtPath(filePath))
            throw new errors.FileNotFoundError(filePath);
        return filePath;
    }
    _getFilledSettings(settings) {
        if (settings["_filled"])
            return settings;
        settings = common.ObjectUtils.assign(this._context.getFormatCodeSettings(), settings);
        fillDefaultFormatCodeSettings(settings, this._context.manipulationSettings);
        settings["_filled"] = true;
        return settings;
    }
    _getFilledUserPreferences(userPreferences) {
        return common.ObjectUtils.assign(this._context.getUserPreferences(), userPreferences);
    }
}

class Type {
    constructor(context, type) {
        this._context = context;
        this._compilerType = type;
    }
    get compilerType() {
        return this._compilerType;
    }
    getText(enclosingNode, typeFormatFlags) {
        return this._context.typeChecker.getTypeText(this, enclosingNode, typeFormatFlags);
    }
    getAliasSymbol() {
        return this.compilerType.aliasSymbol == null ? undefined : this._context.compilerFactory.getSymbol(this.compilerType.aliasSymbol);
    }
    getAliasSymbolOrThrow() {
        return errors.throwIfNullOrUndefined(this.getAliasSymbol(), "Expected to find an alias symbol.");
    }
    getAliasTypeArguments() {
        const aliasTypeArgs = this.compilerType.aliasTypeArguments || [];
        return aliasTypeArgs.map(t => this._context.compilerFactory.getType(t));
    }
    getApparentType() {
        return this._context.typeChecker.getApparentType(this);
    }
    getArrayElementTypeOrThrow() {
        return errors.throwIfNullOrUndefined(this.getArrayElementType(), "Expected to find an array element type.");
    }
    getArrayElementType() {
        if (!this.isArray())
            return undefined;
        return this.getTypeArguments()[0];
    }
    getBaseTypes() {
        const baseTypes = this.compilerType.getBaseTypes() || [];
        return baseTypes.map(t => this._context.compilerFactory.getType(t));
    }
    getBaseTypeOfLiteralType() {
        return this._context.typeChecker.getBaseTypeOfLiteralType(this);
    }
    getCallSignatures() {
        return this.compilerType.getCallSignatures().map(s => this._context.compilerFactory.getSignature(s));
    }
    getConstructSignatures() {
        return this.compilerType.getConstructSignatures().map(s => this._context.compilerFactory.getSignature(s));
    }
    getConstraintOrThrow() {
        return errors.throwIfNullOrUndefined(this.getConstraint(), "Expected to find a constraint.");
    }
    getConstraint() {
        const constraint = this.compilerType.getConstraint();
        return constraint == null ? undefined : this._context.compilerFactory.getType(constraint);
    }
    getDefaultOrThrow() {
        return errors.throwIfNullOrUndefined(this.getDefault(), "Expected to find a default type.");
    }
    getDefault() {
        const defaultType = this.compilerType.getDefault();
        return defaultType == null ? undefined : this._context.compilerFactory.getType(defaultType);
    }
    getProperties() {
        return this.compilerType.getProperties().map(s => this._context.compilerFactory.getSymbol(s));
    }
    getPropertyOrThrow(nameOrFindFunction) {
        return errors.throwIfNullOrUndefined(this.getProperty(nameOrFindFunction), () => getNotFoundErrorMessageForNameOrFindFunction("symbol property", nameOrFindFunction));
    }
    getProperty(nameOrFindFunction) {
        return getSymbolByNameOrFindFunction(this.getProperties(), nameOrFindFunction);
    }
    getApparentProperties() {
        return this.compilerType.getApparentProperties().map(s => this._context.compilerFactory.getSymbol(s));
    }
    getApparentProperty(nameOrFindFunction) {
        return getSymbolByNameOrFindFunction(this.getApparentProperties(), nameOrFindFunction);
    }
    isNullable() {
        return this.getUnionTypes().some(t => t.isNull() || t.isUndefined());
    }
    getNonNullableType() {
        return this._context.compilerFactory.getType(this.compilerType.getNonNullableType());
    }
    getNumberIndexType() {
        const numberIndexType = this.compilerType.getNumberIndexType();
        return numberIndexType == null ? undefined : this._context.compilerFactory.getType(numberIndexType);
    }
    getStringIndexType() {
        const stringIndexType = this.compilerType.getStringIndexType();
        return stringIndexType == null ? undefined : this._context.compilerFactory.getType(stringIndexType);
    }
    getTargetType() {
        const targetType = this.compilerType.target || undefined;
        return targetType == null ? undefined : this._context.compilerFactory.getType(targetType);
    }
    getTargetTypeOrThrow() {
        return errors.throwIfNullOrUndefined(this.getTargetType(), "Expected to find the target type.");
    }
    getTypeArguments() {
        return this._context.typeChecker.getTypeArguments(this);
    }
    getTupleElements() {
        return this.isTuple() ? this.getTypeArguments() : [];
    }
    getUnionTypes() {
        if (!this.isUnion())
            return [];
        return this.compilerType.types.map(t => this._context.compilerFactory.getType(t));
    }
    getIntersectionTypes() {
        if (!this.isIntersection())
            return [];
        return this.compilerType.types.map(t => this._context.compilerFactory.getType(t));
    }
    getSymbol() {
        const tsSymbol = this.compilerType.getSymbol();
        return tsSymbol == null ? undefined : this._context.compilerFactory.getSymbol(tsSymbol);
    }
    getSymbolOrThrow() {
        return errors.throwIfNullOrUndefined(this.getSymbol(), "Expected to find a symbol.");
    }
    isAnonymous() {
        return this._hasObjectFlag(common.ObjectFlags.Anonymous);
    }
    isAny() {
        return this._hasTypeFlag(common.TypeFlags.Any);
    }
    isArray() {
        const symbol = this.getSymbol();
        if (symbol == null)
            return false;
        return symbol.getName() === "Array" && this.getTypeArguments().length === 1;
    }
    isBoolean() {
        return this._hasTypeFlag(common.TypeFlags.Boolean);
    }
    isString() {
        return this._hasTypeFlag(common.TypeFlags.String);
    }
    isNumber() {
        return this._hasTypeFlag(common.TypeFlags.Number);
    }
    isLiteral() {
        const isBooleanLiteralForTs3_0 = this.isBooleanLiteral();
        return this.compilerType.isLiteral() || isBooleanLiteralForTs3_0;
    }
    isBooleanLiteral() {
        return this._hasTypeFlag(common.TypeFlags.BooleanLiteral);
    }
    isEnumLiteral() {
        return this._hasTypeFlag(common.TypeFlags.EnumLiteral) && !this.isUnion();
    }
    isNumberLiteral() {
        return this._hasTypeFlag(common.TypeFlags.NumberLiteral);
    }
    isStringLiteral() {
        return this.compilerType.isStringLiteral();
    }
    isClass() {
        return this.compilerType.isClass();
    }
    isClassOrInterface() {
        return this.compilerType.isClassOrInterface();
    }
    isEnum() {
        const hasEnumFlag = this._hasTypeFlag(common.TypeFlags.Enum);
        if (hasEnumFlag)
            return true;
        if (this.isEnumLiteral() && !this.isUnion())
            return false;
        const symbol = this.getSymbol();
        if (symbol == null)
            return false;
        const valueDeclaration = symbol.getValueDeclaration();
        return valueDeclaration != null && Node.isEnumDeclaration(valueDeclaration);
    }
    isInterface() {
        return this._hasObjectFlag(common.ObjectFlags.Interface);
    }
    isObject() {
        return this._hasTypeFlag(common.TypeFlags.Object);
    }
    isTypeParameter() {
        return this.compilerType.isTypeParameter();
    }
    isTuple() {
        const targetType = this.getTargetType();
        if (targetType == null)
            return false;
        return targetType._hasObjectFlag(common.ObjectFlags.Tuple);
    }
    isUnion() {
        return this.compilerType.isUnion();
    }
    isIntersection() {
        return this.compilerType.isIntersection();
    }
    isUnionOrIntersection() {
        return this.compilerType.isUnionOrIntersection();
    }
    isUnknown() {
        return this._hasTypeFlag(common.TypeFlags.Unknown);
    }
    isNull() {
        return this._hasTypeFlag(common.TypeFlags.Null);
    }
    isUndefined() {
        return this._hasTypeFlag(common.TypeFlags.Undefined);
    }
    getFlags() {
        return this.compilerType.flags;
    }
    getObjectFlags() {
        if (!this.isObject())
            return 0;
        return this.compilerType.objectFlags || 0;
    }
    _hasTypeFlag(flag) {
        return (this.compilerType.flags & flag) === flag;
    }
    _hasObjectFlag(flag) {
        return (this.getObjectFlags() & flag) === flag;
    }
}

class TypeParameter extends Type {
    getConstraintOrThrow() {
        return errors.throwIfNullOrUndefined(this.getConstraint(), "Expected type parameter to have a constraint.");
    }
    getConstraint() {
        const declaration = this._getTypeParameterDeclaration();
        if (declaration == null)
            return undefined;
        const constraintNode = declaration.getConstraint();
        if (constraintNode == null)
            return undefined;
        return this._context.typeChecker.getTypeAtLocation(constraintNode);
    }
    getDefaultOrThrow() {
        return errors.throwIfNullOrUndefined(this.getDefault(), "Expected type parameter to have a default type.");
    }
    getDefault() {
        const declaration = this._getTypeParameterDeclaration();
        if (declaration == null)
            return undefined;
        const defaultNode = declaration.getDefault();
        if (defaultNode == null)
            return undefined;
        return this._context.typeChecker.getTypeAtLocation(defaultNode);
    }
    _getTypeParameterDeclaration() {
        const symbol = this.getSymbol();
        if (symbol == null)
            return undefined;
        const declaration = symbol.getDeclarations()[0];
        if (declaration == null)
            return undefined;
        if (!Node.isTypeParameterDeclaration(declaration))
            return undefined;
        return declaration;
    }
}

class DirectoryEmitResult {
    constructor(_skippedFilePaths, _outputFilePaths) {
        this._skippedFilePaths = _skippedFilePaths;
        this._outputFilePaths = _outputFilePaths;
    }
    getSkippedFilePaths() {
        return this._skippedFilePaths;
    }
    getOutputFilePaths() {
        return this._outputFilePaths;
    }
}

class Directory$1 {
    constructor(context, path) {
        this.__context = context;
        this._setPathInternal(path);
    }
    _setPathInternal(path) {
        this._path = path;
        this._pathParts = path.split("/").filter(p => p.length > 0);
    }
    get _context() {
        this._throwIfDeletedOrRemoved();
        return this.__context;
    }
    isAncestorOf(possibleDescendant) {
        return Directory$1._isAncestorOfDir(this, possibleDescendant);
    }
    isDescendantOf(possibleAncestor) {
        return Directory$1._isAncestorOfDir(possibleAncestor, this);
    }
    _getDepth() {
        return this._pathParts.length;
    }
    getPath() {
        this._throwIfDeletedOrRemoved();
        return this._path;
    }
    getBaseName() {
        return this._pathParts[this._pathParts.length - 1];
    }
    getParentOrThrow() {
        return errors.throwIfNullOrUndefined(this.getParent(), () => `Parent directory of ${this.getPath()} does not exist or was never added.`);
    }
    getParent() {
        if (FileUtils.isRootDirPath(this.getPath()))
            return undefined;
        return this.addDirectoryAtPathIfExists(FileUtils.getDirPath(this.getPath()));
    }
    getDirectoryOrThrow(pathOrCondition) {
        return errors.throwIfNullOrUndefined(this.getDirectory(pathOrCondition), () => {
            if (typeof pathOrCondition === "string")
                return `Could not find a directory at path '${this._context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, this.getPath())}'.`;
            return "Could not find child directory that matched condition.";
        });
    }
    getDirectory(pathOrCondition) {
        if (typeof pathOrCondition === "string") {
            const path = this._context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, this.getPath());
            return this._context.compilerFactory.getDirectoryFromCache(path);
        }
        return this.getDirectories().find(pathOrCondition);
    }
    getSourceFileOrThrow(pathOrCondition) {
        return errors.throwIfNullOrUndefined(this.getSourceFile(pathOrCondition), () => {
            if (typeof pathOrCondition === "string") {
                const absolutePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, this.getPath());
                return `Could not find child source file at path '${absolutePath}'.`;
            }
            return "Could not find child source file that matched condition.";
        });
    }
    getSourceFile(pathOrCondition) {
        if (typeof pathOrCondition === "string") {
            const path = this._context.fileSystemWrapper.getStandardizedAbsolutePath(pathOrCondition, this.getPath());
            return this._context.compilerFactory.getSourceFileFromCacheFromFilePath(path);
        }
        for (const sourceFile of this._getSourceFilesIterator()) {
            if (pathOrCondition(sourceFile))
                return sourceFile;
        }
        return undefined;
    }
    getDirectories() {
        return Array.from(this._getDirectoriesIterator());
    }
    _getDirectoriesIterator() {
        return this._context.compilerFactory.getChildDirectoriesOfDirectory(this.getPath());
    }
    getSourceFiles(globPatterns) {
        const { compilerFactory, fileSystemWrapper } = this._context;
        const dir = this;
        if (typeof globPatterns === "string" || globPatterns instanceof Array) {
            const finalGlobPatterns = typeof globPatterns === "string" ? [globPatterns] : globPatterns;
            return Array.from(getFilteredSourceFiles(finalGlobPatterns));
        }
        else {
            return Array.from(this._getSourceFilesIterator());
        }
        function* getFilteredSourceFiles(globPatterns) {
            const sourceFilePaths = Array.from(getSourceFilePaths());
            const matchedPaths = common.matchGlobs(sourceFilePaths, globPatterns, dir.getPath());
            for (const matchedPath of matchedPaths)
                yield compilerFactory.getSourceFileFromCacheFromFilePath(fileSystemWrapper.getStandardizedAbsolutePath(matchedPath));
            function* getSourceFilePaths() {
                for (const sourceFile of dir._getDescendantSourceFilesIterator())
                    yield sourceFile.getFilePath();
            }
        }
    }
    _getSourceFilesIterator() {
        return this._context.compilerFactory.getChildSourceFilesOfDirectory(this.getPath());
    }
    getDescendantSourceFiles() {
        return Array.from(this._getDescendantSourceFilesIterator());
    }
    *_getDescendantSourceFilesIterator() {
        for (const sourceFile of this._getSourceFilesIterator())
            yield sourceFile;
        for (const directory of this._getDirectoriesIterator())
            yield* directory._getDescendantSourceFilesIterator();
    }
    getDescendantDirectories() {
        return Array.from(this._getDescendantDirectoriesIterator());
    }
    *_getDescendantDirectoriesIterator() {
        for (const directory of this.getDirectories()) {
            yield directory;
            yield* directory._getDescendantDirectoriesIterator();
        }
    }
    addSourceFilesAtPaths(fileGlobs) {
        fileGlobs = typeof fileGlobs === "string" ? [fileGlobs] : fileGlobs;
        fileGlobs = fileGlobs.map(g => {
            if (FileUtils.pathIsAbsolute(g))
                return g;
            return FileUtils.pathJoin(this.getPath(), g);
        });
        return this._context.directoryCoordinator.addSourceFilesAtPaths(fileGlobs, { markInProject: this._isInProject() });
    }
    addDirectoryAtPathIfExists(relativeOrAbsoluteDirPath, options = {}) {
        const dirPath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeOrAbsoluteDirPath, this.getPath());
        return this._context.directoryCoordinator.addDirectoryAtPathIfExists(dirPath, Object.assign(Object.assign({}, options), { markInProject: this._isInProject() }));
    }
    addDirectoryAtPath(relativeOrAbsoluteDirPath, options = {}) {
        const dirPath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeOrAbsoluteDirPath, this.getPath());
        return this._context.directoryCoordinator.addDirectoryAtPath(dirPath, Object.assign(Object.assign({}, options), { markInProject: this._isInProject() }));
    }
    createDirectory(relativeOrAbsoluteDirPath) {
        const dirPath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeOrAbsoluteDirPath, this.getPath());
        return this._context.directoryCoordinator.createDirectoryOrAddIfExists(dirPath, { markInProject: this._isInProject() });
    }
    createSourceFile(relativeFilePath, sourceFileText, options) {
        const filePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeFilePath, this.getPath());
        return this._context.compilerFactory.createSourceFile(filePath, sourceFileText || "", Object.assign(Object.assign({}, (options || {})), { markInProject: this._isInProject() }));
    }
    addSourceFileAtPathIfExists(relativeFilePath) {
        const filePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeFilePath, this.getPath());
        return this._context.directoryCoordinator.addSourceFileAtPathIfExists(filePath, { markInProject: this._isInProject() });
    }
    addSourceFileAtPath(relativeFilePath) {
        const filePath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeFilePath, this.getPath());
        return this._context.directoryCoordinator.addSourceFileAtPath(filePath, { markInProject: this._isInProject() });
    }
    emit(options = {}) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const { fileSystemWrapper } = this._context;
            const writeTasks = [];
            const outputFilePaths = [];
            const skippedFilePaths = [];
            for (const emitResult of this._emitInternal(options)) {
                if (isStandardizedFilePath(emitResult))
                    skippedFilePaths.push(emitResult);
                else {
                    writeTasks.push(fileSystemWrapper.writeFile(emitResult.filePath, emitResult.fileText));
                    outputFilePaths.push(emitResult.filePath);
                }
            }
            yield Promise.all(writeTasks);
            return new DirectoryEmitResult(skippedFilePaths, outputFilePaths);
        });
    }
    emitSync(options = {}) {
        const { fileSystemWrapper } = this._context;
        const outputFilePaths = [];
        const skippedFilePaths = [];
        for (const emitResult of this._emitInternal(options)) {
            if (isStandardizedFilePath(emitResult))
                skippedFilePaths.push(emitResult);
            else {
                fileSystemWrapper.writeFileSync(emitResult.filePath, emitResult.fileText);
                outputFilePaths.push(emitResult.filePath);
            }
        }
        return new DirectoryEmitResult(skippedFilePaths, outputFilePaths);
    }
    _emitInternal(options = {}) {
        const { emitOnlyDtsFiles = false } = options;
        const isJsFile = options.outDir == null ? undefined : /\.js$/i;
        const isMapFile = options.outDir == null ? undefined : /\.js\.map$/i;
        const isDtsFile = options.declarationDir == null && options.outDir == null ? undefined : /\.d\.ts$/i;
        const getStandardizedPath = (path) => path == null
            ? undefined
            : this._context.fileSystemWrapper.getStandardizedAbsolutePath(path, this.getPath());
        const getSubDirPath = (path, dir) => path == null
            ? undefined
            : FileUtils.pathJoin(path, dir.getBaseName());
        const hasDeclarationDir = this._context.compilerOptions.get().declarationDir != null || options.declarationDir != null;
        return emitDirectory(this, getStandardizedPath(options.outDir), getStandardizedPath(options.declarationDir));
        function* emitDirectory(directory, outDir, declarationDir) {
            for (const sourceFile of directory.getSourceFiles()) {
                const output = sourceFile.getEmitOutput({ emitOnlyDtsFiles });
                if (output.getEmitSkipped()) {
                    yield sourceFile.getFilePath();
                    continue;
                }
                for (const outputFile of output.getOutputFiles()) {
                    let filePath = outputFile.getFilePath();
                    const fileText = outputFile.getWriteByteOrderMark() ? FileUtils.getTextWithByteOrderMark(outputFile.getText()) : outputFile.getText();
                    if (outDir != null && (isJsFile.test(filePath) || isMapFile.test(filePath) || (!hasDeclarationDir && isDtsFile.test(filePath))))
                        filePath = FileUtils.pathJoin(outDir, FileUtils.getBaseName(filePath));
                    else if (declarationDir != null && isDtsFile.test(filePath))
                        filePath = FileUtils.pathJoin(declarationDir, FileUtils.getBaseName(filePath));
                    yield { filePath, fileText };
                }
            }
            for (const dir of directory.getDirectories())
                yield* emitDirectory(dir, getSubDirPath(outDir, dir), getSubDirPath(declarationDir, dir));
        }
    }
    copyToDirectory(dirPathOrDirectory, options) {
        const dirPath = typeof dirPathOrDirectory === "string" ? dirPathOrDirectory : dirPathOrDirectory.getPath();
        return this.copy(FileUtils.pathJoin(dirPath, this.getBaseName()), options);
    }
    copy(relativeOrAbsolutePath, options) {
        const originalPath = this.getPath();
        const fileSystem = this._context.fileSystemWrapper;
        const newPath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(relativeOrAbsolutePath, this.getPath());
        if (originalPath === newPath)
            return this;
        options = getDirectoryCopyOptions(options);
        if (options.includeUntrackedFiles)
            fileSystem.queueCopyDirectory(originalPath, newPath);
        return this._copyInternal(newPath, options);
    }
    copyImmediately(relativeOrAbsolutePath, options) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const fileSystem = this._context.fileSystemWrapper;
            const originalPath = this.getPath();
            const newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);
            if (originalPath === newPath) {
                yield this.save();
                return this;
            }
            options = getDirectoryCopyOptions(options);
            const newDir = this._copyInternal(newPath, options);
            if (options.includeUntrackedFiles)
                yield fileSystem.copyDirectoryImmediately(originalPath, newPath);
            yield newDir.save();
            return newDir;
        });
    }
    copyImmediatelySync(relativeOrAbsolutePath, options) {
        const fileSystem = this._context.fileSystemWrapper;
        const originalPath = this.getPath();
        const newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);
        if (originalPath === newPath) {
            this.saveSync();
            return this;
        }
        options = getDirectoryCopyOptions(options);
        const newDir = this._copyInternal(newPath, options);
        if (options.includeUntrackedFiles)
            fileSystem.copyDirectoryImmediatelySync(originalPath, newPath);
        newDir.saveSync();
        return newDir;
    }
    _copyInternal(newPath, options) {
        const originalPath = this.getPath();
        if (originalPath === newPath)
            return this;
        const { fileSystemWrapper: fileSystem, compilerFactory } = this._context;
        const copyingDirectories = [this, ...this.getDescendantDirectories()].map(directory => ({
            newDirPath: directory === this ? newPath : fileSystem.getStandardizedAbsolutePath(this.getRelativePathTo(directory), newPath),
        }));
        const copyingSourceFiles = this.getDescendantSourceFiles().map(sourceFile => ({
            sourceFile,
            newFilePath: fileSystem.getStandardizedAbsolutePath(this.getRelativePathTo(sourceFile), newPath),
            references: this._getReferencesForCopy(sourceFile),
        }));
        for (const { newDirPath } of copyingDirectories)
            this._context.compilerFactory.createDirectoryOrAddIfExists(newDirPath, { markInProject: this._isInProject() });
        for (const { sourceFile, newFilePath } of copyingSourceFiles)
            sourceFile._copyInternal(newFilePath, options);
        for (const { references, newFilePath } of copyingSourceFiles)
            this.getSourceFileOrThrow(newFilePath)._updateReferencesForCopyInternal(references);
        return compilerFactory.getDirectoryFromCache(newPath);
    }
    moveToDirectory(dirPathOrDirectory, options) {
        const dirPath = typeof dirPathOrDirectory === "string" ? dirPathOrDirectory : dirPathOrDirectory.getPath();
        return this.move(FileUtils.pathJoin(dirPath, this.getBaseName()), options);
    }
    move(relativeOrAbsolutePath, options) {
        const fileSystem = this._context.fileSystemWrapper;
        const originalPath = this.getPath();
        const newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);
        if (originalPath === newPath)
            return this;
        return this._moveInternal(newPath, options, () => fileSystem.queueMoveDirectory(originalPath, newPath));
    }
    moveImmediately(relativeOrAbsolutePath, options) {
        return __awaiter$1(this, void 0, void 0, function*() {
            const fileSystem = this._context.fileSystemWrapper;
            const originalPath = this.getPath();
            const newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);
            if (originalPath === newPath) {
                yield this.save();
                return this;
            }
            this._moveInternal(newPath, options);
            yield fileSystem.moveDirectoryImmediately(originalPath, newPath);
            yield this.save();
            return this;
        });
    }
    moveImmediatelySync(relativeOrAbsolutePath, options) {
        const fileSystem = this._context.fileSystemWrapper;
        const originalPath = this.getPath();
        const newPath = fileSystem.getStandardizedAbsolutePath(relativeOrAbsolutePath, originalPath);
        if (originalPath === newPath) {
            this.saveSync();
            return this;
        }
        this._moveInternal(newPath, options);
        fileSystem.moveDirectoryImmediatelySync(originalPath, newPath);
        this.saveSync();
        return this;
    }
    _moveInternal(newPath, options, preAction) {
        const originalPath = this.getPath();
        if (originalPath === newPath)
            return this;
        const existingDir = this._context.compilerFactory.getDirectoryFromCacheOnlyIfInCache(newPath);
        const markInProject = existingDir != null && existingDir._isInProject();
        if (preAction)
            preAction();
        const fileSystem = this._context.fileSystemWrapper;
        const compilerFactory = this._context.compilerFactory;
        const movingDirectories = [this, ...this.getDescendantDirectories()].map(directory => ({
            directory,
            oldPath: directory.getPath(),
            newDirPath: directory === this ? newPath : fileSystem.getStandardizedAbsolutePath(this.getRelativePathTo(directory), newPath),
        }));
        const movingSourceFiles = this.getDescendantSourceFiles().map(sourceFile => ({
            sourceFile,
            newFilePath: fileSystem.getStandardizedAbsolutePath(this.getRelativePathTo(sourceFile), newPath),
            references: this._getReferencesForMove(sourceFile),
        }));
        for (const { directory, oldPath, newDirPath } of movingDirectories) {
            compilerFactory.removeDirectoryFromCache(oldPath);
            const dirToOverwrite = compilerFactory.getDirectoryFromCache(newDirPath);
            if (dirToOverwrite != null)
                dirToOverwrite._forgetOnlyThis();
            directory._setPathInternal(newDirPath);
            compilerFactory.addDirectoryToCache(directory);
        }
        for (const { sourceFile, newFilePath } of movingSourceFiles)
            sourceFile._moveInternal(newFilePath, options);
        for (const { sourceFile, references } of movingSourceFiles)
            sourceFile._updateReferencesForMoveInternal(references, originalPath);
        if (markInProject)
            this._markAsInProject();
        return this;
    }
    clear() {
        const path = this.getPath();
        this._deleteDescendants();
        this._context.fileSystemWrapper.queueDirectoryDelete(path);
        this._context.fileSystemWrapper.queueMkdir(path);
    }
    clearImmediately() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const path = this.getPath();
            this._deleteDescendants();
            yield this._context.fileSystemWrapper.clearDirectoryImmediately(path);
        });
    }
    clearImmediatelySync() {
        const path = this.getPath();
        this._deleteDescendants();
        this._context.fileSystemWrapper.clearDirectoryImmediatelySync(path);
    }
    delete() {
        const path = this.getPath();
        this._deleteDescendants();
        this._context.fileSystemWrapper.queueDirectoryDelete(path);
        this.forget();
    }
    _deleteDescendants() {
        for (const sourceFile of this.getSourceFiles())
            sourceFile.delete();
        for (const dir of this.getDirectories())
            dir.delete();
    }
    deleteImmediately() {
        return __awaiter$1(this, void 0, void 0, function*() {
            const { fileSystemWrapper } = this._context;
            const path = this.getPath();
            this.forget();
            yield fileSystemWrapper.deleteDirectoryImmediately(path);
        });
    }
    deleteImmediatelySync() {
        const { fileSystemWrapper } = this._context;
        const path = this.getPath();
        this.forget();
        fileSystemWrapper.deleteDirectoryImmediatelySync(path);
    }
    forget() {
        if (this.wasForgotten())
            return;
        for (const sourceFile of this.getSourceFiles())
            sourceFile.forget();
        for (const dir of this.getDirectories())
            dir.forget();
        this._forgetOnlyThis();
    }
    _forgetOnlyThis() {
        if (this.wasForgotten())
            return;
        this._context.compilerFactory.removeDirectoryFromCache(this.getPath());
        this.__context = undefined;
    }
    save() {
        return __awaiter$1(this, void 0, void 0, function*() {
            yield this._context.fileSystemWrapper.saveForDirectory(this.getPath());
            const unsavedSourceFiles = this.getDescendantSourceFiles().filter(s => !s.isSaved());
            yield Promise.all(unsavedSourceFiles.map(s => s.save()));
        });
    }
    saveSync() {
        this._context.fileSystemWrapper.saveForDirectorySync(this.getPath());
        const unsavedSourceFiles = this.getDescendantSourceFiles().filter(s => !s.isSaved());
        unsavedSourceFiles.forEach(s => s.saveSync());
    }
    getRelativePathTo(sourceFileOrDir) {
        return FileUtils.getRelativePathTo(this.getPath(), getPath());
        function getPath() {
            return sourceFileOrDir instanceof SourceFile ? sourceFileOrDir.getFilePath() : sourceFileOrDir.getPath();
        }
    }
    getRelativePathAsModuleSpecifierTo(sourceFileOrDir) {
        const moduleResolution = this._context.program.getEmitModuleResolutionKind();
        const thisDirectory = this;
        const moduleSpecifier = FileUtils.getRelativePathTo(this.getPath(), getPath()).replace(/((\.d\.ts$)|(\.[^/.]+$))/i, "");
        return moduleSpecifier.startsWith("../") ? moduleSpecifier : "./" + moduleSpecifier;
        function getPath() {
            return sourceFileOrDir instanceof SourceFile ? getPathForSourceFile(sourceFileOrDir) : getPathForDirectory(sourceFileOrDir);
            function getPathForSourceFile(sourceFile) {
                switch (moduleResolution) {
                    case common.ModuleResolutionKind.NodeJs:
                        const filePath = sourceFile.getFilePath();
                        if (sourceFile.getDirectory() === thisDirectory)
                            return filePath;
                        return filePath.replace(/\/index?(\.d\.ts|\.ts|\.js)$/i, "");
                    case common.ModuleResolutionKind.Classic:
                        return sourceFile.getFilePath();
                    default:
                        return errors.throwNotImplementedForNeverValueError(moduleResolution);
                }
            }
            function getPathForDirectory(dir) {
                switch (moduleResolution) {
                    case common.ModuleResolutionKind.NodeJs:
                        if (dir === thisDirectory)
                            return FileUtils.pathJoin(dir.getPath(), "index.ts");
                        return dir.getPath();
                    case common.ModuleResolutionKind.Classic:
                        return FileUtils.pathJoin(dir.getPath(), "index.ts");
                    default:
                        return errors.throwNotImplementedForNeverValueError(moduleResolution);
                }
            }
        }
    }
    wasForgotten() {
        return this.__context == null;
    }
    _isInProject() {
        return this._context.inProjectCoordinator.isDirectoryInProject(this);
    }
    _markAsInProject() {
        this._context.inProjectCoordinator.markDirectoryAsInProject(this);
    }
    _hasLoadedParent() {
        return this._context.compilerFactory.containsDirectoryAtPath(FileUtils.getDirPath(this.getPath()));
    }
    _throwIfDeletedOrRemoved() {
        if (this.wasForgotten())
            throw new errors.InvalidOperationError("Cannot use a directory that was deleted, removed, or overwritten.");
    }
    _getReferencesForCopy(sourceFile) {
        const literalReferences = sourceFile._getReferencesForCopyInternal();
        return literalReferences.filter(r => !this.isAncestorOf(r[1]));
    }
    _getReferencesForMove(sourceFile) {
        const { literalReferences, referencingLiterals } = sourceFile._getReferencesForMoveInternal();
        return {
            literalReferences: literalReferences.filter(r => !this.isAncestorOf(r[1])),
            referencingLiterals: referencingLiterals.filter(l => !this.isAncestorOf(l._sourceFile)),
        };
    }
    static _isAncestorOfDir(ancestor, descendant) {
        if (descendant instanceof SourceFile) {
            descendant = descendant.getDirectory();
            if (ancestor === descendant)
                return true;
        }
        if (ancestor._pathParts.length >= descendant._pathParts.length)
            return false;
        for (let i = ancestor._pathParts.length - 1; i >= 0; i--) {
            if (ancestor._pathParts[i] !== descendant._pathParts[i])
                return false;
        }
        return true;
    }
}
function getDirectoryCopyOptions(options) {
    options = common.ObjectUtils.clone(options || {});
    setValueIfUndefined(options, "includeUntrackedFiles", true);
    return options;
}
function isStandardizedFilePath(filePath) {
    return typeof filePath === "string";
}

class DirectoryCoordinator {
    constructor(compilerFactory, fileSystemWrapper) {
        this.compilerFactory = compilerFactory;
        this.fileSystemWrapper = fileSystemWrapper;
    }
    addDirectoryAtPathIfExists(dirPath, options) {
        const directory = this.compilerFactory.getDirectoryFromPath(dirPath, options);
        if (directory == null)
            return undefined;
        if (options.recursive) {
            for (const descendantDirPath of FileUtils.getDescendantDirectories(this.fileSystemWrapper, dirPath))
                this.compilerFactory.createDirectoryOrAddIfExists(descendantDirPath, options);
        }
        return directory;
    }
    addDirectoryAtPath(dirPath, options) {
        const directory = this.addDirectoryAtPathIfExists(dirPath, options);
        if (directory == null)
            throw new errors.DirectoryNotFoundError(dirPath);
        return directory;
    }
    createDirectoryOrAddIfExists(dirPath, options) {
        return this.compilerFactory.createDirectoryOrAddIfExists(dirPath, options);
    }
    addSourceFileAtPathIfExists(filePath, options) {
        return this.compilerFactory.addOrGetSourceFileFromFilePath(filePath, {
            markInProject: options.markInProject,
            scriptKind: undefined,
        });
    }
    addSourceFileAtPath(filePath, options) {
        const sourceFile = this.addSourceFileAtPathIfExists(filePath, options);
        if (sourceFile == null)
            throw new errors.FileNotFoundError(this.fileSystemWrapper.getStandardizedAbsolutePath(filePath));
        return sourceFile;
    }
    addSourceFilesAtPaths(fileGlobs, options) {
        if (typeof fileGlobs === "string")
            fileGlobs = [fileGlobs];
        const sourceFiles = [];
        const globbedDirectories = new Set();
        for (const filePath of this.fileSystemWrapper.globSync(fileGlobs)) {
            const sourceFile = this.addSourceFileAtPathIfExists(filePath, options);
            if (sourceFile != null)
                sourceFiles.push(sourceFile);
            globbedDirectories.add(FileUtils.getDirPath(filePath));
        }
        for (const dirPath of FileUtils.getParentMostPaths(Array.from(globbedDirectories)))
            this.addDirectoryAtPathIfExists(dirPath, { recursive: true, markInProject: options.markInProject });
        return sourceFiles;
    }
}

class DirectoryCache {
    constructor(context) {
        this.context = context;
        this.directoriesByPath = new KeyValueCache();
        this.sourceFilesByDirPath = new KeyValueCache();
        this.directoriesByDirPath = new KeyValueCache();
        this.orphanDirs = new KeyValueCache();
    }
    has(dirPath) {
        return this.directoriesByPath.has(dirPath);
    }
    get(dirPath) {
        if (!this.directoriesByPath.has(dirPath)) {
            for (const orphanDir of this.orphanDirs.getValues()) {
                if (FileUtils.pathStartsWith(orphanDir.getPath(), dirPath))
                    return this.createOrAddIfExists(dirPath);
            }
            return undefined;
        }
        return this.directoriesByPath.get(dirPath);
    }
    getOrphans() {
        return this.orphanDirs.getValues();
    }
    getAll() {
        return this.directoriesByPath.getValuesAsArray();
    }
    *getAllByDepth() {
        const dirLevels = new KeyValueCache();
        let depth = 0;
        for (const orphanDir of this.getOrphans())
            addToDirLevels(orphanDir);
        depth = Math.min(...Array.from(dirLevels.getKeys()));
        while (dirLevels.getSize() > 0) {
            for (const dir of dirLevels.get(depth) || []) {
                yield dir;
                dir.getDirectories().forEach(addToDirLevels);
            }
            dirLevels.removeByKey(depth);
            depth++;
        }
        function addToDirLevels(dir) {
            const dirDepth = dir._getDepth();
            if (depth > dirDepth)
                throw new Error(`For some reason a subdirectory had a lower depth than the parent directory: ${dir.getPath()}`);
            const dirs = dirLevels.getOrCreate(dirDepth, () => []);
            dirs.push(dir);
        }
    }
    remove(dirPath) {
        this.removeFromDirectoriesByDirPath(dirPath);
        this.directoriesByPath.removeByKey(dirPath);
        this.orphanDirs.removeByKey(dirPath);
    }
    *getChildDirectoriesOfDirectory(dirPath) {
        var _a;
        const entries = (_a = this.directoriesByDirPath.get(dirPath)) === null || _a === void 0 ? void 0 : _a.entries();
        if (entries == null)
            return;
        for (const dir of entries)
            yield dir;
    }
    *getChildSourceFilesOfDirectory(dirPath) {
        var _a;
        const entries = (_a = this.sourceFilesByDirPath.get(dirPath)) === null || _a === void 0 ? void 0 : _a.entries();
        if (entries == null)
            return;
        for (const sourceFile of entries)
            yield sourceFile;
    }
    addSourceFile(sourceFile) {
        const dirPath = sourceFile.getDirectoryPath();
        this.createOrAddIfExists(dirPath);
        const sourceFiles = this.sourceFilesByDirPath.getOrCreate(dirPath, () => new SortedKeyValueArray(item => item.getBaseName(), LocaleStringComparer.instance));
        sourceFiles.set(sourceFile);
    }
    removeSourceFile(filePath) {
        const dirPath = FileUtils.getDirPath(filePath);
        const sourceFiles = this.sourceFilesByDirPath.get(dirPath);
        if (sourceFiles == null)
            return;
        sourceFiles.removeByKey(FileUtils.getBaseName(filePath));
        if (!sourceFiles.hasItems())
            this.sourceFilesByDirPath.removeByKey(dirPath);
    }
    createOrAddIfExists(dirPath) {
        if (this.has(dirPath))
            return this.get(dirPath);
        this.fillParentsOfDirPath(dirPath);
        return this.createDirectory(dirPath);
    }
    createDirectory(path) {
        const newDirectory = new Directory$1(this.context, path);
        this.addDirectory(newDirectory);
        return newDirectory;
    }
    addDirectory(directory) {
        const path = directory.getPath();
        const parentDirPath = FileUtils.getDirPath(path);
        const isRootDir = parentDirPath === path;
        for (const orphanDir of this.orphanDirs.getValues()) {
            const orphanDirPath = orphanDir.getPath();
            const orphanDirParentPath = FileUtils.getDirPath(orphanDirPath);
            const isOrphanRootDir = orphanDirParentPath === orphanDirPath;
            if (!isOrphanRootDir && orphanDirParentPath === path)
                this.orphanDirs.removeByKey(orphanDirPath);
        }
        if (!isRootDir)
            this.addToDirectoriesByDirPath(directory);
        if (!this.has(parentDirPath))
            this.orphanDirs.set(path, directory);
        this.directoriesByPath.set(path, directory);
        if (!this.context.fileSystemWrapper.directoryExistsSync(path))
            this.context.fileSystemWrapper.queueMkdir(path);
        for (const orphanDir of this.orphanDirs.getValues()) {
            if (directory.isAncestorOf(orphanDir))
                this.fillParentsOfDirPath(orphanDir.getPath());
        }
    }
    addToDirectoriesByDirPath(directory) {
        if (FileUtils.isRootDirPath(directory.getPath()))
            return;
        const parentDirPath = FileUtils.getDirPath(directory.getPath());
        const directories = this.directoriesByDirPath.getOrCreate(parentDirPath, () => new SortedKeyValueArray(item => item.getBaseName(), LocaleStringComparer.instance));
        directories.set(directory);
    }
    removeFromDirectoriesByDirPath(dirPath) {
        if (FileUtils.isRootDirPath(dirPath))
            return;
        const parentDirPath = FileUtils.getDirPath(dirPath);
        const directories = this.directoriesByDirPath.get(parentDirPath);
        if (directories == null)
            return;
        directories.removeByKey(FileUtils.getBaseName(dirPath));
        if (!directories.hasItems())
            this.directoriesByDirPath.removeByKey(parentDirPath);
    }
    fillParentsOfDirPath(dirPath) {
        const passedDirPaths = [];
        let parentDir = FileUtils.getDirPath(dirPath);
        while (dirPath !== parentDir) {
            dirPath = parentDir;
            parentDir = FileUtils.getDirPath(dirPath);
            if (this.directoriesByPath.has(dirPath)) {
                for (const currentDirPath of passedDirPaths)
                    this.createDirectory(currentDirPath);
                break;
            }
            passedDirPaths.unshift(dirPath);
        }
    }
}

class ForgetfulNodeCache extends KeyValueCache {
    constructor() {
        super(...arguments);
        this.forgetStack = [];
    }
    getOrCreate(key, createFunc) {
        return super.getOrCreate(key, () => {
            const node = createFunc();
            if (this.forgetStack.length > 0)
                this.forgetStack[this.forgetStack.length - 1].add(node);
            return node;
        });
    }
    setForgetPoint() {
        this.forgetStack.push(new Set());
    }
    forgetLastPoint() {
        const nodes = this.forgetStack.pop();
        if (nodes != null)
            this.forgetNodes(nodes.values());
    }
    rememberNode(node) {
        if (node.wasForgotten())
            throw new errors.InvalidOperationError("Cannot remember a node that was removed or forgotten.");
        let wasInForgetStack = false;
        for (const stackItem of this.forgetStack) {
            if (stackItem.delete(node)) {
                wasInForgetStack = true;
                break;
            }
        }
        if (wasInForgetStack)
            this.rememberParentOfNode(node);
        return wasInForgetStack;
    }
    rememberParentOfNode(node) {
        const parent = node.getParentSyntaxList() || node.getParent();
        if (parent != null)
            this.rememberNode(parent);
    }
    forgetNodes(nodes) {
        for (const node of nodes) {
            if (node.wasForgotten() || node.getKind() === ts$1.SyntaxKind.SourceFile)
                continue;
            node._forgetOnlyThis();
        }
    }
}

const kindToWrapperMappings = {
    [ts$1.SyntaxKind.SourceFile]: SourceFile,
    [ts$1.SyntaxKind.ArrayBindingPattern]: ArrayBindingPattern,
    [ts$1.SyntaxKind.ArrayLiteralExpression]: ArrayLiteralExpression,
    [ts$1.SyntaxKind.ArrayType]: ArrayTypeNode,
    [ts$1.SyntaxKind.ArrowFunction]: ArrowFunction,
    [ts$1.SyntaxKind.AsExpression]: AsExpression,
    [ts$1.SyntaxKind.AwaitExpression]: AwaitExpression,
    [ts$1.SyntaxKind.BigIntLiteral]: BigIntLiteral,
    [ts$1.SyntaxKind.BindingElement]: BindingElement,
    [ts$1.SyntaxKind.BinaryExpression]: BinaryExpression,
    [ts$1.SyntaxKind.Block]: Block,
    [ts$1.SyntaxKind.BreakStatement]: BreakStatement,
    [ts$1.SyntaxKind.CallExpression]: CallExpression,
    [ts$1.SyntaxKind.CallSignature]: CallSignatureDeclaration,
    [ts$1.SyntaxKind.CaseBlock]: CaseBlock,
    [ts$1.SyntaxKind.CaseClause]: CaseClause,
    [ts$1.SyntaxKind.CatchClause]: CatchClause,
    [ts$1.SyntaxKind.ClassDeclaration]: ClassDeclaration,
    [ts$1.SyntaxKind.ClassExpression]: ClassExpression,
    [ts$1.SyntaxKind.ConditionalType]: ConditionalTypeNode,
    [ts$1.SyntaxKind.Constructor]: ConstructorDeclaration,
    [ts$1.SyntaxKind.ConstructorType]: ConstructorTypeNode,
    [ts$1.SyntaxKind.ConstructSignature]: ConstructSignatureDeclaration,
    [ts$1.SyntaxKind.ContinueStatement]: ContinueStatement,
    [ts$1.SyntaxKind.CommaListExpression]: CommaListExpression,
    [ts$1.SyntaxKind.ComputedPropertyName]: ComputedPropertyName,
    [ts$1.SyntaxKind.ConditionalExpression]: ConditionalExpression,
    [ts$1.SyntaxKind.DebuggerStatement]: DebuggerStatement,
    [ts$1.SyntaxKind.Decorator]: Decorator,
    [ts$1.SyntaxKind.DefaultClause]: DefaultClause,
    [ts$1.SyntaxKind.DeleteExpression]: DeleteExpression,
    [ts$1.SyntaxKind.DoStatement]: DoStatement,
    [ts$1.SyntaxKind.ElementAccessExpression]: ElementAccessExpression,
    [ts$1.SyntaxKind.EmptyStatement]: EmptyStatement,
    [ts$1.SyntaxKind.EnumDeclaration]: EnumDeclaration,
    [ts$1.SyntaxKind.EnumMember]: EnumMember,
    [ts$1.SyntaxKind.ExportAssignment]: ExportAssignment,
    [ts$1.SyntaxKind.ExportDeclaration]: ExportDeclaration,
    [ts$1.SyntaxKind.ExportSpecifier]: ExportSpecifier,
    [ts$1.SyntaxKind.ExpressionWithTypeArguments]: ExpressionWithTypeArguments,
    [ts$1.SyntaxKind.ExpressionStatement]: ExpressionStatement,
    [ts$1.SyntaxKind.ExternalModuleReference]: ExternalModuleReference,
    [ts$1.SyntaxKind.QualifiedName]: QualifiedName,
    [ts$1.SyntaxKind.ForInStatement]: ForInStatement,
    [ts$1.SyntaxKind.ForOfStatement]: ForOfStatement,
    [ts$1.SyntaxKind.ForStatement]: ForStatement,
    [ts$1.SyntaxKind.FunctionDeclaration]: FunctionDeclaration,
    [ts$1.SyntaxKind.FunctionExpression]: FunctionExpression,
    [ts$1.SyntaxKind.FunctionType]: FunctionTypeNode,
    [ts$1.SyntaxKind.GetAccessor]: GetAccessorDeclaration,
    [ts$1.SyntaxKind.HeritageClause]: HeritageClause,
    [ts$1.SyntaxKind.Identifier]: Identifier,
    [ts$1.SyntaxKind.IfStatement]: IfStatement,
    [ts$1.SyntaxKind.ImportClause]: ImportClause,
    [ts$1.SyntaxKind.ImportDeclaration]: ImportDeclaration,
    [ts$1.SyntaxKind.ImportEqualsDeclaration]: ImportEqualsDeclaration,
    [ts$1.SyntaxKind.ImportSpecifier]: ImportSpecifier,
    [ts$1.SyntaxKind.ImportType]: ImportTypeNode,
    [ts$1.SyntaxKind.IndexedAccessType]: IndexedAccessTypeNode,
    [ts$1.SyntaxKind.IndexSignature]: IndexSignatureDeclaration,
    [ts$1.SyntaxKind.InferType]: InferTypeNode,
    [ts$1.SyntaxKind.InterfaceDeclaration]: InterfaceDeclaration,
    [ts$1.SyntaxKind.IntersectionType]: IntersectionTypeNode,
    [ts$1.SyntaxKind.JSDocAugmentsTag]: JSDocAugmentsTag,
    [ts$1.SyntaxKind.JSDocClassTag]: JSDocClassTag,
    [ts$1.SyntaxKind.JSDocFunctionType]: JSDocFunctionType,
    [ts$1.SyntaxKind.JSDocParameterTag]: JSDocParameterTag,
    [ts$1.SyntaxKind.JSDocPrivateTag]: JSDocPrivateTag,
    [ts$1.SyntaxKind.JSDocPropertyTag]: JSDocPropertyTag,
    [ts$1.SyntaxKind.JSDocProtectedTag]: JSDocProtectedTag,
    [ts$1.SyntaxKind.JSDocPublicTag]: JSDocPublicTag,
    [ts$1.SyntaxKind.JSDocReturnTag]: JSDocReturnTag,
    [ts$1.SyntaxKind.JSDocReadonlyTag]: JSDocReadonlyTag,
    [ts$1.SyntaxKind.JSDocSignature]: JSDocSignature,
    [ts$1.SyntaxKind.JSDocTag]: JSDocUnknownTag,
    [ts$1.SyntaxKind.JSDocTemplateTag]: JSDocTemplateTag,
    [ts$1.SyntaxKind.JSDocThisTag]: JSDocThisTag,
    [ts$1.SyntaxKind.JSDocTypeExpression]: JSDocTypeExpression,
    [ts$1.SyntaxKind.JSDocTypeTag]: JSDocTypeTag,
    [ts$1.SyntaxKind.JSDocTypedefTag]: JSDocTypedefTag,
    [ts$1.SyntaxKind.JsxAttribute]: JsxAttribute,
    [ts$1.SyntaxKind.JsxClosingElement]: JsxClosingElement,
    [ts$1.SyntaxKind.JsxClosingFragment]: JsxClosingFragment,
    [ts$1.SyntaxKind.JsxElement]: JsxElement,
    [ts$1.SyntaxKind.JsxExpression]: JsxExpression,
    [ts$1.SyntaxKind.JsxFragment]: JsxFragment,
    [ts$1.SyntaxKind.JsxOpeningElement]: JsxOpeningElement,
    [ts$1.SyntaxKind.JsxOpeningFragment]: JsxOpeningFragment,
    [ts$1.SyntaxKind.JsxSelfClosingElement]: JsxSelfClosingElement,
    [ts$1.SyntaxKind.JsxSpreadAttribute]: JsxSpreadAttribute,
    [ts$1.SyntaxKind.JsxText]: JsxText,
    [ts$1.SyntaxKind.LabeledStatement]: LabeledStatement,
    [ts$1.SyntaxKind.LiteralType]: LiteralTypeNode,
    [ts$1.SyntaxKind.MetaProperty]: MetaProperty,
    [ts$1.SyntaxKind.MethodDeclaration]: MethodDeclaration,
    [ts$1.SyntaxKind.MethodSignature]: MethodSignature,
    [ts$1.SyntaxKind.ModuleBlock]: ModuleBlock,
    [ts$1.SyntaxKind.ModuleDeclaration]: NamespaceDeclaration,
    [ts$1.SyntaxKind.NamedExports]: NamedExports,
    [ts$1.SyntaxKind.NamedImports]: NamedImports,
    [ts$1.SyntaxKind.NamespaceExport]: NamespaceExport,
    [ts$1.SyntaxKind.NamespaceImport]: NamespaceImport,
    [ts$1.SyntaxKind.NewExpression]: NewExpression,
    [ts$1.SyntaxKind.NonNullExpression]: NonNullExpression,
    [ts$1.SyntaxKind.NotEmittedStatement]: NotEmittedStatement,
    [ts$1.SyntaxKind.NoSubstitutionTemplateLiteral]: NoSubstitutionTemplateLiteral,
    [ts$1.SyntaxKind.NumericLiteral]: NumericLiteral,
    [ts$1.SyntaxKind.ObjectBindingPattern]: ObjectBindingPattern,
    [ts$1.SyntaxKind.ObjectLiteralExpression]: ObjectLiteralExpression,
    [ts$1.SyntaxKind.OmittedExpression]: OmittedExpression,
    [ts$1.SyntaxKind.Parameter]: ParameterDeclaration,
    [ts$1.SyntaxKind.ParenthesizedExpression]: ParenthesizedExpression,
    [ts$1.SyntaxKind.ParenthesizedType]: ParenthesizedTypeNode,
    [ts$1.SyntaxKind.PartiallyEmittedExpression]: PartiallyEmittedExpression,
    [ts$1.SyntaxKind.PostfixUnaryExpression]: PostfixUnaryExpression,
    [ts$1.SyntaxKind.PrefixUnaryExpression]: PrefixUnaryExpression,
    [ts$1.SyntaxKind.PrivateIdentifier]: PrivateIdentifier,
    [ts$1.SyntaxKind.PropertyAccessExpression]: PropertyAccessExpression,
    [ts$1.SyntaxKind.PropertyAssignment]: PropertyAssignment,
    [ts$1.SyntaxKind.PropertyDeclaration]: PropertyDeclaration,
    [ts$1.SyntaxKind.PropertySignature]: PropertySignature,
    [ts$1.SyntaxKind.RegularExpressionLiteral]: RegularExpressionLiteral,
    [ts$1.SyntaxKind.ReturnStatement]: ReturnStatement,
    [ts$1.SyntaxKind.SetAccessor]: SetAccessorDeclaration,
    [ts$1.SyntaxKind.ShorthandPropertyAssignment]: ShorthandPropertyAssignment,
    [ts$1.SyntaxKind.SpreadAssignment]: SpreadAssignment,
    [ts$1.SyntaxKind.SpreadElement]: SpreadElement,
    [ts$1.SyntaxKind.StringLiteral]: StringLiteral,
    [ts$1.SyntaxKind.SwitchStatement]: SwitchStatement,
    [ts$1.SyntaxKind.SyntaxList]: SyntaxList,
    [ts$1.SyntaxKind.TaggedTemplateExpression]: TaggedTemplateExpression,
    [ts$1.SyntaxKind.TemplateExpression]: TemplateExpression,
    [ts$1.SyntaxKind.TemplateHead]: TemplateHead,
    [ts$1.SyntaxKind.TemplateMiddle]: TemplateMiddle,
    [ts$1.SyntaxKind.TemplateSpan]: TemplateSpan,
    [ts$1.SyntaxKind.TemplateTail]: TemplateTail,
    [ts$1.SyntaxKind.ThisType]: ThisTypeNode,
    [ts$1.SyntaxKind.ThrowStatement]: ThrowStatement,
    [ts$1.SyntaxKind.TryStatement]: TryStatement,
    [ts$1.SyntaxKind.TupleType]: TupleTypeNode,
    [ts$1.SyntaxKind.TypeAliasDeclaration]: TypeAliasDeclaration,
    [ts$1.SyntaxKind.TypeAssertionExpression]: TypeAssertion,
    [ts$1.SyntaxKind.TypeLiteral]: TypeLiteralNode,
    [ts$1.SyntaxKind.TypeParameter]: TypeParameterDeclaration,
    [ts$1.SyntaxKind.TypePredicate]: TypePredicateNode,
    [ts$1.SyntaxKind.TypeReference]: TypeReferenceNode,
    [ts$1.SyntaxKind.UnionType]: UnionTypeNode,
    [ts$1.SyntaxKind.VariableDeclaration]: VariableDeclaration,
    [ts$1.SyntaxKind.VariableDeclarationList]: VariableDeclarationList,
    [ts$1.SyntaxKind.VariableStatement]: VariableStatement,
    [ts$1.SyntaxKind.JSDocComment]: JSDoc,
    [ts$1.SyntaxKind.TypeOfExpression]: TypeOfExpression,
    [ts$1.SyntaxKind.WhileStatement]: WhileStatement,
    [ts$1.SyntaxKind.WithStatement]: WithStatement,
    [ts$1.SyntaxKind.YieldExpression]: YieldExpression,
    [ts$1.SyntaxKind.SemicolonToken]: Node,
    [ts$1.SyntaxKind.AnyKeyword]: Expression,
    [ts$1.SyntaxKind.BooleanKeyword]: Expression,
    [ts$1.SyntaxKind.FalseKeyword]: BooleanLiteral,
    [ts$1.SyntaxKind.ImportKeyword]: ImportExpression,
    [ts$1.SyntaxKind.InferKeyword]: Node,
    [ts$1.SyntaxKind.NeverKeyword]: Node,
    [ts$1.SyntaxKind.NullKeyword]: NullLiteral,
    [ts$1.SyntaxKind.NumberKeyword]: Expression,
    [ts$1.SyntaxKind.ObjectKeyword]: Expression,
    [ts$1.SyntaxKind.StringKeyword]: Expression,
    [ts$1.SyntaxKind.SymbolKeyword]: Expression,
    [ts$1.SyntaxKind.SuperKeyword]: SuperExpression,
    [ts$1.SyntaxKind.ThisKeyword]: ThisExpression,
    [ts$1.SyntaxKind.TrueKeyword]: BooleanLiteral,
    [ts$1.SyntaxKind.UndefinedKeyword]: Expression,
    [ts$1.SyntaxKind.VoidExpression]: VoidExpression,
};

class CompilerFactory {
    constructor(context) {
        this.context = context;
        this.sourceFileCacheByFilePath = new Map();
        this.diagnosticCache = new WeakCache();
        this.definitionInfoCache = new WeakCache();
        this.documentSpanCache = new WeakCache();
        this.diagnosticMessageChainCache = new WeakCache();
        this.jsDocTagInfoCache = new WeakCache();
        this.signatureCache = new WeakCache();
        this.symbolCache = new WeakCache();
        this.symbolDisplayPartCache = new WeakCache();
        this.referenceEntryCache = new WeakCache();
        this.referencedSymbolCache = new WeakCache();
        this.referencedSymbolDefinitionInfoCache = new WeakCache();
        this.typeCache = new WeakCache();
        this.typeParameterCache = new WeakCache();
        this.nodeCache = new ForgetfulNodeCache();
        this.sourceFileAddedEventContainer = new EventContainer();
        this.sourceFileRemovedEventContainer = new EventContainer();
        this.documentRegistry = new DocumentRegistry(context.fileSystemWrapper);
        this.directoryCache = new DirectoryCache(context);
        this.context.compilerOptions.onModified(() => {
            const currentSourceFiles = Array.from(this.sourceFileCacheByFilePath.values());
            for (const sourceFile of currentSourceFiles) {
                replaceSourceFileForCacheUpdate(sourceFile);
            }
        });
    }
    *getSourceFilesByDirectoryDepth() {
        for (const dir of this.getDirectoriesByDepth())
            yield* dir.getSourceFiles();
    }
    getSourceFilePaths() {
        return this.sourceFileCacheByFilePath.keys();
    }
    getChildDirectoriesOfDirectory(dirPath) {
        return this.directoryCache.getChildDirectoriesOfDirectory(dirPath);
    }
    getChildSourceFilesOfDirectory(dirPath) {
        return this.directoryCache.getChildSourceFilesOfDirectory(dirPath);
    }
    onSourceFileAdded(subscription, subscribe = true) {
        if (subscribe)
            this.sourceFileAddedEventContainer.subscribe(subscription);
        else
            this.sourceFileAddedEventContainer.unsubscribe(subscription);
    }
    onSourceFileRemoved(subscription) {
        this.sourceFileRemovedEventContainer.subscribe(subscription);
    }
    createSourceFile(filePath, sourceFileText, options) {
        sourceFileText = sourceFileText instanceof Function ? getTextFromStringOrWriter(this.context.createWriter(), sourceFileText) : sourceFileText || "";
        if (typeof sourceFileText === "string")
            return this.createSourceFileFromText(filePath, sourceFileText, options);
        const writer = this.context.createWriter();
        const structurePrinter = this.context.structurePrinterFactory.forSourceFile({
            isAmbient: FileUtils.getExtension(filePath) === ".d.ts",
        });
        structurePrinter.printText(writer, sourceFileText);
        return this.createSourceFileFromText(filePath, writer.toString(), options);
    }
    createSourceFileFromText(filePath, sourceText, options) {
        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);
        if (options.overwrite === true)
            return this.createOrOverwriteSourceFileFromText(filePath, sourceText, options);
        this.throwIfFileExists(filePath, "Did you mean to provide the overwrite option?");
        return this.createSourceFileFromTextInternal(filePath, sourceText, options);
    }
    throwIfFileExists(filePath, prefixMessage) {
        if (!this.containsSourceFileAtPath(filePath) && !this.context.fileSystemWrapper.fileExistsSync(filePath))
            return;
        prefixMessage = prefixMessage == null ? "" : prefixMessage + " ";
        throw new errors.InvalidOperationError(`${prefixMessage}A source file already exists at the provided file path: ${filePath}`);
    }
    createOrOverwriteSourceFileFromText(filePath, sourceText, options) {
        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);
        const existingSourceFile = this.addOrGetSourceFileFromFilePath(filePath, options);
        if (existingSourceFile != null) {
            existingSourceFile.getChildren().forEach(c => c.forget());
            this.replaceCompilerNode(existingSourceFile, this.createCompilerSourceFileFromText(filePath, sourceText, options.scriptKind));
            return existingSourceFile;
        }
        return this.createSourceFileFromTextInternal(filePath, sourceText, options);
    }
    getSourceFileFromCacheFromFilePath(filePath) {
        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);
        return this.sourceFileCacheByFilePath.get(filePath);
    }
    addOrGetSourceFileFromFilePath(filePath, options) {
        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);
        let sourceFile = this.sourceFileCacheByFilePath.get(filePath);
        if (sourceFile == null) {
            let fileText;
            try {
                fileText = this.context.fileSystemWrapper.readFileSync(filePath, this.context.getEncoding());
            }
            catch (_a) {
            }
            if (fileText != null) {
                this.context.logger.log(`Loaded file: ${filePath}`);
                sourceFile = this.createSourceFileFromTextInternal(filePath, fileText, options);
                sourceFile._setIsSaved(true);
            }
        }
        if (sourceFile != null && options.markInProject)
            sourceFile._markAsInProject();
        return sourceFile;
    }
    containsSourceFileAtPath(filePath) {
        filePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(filePath);
        return this.sourceFileCacheByFilePath.has(filePath);
    }
    containsDirectoryAtPath(dirPath) {
        dirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath);
        return this.directoryCache.has(dirPath);
    }
    getSourceFileForNode(compilerNode) {
        let currentNode = compilerNode;
        while (currentNode.kind !== ts$1.SyntaxKind.SourceFile) {
            if (currentNode.parent == null)
                return undefined;
            currentNode = currentNode.parent;
        }
        return this.getSourceFile(currentNode, { markInProject: false });
    }
    hasCompilerNode(compilerNode) {
        return this.nodeCache.has(compilerNode);
    }
    getExistingNodeFromCompilerNode(compilerNode) {
        return this.nodeCache.get(compilerNode);
    }
    getNodeFromCompilerNode(compilerNode, sourceFile) {
        if (compilerNode.kind === ts$1.SyntaxKind.SourceFile)
            return this.getSourceFile(compilerNode, { markInProject: false });
        return this.nodeCache.getOrCreate(compilerNode, () => {
            const node = createNode.call(this);
            initializeNode.call(this, node);
            return node;
        });
        function createNode() {
            if (isCommentNode(compilerNode)) {
                if (CommentNodeParser.isCommentStatement(compilerNode))
                    return new CommentStatement(this.context, compilerNode, sourceFile);
                if (CommentNodeParser.isCommentClassElement(compilerNode))
                    return new CommentClassElement(this.context, compilerNode, sourceFile);
                if (CommentNodeParser.isCommentTypeElement(compilerNode))
                    return new CommentTypeElement(this.context, compilerNode, sourceFile);
                if (CommentNodeParser.isCommentObjectLiteralElement(compilerNode))
                    return new CommentObjectLiteralElement(this.context, compilerNode, sourceFile);
                if (CommentNodeParser.isCommentEnumMember(compilerNode))
                    return new CommentEnumMember(this.context, compilerNode, sourceFile);
                return errors.throwNotImplementedForNeverValueError(compilerNode);
            }
            const ctor = kindToWrapperMappings[compilerNode.kind] || Node;
            return new ctor(this.context, compilerNode, sourceFile);
        }
        function isCommentNode(node) {
            return node._commentKind != null;
        }
        function initializeNode(node) {
            if (compilerNode.parent != null) {
                const parentNode = this.getNodeFromCompilerNode(compilerNode.parent, sourceFile);
                parentNode._wrappedChildCount++;
            }
            const parentSyntaxList = node._getParentSyntaxListIfWrapped();
            if (parentSyntaxList != null)
                parentSyntaxList._wrappedChildCount++;
            if (compilerNode.kind === ts$1.SyntaxKind.SyntaxList) {
                let count = 0;
                for (const _ of node._getChildrenInCacheIterator())
                    count++;
                node._wrappedChildCount = count;
            }
        }
    }
    createSourceFileFromTextInternal(filePath, text, options) {
        const hasBom = StringUtils.hasBom(text);
        if (hasBom)
            text = StringUtils.stripBom(text);
        const sourceFile = this.getSourceFile(this.createCompilerSourceFileFromText(filePath, text, options.scriptKind), options);
        if (hasBom)
            sourceFile._hasBom = true;
        return sourceFile;
    }
    createCompilerSourceFileFromText(filePath, text, scriptKind) {
        return this.documentRegistry.createOrUpdateSourceFile(filePath, this.context.compilerOptions.get(), ts$1.ScriptSnapshot.fromString(text), scriptKind);
    }
    getSourceFile(compilerSourceFile, options) {
        let wasAdded = false;
        const sourceFile = this.nodeCache.getOrCreate(compilerSourceFile, () => {
            const createdSourceFile = new SourceFile(this.context, compilerSourceFile);
            if (!options.markInProject)
                this.context.inProjectCoordinator.setSourceFileNotInProject(createdSourceFile);
            this.addSourceFileToCache(createdSourceFile);
            wasAdded = true;
            return createdSourceFile;
        });
        if (options.markInProject)
            sourceFile._markAsInProject();
        if (wasAdded)
            this.sourceFileAddedEventContainer.fire(sourceFile);
        return sourceFile;
    }
    addSourceFileToCache(sourceFile) {
        this.sourceFileCacheByFilePath.set(sourceFile.getFilePath(), sourceFile);
        this.context.fileSystemWrapper.removeFileDelete(sourceFile.getFilePath());
        this.directoryCache.addSourceFile(sourceFile);
    }
    getDirectoryFromPath(dirPath, options) {
        dirPath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath);
        let directory = this.directoryCache.get(dirPath);
        if (directory == null && this.context.fileSystemWrapper.directoryExistsSync(dirPath))
            directory = this.directoryCache.createOrAddIfExists(dirPath);
        if (directory != null && options.markInProject)
            directory._markAsInProject();
        return directory;
    }
    createDirectoryOrAddIfExists(dirPath, options) {
        const directory = this.directoryCache.createOrAddIfExists(dirPath);
        if (directory != null && options.markInProject)
            directory._markAsInProject();
        return directory;
    }
    getDirectoryFromCache(dirPath) {
        return this.directoryCache.get(dirPath);
    }
    getDirectoryFromCacheOnlyIfInCache(dirPath) {
        return this.directoryCache.has(dirPath)
            ? this.directoryCache.get(dirPath)
            : undefined;
    }
    getDirectoriesByDepth() {
        return this.directoryCache.getAllByDepth();
    }
    getOrphanDirectories() {
        return this.directoryCache.getOrphans();
    }
    getSymbolDisplayPart(compilerObject) {
        return this.symbolDisplayPartCache.getOrCreate(compilerObject, () => new SymbolDisplayPart(compilerObject));
    }
    getType(type) {
        if ((type.flags & common.TypeFlags.TypeParameter) === common.TypeFlags.TypeParameter)
            return this.getTypeParameter(type);
        return this.typeCache.getOrCreate(type, () => new Type(this.context, type));
    }
    getTypeParameter(typeParameter) {
        return this.typeParameterCache.getOrCreate(typeParameter, () => new TypeParameter(this.context, typeParameter));
    }
    getSignature(signature) {
        return this.signatureCache.getOrCreate(signature, () => new Signature(this.context, signature));
    }
    getSymbol(symbol) {
        return this.symbolCache.getOrCreate(symbol, () => new Symbol$1(this.context, symbol));
    }
    getDefinitionInfo(compilerObject) {
        return this.definitionInfoCache.getOrCreate(compilerObject, () => new DefinitionInfo(this.context, compilerObject));
    }
    getDocumentSpan(compilerObject) {
        return this.documentSpanCache.getOrCreate(compilerObject, () => new DocumentSpan(this.context, compilerObject));
    }
    getReferenceEntry(compilerObject) {
        return this.referenceEntryCache.getOrCreate(compilerObject, () => new ReferenceEntry(this.context, compilerObject));
    }
    getReferencedSymbol(compilerObject) {
        return this.referencedSymbolCache.getOrCreate(compilerObject, () => new ReferencedSymbol(this.context, compilerObject));
    }
    getReferencedSymbolDefinitionInfo(compilerObject) {
        return this.referencedSymbolDefinitionInfoCache.getOrCreate(compilerObject, () => new ReferencedSymbolDefinitionInfo(this.context, compilerObject));
    }
    getDiagnostic(diagnostic) {
        return this.diagnosticCache.getOrCreate(diagnostic, () => {
            if (diagnostic.start != null)
                return new DiagnosticWithLocation(this.context, diagnostic);
            return new Diagnostic(this.context, diagnostic);
        });
    }
    getDiagnosticWithLocation(diagnostic) {
        return this.diagnosticCache.getOrCreate(diagnostic, () => new DiagnosticWithLocation(this.context, diagnostic));
    }
    getDiagnosticMessageChain(compilerObject) {
        return this.diagnosticMessageChainCache.getOrCreate(compilerObject, () => new DiagnosticMessageChain(compilerObject));
    }
    getJSDocTagInfo(jsDocTagInfo) {
        return this.jsDocTagInfoCache.getOrCreate(jsDocTagInfo, () => new JSDocTagInfo(jsDocTagInfo));
    }
    replaceCompilerNode(oldNode, newNode) {
        const nodeToReplace = oldNode instanceof Node ? oldNode.compilerNode : oldNode;
        const node = oldNode instanceof Node ? oldNode : this.nodeCache.get(oldNode);
        if (nodeToReplace.kind === ts$1.SyntaxKind.SourceFile && nodeToReplace.fileName !== newNode.fileName) {
            const sourceFile = node;
            this.removeCompilerNodeFromCache(nodeToReplace);
            sourceFile._replaceCompilerNodeFromFactory(newNode);
            this.nodeCache.set(newNode, sourceFile);
            this.addSourceFileToCache(sourceFile);
            this.sourceFileAddedEventContainer.fire(sourceFile);
        }
        else {
            this.nodeCache.replaceKey(nodeToReplace, newNode);
            if (node != null)
                node._replaceCompilerNodeFromFactory(newNode);
        }
    }
    removeNodeFromCache(node) {
        this.removeCompilerNodeFromCache(node.compilerNode);
    }
    removeCompilerNodeFromCache(compilerNode) {
        this.nodeCache.removeByKey(compilerNode);
        if (compilerNode.kind === ts$1.SyntaxKind.SourceFile) {
            const sourceFile = compilerNode;
            const standardizedFilePath = this.context.fileSystemWrapper.getStandardizedAbsolutePath(sourceFile.fileName);
            this.directoryCache.removeSourceFile(standardizedFilePath);
            const wrappedSourceFile = this.sourceFileCacheByFilePath.get(standardizedFilePath);
            this.sourceFileCacheByFilePath.delete(standardizedFilePath);
            this.documentRegistry.removeSourceFile(standardizedFilePath);
            if (wrappedSourceFile != null)
                this.sourceFileRemovedEventContainer.fire(wrappedSourceFile);
        }
    }
    addDirectoryToCache(directory) {
        this.directoryCache.addDirectory(directory);
    }
    removeDirectoryFromCache(dirPath) {
        this.directoryCache.remove(dirPath);
    }
    forgetNodesCreatedInBlock(block) {
        this.nodeCache.setForgetPoint();
        let wasPromise = false;
        let result;
        try {
            result = block((...nodes) => {
                for (const node of nodes)
                    this.nodeCache.rememberNode(node);
            });
            if (Node.isNode(result))
                this.nodeCache.rememberNode(result);
            if (isPromise(result)) {
                wasPromise = true;
                return result.then(value => {
                    if (Node.isNode(value))
                        this.nodeCache.rememberNode(value);
                    this.nodeCache.forgetLastPoint();
                    return value;
                });
            }
        }
        finally {
            if (!wasPromise)
                this.nodeCache.forgetLastPoint();
        }
        return result;
        function isPromise(value) {
            return value != null && typeof value.then === "function";
        }
    }
}

class InProjectCoordinator {
    constructor(compilerFactory) {
        this.compilerFactory = compilerFactory;
        this.notInProjectFiles = new Set();
        compilerFactory.onSourceFileRemoved(sourceFile => {
            this.notInProjectFiles.delete(sourceFile);
        });
    }
    setSourceFileNotInProject(sourceFile) {
        this.notInProjectFiles.add(sourceFile);
        sourceFile._inProject = false;
    }
    markSourceFileAsInProject(sourceFile) {
        if (this.isSourceFileInProject(sourceFile))
            return;
        this._internalMarkSourceFileAsInProject(sourceFile);
        this.notInProjectFiles.delete(sourceFile);
    }
    markSourceFilesAsInProjectForResolution() {
        const nodeModulesSearchName = "/node_modules/";
        const compilerFactory = this.compilerFactory;
        const changedSourceFiles = [];
        const unchangedSourceFiles = [];
        for (const sourceFile of [...this.notInProjectFiles.values()]) {
            if (shouldMarkInProject(sourceFile)) {
                this._internalMarkSourceFileAsInProject(sourceFile);
                this.notInProjectFiles.delete(sourceFile);
                changedSourceFiles.push(sourceFile);
            }
            else {
                unchangedSourceFiles.push(sourceFile);
            }
        }
        return { changedSourceFiles, unchangedSourceFiles };
        function shouldMarkInProject(sourceFile) {
            const filePath = sourceFile.getFilePath();
            const index = filePath.toLowerCase().lastIndexOf(nodeModulesSearchName);
            if (index === -1)
                return true;
            const nodeModulesPath = filePath.substring(0, index + nodeModulesSearchName.length - 1);
            const nodeModulesDir = compilerFactory.getDirectoryFromCacheOnlyIfInCache(nodeModulesPath);
            if (nodeModulesDir != null && nodeModulesDir._isInProject())
                return true;
            let directory = sourceFile.getDirectory();
            while (directory != null && directory.getPath() !== nodeModulesPath) {
                if (directory._isInProject())
                    return true;
                directory = compilerFactory.getDirectoryFromCacheOnlyIfInCache(FileUtils.getDirPath(directory.getPath()));
            }
            return false;
        }
    }
    _internalMarkSourceFileAsInProject(sourceFile) {
        sourceFile._inProject = true;
        this.markDirectoryAsInProject(sourceFile.getDirectory());
    }
    isSourceFileInProject(sourceFile) {
        return sourceFile._inProject === true;
    }
    setDirectoryAndFilesAsNotInProjectForTesting(directory) {
        for (const subDir of directory.getDirectories())
            this.setDirectoryAndFilesAsNotInProjectForTesting(subDir);
        for (const file of directory.getSourceFiles()) {
            delete file._inProject;
            this.notInProjectFiles.add(file);
        }
        delete directory._inProject;
    }
    markDirectoryAsInProject(directory) {
        if (this.isDirectoryInProject(directory))
            return;
        const inProjectCoordinator = this;
        const compilerFactory = this.compilerFactory;
        directory._inProject = true;
        markAncestorDirs(directory);
        function markAncestorDirs(dir) {
            const ancestorDirs = Array.from(getAncestorsUpToOneInProject(dir));
            const topAncestor = ancestorDirs[ancestorDirs.length - 1];
            if (topAncestor == null || !inProjectCoordinator.isDirectoryInProject(topAncestor))
                return;
            for (const ancestorDir of ancestorDirs)
                ancestorDir._inProject = true;
        }
        function* getAncestorsUpToOneInProject(dir) {
            if (FileUtils.isRootDirPath(dir.getPath()))
                return;
            const parentDirPath = FileUtils.getDirPath(dir.getPath());
            const parentDir = compilerFactory.getDirectoryFromCacheOnlyIfInCache(parentDirPath);
            if (parentDir == null)
                return;
            yield parentDir;
            if (!inProjectCoordinator.isDirectoryInProject(parentDir))
                yield* getAncestorsUpToOneInProject(parentDir);
        }
    }
    isDirectoryInProject(directory) {
        return directory._inProject === true;
    }
}

class StructurePrinterFactory {
    constructor(_getFormatCodeSettings) {
        this._getFormatCodeSettings = _getFormatCodeSettings;
    }
    getFormatCodeSettings() {
        return this._getFormatCodeSettings();
    }
    forInitializerExpressionableNode() {
        return new InitializerExpressionableNodeStructurePrinter();
    }
    forModifierableNode() {
        return new ModifierableNodeStructurePrinter();
    }
    forReturnTypedNode(alwaysWrite) {
        return new ReturnTypedNodeStructurePrinter(alwaysWrite);
    }
    forTypedNode(separator, alwaysWrite) {
        return new TypedNodeStructurePrinter(separator, alwaysWrite);
    }
    forClassDeclaration(options) {
        return new ClassDeclarationStructurePrinter(this, options);
    }
    forClassMember(options) {
        return new ClassMemberStructurePrinter(this, options);
    }
    forConstructorDeclaration(options) {
        return new ConstructorDeclarationStructurePrinter(this, options);
    }
    forGetAccessorDeclaration(options) {
        return new GetAccessorDeclarationStructurePrinter(this, options);
    }
    forMethodDeclaration(options) {
        return new MethodDeclarationStructurePrinter(this, options);
    }
    forPropertyDeclaration() {
        return new PropertyDeclarationStructurePrinter(this);
    }
    forSetAccessorDeclaration(options) {
        return new SetAccessorDeclarationStructurePrinter(this, options);
    }
    forDecorator() {
        return new DecoratorStructurePrinter(this);
    }
    forJSDoc() {
        return new JSDocStructurePrinter(this);
    }
    forJSDocTag(options) {
        return new JSDocTagStructurePrinter(this, options);
    }
    forEnumDeclaration() {
        return new EnumDeclarationStructurePrinter(this);
    }
    forEnumMember() {
        return new EnumMemberStructurePrinter(this);
    }
    forObjectLiteralExpressionProperty() {
        return new ObjectLiteralExpressionPropertyStructurePrinter(this);
    }
    forPropertyAssignment() {
        return new PropertyAssignmentStructurePrinter(this);
    }
    forShorthandPropertyAssignment() {
        return new ShorthandPropertyAssignmentStructurePrinter(this);
    }
    forSpreadAssignment() {
        return new SpreadAssignmentStructurePrinter(this);
    }
    forFunctionDeclaration(options) {
        return new FunctionDeclarationStructurePrinter(this, options);
    }
    forParameterDeclaration() {
        return new ParameterDeclarationStructurePrinter(this);
    }
    forCallSignatureDeclaration() {
        return new CallSignatureDeclarationStructurePrinter(this);
    }
    forConstructSignatureDeclaration() {
        return new ConstructSignatureDeclarationStructurePrinter(this);
    }
    forIndexSignatureDeclaration() {
        return new IndexSignatureDeclarationStructurePrinter(this);
    }
    forInterfaceDeclaration() {
        return new InterfaceDeclarationStructurePrinter(this);
    }
    forMethodSignature() {
        return new MethodSignatureStructurePrinter(this);
    }
    forPropertySignature() {
        return new PropertySignatureStructurePrinter(this);
    }
    forTypeElementMemberedNode() {
        return new TypeElementMemberedNodeStructurePrinter(this);
    }
    forTypeElementMember() {
        return new TypeElementMemberStructurePrinter(this);
    }
    forJsxAttribute() {
        return new JsxAttributeStructurePrinter(this);
    }
    forJsxChildDecider() {
        return new JsxChildDeciderStructurePrinter(this);
    }
    forJsxElement() {
        return new JsxElementStructurePrinter(this);
    }
    forJsxAttributeDecider() {
        return new JsxAttributeDeciderStructurePrinter(this);
    }
    forJsxSelfClosingElement() {
        return new JsxSelfClosingElementStructurePrinter(this);
    }
    forJsxSpreadAttribute() {
        return new JsxSpreadAttributeStructurePrinter(this);
    }
    forExportAssignment() {
        return new ExportAssignmentStructurePrinter(this);
    }
    forExportDeclaration() {
        return new ExportDeclarationStructurePrinter(this);
    }
    forImportDeclaration() {
        return new ImportDeclarationStructurePrinter(this);
    }
    forNamespaceDeclaration(options) {
        return new NamespaceDeclarationStructurePrinter(this, options);
    }
    forNamedImportExportSpecifier() {
        return new NamedImportExportSpecifierStructurePrinter(this);
    }
    forSourceFile(options) {
        return new SourceFileStructurePrinter(this, options);
    }
    forStatementedNode(options) {
        return new StatementedNodeStructurePrinter(this, options);
    }
    forStatement(options) {
        return new StatementStructurePrinter(this, options);
    }
    forVariableStatement() {
        return new VariableStatementStructurePrinter(this);
    }
    forVariableDeclaration() {
        return new VariableDeclarationStructurePrinter(this);
    }
    forTypeAliasDeclaration() {
        return new TypeAliasDeclarationStructurePrinter(this);
    }
    forTypeParameterDeclaration() {
        return new TypeParameterDeclarationStructurePrinter(this);
    }
}
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forInitializerExpressionableNode", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forModifierableNode", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forReturnTypedNode", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forTypedNode", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forClassDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forClassMember", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forConstructorDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forGetAccessorDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forMethodDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forPropertyDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forSetAccessorDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forDecorator", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forJSDoc", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forJSDocTag", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forEnumDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forEnumMember", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forObjectLiteralExpressionProperty", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forPropertyAssignment", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forShorthandPropertyAssignment", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forSpreadAssignment", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forFunctionDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forParameterDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forCallSignatureDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forConstructSignatureDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forIndexSignatureDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forInterfaceDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forMethodSignature", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forPropertySignature", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forTypeElementMemberedNode", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forTypeElementMember", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forJsxAttribute", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forJsxChildDecider", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forJsxElement", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forJsxAttributeDecider", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forJsxSelfClosingElement", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forJsxSpreadAttribute", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forExportAssignment", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forExportDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forImportDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forNamespaceDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forNamedImportExportSpecifier", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forSourceFile", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forStatementedNode", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forStatement", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forVariableStatement", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forVariableDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forTypeAliasDeclaration", null);
__decorate$1([
    Memoize
], StructurePrinterFactory.prototype, "forTypeParameterDeclaration", null);

class ProjectContext {
    constructor(project, fileSystemWrapper, compilerOptionsContainer, opts) {
        this.logger = new ConsoleLogger();
        this.manipulationSettings = new ManipulationSettingsContainer();
        this._project = project;
        this.fileSystemWrapper = fileSystemWrapper;
        this._compilerOptions = compilerOptionsContainer;
        this.compilerFactory = new CompilerFactory(this);
        this.inProjectCoordinator = new InProjectCoordinator(this.compilerFactory);
        this.structurePrinterFactory = new StructurePrinterFactory(() => this.manipulationSettings.getFormatCodeSettings());
        this.lazyReferenceCoordinator = new LazyReferenceCoordinator(this.compilerFactory);
        this.directoryCoordinator = new DirectoryCoordinator(this.compilerFactory, fileSystemWrapper);
        this._languageService = opts.createLanguageService
            ? new LanguageService(this, {
                resolutionHost: opts.resolutionHost && opts.resolutionHost(this.getModuleResolutionHost(), () => this.compilerOptions.get()),
            })
            : undefined;
        if (opts.typeChecker != null) {
            errors.throwIfTrue(opts.createLanguageService, "Cannot specify a type checker and create a language service.");
            this._customTypeChecker = new TypeChecker(this);
            this._customTypeChecker._reset(() => opts.typeChecker);
        }
    }
    get project() {
        if (this._project == null)
            throw new errors.InvalidOperationError("This operation is not permitted in this context.");
        return this._project;
    }
    get compilerOptions() {
        return this._compilerOptions;
    }
    get languageService() {
        if (this._languageService == null)
            throw this.getToolRequiredError("language service");
        return this._languageService;
    }
    get program() {
        if (this._languageService == null)
            throw this.getToolRequiredError("program");
        return this.languageService.getProgram();
    }
    get typeChecker() {
        if (this._customTypeChecker != null)
            return this._customTypeChecker;
        if (this._languageService == null)
            throw this.getToolRequiredError("type checker");
        return this.program.getTypeChecker();
    }
    hasLanguageService() {
        return this._languageService != null;
    }
    getEncoding() {
        return this.compilerOptions.getEncoding();
    }
    getFormatCodeSettings() {
        return this.manipulationSettings.getFormatCodeSettings();
    }
    getUserPreferences() {
        return this.manipulationSettings.getUserPreferences();
    }
    resetProgram() {
        this.languageService._resetProgram();
    }
    createWriter() {
        const indentationText = this.manipulationSettings.getIndentationText();
        return new CodeBlockWriter({
            newLine: this.manipulationSettings.getNewLineKindAsString(),
            indentNumberOfSpaces: indentationText === exports.IndentationText.Tab ? undefined : indentationText.length,
            useTabs: indentationText === exports.IndentationText.Tab,
            useSingleQuote: this.manipulationSettings.getQuoteKind() === exports.QuoteKind.Single,
        });
    }
    getPreEmitDiagnostics(sourceFile) {
        const compilerDiagnostics = ts$1.getPreEmitDiagnostics(this.program.compilerObject, sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.compilerNode);
        return compilerDiagnostics.map(d => this.compilerFactory.getDiagnostic(d));
    }
    getSourceFileContainer() {
        return {
            addOrGetSourceFileFromFilePath: (filePath, opts) => {
                var _a;
                return Promise.resolve((_a = this.compilerFactory.addOrGetSourceFileFromFilePath(filePath, opts)) === null || _a === void 0 ? void 0 : _a.compilerNode);
            },
            addOrGetSourceFileFromFilePathSync: (filePath, opts) => {
                var _a;
                return (_a = this.compilerFactory.addOrGetSourceFileFromFilePath(filePath, opts)) === null || _a === void 0 ? void 0 : _a.compilerNode;
            },
            containsDirectoryAtPath: dirPath => this.compilerFactory.containsDirectoryAtPath(dirPath),
            containsSourceFileAtPath: filePath => this.compilerFactory.containsSourceFileAtPath(filePath),
            getSourceFileFromCacheFromFilePath: filePath => {
                const sourceFile = this.compilerFactory.getSourceFileFromCacheFromFilePath(filePath);
                return sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.compilerNode;
            },
            getSourceFilePaths: () => this.compilerFactory.getSourceFilePaths(),
            getSourceFileVersion: sourceFile => this.compilerFactory.documentRegistry.getSourceFileVersion(sourceFile),
            getChildDirectoriesOfDirectory: dirPath => {
                const result = [];
                for (const dir of this.compilerFactory.getChildDirectoriesOfDirectory(dirPath))
                    result.push(dir.getPath());
                return result;
            },
        };
    }
    getModuleResolutionHost() {
        return common.createModuleResolutionHost({
            transactionalFileSystem: this.fileSystemWrapper,
            getEncoding: () => this.getEncoding(),
            sourceFileContainer: this.getSourceFileContainer(),
        });
    }
    getToolRequiredError(name) {
        return new errors.InvalidOperationError(`A ${name} is required for this operation. `
            + "This might occur when manipulating or getting type information from a node that was not added "
            + `to a Project object and created via ${"createWrappedNode"}. `
            + `Please submit a bug report if you don't believe a ${name} should be required for this operation.`);
    }
}
__decorate$1([
    Memoize
], ProjectContext.prototype, "getSourceFileContainer", null);
__decorate$1([
    Memoize
], ProjectContext.prototype, "getModuleResolutionHost", null);

class Project {
    constructor(options = {}) {
        verifyOptions();
        const fileSystem = getFileSystem();
        const fileSystemWrapper = new TransactionalFileSystem(fileSystem);
        const tsConfigResolver = options.tsConfigFilePath == null
            ? undefined
            : new common.TsConfigResolver(fileSystemWrapper, fileSystemWrapper.getStandardizedAbsolutePath(options.tsConfigFilePath), getEncoding());
        const compilerOptions = getCompilerOptions();
        const compilerOptionsContainer = new CompilerOptionsContainer();
        compilerOptionsContainer.set(compilerOptions);
        this._context = new ProjectContext(this, fileSystemWrapper, compilerOptionsContainer, {
            createLanguageService: true,
            resolutionHost: options.resolutionHost,
        });
        if (options.manipulationSettings != null)
            this._context.manipulationSettings.set(options.manipulationSettings);
        if (tsConfigResolver != null && options.addFilesFromTsConfig !== false) {
            this._addSourceFilesForTsConfigResolver(tsConfigResolver, compilerOptions);
            if (!options.skipFileDependencyResolution)
                this.resolveSourceFileDependencies();
        }
        function verifyOptions() {
            if (options.fileSystem != null && options.useInMemoryFileSystem)
                throw new errors.InvalidOperationError("Cannot provide a file system when specifying to use an in-memory file system.");
            if (options.skipLoadingLibFiles && !options.useInMemoryFileSystem) {
                throw new errors.InvalidOperationError(`The ${"skipLoadingLibFiles"} option can only be true when ${"useInMemoryFileSystem"} is true.`);
            }
        }
        function getFileSystem() {
            var _a;
            if (options.useInMemoryFileSystem)
                return new common.InMemoryFileSystemHost({ skipLoadingLibFiles: options.skipLoadingLibFiles });
            return (_a = options.fileSystem) !== null && _a !== void 0 ? _a : new InMemoryFileSystemHost();
        }
        function getCompilerOptions() {
            var _a;
            return Object.assign(Object.assign({}, getTsConfigCompilerOptions()), ((_a = options.compilerOptions) !== null && _a !== void 0 ? _a : {}));
        }
        function getTsConfigCompilerOptions() {
            var _a;
            return (_a = tsConfigResolver === null || tsConfigResolver === void 0 ? void 0 : tsConfigResolver.getCompilerOptions()) !== null && _a !== void 0 ? _a : {};
        }
        function getEncoding() {
            var _a;
            const defaultEncoding = "utf-8";
            if (options.compilerOptions != null)
                return (_a = options.compilerOptions.charset) !== null && _a !== void 0 ? _a : defaultEncoding;
            return defaultEncoding;
        }
    }
    get manipulationSettings() {
        return this._context.manipulationSettings;
    }
    get compilerOptions() {
        return this._context.compilerOptions;
    }
    resolveSourceFileDependencies() {
        const sourceFiles = new Set();
        const onSourceFileAdded = (sourceFile) => sourceFiles.add(sourceFile);
        const { compilerFactory, inProjectCoordinator } = this._context;
        compilerFactory.onSourceFileAdded(onSourceFileAdded);
        try {
            this.getProgram().compilerObject;
        }
        finally {
            compilerFactory.onSourceFileAdded(onSourceFileAdded, false);
        }
        const result = inProjectCoordinator.markSourceFilesAsInProjectForResolution();
        for (const sourceFile of result.changedSourceFiles)
            sourceFiles.add(sourceFile);
        for (const sourceFile of result.unchangedSourceFiles)
            sourceFiles.delete(sourceFile);
        return Array.from(sourceFiles.values());
    }
    addDirectoryAtPathIfExists(dirPath, options = {}) {
        return this._context.directoryCoordinator.addDirectoryAtPathIfExists(this._context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath), Object.assign(Object.assign({}, options), { markInProject: true }));
    }
    addDirectoryAtPath(dirPath, options = {}) {
        return this._context.directoryCoordinator.addDirectoryAtPath(this._context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath), Object.assign(Object.assign({}, options), { markInProject: true }));
    }
    createDirectory(dirPath) {
        return this._context.directoryCoordinator.createDirectoryOrAddIfExists(this._context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath), { markInProject: true });
    }
    getDirectoryOrThrow(dirPath) {
        return errors.throwIfNullOrUndefined(this.getDirectory(dirPath), () => `Could not find a directory at the specified path: ${this._context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath)}`);
    }
    getDirectory(dirPath) {
        const { compilerFactory } = this._context;
        return compilerFactory.getDirectoryFromCache(this._context.fileSystemWrapper.getStandardizedAbsolutePath(dirPath));
    }
    getDirectories() {
        return Array.from(this._getProjectDirectoriesByDirectoryDepth());
    }
    getRootDirectories() {
        const { inProjectCoordinator } = this._context;
        const result = [];
        for (const dir of this._context.compilerFactory.getOrphanDirectories()) {
            for (const inProjectDir of findInProjectDirectories(dir))
                result.push(inProjectDir);
        }
        return result;
        function* findInProjectDirectories(dir) {
            if (inProjectCoordinator.isDirectoryInProject(dir)) {
                yield dir;
                return;
            }
            for (const childDir of dir._getDirectoriesIterator())
                yield* findInProjectDirectories(childDir);
        }
    }
    addSourceFilesAtPaths(fileGlobs) {
        return this._context.directoryCoordinator.addSourceFilesAtPaths(fileGlobs, { markInProject: true });
    }
    addSourceFileAtPathIfExists(filePath) {
        return this._context.directoryCoordinator.addSourceFileAtPathIfExists(this._context.fileSystemWrapper.getStandardizedAbsolutePath(filePath), { markInProject: true });
    }
    addSourceFileAtPath(filePath) {
        return this._context.directoryCoordinator.addSourceFileAtPath(this._context.fileSystemWrapper.getStandardizedAbsolutePath(filePath), { markInProject: true });
    }
    addSourceFilesFromTsConfig(tsConfigFilePath) {
        const resolver = new common.TsConfigResolver(this._context.fileSystemWrapper, this._context.fileSystemWrapper.getStandardizedAbsolutePath(tsConfigFilePath), this._context.getEncoding());
        return this._addSourceFilesForTsConfigResolver(resolver, resolver.getCompilerOptions());
    }
    _addSourceFilesForTsConfigResolver(tsConfigResolver, compilerOptions) {
        const paths = tsConfigResolver.getPaths(compilerOptions);
        const addedSourceFiles = paths.filePaths.map(p => this.addSourceFileAtPath(p));
        for (const dirPath of paths.directoryPaths)
            this.addDirectoryAtPathIfExists(dirPath);
        return addedSourceFiles;
    }
    createSourceFile(filePath, sourceFileText, options) {
        return this._context.compilerFactory.createSourceFile(this._context.fileSystemWrapper.getStandardizedAbsolutePath(filePath), sourceFileText !== null && sourceFileText !== void 0 ? sourceFileText : "", Object.assign(Object.assign({}, (options !== null && options !== void 0 ? options : {})), { markInProject: true }));
    }
    removeSourceFile(sourceFile) {
        const previouslyForgotten = sourceFile.wasForgotten();
        sourceFile.forget();
        return !previouslyForgotten;
    }
    getSourceFileOrThrow(fileNameOrSearchFunction) {
        const sourceFile = this.getSourceFile(fileNameOrSearchFunction);
        if (sourceFile != null)
            return sourceFile;
        if (typeof fileNameOrSearchFunction === "string") {
            const fileNameOrPath = FileUtils.standardizeSlashes(fileNameOrSearchFunction);
            if (FileUtils.pathIsAbsolute(fileNameOrPath) || fileNameOrPath.indexOf("/") >= 0) {
                const errorFileNameOrPath = this._context.fileSystemWrapper.getStandardizedAbsolutePath(fileNameOrPath);
                throw new errors.InvalidOperationError(`Could not find source file in project at the provided path: ${errorFileNameOrPath}`);
            }
            else {
                throw new errors.InvalidOperationError(`Could not find source file in project with the provided file name: ${fileNameOrSearchFunction}`);
            }
        }
        else {
            throw new errors.InvalidOperationError(`Could not find source file in project based on the provided condition.`);
        }
    }
    getSourceFile(fileNameOrSearchFunction) {
        const filePathOrSearchFunction = getFilePathOrSearchFunction(this._context.fileSystemWrapper);
        if (isStandardizedFilePath(filePathOrSearchFunction)) {
            return this._context.compilerFactory.getSourceFileFromCacheFromFilePath(filePathOrSearchFunction);
        }
        return common.IterableUtils.find(this._getProjectSourceFilesByDirectoryDepth(), filePathOrSearchFunction);
        function getFilePathOrSearchFunction(fileSystemWrapper) {
            if (fileNameOrSearchFunction instanceof Function)
                return fileNameOrSearchFunction;
            const fileNameOrPath = FileUtils.standardizeSlashes(fileNameOrSearchFunction);
            if (FileUtils.pathIsAbsolute(fileNameOrPath) || fileNameOrPath.indexOf("/") >= 0)
                return fileSystemWrapper.getStandardizedAbsolutePath(fileNameOrPath);
            else
                return def => FileUtils.pathEndsWith(def.getFilePath(), fileNameOrPath);
        }
        function isStandardizedFilePath(obj) {
            return typeof obj === "string";
        }
    }
    getSourceFiles(globPatterns) {
        const { compilerFactory, fileSystemWrapper } = this._context;
        const sourceFiles = this._getProjectSourceFilesByDirectoryDepth();
        if (typeof globPatterns === "string" || globPatterns instanceof Array)
            return Array.from(getFilteredSourceFiles());
        else
            return Array.from(sourceFiles);
        function* getFilteredSourceFiles() {
            const sourceFilePaths = Array.from(getSourceFilePaths());
            const matchedPaths = common.matchGlobs(sourceFilePaths, globPatterns, fileSystemWrapper.getCurrentDirectory());
            for (const matchedPath of matchedPaths)
                yield compilerFactory.getSourceFileFromCacheFromFilePath(fileSystemWrapper.getStandardizedAbsolutePath(matchedPath));
            function* getSourceFilePaths() {
                for (const sourceFile of sourceFiles)
                    yield sourceFile.getFilePath();
            }
        }
    }
    *_getProjectSourceFilesByDirectoryDepth() {
        const { compilerFactory, inProjectCoordinator } = this._context;
        for (const sourceFile of compilerFactory.getSourceFilesByDirectoryDepth()) {
            if (inProjectCoordinator.isSourceFileInProject(sourceFile))
                yield sourceFile;
        }
    }
    *_getProjectDirectoriesByDirectoryDepth() {
        const { compilerFactory, inProjectCoordinator } = this._context;
        for (const directory of compilerFactory.getDirectoriesByDepth()) {
            if (inProjectCoordinator.isDirectoryInProject(directory))
                yield directory;
        }
    }
    getAmbientModule(moduleName) {
        moduleName = normalizeAmbientModuleName(moduleName);
        return this.getAmbientModules().find(s => s.getName() === moduleName);
    }
    getAmbientModuleOrThrow(moduleName) {
        return errors.throwIfNullOrUndefined(this.getAmbientModule(moduleName), () => `Could not find ambient module with name: ${normalizeAmbientModuleName(moduleName)}`);
    }
    getAmbientModules() {
        return this.getTypeChecker().getAmbientModules();
    }
    save() {
        return __awaiter$1(this, void 0, void 0, function*() {
            yield this._context.fileSystemWrapper.flush();
            yield Promise.all(this._getUnsavedSourceFiles().map(f => f.save()));
        });
    }
    saveSync() {
        this._context.fileSystemWrapper.flushSync();
        for (const file of this._getUnsavedSourceFiles())
            file.saveSync();
    }
    enableLogging(enabled = true) {
        this._context.logger.setEnabled(enabled);
    }
    _getUnsavedSourceFiles() {
        return Array.from(getUnsavedIterator(this._context.compilerFactory.getSourceFilesByDirectoryDepth()));
        function* getUnsavedIterator(sourceFiles) {
            for (const sourceFile of sourceFiles) {
                if (!sourceFile.isSaved())
                    yield sourceFile;
            }
        }
    }
    getPreEmitDiagnostics() {
        return this._context.getPreEmitDiagnostics();
    }
    getLanguageService() {
        return this._context.languageService;
    }
    getProgram() {
        return this._context.program;
    }
    getTypeChecker() {
        return this._context.typeChecker;
    }
    getFileSystem() {
        return this._context.fileSystemWrapper.getFileSystem();
    }
    emit(emitOptions = {}) {
        return this._context.program.emit(emitOptions);
    }
    emitSync(emitOptions = {}) {
        return this._context.program.emitSync(emitOptions);
    }
    emitToMemory(emitOptions = {}) {
        return this._context.program.emitToMemory(emitOptions);
    }
    getCompilerOptions() {
        return this._context.compilerOptions.get();
    }
    createWriter() {
        return this._context.createWriter();
    }
    forgetNodesCreatedInBlock(block) {
        return this._context.compilerFactory.forgetNodesCreatedInBlock(block);
    }
    formatDiagnosticsWithColorAndContext(diagnostics, opts = {}) {
        return ts$1.formatDiagnosticsWithColorAndContext(diagnostics.map(d => d.compilerObject), {
            getCurrentDirectory: () => this._context.fileSystemWrapper.getCurrentDirectory(),
            getCanonicalFileName: fileName => fileName,
            getNewLine: () => { var _a; return (_a = opts.newLineChar) !== null && _a !== void 0 ? _a : require("os").EOL; },
        });
    }
    getModuleResolutionHost() {
        return this._context.getModuleResolutionHost();
    }
}
function normalizeAmbientModuleName(moduleName) {
    if (isQuote(moduleName[0]) && isQuote(moduleName[moduleName.length - 1]))
        moduleName = moduleName.substring(1, moduleName.length - 1);
    return `"${moduleName}"`;
    function isQuote(char) {
        return char === `"` || char === "'";
    }
}

const SyntaxKind = {
    "0": "FirstToken",
    "1": "EndOfFileToken",
    "2": "FirstTriviaToken",
    "3": "MultiLineCommentTrivia",
    "4": "NewLineTrivia",
    "5": "WhitespaceTrivia",
    "6": "ShebangTrivia",
    "7": "LastTriviaToken",
    "8": "FirstLiteralToken",
    "9": "BigIntLiteral",
    "10": "StringLiteral",
    "11": "JsxText",
    "12": "JsxTextAllWhiteSpaces",
    "13": "RegularExpressionLiteral",
    "14": "FirstTemplateToken",
    "15": "TemplateHead",
    "16": "TemplateMiddle",
    "17": "LastTemplateToken",
    "18": "FirstPunctuation",
    "19": "CloseBraceToken",
    "20": "OpenParenToken",
    "21": "CloseParenToken",
    "22": "OpenBracketToken",
    "23": "CloseBracketToken",
    "24": "DotToken",
    "25": "DotDotDotToken",
    "26": "SemicolonToken",
    "27": "CommaToken",
    "28": "QuestionDotToken",
    "29": "FirstBinaryOperator",
    "30": "LessThanSlashToken",
    "31": "GreaterThanToken",
    "32": "LessThanEqualsToken",
    "33": "GreaterThanEqualsToken",
    "34": "EqualsEqualsToken",
    "35": "ExclamationEqualsToken",
    "36": "EqualsEqualsEqualsToken",
    "37": "ExclamationEqualsEqualsToken",
    "38": "EqualsGreaterThanToken",
    "39": "PlusToken",
    "40": "MinusToken",
    "41": "AsteriskToken",
    "42": "AsteriskAsteriskToken",
    "43": "SlashToken",
    "44": "PercentToken",
    "45": "PlusPlusToken",
    "46": "MinusMinusToken",
    "47": "LessThanLessThanToken",
    "48": "GreaterThanGreaterThanToken",
    "49": "GreaterThanGreaterThanGreaterThanToken",
    "50": "AmpersandToken",
    "51": "BarToken",
    "52": "CaretToken",
    "53": "ExclamationToken",
    "54": "TildeToken",
    "55": "AmpersandAmpersandToken",
    "56": "BarBarToken",
    "57": "QuestionToken",
    "58": "ColonToken",
    "59": "AtToken",
    "60": "QuestionQuestionToken",
    "61": "BacktickToken",
    "62": "FirstAssignment",
    "63": "FirstCompoundAssignment",
    "64": "MinusEqualsToken",
    "65": "AsteriskEqualsToken",
    "66": "AsteriskAsteriskEqualsToken",
    "67": "SlashEqualsToken",
    "68": "PercentEqualsToken",
    "69": "LessThanLessThanEqualsToken",
    "70": "GreaterThanGreaterThanEqualsToken",
    "71": "GreaterThanGreaterThanGreaterThanEqualsToken",
    "72": "AmpersandEqualsToken",
    "73": "BarEqualsToken",
    "74": "LastBinaryOperator",
    "75": "Identifier",
    "76": "PrivateIdentifier",
    "77": "FirstKeyword",
    "78": "CaseKeyword",
    "79": "CatchKeyword",
    "80": "ClassKeyword",
    "81": "ConstKeyword",
    "82": "ContinueKeyword",
    "83": "DebuggerKeyword",
    "84": "DefaultKeyword",
    "85": "DeleteKeyword",
    "86": "DoKeyword",
    "87": "ElseKeyword",
    "88": "EnumKeyword",
    "89": "ExportKeyword",
    "90": "ExtendsKeyword",
    "91": "FalseKeyword",
    "92": "FinallyKeyword",
    "93": "ForKeyword",
    "94": "FunctionKeyword",
    "95": "IfKeyword",
    "96": "ImportKeyword",
    "97": "InKeyword",
    "98": "InstanceOfKeyword",
    "99": "NewKeyword",
    "100": "NullKeyword",
    "101": "ReturnKeyword",
    "102": "SuperKeyword",
    "103": "SwitchKeyword",
    "104": "ThisKeyword",
    "105": "ThrowKeyword",
    "106": "TrueKeyword",
    "107": "TryKeyword",
    "108": "TypeOfKeyword",
    "109": "VarKeyword",
    "110": "VoidKeyword",
    "111": "WhileKeyword",
    "112": "LastReservedWord",
    "113": "FirstFutureReservedWord",
    "114": "InterfaceKeyword",
    "115": "LetKeyword",
    "116": "PackageKeyword",
    "117": "PrivateKeyword",
    "118": "ProtectedKeyword",
    "119": "PublicKeyword",
    "120": "StaticKeyword",
    "121": "LastFutureReservedWord",
    "122": "FirstContextualKeyword",
    "123": "AsKeyword",
    "124": "AssertsKeyword",
    "125": "AnyKeyword",
    "126": "AsyncKeyword",
    "127": "AwaitKeyword",
    "128": "BooleanKeyword",
    "129": "ConstructorKeyword",
    "130": "DeclareKeyword",
    "131": "GetKeyword",
    "132": "InferKeyword",
    "133": "IsKeyword",
    "134": "KeyOfKeyword",
    "135": "ModuleKeyword",
    "136": "NamespaceKeyword",
    "137": "NeverKeyword",
    "138": "ReadonlyKeyword",
    "139": "RequireKeyword",
    "140": "NumberKeyword",
    "141": "ObjectKeyword",
    "142": "SetKeyword",
    "143": "StringKeyword",
    "144": "SymbolKeyword",
    "145": "TypeKeyword",
    "146": "UndefinedKeyword",
    "147": "UniqueKeyword",
    "148": "UnknownKeyword",
    "149": "FromKeyword",
    "150": "GlobalKeyword",
    "151": "BigIntKeyword",
    "152": "LastContextualKeyword",
    "153": "FirstNode",
    "154": "ComputedPropertyName",
    "155": "TypeParameter",
    "156": "Parameter",
    "157": "Decorator",
    "158": "PropertySignature",
    "159": "PropertyDeclaration",
    "160": "MethodSignature",
    "161": "MethodDeclaration",
    "162": "Constructor",
    "163": "GetAccessor",
    "164": "SetAccessor",
    "165": "CallSignature",
    "166": "ConstructSignature",
    "167": "IndexSignature",
    "168": "FirstTypeNode",
    "169": "TypeReference",
    "170": "FunctionType",
    "171": "ConstructorType",
    "172": "TypeQuery",
    "173": "TypeLiteral",
    "174": "ArrayType",
    "175": "TupleType",
    "176": "OptionalType",
    "177": "RestType",
    "178": "UnionType",
    "179": "IntersectionType",
    "180": "ConditionalType",
    "181": "InferType",
    "182": "ParenthesizedType",
    "183": "ThisType",
    "184": "TypeOperator",
    "185": "IndexedAccessType",
    "186": "MappedType",
    "187": "LiteralType",
    "188": "LastTypeNode",
    "189": "ObjectBindingPattern",
    "190": "ArrayBindingPattern",
    "191": "BindingElement",
    "192": "ArrayLiteralExpression",
    "193": "ObjectLiteralExpression",
    "194": "PropertyAccessExpression",
    "195": "ElementAccessExpression",
    "196": "CallExpression",
    "197": "NewExpression",
    "198": "TaggedTemplateExpression",
    "199": "TypeAssertionExpression",
    "200": "ParenthesizedExpression",
    "201": "FunctionExpression",
    "202": "ArrowFunction",
    "203": "DeleteExpression",
    "204": "TypeOfExpression",
    "205": "VoidExpression",
    "206": "AwaitExpression",
    "207": "PrefixUnaryExpression",
    "208": "PostfixUnaryExpression",
    "209": "BinaryExpression",
    "210": "ConditionalExpression",
    "211": "TemplateExpression",
    "212": "YieldExpression",
    "213": "SpreadElement",
    "214": "ClassExpression",
    "215": "OmittedExpression",
    "216": "ExpressionWithTypeArguments",
    "217": "AsExpression",
    "218": "NonNullExpression",
    "219": "MetaProperty",
    "220": "SyntheticExpression",
    "221": "TemplateSpan",
    "222": "SemicolonClassElement",
    "223": "Block",
    "224": "EmptyStatement",
    "225": "FirstStatement",
    "226": "ExpressionStatement",
    "227": "IfStatement",
    "228": "DoStatement",
    "229": "WhileStatement",
    "230": "ForStatement",
    "231": "ForInStatement",
    "232": "ForOfStatement",
    "233": "ContinueStatement",
    "234": "BreakStatement",
    "235": "ReturnStatement",
    "236": "WithStatement",
    "237": "SwitchStatement",
    "238": "LabeledStatement",
    "239": "ThrowStatement",
    "240": "TryStatement",
    "241": "LastStatement",
    "242": "VariableDeclaration",
    "243": "VariableDeclarationList",
    "244": "FunctionDeclaration",
    "245": "ClassDeclaration",
    "246": "InterfaceDeclaration",
    "247": "TypeAliasDeclaration",
    "248": "EnumDeclaration",
    "249": "ModuleDeclaration",
    "250": "ModuleBlock",
    "251": "CaseBlock",
    "252": "NamespaceExportDeclaration",
    "253": "ImportEqualsDeclaration",
    "254": "ImportDeclaration",
    "255": "ImportClause",
    "256": "NamespaceImport",
    "257": "NamedImports",
    "258": "ImportSpecifier",
    "259": "ExportAssignment",
    "260": "ExportDeclaration",
    "261": "NamedExports",
    "262": "NamespaceExport",
    "263": "ExportSpecifier",
    "264": "MissingDeclaration",
    "265": "ExternalModuleReference",
    "266": "JsxElement",
    "267": "JsxSelfClosingElement",
    "268": "JsxOpeningElement",
    "269": "JsxClosingElement",
    "270": "JsxFragment",
    "271": "JsxOpeningFragment",
    "272": "JsxClosingFragment",
    "273": "JsxAttribute",
    "274": "JsxAttributes",
    "275": "JsxSpreadAttribute",
    "276": "JsxExpression",
    "277": "CaseClause",
    "278": "DefaultClause",
    "279": "HeritageClause",
    "280": "CatchClause",
    "281": "PropertyAssignment",
    "282": "ShorthandPropertyAssignment",
    "283": "SpreadAssignment",
    "284": "EnumMember",
    "285": "UnparsedPrologue",
    "286": "UnparsedPrepend",
    "287": "UnparsedText",
    "288": "UnparsedInternalText",
    "289": "UnparsedSyntheticReference",
    "290": "SourceFile",
    "291": "Bundle",
    "292": "UnparsedSource",
    "293": "InputFiles",
    "294": "FirstJSDocNode",
    "295": "JSDocAllType",
    "296": "JSDocUnknownType",
    "297": "JSDocNullableType",
    "298": "JSDocNonNullableType",
    "299": "JSDocOptionalType",
    "300": "JSDocFunctionType",
    "301": "JSDocVariadicType",
    "302": "JSDocNamepathType",
    "303": "JSDocComment",
    "304": "JSDocTypeLiteral",
    "305": "JSDocSignature",
    "306": "FirstJSDocTagNode",
    "307": "JSDocAugmentsTag",
    "308": "JSDocImplementsTag",
    "309": "JSDocAuthorTag",
    "310": "JSDocClassTag",
    "311": "JSDocPublicTag",
    "312": "JSDocPrivateTag",
    "313": "JSDocProtectedTag",
    "314": "JSDocReadonlyTag",
    "315": "JSDocCallbackTag",
    "316": "JSDocEnumTag",
    "317": "JSDocParameterTag",
    "318": "JSDocReturnTag",
    "319": "JSDocThisTag",
    "320": "JSDocTypeTag",
    "321": "JSDocTemplateTag",
    "322": "JSDocTypedefTag",
    "323": "LastJSDocTagNode",
    "324": "SyntaxList",
    "325": "NotEmittedStatement",
    "326": "PartiallyEmittedExpression",
    "327": "CommaListExpression",
    "328": "MergeDeclarationMarker",
    "329": "EndOfDeclarationMarker",
    "330": "SyntheticReferenceExpression",
    "331": "Count",
    "Unknown": 0,
    "EndOfFileToken": 1,
    "SingleLineCommentTrivia": 2,
    "MultiLineCommentTrivia": 3,
    "NewLineTrivia": 4,
    "WhitespaceTrivia": 5,
    "ShebangTrivia": 6,
    "ConflictMarkerTrivia": 7,
    "NumericLiteral": 8,
    "BigIntLiteral": 9,
    "StringLiteral": 10,
    "JsxText": 11,
    "JsxTextAllWhiteSpaces": 12,
    "RegularExpressionLiteral": 13,
    "NoSubstitutionTemplateLiteral": 14,
    "TemplateHead": 15,
    "TemplateMiddle": 16,
    "TemplateTail": 17,
    "OpenBraceToken": 18,
    "CloseBraceToken": 19,
    "OpenParenToken": 20,
    "CloseParenToken": 21,
    "OpenBracketToken": 22,
    "CloseBracketToken": 23,
    "DotToken": 24,
    "DotDotDotToken": 25,
    "SemicolonToken": 26,
    "CommaToken": 27,
    "QuestionDotToken": 28,
    "LessThanToken": 29,
    "LessThanSlashToken": 30,
    "GreaterThanToken": 31,
    "LessThanEqualsToken": 32,
    "GreaterThanEqualsToken": 33,
    "EqualsEqualsToken": 34,
    "ExclamationEqualsToken": 35,
    "EqualsEqualsEqualsToken": 36,
    "ExclamationEqualsEqualsToken": 37,
    "EqualsGreaterThanToken": 38,
    "PlusToken": 39,
    "MinusToken": 40,
    "AsteriskToken": 41,
    "AsteriskAsteriskToken": 42,
    "SlashToken": 43,
    "PercentToken": 44,
    "PlusPlusToken": 45,
    "MinusMinusToken": 46,
    "LessThanLessThanToken": 47,
    "GreaterThanGreaterThanToken": 48,
    "GreaterThanGreaterThanGreaterThanToken": 49,
    "AmpersandToken": 50,
    "BarToken": 51,
    "CaretToken": 52,
    "ExclamationToken": 53,
    "TildeToken": 54,
    "AmpersandAmpersandToken": 55,
    "BarBarToken": 56,
    "QuestionToken": 57,
    "ColonToken": 58,
    "AtToken": 59,
    "QuestionQuestionToken": 60,
    "BacktickToken": 61,
    "EqualsToken": 62,
    "PlusEqualsToken": 63,
    "MinusEqualsToken": 64,
    "AsteriskEqualsToken": 65,
    "AsteriskAsteriskEqualsToken": 66,
    "SlashEqualsToken": 67,
    "PercentEqualsToken": 68,
    "LessThanLessThanEqualsToken": 69,
    "GreaterThanGreaterThanEqualsToken": 70,
    "GreaterThanGreaterThanGreaterThanEqualsToken": 71,
    "AmpersandEqualsToken": 72,
    "BarEqualsToken": 73,
    "CaretEqualsToken": 74,
    "Identifier": 75,
    "PrivateIdentifier": 76,
    "BreakKeyword": 77,
    "CaseKeyword": 78,
    "CatchKeyword": 79,
    "ClassKeyword": 80,
    "ConstKeyword": 81,
    "ContinueKeyword": 82,
    "DebuggerKeyword": 83,
    "DefaultKeyword": 84,
    "DeleteKeyword": 85,
    "DoKeyword": 86,
    "ElseKeyword": 87,
    "EnumKeyword": 88,
    "ExportKeyword": 89,
    "ExtendsKeyword": 90,
    "FalseKeyword": 91,
    "FinallyKeyword": 92,
    "ForKeyword": 93,
    "FunctionKeyword": 94,
    "IfKeyword": 95,
    "ImportKeyword": 96,
    "InKeyword": 97,
    "InstanceOfKeyword": 98,
    "NewKeyword": 99,
    "NullKeyword": 100,
    "ReturnKeyword": 101,
    "SuperKeyword": 102,
    "SwitchKeyword": 103,
    "ThisKeyword": 104,
    "ThrowKeyword": 105,
    "TrueKeyword": 106,
    "TryKeyword": 107,
    "TypeOfKeyword": 108,
    "VarKeyword": 109,
    "VoidKeyword": 110,
    "WhileKeyword": 111,
    "WithKeyword": 112,
    "ImplementsKeyword": 113,
    "InterfaceKeyword": 114,
    "LetKeyword": 115,
    "PackageKeyword": 116,
    "PrivateKeyword": 117,
    "ProtectedKeyword": 118,
    "PublicKeyword": 119,
    "StaticKeyword": 120,
    "YieldKeyword": 121,
    "AbstractKeyword": 122,
    "AsKeyword": 123,
    "AssertsKeyword": 124,
    "AnyKeyword": 125,
    "AsyncKeyword": 126,
    "AwaitKeyword": 127,
    "BooleanKeyword": 128,
    "ConstructorKeyword": 129,
    "DeclareKeyword": 130,
    "GetKeyword": 131,
    "InferKeyword": 132,
    "IsKeyword": 133,
    "KeyOfKeyword": 134,
    "ModuleKeyword": 135,
    "NamespaceKeyword": 136,
    "NeverKeyword": 137,
    "ReadonlyKeyword": 138,
    "RequireKeyword": 139,
    "NumberKeyword": 140,
    "ObjectKeyword": 141,
    "SetKeyword": 142,
    "StringKeyword": 143,
    "SymbolKeyword": 144,
    "TypeKeyword": 145,
    "UndefinedKeyword": 146,
    "UniqueKeyword": 147,
    "UnknownKeyword": 148,
    "FromKeyword": 149,
    "GlobalKeyword": 150,
    "BigIntKeyword": 151,
    "OfKeyword": 152,
    "QualifiedName": 153,
    "ComputedPropertyName": 154,
    "TypeParameter": 155,
    "Parameter": 156,
    "Decorator": 157,
    "PropertySignature": 158,
    "PropertyDeclaration": 159,
    "MethodSignature": 160,
    "MethodDeclaration": 161,
    "Constructor": 162,
    "GetAccessor": 163,
    "SetAccessor": 164,
    "CallSignature": 165,
    "ConstructSignature": 166,
    "IndexSignature": 167,
    "TypePredicate": 168,
    "TypeReference": 169,
    "FunctionType": 170,
    "ConstructorType": 171,
    "TypeQuery": 172,
    "TypeLiteral": 173,
    "ArrayType": 174,
    "TupleType": 175,
    "OptionalType": 176,
    "RestType": 177,
    "UnionType": 178,
    "IntersectionType": 179,
    "ConditionalType": 180,
    "InferType": 181,
    "ParenthesizedType": 182,
    "ThisType": 183,
    "TypeOperator": 184,
    "IndexedAccessType": 185,
    "MappedType": 186,
    "LiteralType": 187,
    "ImportType": 188,
    "ObjectBindingPattern": 189,
    "ArrayBindingPattern": 190,
    "BindingElement": 191,
    "ArrayLiteralExpression": 192,
    "ObjectLiteralExpression": 193,
    "PropertyAccessExpression": 194,
    "ElementAccessExpression": 195,
    "CallExpression": 196,
    "NewExpression": 197,
    "TaggedTemplateExpression": 198,
    "TypeAssertionExpression": 199,
    "ParenthesizedExpression": 200,
    "FunctionExpression": 201,
    "ArrowFunction": 202,
    "DeleteExpression": 203,
    "TypeOfExpression": 204,
    "VoidExpression": 205,
    "AwaitExpression": 206,
    "PrefixUnaryExpression": 207,
    "PostfixUnaryExpression": 208,
    "BinaryExpression": 209,
    "ConditionalExpression": 210,
    "TemplateExpression": 211,
    "YieldExpression": 212,
    "SpreadElement": 213,
    "ClassExpression": 214,
    "OmittedExpression": 215,
    "ExpressionWithTypeArguments": 216,
    "AsExpression": 217,
    "NonNullExpression": 218,
    "MetaProperty": 219,
    "SyntheticExpression": 220,
    "TemplateSpan": 221,
    "SemicolonClassElement": 222,
    "Block": 223,
    "EmptyStatement": 224,
    "VariableStatement": 225,
    "ExpressionStatement": 226,
    "IfStatement": 227,
    "DoStatement": 228,
    "WhileStatement": 229,
    "ForStatement": 230,
    "ForInStatement": 231,
    "ForOfStatement": 232,
    "ContinueStatement": 233,
    "BreakStatement": 234,
    "ReturnStatement": 235,
    "WithStatement": 236,
    "SwitchStatement": 237,
    "LabeledStatement": 238,
    "ThrowStatement": 239,
    "TryStatement": 240,
    "DebuggerStatement": 241,
    "VariableDeclaration": 242,
    "VariableDeclarationList": 243,
    "FunctionDeclaration": 244,
    "ClassDeclaration": 245,
    "InterfaceDeclaration": 246,
    "TypeAliasDeclaration": 247,
    "EnumDeclaration": 248,
    "ModuleDeclaration": 249,
    "ModuleBlock": 250,
    "CaseBlock": 251,
    "NamespaceExportDeclaration": 252,
    "ImportEqualsDeclaration": 253,
    "ImportDeclaration": 254,
    "ImportClause": 255,
    "NamespaceImport": 256,
    "NamedImports": 257,
    "ImportSpecifier": 258,
    "ExportAssignment": 259,
    "ExportDeclaration": 260,
    "NamedExports": 261,
    "NamespaceExport": 262,
    "ExportSpecifier": 263,
    "MissingDeclaration": 264,
    "ExternalModuleReference": 265,
    "JsxElement": 266,
    "JsxSelfClosingElement": 267,
    "JsxOpeningElement": 268,
    "JsxClosingElement": 269,
    "JsxFragment": 270,
    "JsxOpeningFragment": 271,
    "JsxClosingFragment": 272,
    "JsxAttribute": 273,
    "JsxAttributes": 274,
    "JsxSpreadAttribute": 275,
    "JsxExpression": 276,
    "CaseClause": 277,
    "DefaultClause": 278,
    "HeritageClause": 279,
    "CatchClause": 280,
    "PropertyAssignment": 281,
    "ShorthandPropertyAssignment": 282,
    "SpreadAssignment": 283,
    "EnumMember": 284,
    "UnparsedPrologue": 285,
    "UnparsedPrepend": 286,
    "UnparsedText": 287,
    "UnparsedInternalText": 288,
    "UnparsedSyntheticReference": 289,
    "SourceFile": 290,
    "Bundle": 291,
    "UnparsedSource": 292,
    "InputFiles": 293,
    "JSDocTypeExpression": 294,
    "JSDocAllType": 295,
    "JSDocUnknownType": 296,
    "JSDocNullableType": 297,
    "JSDocNonNullableType": 298,
    "JSDocOptionalType": 299,
    "JSDocFunctionType": 300,
    "JSDocVariadicType": 301,
    "JSDocNamepathType": 302,
    "JSDocComment": 303,
    "JSDocTypeLiteral": 304,
    "JSDocSignature": 305,
    "JSDocTag": 306,
    "JSDocAugmentsTag": 307,
    "JSDocImplementsTag": 308,
    "JSDocAuthorTag": 309,
    "JSDocClassTag": 310,
    "JSDocPublicTag": 311,
    "JSDocPrivateTag": 312,
    "JSDocProtectedTag": 313,
    "JSDocReadonlyTag": 314,
    "JSDocCallbackTag": 315,
    "JSDocEnumTag": 316,
    "JSDocParameterTag": 317,
    "JSDocReturnTag": 318,
    "JSDocThisTag": 319,
    "JSDocTypeTag": 320,
    "JSDocTemplateTag": 321,
    "JSDocTypedefTag": 322,
    "JSDocPropertyTag": 323,
    "SyntaxList": 324,
    "NotEmittedStatement": 325,
    "PartiallyEmittedExpression": 326,
    "CommaListExpression": 327,
    "MergeDeclarationMarker": 328,
    "EndOfDeclarationMarker": 329,
    "SyntheticReferenceExpression": 330,
    "Count": 331,
    "FirstAssignment": 62,
    "LastAssignment": 74,
    "FirstCompoundAssignment": 63,
    "LastCompoundAssignment": 74,
    "FirstReservedWord": 77,
    "LastReservedWord": 112,
    "FirstKeyword": 77,
    "LastKeyword": 152,
    "FirstFutureReservedWord": 113,
    "LastFutureReservedWord": 121,
    "FirstTypeNode": 168,
    "LastTypeNode": 188,
    "FirstPunctuation": 18,
    "LastPunctuation": 74,
    "FirstToken": 0,
    "LastToken": 152,
    "FirstTriviaToken": 2,
    "LastTriviaToken": 7,
    "FirstLiteralToken": 8,
    "LastLiteralToken": 14,
    "FirstTemplateToken": 14,
    "LastTemplateToken": 17,
    "FirstBinaryOperator": 29,
    "LastBinaryOperator": 74,
    "FirstStatement": 225,
    "LastStatement": 241,
    "FirstNode": 153,
    "FirstJSDocNode": 294,
    "LastJSDocNode": 323,
    "FirstJSDocTagNode": 306,
    "LastJSDocTagNode": 323,
    "FirstContextualKeyword": 122,
    "LastContextualKeyword": 152
};

function getIndentationWidth(text) {
    return (/^ {2,}/m.exec(text) || [""])[0].length;
}
function transform (sourceFile) {
    sourceFile.forEachDescendant(function (node) {
        switch (node.getKind()) {
            case SyntaxKind.DoStatement:
            case SyntaxKind.ForInStatement:
            case SyntaxKind.ForOfStatement:
            case SyntaxKind.ForStatement:
            case SyntaxKind.IfStatement:
            case SyntaxKind.WhileStatement:
                const statements = [];
                if (node.getText().endsWith(" and") || node.getText().endsWith(" or")) {
                    const newNodeText = node.getFullText().trim() + node.getNextSibling().getFullText();
                    node.replaceWithText(newNodeText.replace(/ and /g, " && ").replace(/ or /g, " || "));
                    node.getNextSibling().remove();
                }
                const [identifier, condition, firstStatement] = /([a-z]+) (.*):(.*)/s.exec(node.getText()).slice(1);
                statements.push(" ".repeat(4) + firstStatement.trim());
                const indentationWidth = getIndentationWidth(firstStatement);
                const nodesToRemove = [];
                for (let nextSibling = node.getNextSibling(); nextSibling !== undefined; nextSibling = nextSibling === null || nextSibling === void 0 ? void 0 : nextSibling.getNextSibling()) {
                    for (const line of nextSibling.getFullText().split(/\r?\n/g)) {
                        if (line === "") {
                            continue;
                        }
                        if (getIndentationWidth(line) === indentationWidth) {
                            statements.push(" ".repeat(4) + nextSibling.getText().trim());
                            nodesToRemove.push(nextSibling);
                        }
                        else {
                            nextSibling = undefined;
                            break;
                        }
                    }
                }
                for (const node of nodesToRemove) {
                    node.remove();
                }
                node.replaceWithText(identifier + " (" + condition + ") {\n" + statements.join("\n") + "\n}\n");
                break;
            case SyntaxKind.SwitchStatement:
                const [caseBlock] = node.getChildrenOfKind(SyntaxKind.CaseBlock);
        }
    });
}

const project = new Project({
    "compilerOptions": {
        "allowJs": true,
        "allowSyntheticDefaultImports": true,
        "alwaysStrict": true,
        "esModuleInterop": true,
        "experimentalDecorators": true,
        "moduleResolution": "Node",
        "target": "ES2015",
        "preserveConstEnums": true
    }
});
globalThis.compile = function (input) {
    // Normalize whitespace
    input = input.replace(/^\t+/gm, function (match) {
        return " ".repeat(match.length * 4);
    }).replace(/[ \t]+$/gm, "");
    const sourceFile = project.createSourceFile("input.ts", input, { "overwrite": true });
    transform(sourceFile);
    const output = project.emitToMemory().getFiles()[0].text;
    project.removeSourceFile(sourceFile);
    return output;
};
